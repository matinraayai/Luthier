//===-- LLVMError.h ------------------------------------------*- C++ -*----===//
// Copyright 2022-2025 @ Northeastern University Computer Architecture Lab
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//===----------------------------------------------------------------------===//
///
/// \file
/// This file implements an \c llvm::ErrorInfo that consumes errors
/// generated by LLVM and generates a more verbose error message.
//===----------------------------------------------------------------------===//
#ifndef LUTHIER_LLVM_LLVM_ERROR_H
#define LUTHIER_LLVM_LLVM_ERROR_H
#include "luthier/Common/LuthierError.h"

namespace luthier {

/// \brief ErrorInfo used to consume \c llvm::Error encountered in calls to the
/// LLVM library and return a new \c llvm::Error with the original error message
/// and line info/stack trace of where it was encountered for easier debugging
class LLVMError final : public LuthierError {
public:
  static char ID; ///< ID of the Error
  explicit LLVMError(std::string ErrorMsg,
                     const std::source_location ErrorLocation =
                         std::source_location::current(),
                     StackTraceType StackTrace = StackTraceInitializer())
      : LuthierError(std::move(ErrorMsg), ErrorLocation,
                     std::move(StackTrace)) {};

  explicit LLVMError(const llvm::formatv_object_base &FormatObject,
                     const std::source_location ErrorLocation =
                         std::source_location::current(),
                     StackTraceType StackTrace = StackTraceInitializer())
      : LuthierError(std::move(FormatObject.str()), ErrorLocation,
                     std::move(StackTrace)) {};

  void log(llvm::raw_ostream &OS) const override;

  [[nodiscard]] std::error_code convertToErrorCode() const override {
    llvm_unreachable("Not implemented");
  }
};

/// \brief Macro used to check an \c llvm::Error and on error, wraps its
/// original error message inside a \c luthier::LLVMError to provide a more
/// helpful error message
#define LUTHIER_LLVM_ERROR_CHECK(Expr, ErrorMsg)                               \
  (Expr) ? llvm::make_error<luthier::LLVMError>(                               \
               ErrorMsg, std::source_location::current(),                      \
               luthier::LLVMError::StackTraceInitializer())                    \
         : llvm::Error::success()

} // namespace luthier
#endif