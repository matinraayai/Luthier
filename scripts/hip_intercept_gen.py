# !/usr/bin/env python3
import os
import io
import re

import argparse

from cxxheaderparser.simple import parse_string, ClassScope, ParsedData, Function
import cxxheaderparser.types as cxx_types
from header_preprocessor import ROCmPreprocessor
from typing import *


def parse_and_validate_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser("HIP API interception generation script for Luthier; Originally used by AMD in "
                                     "the Roctracer project")
    parser.add_argument("--hip-include-dir", type=str,
                        default="/opt/rocm/include/hip/amd_detail/",
                        help="location of the HIP include directory")
    parser.add_argument("--cpp-compiler-callback-save-path", type=str,
                        default="../src/lib/hip/hip_compiler_intercept.cpp",
                        help="location of where the generated C++ callback file will be saved")
    parser.add_argument("--cpp-runtime-callback-save-path", type=str,
                        default="../src/lib/hip/hip_runtime_intercept.cpp",
                        help="location of where the generated C++ callback file will be saved")
    args = parser.parse_args()
    return args


def parse_header_file(header_file: str) -> ParsedData:
    preprocessor = ROCmPreprocessor()
    preprocessor.line_directive = None
    preprocessor.passthru_unfound_includes = True
    preprocessor.passthru_includes = re.compile(r".*")
    preprocessor.define("__GNUC__")
    preprocessor.define("LITTLEENDIAN_CPU")
    preprocessor.define("_M_X64")
    preprocessor.define("ROCPROFILER_EXTERN_C_INIT")
    preprocessor.define("ROCPROFILER_EXTERN_C_FINI")
    with open(header_file, 'r') as hf:
        preprocessor.parse(hf)
        str_io = io.StringIO()
        preprocessor.write(str_io)
    preprocessed_header = str_io.getvalue()
    parsed = parse_string(preprocessed_header)
    str_io.close()
    return parsed


def parse_hip_typedefs(header_files: Iterable[str]) -> dict[str, Function]:
    functions = {}
    for header in header_files:
        phf = parse_header_file(header)
        for f in phf.namespace.typedefs:
            functions[f.name] = f
    return functions


def get_api_tables(parsed_hip_api_trace_header: ParsedData, api_table_names: List[str]) -> Dict[str, ClassScope]:
    api_tables = {}
    for cls in parsed_hip_api_trace_header.namespace.classes:
        typename = cls.class_decl.typename
        if typename.classkey == "struct" and len(typename.segments) == 1 \
                and typename.segments[0].name in api_table_names:
            api_tables[typename.segments[0].name] = cls
    return api_tables


def main():
    # Name of the API tables to capture in HIP
    api_table_names = ["HipCompilerDispatchTable", "HipDispatchTable"]

    args = parse_and_validate_args()
    # All possible HIP API functions are located in these headers
    hip_include_files = tuple(os.path.join(args.hip_include_dir, header_file) for header_file in
                              ["hip_api_trace.hpp"])

    parsed_api_enum = parse_header_file("/opt/rocm/include/rocprofiler-sdk/hip/runtime_api_id.h")
    parsed_api_enum = [ting.name for ting in parsed_api_enum.namespace.enums[0].values]

    # parsed_args = parse_header_file("/opt/rocm/include/rocprofiler-sdk/hip/api_args.h")
    # print(parsed_args.namespace.classes[2].classes)
    # print([ting.class_decl.typename.segments[0].name for ting in parsed_args.namespace.classes[2]])

    # This returns a Dict that contains all HIP API functions and other functions not of interest to us.
    # It maps the name of the function (e.g. hip_init) to its cxxheaderparser Function type
    hip_functions = parse_hip_typedefs(hip_include_files)

    parsed_api_trace_header = parse_header_file(os.path.join(args.hip_include_dir, "hip_api_trace.hpp"))

    # Parse the API tables in hip_api_trace.h
    api_tables = get_api_tables(parsed_api_trace_header, api_table_names)

    table_gets = { "HipCompilerDispatchTable" : 'getSavedCompilerTable()', "HipDispatchTable" : "getSavedRuntimeTable()" }

    api_id_types  = { "HipCompilerDispatchTable" : "ROCPROFILER_HIP_COMPILER_API_ID_",
                     "HipDispatchTable" : "ROCPROFILER_HIP_RUNTIME_API_ID_" }

    # Generate the callback functions that will replace the original HIP functions
    callback_defs = []
    compiler_defs = [f"""/* Generated by {os.path.basename(__file__)}. DO NOT EDIT! */
#include "hip/hip_compiler_intercept.hpp"
#include "luthier/luthier.h"
#include "luthier/types.h"
#include <rocprofiler-sdk/hip/api_args.h>
#include <rocprofiler-sdk/hip/api_id.h>

"""]

    runtime_defs = [f"""/* Generated by {os.path.basename(__file__)}. DO NOT EDIT! */
#include "hip/hip_runtime_intercept.hpp"
#include "luthier/luthier.h"
#include "luthier/types.h"
#include <rocprofiler-sdk/hip/api_args.h>
#include <rocprofiler-sdk/hip/api_id.h>


"""]

    bad = [
"hipChooseDeviceR0000",
"hipGetDevicePropertiesR0600",
"hipGetDevicePropertiesR0000",
"hipKernelNameRef",
"hipLaunchCooperativeKernel",
"hipModuleLaunchCooperativeKernel",
"hipModuleLaunchKernel",
"hipModuleOccupancyMaxActiveBlocksPerMultiprocessor",
"hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags",
"hipModuleOccupancyMaxPotentialBlockSize",
"hipModuleOccupancyMaxPotentialBlockSizeWithFlags",
"hipOccupancyMaxActiveBlocksPerMultiprocessor",
"hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags",
"hipOccupancyMaxPotentialBlockSize",
"hipExtModuleLaunchKernel",
"hipHccModuleLaunchKernel",
"hipLaunchCooperativeKernel_spt"
    ]

    dim_threes = [
        "gridDim",
        "blockDim",
        "numBlocks",
        "dimBlocks"
    ]

    for api_name in api_table_names:
        api_table = api_tables[api_name]
        get_func = table_gets[api_name]
        api_id_type = api_id_types[api_name]
        for f in api_table.fields:
            # look for functions in the API Tables, not fields
            # function fields in the API table are defined as pointers to the decltype of their target HIP function
            if isinstance(f.type.typename, cxx_types.PQName) and f.type.typename.segments[0].name != 'size_t':
                # Name of the hip function (e.g.) hip_init
                hip_function_name = f.type.typename.segments[0].name
                # The field of the API Table this function corresponds to (e.g.) hip_init_fn
                api_table_function_name = f.name
                # The hip function representation parsed by cxxheaderparser
                hip_function_cxx = hip_functions[hip_function_name]

                # Format the args for later
                formatted_params = [p.format() for p in hip_function_cxx.type.ptr_to.parameters]
                # Generate the callback
                return_type = hip_function_cxx.type.ptr_to.return_type.format()
                actual_fun_name = api_table_function_name[:-3]

                if ((api_name == "HipDispatchTable" and ("ROCPROFILER_HIP_RUNTIME_API_ID_" + actual_fun_name) not in parsed_api_enum)
                    or actual_fun_name in bad):
                    continue

                callback_defs.append(
                    f"""static {return_type} {actual_fun_name}_callback({", ".join(formatted_params)}) {{
  auto& HipInterceptor = luthier::hip::{"Compiler" if (api_name == "HipCompilerDispatchTable") else "Runtime"}Interceptor::instance();
  auto ApiId = {api_id_type}{actual_fun_name};
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {{
""")
                if return_type != "void":
                    callback_defs.append(f"""    {return_type} Out{{}};
""")
                callback_defs.append("""    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
""")
                for p in hip_function_cxx.type.ptr_to.parameters:
                    dimmy_three =  p.name in dim_threes and (api_name == "HipDispatchTable" or actual_fun_name == "__hipPushCallConfiguration")
                    callback_defs.append(f"""    Args.{actual_fun_name}.{p.name} = {f"luthier::convertToRocprofilerDim3({p.name})" if dimmy_three else p.name};
""")
                callback_defs.append(
                    """    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
""")
                callback_defs.append(
                    f"""      {"Out =" if return_type != "void" else ""} HipInterceptor.{get_func}.{api_table_function_name}(""")
                for i, p in enumerate(hip_function_cxx.type.ptr_to.parameters):
                    dimmy_three =  p.name in dim_threes and (api_name == "HipDispatchTable" or actual_fun_name == "__hipPushCallConfiguration")
                    callback_defs.append(f'Args.{actual_fun_name}.{p.name}' if not dimmy_three else f"{p.name}")
                    if i != len(hip_function_cxx.type.ptr_to.parameters) - 1:
                        callback_defs.append(", ")
                callback_defs.append(");\n")
                callback_defs.append(
                    f"""    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    {"return Out;" if return_type != "void" else ""}
  }}
  else {{
""")
                callback_defs.append(f"""    return HipInterceptor.{get_func}.{api_table_function_name}(""")
                for i, p in enumerate(hip_function_cxx.type.ptr_to.parameters):
                    dimmy_three =  p.name in dim_threes and (api_name == "HipDispatchTable" or actual_fun_name == "__hipPushCallConfiguration")
                    callback_defs.append(p.name)
                    if i != len(hip_function_cxx.type.ptr_to.parameters) - 1:
                        callback_defs.append(", ")
                callback_defs.append(""");
  }
""")
                callback_defs.append("""}

""")

                if (api_name == "HipCompilerDispatchTable"):
                    compiler_defs += callback_defs
                else:
                    runtime_defs += callback_defs

                callback_defs.clear()


    # compiler captureCompilerDispatchTable
    compiler_capture_defs = []
    api_table = api_tables["HipCompilerDispatchTable"]
    # First create the wrapper install function's prototype
    compiler_capture_defs.append(
        f'void luthier::hip::CompilerInterceptor::captureCompilerDispatchTable(HipCompilerDispatchTable *CompilerTable) {{\n')
    compiler_capture_defs.append(f'\tSavedCompilerDispatchTable = *CompilerTable;\n')
    # for f in api_table.fields:
    #     # look for functions in the API Tables, not fields
    #     # function fields in the API table are defined as pointers to the decltype of their target HSA function
    #     if isinstance(f.type.typename, cxx_types.PQName) and f.type.typename.segments[0].name != 'size_t':
    #         # Name of the hsa function (e.g.) hsa_init
    #         # hsa_function_name = f.type.ptr_to.typename.segments[0].tokens[0].value
    #         # The field of the API Table this function corresponds to (e.g.) hsa_init_fn
    #         api_table_function_name = f.name
    #         actual_fun_name = api_table_function_name[:-3]

    #         if (actual_fun_name in bad):
    #             continue

    #         # Install the callback
    #         compiler_capture_defs.append(f'\tCompilerTable->{api_table_function_name} = {actual_fun_name}_callback;\n')
    compiler_capture_defs.append("};\n\n")


    # Runtime captureRuntimeTable
    runtime_capture_defs = []
    api_table = api_tables["HipDispatchTable"]
    # First create the wrapper install function's prototype
    runtime_capture_defs.append(
        f'void luthier::hip::RuntimeInterceptor::captureRuntimeTable(HipDispatchTable *RuntimeTable) {{\n')
    runtime_capture_defs.append(f'\tSavedDispatchTable = *RuntimeTable;\n')
    # for f in api_table.fields:
    #     # look for functions in the API Tables, not fields
    #     # function fields in the API table are defined as pointers to the decltype of their target HSA function
    #     if isinstance(f.type.typename, cxx_types.PQName) and f.type.typename.segments[0].name != 'size_t':
    #         # Name of the hsa function (e.g.) hsa_init
    #         # hsa_function_name = f.type.ptr_to.typename.segments[0].tokens[0].value
    #         # The field of the API Table this function corresponds to (e.g.) hsa_init_fn
    #         api_table_function_name = f.name
    #         actual_fun_name = api_table_function_name[:-3]
    #         # Install the callback
    #         if ((("ROCPROFILER_HIP_RUNTIME_API_ID_" + actual_fun_name) not in parsed_api_enum)
    #             or actual_fun_name in bad):
    #             continue

    #         runtime_capture_defs.append(f'\tRuntimeTable->{api_table_function_name} = {actual_fun_name}_callback;\n')
    runtime_capture_defs.append("};\n\n")

    compiler_callback_toggles = []
    runtime_callback_toggles = []
    toggle_defs = []
    for api_name in api_table_names:
        api_table = api_tables[api_name]
        get_func = table_gets[api_name]
        api_id_type = api_id_types[api_name]
        for f in api_table.fields:
            # look for functions in the API Tables, not fields
            # function fields in the API table are defined as pointers to the decltype of their target HIP function
            if isinstance(f.type.typename, cxx_types.PQName) and f.type.typename.segments[0].name != 'size_t':
                # Name of the hip function (e.g.) hip_init
                hip_function_name = f.type.typename.segments[0].name
                # The field of the API Table this function corresponds to (e.g.) hip_init_fn
                api_table_function_name = f.name
                # The hip function representation parsed by cxxheaderparser
                hip_function_cxx = hip_functions[hip_function_name]

                # Format the args for later
                formatted_params = [p.format() for p in hip_function_cxx.type.ptr_to.parameters]
                # Generate the callback
                return_type = hip_function_cxx.type.ptr_to.return_type.format()
                actual_fun_name = api_table_function_name[:-3]
                if ((api_name == "HipDispatchTable" and ("ROCPROFILER_HIP_RUNTIME_API_ID_" + actual_fun_name) not in parsed_api_enum)
                    or actual_fun_name in bad):
                    continue

                if api_name == "HipCompilerDispatchTable":
                    toggle_defs.append(f"""static void toggle_{actual_fun_name}(HipCompilerDispatchTable *InternalHipApiTable, HipCompilerDispatchTable SavedTable, bool On) {{
  if (On)
    InternalHipApiTable->{actual_fun_name}_fn = {actual_fun_name}_callback;
  else
    InternalHipApiTable->{actual_fun_name}_fn = {"createInterceptQueue" if actual_fun_name == "hsa_queue_create" else f"SavedTable.{actual_fun_name}_fn"};
}}\n\n""")
                else:
                    toggle_defs.append(f"""static void toggle_{actual_fun_name}(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {{
  if (On)
    InternalRuntimeDispatchTable->{actual_fun_name}_fn = {actual_fun_name}_callback;
  else
    InternalRuntimeDispatchTable->{actual_fun_name}_fn = {"createInterceptQueue" if actual_fun_name == "hsa_queue_create" else f"SavedTable.{actual_fun_name}_fn"};
}}\n\n""")
                
                if (api_name == "HipCompilerDispatchTable"):
                    compiler_callback_toggles += toggle_defs
                else:
                    runtime_callback_toggles += toggle_defs

                toggle_defs.clear()

    compiler_map_def = ["static const llvm::DenseMap<rocprofiler_hip_compiler_api_id_t, std::function<void(HipCompilerDispatchTable *, const HipCompilerDispatchTable &, bool On)>> HipCompilerDispatchCallbackToggleFunctionsMap {\n"]
    runtime_map_def = ["static const llvm::DenseMap<rocprofiler_hip_runtime_api_id_t, std::function<void(HipDispatchTable *, const HipDispatchTable &, bool On)>> HipDispatchCallbackToggleFunctionsMap {\n"]

    for api_name in api_table_names:
        api_table = api_tables[api_name]
        get_func = table_gets[api_name]
        api_id_type = api_id_types[api_name]
        for f in api_table.fields:
            # look for functions in the API Tables, not fields
            # function fields in the API table are defined as pointers to the decltype of their target HIP function
            if isinstance(f.type.typename, cxx_types.PQName) and f.type.typename.segments[0].name != 'size_t':
                # Name of the hip function (e.g.) hip_init
                hip_function_name = f.type.typename.segments[0].name
                # The field of the API Table this function corresponds to (e.g.) hip_init_fn
                api_table_function_name = f.name
                # The hip function representation parsed by cxxheaderparser
                hip_function_cxx = hip_functions[hip_function_name]

                # Format the args for later
                formatted_params = [p.format() for p in hip_function_cxx.type.ptr_to.parameters]
                # Generate the callback
                return_type = hip_function_cxx.type.ptr_to.return_type.format()
                actual_fun_name = api_table_function_name[:-3]
                if ((api_name == "HipDispatchTable" and ("ROCPROFILER_HIP_RUNTIME_API_ID_" + actual_fun_name) not in parsed_api_enum)
                    or actual_fun_name in bad):
                    continue

                if (api_name == "HipCompilerDispatchTable"):
                    compiler_map_def.append(f"""  {{ ROCPROFILER_HIP_COMPILER_API_ID_{actual_fun_name}, toggle_{actual_fun_name} }},\n""")
                else:
                    runtime_map_def.append(f"""  {{ ROCPROFILER_HIP_RUNTIME_API_ID_{actual_fun_name}, toggle_{actual_fun_name} }},\n""")

    compiler_map_def.append("};")
    runtime_map_def.append("};")

    compiler_enable_disable_funcs = f"""
void luthier::hip::CompilerInterceptor::enableUserCallback(rocprofiler_hip_compiler_api_id_t Op) {{
  HipCompilerDispatchCallbackToggleFunctionsMap.at(Op)(InternalCompilerDispatchTable, SavedCompilerDispatchTable, true);
  EnabledUserOps.insert(Op);
}}

void luthier::hip::CompilerInterceptor::disableUserCallback(rocprofiler_hip_compiler_api_id_t Op) {{
  EnabledUserOps.erase(Op);
  if (!EnabledInternalOps.contains(Op))
    HipCompilerDispatchCallbackToggleFunctionsMap.at(Op)(InternalCompilerDispatchTable, SavedCompilerDispatchTable, false);
}}

void luthier::hip::CompilerInterceptor::enableInternalCallback(rocprofiler_hip_compiler_api_id_t Op) {{
  HipCompilerDispatchCallbackToggleFunctionsMap.at(Op)(InternalCompilerDispatchTable, SavedCompilerDispatchTable, true);
  EnabledInternalOps.insert(Op);
}}

void luthier::hip::CompilerInterceptor::disableInternalCallback(rocprofiler_hip_compiler_api_id_t Op) {{
  EnabledInternalOps.erase(Op);
  if (!EnabledUserOps.contains(Op))
    HipCompilerDispatchCallbackToggleFunctionsMap.at(Op)(InternalCompilerDispatchTable, SavedCompilerDispatchTable, false);
}}\n\n"""
    
    runtime_enable_disable_funcs = f"""
void luthier::hip::RuntimeInterceptor::enableUserCallback(rocprofiler_hip_runtime_api_id_t Op) {{
  HipDispatchCallbackToggleFunctionsMap.at(Op)(InternalRuntimeDispatchTable, SavedDispatchTable, true);
  EnabledUserOps.insert(Op);
}}

void luthier::hip::RuntimeInterceptor::disableUserCallback(rocprofiler_hip_runtime_api_id_t Op) {{
  EnabledUserOps.erase(Op);
  if (!EnabledInternalOps.contains(Op))
    HipDispatchCallbackToggleFunctionsMap.at(Op)(InternalRuntimeDispatchTable, SavedDispatchTable, false);
}}

void luthier::hip::RuntimeInterceptor::enableInternalCallback(rocprofiler_hip_runtime_api_id_t Op) {{
  HipDispatchCallbackToggleFunctionsMap.at(Op)(InternalRuntimeDispatchTable, SavedDispatchTable, true);
  EnabledInternalOps.insert(Op);
}}

void luthier::hip::RuntimeInterceptor::disableInternalCallback(rocprofiler_hip_runtime_api_id_t Op) {{
  EnabledInternalOps.erase(Op);
  if (!EnabledUserOps.contains(Op))
    HipDispatchCallbackToggleFunctionsMap.at(Op)(InternalRuntimeDispatchTable, SavedDispatchTable, false);
}}\n\n"""

    with open(args.cpp_compiler_callback_save_path, "w") as f:
        f.writelines("// NOLINTBEGIN\n")
        f.writelines(compiler_defs)
        f.write("\n")
        f.writelines(compiler_capture_defs)
        f.write("\n")
        f.writelines(compiler_callback_toggles)
        f.write("\n")
        f.writelines(compiler_map_def)
        f.write("\n")
        f.writelines(compiler_enable_disable_funcs)
        f.writelines("// NOLINTEND\n")

    with open(args.cpp_runtime_callback_save_path, "w") as f:
        f.writelines("// NOLINTBEGIN\n")
        f.writelines(runtime_defs)
        f.write("\n")
        f.writelines(runtime_capture_defs)
        f.write("\n")
        f.writelines(runtime_callback_toggles)
        f.write("\n")
        f.writelines(runtime_map_def)
        f.write("\n")
        f.writelines(runtime_enable_disable_funcs)
        f.writelines("// NOLINTEND\n")


if __name__ == "__main__":
    main()
