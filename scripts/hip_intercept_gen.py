# !/usr/bin/env python3
import os
import io
import re

import argparse

from cxxheaderparser.simple import parse_string, ClassScope, ParsedData, Function
import cxxheaderparser.types as cxx_types
from header_preprocessor import ROCmPreprocessor
from typing import *


def parse_and_validate_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser("HIP API interception generation script for Luthier; Originally used by AMD in "
                                     "the Roctracer project")
    parser.add_argument("--hip-include-dir", type=str,
                        default="/opt/rocm/include/hip/amd_detail/",
                        help="location of the HIP include directory")
    parser.add_argument("--cpp-callback-save-path", type=str,
                        default="../src/hip_intercept.cpp",
                        help="location of where the generated C++ callback file will be saved")
    parser.add_argument("--hpp-structs-save-path", type=str,
                        default="../include/luthier/hip_trace_api.h",
                        help="location of where the generated C++ header file containing the callback args struct "
                             "and callback enumerators will be saved")
    args = parser.parse_args()
    return args


def parse_header_file(header_file: str) -> ParsedData:
    preprocessor = ROCmPreprocessor()
    preprocessor.line_directive = None
    preprocessor.passthru_unfound_includes = True
    preprocessor.passthru_includes = re.compile(r".*")
    preprocessor.define("__GNUC__")
    preprocessor.define("LITTLEENDIAN_CPU")
    preprocessor.define("_M_X64")
    preprocessor.define("ROCPROFILER_EXTERN_C_INIT")
    preprocessor.define("ROCPROFILER_EXTERN_C_FINI")
    with open(header_file, 'r') as hf:
        preprocessor.parse(hf)
        str_io = io.StringIO()
        preprocessor.write(str_io)
    preprocessed_header = str_io.getvalue()
    parsed = parse_string(preprocessed_header)
    str_io.close()
    return parsed


def parse_hip_typedefs(header_files: Iterable[str]) -> dict[str, Function]:
    functions = {}
    for header in header_files:
        phf = parse_header_file(header)
        for f in phf.namespace.typedefs:
            functions[f.name] = f
    return functions


def get_api_tables(parsed_hip_api_trace_header: ParsedData, api_table_names: List[str]) -> Dict[str, ClassScope]:
    api_tables = {}
    for cls in parsed_hip_api_trace_header.namespace.classes:
        typename = cls.class_decl.typename
        if typename.classkey == "struct" and len(typename.segments) == 1 \
                and typename.segments[0].name in api_table_names:
            api_tables[typename.segments[0].name] = cls
    return api_tables


def main():
    # Name of the API tables to capture in HIP
    api_table_names = ["HipCompilerDispatchTable", "HipDispatchTable"]

    args = parse_and_validate_args()
    # All possible HIP API functions are located in these headers
    hip_include_files = tuple(os.path.join(args.hip_include_dir, header_file) for header_file in
                              ["hip_api_trace.hpp"])

    parsed_api_enum = parse_header_file("/opt/rocm/include/rocprofiler-sdk/hip/runtime_api_id.h")
    parsed_api_enum = [ting.name for ting in parsed_api_enum.namespace.enums[0].values]

    # parsed_args = parse_header_file("/opt/rocm/include/rocprofiler-sdk/hip/api_args.h")
    # print(parsed_args.namespace.classes[2].classes)
    # print([ting.class_decl.typename.segments[0].name for ting in parsed_args.namespace.classes[2]])

    # This returns a Dict that contains all HIP API functions and other functions not of interest to us.
    # It maps the name of the function (e.g. hip_init) to its cxxheaderparser Function type
    hip_functions = parse_hip_typedefs(hip_include_files)

    parsed_api_trace_header = parse_header_file(os.path.join(args.hip_include_dir, "hip_api_trace.hpp"))

    # Parse the API tables in hip_api_trace.h
    api_tables = get_api_tables(parsed_api_trace_header, api_table_names)

    table_gets = { "HipCompilerDispatchTable" : 'getSavedCompilerTable()', "HipDispatchTable" : "getSavedRuntimeTable()" }

    api_id_types  = { "HipCompilerDispatchTable" : "ROCPROFILER_HIP_COMPILER_API_ID_",
                     "HipDispatchTable" : "ROCPROFILER_HIP_RUNTIME_API_ID_" }

    # Generate the callback functions that will replace the original HIP functions
    callback_defs = []
    compiler_defs = [f"""/* Generated by {os.path.basename(__file__)}. DO NOT EDIT! */
#include "hip/hip_compiler_intercept.hpp"
#include "luthier/types.h"
#include <rocprofiler-sdk/hip/api_args.h>
#include <rocprofiler-sdk/hip/api_id.h>

rocprofiler_dim3_t convertToRocprofilerDim3(const dim3& d) {{
    return rocprofiler_dim3_t{{d.x, d.y, d.z}};
}}

"""]

    runtime_defs = [f"""/* Generated by {os.path.basename(__file__)}. DO NOT EDIT! */
#include "hip/hip_runtime_intercept.hpp"
#include "luthier/types.h"
#include <rocprofiler-sdk/hip/api_args.h>
#include <rocprofiler-sdk/hip/api_id.h>

rocprofiler_dim3_t convertToRocprofilerDim3(const dim3& d) {{
    return rocprofiler_dim3_t{{d.x, d.y, d.z}};
}}


"""]

    bad = [
"hipChooseDeviceR0000",
"hipGetDevicePropertiesR0600",
"hipGetDevicePropertiesR0000",
"hipKernelNameRef",
"hipLaunchCooperativeKernel",
"hipModuleLaunchCooperativeKernel",
"hipModuleLaunchKernel",
"hipModuleOccupancyMaxActiveBlocksPerMultiprocessor",
"hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags",
"hipModuleOccupancyMaxPotentialBlockSize",
"hipModuleOccupancyMaxPotentialBlockSizeWithFlags",
"hipOccupancyMaxActiveBlocksPerMultiprocessor",
"hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags",
"hipOccupancyMaxPotentialBlockSize",
"hipExtModuleLaunchKernel",
"hipHccModuleLaunchKernel",
"hipLaunchCooperativeKernel_spt"
    ]

    dim_threes = [
        "gridDim",
        "blockDim",
        "numBlocks",
        "dimBlocks"
    ]

    for api_name in api_table_names:
        api_table = api_tables[api_name]
        get_func = table_gets[api_name]
        api_id_type = api_id_types[api_name]
        for f in api_table.fields:
            # look for functions in the API Tables, not fields
            # function fields in the API table are defined as pointers to the decltype of their target HIP function
            if isinstance(f.type.typename, cxx_types.PQName) and f.type.typename.segments[0].name != 'size_t':
                # Name of the hip function (e.g.) hip_init
                hip_function_name = f.type.typename.segments[0].name
                # The field of the API Table this function corresponds to (e.g.) hip_init_fn
                api_table_function_name = f.name
                # The hip function representation parsed by cxxheaderparser
                hip_function_cxx = hip_functions[hip_function_name]

                # Format the args for later
                formatted_params = [p.format() for p in hip_function_cxx.type.ptr_to.parameters]
                # Generate the callback
                return_type = hip_function_cxx.type.ptr_to.return_type.format()
                actual_fun_name = api_table_function_name[:-3]

                if ((api_name == "HipDispatchTable" and ("ROCPROFILER_HIP_RUNTIME_API_ID_" + actual_fun_name) not in parsed_api_enum)
                    or actual_fun_name in bad):
                    continue

                callback_defs.append(
                    f"""static {return_type} {actual_fun_name}_callback({", ".join(formatted_params)}) {{
  auto& HipInterceptor = luthier::hip::{"Compiler" if (api_name == "HipCompilerDispatchTable") else "Runtime"}Interceptor::instance();
  auto ApiId = {api_id_type}{actual_fun_name};
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {{
""")
                if return_type != "void":
                    callback_defs.append(f"""    {return_type} Out{{}};
""")
                callback_defs.append("""    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
""")
                for p in hip_function_cxx.type.ptr_to.parameters:
                    dimmy_three =  p.name in dim_threes and (api_name == "HipDispatchTable" or actual_fun_name == "__hipPushCallConfiguration")
                    callback_defs.append(f"""    Args.{actual_fun_name}.{p.name} = {f"convertToRocprofilerDim3({p.name})" if dimmy_three else p.name};
""")
                callback_defs.append(
                    """    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
""")
                callback_defs.append(
                    f"""      {"Out =" if return_type != "void" else ""} HipInterceptor.{get_func}.{api_table_function_name}(""")
                for i, p in enumerate(hip_function_cxx.type.ptr_to.parameters):
                    dimmy_three =  p.name in dim_threes and (api_name == "HipDispatchTable" or actual_fun_name == "__hipPushCallConfiguration")
                    callback_defs.append(f'Args.{actual_fun_name}.{p.name}' if not dimmy_three else f"{p.name}")
                    if i != len(hip_function_cxx.type.ptr_to.parameters) - 1:
                        callback_defs.append(", ")
                callback_defs.append(");\n")
                callback_defs.append(
                    f"""    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    {"return Out;" if return_type != "void" else ""}
  }}
  else {{
""")
                callback_defs.append(f"""    return HipInterceptor.{get_func}.{api_table_function_name}(""")
                for i, p in enumerate(hip_function_cxx.type.ptr_to.parameters):
                    dimmy_three =  p.name in dim_threes and (api_name == "HipDispatchTable" or actual_fun_name == "__hipPushCallConfiguration")
                    callback_defs.append(p.name)
                    if i != len(hip_function_cxx.type.ptr_to.parameters) - 1:
                        callback_defs.append(", ")
                callback_defs.append(""");
  }
""")
                callback_defs.append("""}

""")

                if (api_name == "HipCompilerDispatchTable"):
                    compiler_defs += callback_defs
                else:
                    runtime_defs += callback_defs

                callback_defs.clear()


    # compiler captureCompilerDispatchTable
    compiler_capture_defs = []
    api_table = api_tables["HipCompilerDispatchTable"]
    # First create the wrapper install function's prototype
    compiler_capture_defs.append(
        f'void luthier::hip::CompilerInterceptor::captureCompilerDispatchTable(HipCompilerDispatchTable *CompilerTable) {{\n')
    compiler_capture_defs.append(f'\tSavedCompilerDispatchTable = *CompilerTable;\n')
    for f in api_table.fields:
        # look for functions in the API Tables, not fields
        # function fields in the API table are defined as pointers to the decltype of their target HSA function
        if isinstance(f.type.typename, cxx_types.PQName) and f.type.typename.segments[0].name != 'size_t':
            # Name of the hsa function (e.g.) hsa_init
            # hsa_function_name = f.type.ptr_to.typename.segments[0].tokens[0].value
            # The field of the API Table this function corresponds to (e.g.) hsa_init_fn
            api_table_function_name = f.name
            actual_fun_name = api_table_function_name[:-3]

            if (actual_fun_name in bad):
                continue

            # Install the callback
            compiler_capture_defs.append(f'\tCompilerTable->{api_table_function_name} = {actual_fun_name}_callback;\n')
    compiler_capture_defs.append("};\n\n")


    # Runtime captureRuntimeTable
    runtime_capture_defs = []
    api_table = api_tables["HipDispatchTable"]
    # First create the wrapper install function's prototype
    runtime_capture_defs.append(
        f'void luthier::hip::RuntimeInterceptor::captureRuntimeTable(HipDispatchTable *RuntimeTable) {{\n')
    runtime_capture_defs.append(f'\tSavedDispatchTable = *RuntimeTable;\n')
    for f in api_table.fields:
        # look for functions in the API Tables, not fields
        # function fields in the API table are defined as pointers to the decltype of their target HSA function
        if isinstance(f.type.typename, cxx_types.PQName) and f.type.typename.segments[0].name != 'size_t':
            # Name of the hsa function (e.g.) hsa_init
            # hsa_function_name = f.type.ptr_to.typename.segments[0].tokens[0].value
            # The field of the API Table this function corresponds to (e.g.) hsa_init_fn
            api_table_function_name = f.name
            actual_fun_name = api_table_function_name[:-3]
            # Install the callback
            if ((("ROCPROFILER_HIP_RUNTIME_API_ID_" + actual_fun_name) not in parsed_api_enum)
                or actual_fun_name in bad):
                continue

            runtime_capture_defs.append(f'\tRuntimeTable->{api_table_function_name} = {actual_fun_name}_callback;\n')
    runtime_capture_defs.append("};\n\n")

    with open("/root/Luthier/src/hip_compiler_intercept.cpp", "w") as f:
        f.writelines("// NOLINTBEGIN\n")
        f.writelines(compiler_defs)
        f.write("\n")
        f.writelines(compiler_capture_defs)
        f.writelines("// NOLINTEND\n")

    with open("/root/Luthier/src/hip_runtime_intercept.cpp", "w") as f:
        f.writelines("// NOLINTBEGIN\n")
        f.writelines(runtime_defs)
        f.write("\n")
        f.writelines(runtime_capture_defs)
        f.writelines("// NOLINTEND\n")


if __name__ == "__main__":
    main()
