// NOLINTBEGIN
/* Generated by hsa_intercept_gen.py. DO NOT EDIT! */
#include <hsa/hsa_api_trace.h>
#include "luthier/hsa_trace_api.h"
#include "hsa_intercept.hpp"
#include "luthier/types.h"

//bool luthier::hsa::Interceptor::EnableTempCallback = true;

void queueSubmitWriteInterceptor(const void *Packets, uint64_t PktCount,
                                 uint64_t UserPktIndex, void *Data, 
                                 hsa_amd_queue_intercept_packet_writer Writer) {
  auto &HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto &HsaUserCallback = HsaInterceptor.getUserCallback();
  auto &HsaInternalCallback = HsaInterceptor.getInternalCallback();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_packet_submit;
  luthier::hsa::ApiEvtArgs Args;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId);
  if (IsUserCallbackEnabled || IsInternalCallbackEnabled) {
    // Copy the packets to a non-const buffer
    std::vector<luthier::HsaAqlPacket> ModifiedPackets(
      reinterpret_cast<const luthier::HsaAqlPacket*>(Packets),
      reinterpret_cast<const luthier::HsaAqlPacket*>(Packets) + PktCount);
    Args.hsa_queue_packet_submit.packets = ModifiedPackets.data();
    Args.hsa_queue_packet_submit.pkt_count = PktCount;
    Args.hsa_queue_packet_submit.user_pkt_index = UserPktIndex;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, nullptr);
    // Write the packets to hardware queue
    // Even if the packets are not modified, this call has to be made to ensure
    // the packets are copied to the hardware queue
    Writer(Args.hsa_queue_packet_submit.packets, Args.hsa_queue_packet_submit.pkt_count);
  } else {
    Writer(Packets, PktCount);
  }
}

static hsa_status_t createInterceptQueue(hsa_agent_t agent, uint32_t size, 
                                         hsa_queue_type32_t type, 
                                         void (* callback)(hsa_status_t status, hsa_queue_t* source, void* data), 
                                         void* data, uint32_t private_segment_size, 
                                         uint32_t group_segment_size, hsa_queue_t** queue) {
    const auto& AmdExtTable = luthier::hsa::Interceptor::instance().getSavedHsaTables().amd_ext;
    hsa_status_t Out = AmdExtTable.hsa_amd_queue_intercept_create_fn(agent, 
                                                                     size,
                                                                     type, 
                                                                     callback,
                                                                     data, 
                                                                     private_segment_size,
                                                                     group_segment_size, 
                                                                     queue);
    if (Out != HSA_STATUS_SUCCESS)
      return Out;
    Out = AmdExtTable.hsa_amd_queue_intercept_register_fn(*queue, queueSubmitWriteInterceptor, *queue);
    return Out;
}
static hsa_status_t hsa_init_callback() {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_init;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_init_fn();
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_init_fn();
  }
}

static hsa_status_t hsa_shut_down_callback() {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_shut_down;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_shut_down_fn();
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_shut_down_fn();
  }
}

static hsa_status_t hsa_system_get_info_callback(hsa_system_info_t attribute, void* value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_system_get_info;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_system_get_info.attribute = attribute;
    Args.hsa_system_get_info.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_system_get_info_fn(Args.hsa_system_get_info.attribute, Args.hsa_system_get_info.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_system_get_info_fn(attribute, value);
  }
}

static hsa_status_t hsa_system_extension_supported_callback(uint16_t extension, uint16_t version_major, uint16_t version_minor, bool* result) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_system_extension_supported;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_system_extension_supported.extension = extension;
    Args.hsa_system_extension_supported.version_major = version_major;
    Args.hsa_system_extension_supported.version_minor = version_minor;
    Args.hsa_system_extension_supported.result = result;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_system_extension_supported_fn(Args.hsa_system_extension_supported.extension, Args.hsa_system_extension_supported.version_major, Args.hsa_system_extension_supported.version_minor, Args.hsa_system_extension_supported.result);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_system_extension_supported_fn(extension, version_major, version_minor, result);
  }
}

static hsa_status_t hsa_system_get_extension_table_callback(uint16_t extension, uint16_t version_major, uint16_t version_minor, void* table) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_system_get_extension_table;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_system_get_extension_table.extension = extension;
    Args.hsa_system_get_extension_table.version_major = version_major;
    Args.hsa_system_get_extension_table.version_minor = version_minor;
    Args.hsa_system_get_extension_table.table = table;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_system_get_extension_table_fn(Args.hsa_system_get_extension_table.extension, Args.hsa_system_get_extension_table.version_major, Args.hsa_system_get_extension_table.version_minor, Args.hsa_system_get_extension_table.table);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_system_get_extension_table_fn(extension, version_major, version_minor, table);
  }
}

static hsa_status_t hsa_iterate_agents_callback(hsa_status_t (* callback)(hsa_agent_t agent, void* data), void* data) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_iterate_agents;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_iterate_agents.callback = callback;
    Args.hsa_iterate_agents.data = data;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_iterate_agents_fn(Args.hsa_iterate_agents.callback, Args.hsa_iterate_agents.data);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_iterate_agents_fn(callback, data);
  }
}

static hsa_status_t hsa_agent_get_info_callback(hsa_agent_t agent, hsa_agent_info_t attribute, void* value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_agent_get_info;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_agent_get_info.agent = agent;
    Args.hsa_agent_get_info.attribute = attribute;
    Args.hsa_agent_get_info.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_agent_get_info_fn(Args.hsa_agent_get_info.agent, Args.hsa_agent_get_info.attribute, Args.hsa_agent_get_info.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_agent_get_info_fn(agent, attribute, value);
  }
}

static hsa_status_t hsa_queue_create_callback(hsa_agent_t agent, uint32_t size, hsa_queue_type32_t type, void (* callback)(hsa_status_t status, hsa_queue_t* source, void* data), void* data, uint32_t private_segment_size, uint32_t group_segment_size, hsa_queue_t** queue) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_create;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_create.agent = agent;
    Args.hsa_queue_create.size = size;
    Args.hsa_queue_create.type = type;
    Args.hsa_queue_create.callback = callback;
    Args.hsa_queue_create.data = data;
    Args.hsa_queue_create.private_segment_size = private_segment_size;
    Args.hsa_queue_create.group_segment_size = group_segment_size;
    Args.hsa_queue_create.queue = queue;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = createInterceptQueue(
                                                            Args.hsa_queue_create.agent, 
                                                            Args.hsa_queue_create.size,
                                                            Args.hsa_queue_create.type, 
                                                            Args.hsa_queue_create.callback,
                                                            Args.hsa_queue_create.data, 
                                                            Args.hsa_queue_create.private_segment_size,
                                                            Args.hsa_queue_create.group_segment_size, 
                                                            Args.hsa_queue_create.queue);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return createInterceptQueue(
                                                           agent, 
                                                           size,
                                                           type, 
                                                           callback,
                                                           data, 
                                                           private_segment_size,
                                                           group_segment_size, 
                                                           queue);
  }
}

static hsa_status_t hsa_soft_queue_create_callback(hsa_region_t region, uint32_t size, hsa_queue_type32_t type, uint32_t features, hsa_signal_t doorbell_signal, hsa_queue_t** queue) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_soft_queue_create;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_soft_queue_create.region = region;
    Args.hsa_soft_queue_create.size = size;
    Args.hsa_soft_queue_create.type = type;
    Args.hsa_soft_queue_create.features = features;
    Args.hsa_soft_queue_create.doorbell_signal = doorbell_signal;
    Args.hsa_soft_queue_create.queue = queue;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_soft_queue_create_fn(Args.hsa_soft_queue_create.region, Args.hsa_soft_queue_create.size, Args.hsa_soft_queue_create.type, Args.hsa_soft_queue_create.features, Args.hsa_soft_queue_create.doorbell_signal, Args.hsa_soft_queue_create.queue);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_soft_queue_create_fn(region, size, type, features, doorbell_signal, queue);
  }
}

static hsa_status_t hsa_queue_destroy_callback(hsa_queue_t* queue) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_destroy;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_destroy.queue = queue;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_queue_destroy_fn(Args.hsa_queue_destroy.queue);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_destroy_fn(queue);
  }
}

static hsa_status_t hsa_queue_inactivate_callback(hsa_queue_t* queue) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_inactivate;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_inactivate.queue = queue;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_queue_inactivate_fn(Args.hsa_queue_inactivate.queue);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_inactivate_fn(queue);
  }
}

static uint64_t hsa_queue_load_read_index_scacquire_callback(const hsa_queue_t* queue) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_load_read_index_scacquire;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    uint64_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_load_read_index_scacquire.queue = queue;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_queue_load_read_index_scacquire_fn(Args.hsa_queue_load_read_index_scacquire.queue);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_load_read_index_scacquire_fn(queue);
  }
}

static uint64_t hsa_queue_load_read_index_relaxed_callback(const hsa_queue_t* queue) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_load_read_index_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    uint64_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_load_read_index_relaxed.queue = queue;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_queue_load_read_index_relaxed_fn(Args.hsa_queue_load_read_index_relaxed.queue);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_load_read_index_relaxed_fn(queue);
  }
}

static uint64_t hsa_queue_load_write_index_scacquire_callback(const hsa_queue_t* queue) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_load_write_index_scacquire;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    uint64_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_load_write_index_scacquire.queue = queue;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_queue_load_write_index_scacquire_fn(Args.hsa_queue_load_write_index_scacquire.queue);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_load_write_index_scacquire_fn(queue);
  }
}

static uint64_t hsa_queue_load_write_index_relaxed_callback(const hsa_queue_t* queue) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_load_write_index_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    uint64_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_load_write_index_relaxed.queue = queue;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_queue_load_write_index_relaxed_fn(Args.hsa_queue_load_write_index_relaxed.queue);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_load_write_index_relaxed_fn(queue);
  }
}

static void hsa_queue_store_write_index_relaxed_callback(const hsa_queue_t* queue, uint64_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_store_write_index_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_store_write_index_relaxed.queue = queue;
    Args.hsa_queue_store_write_index_relaxed.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_queue_store_write_index_relaxed_fn(Args.hsa_queue_store_write_index_relaxed.queue, Args.hsa_queue_store_write_index_relaxed.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_store_write_index_relaxed_fn(queue, value);
  }
}

static void hsa_queue_store_write_index_screlease_callback(const hsa_queue_t* queue, uint64_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_store_write_index_screlease;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_store_write_index_screlease.queue = queue;
    Args.hsa_queue_store_write_index_screlease.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_queue_store_write_index_screlease_fn(Args.hsa_queue_store_write_index_screlease.queue, Args.hsa_queue_store_write_index_screlease.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_store_write_index_screlease_fn(queue, value);
  }
}

static uint64_t hsa_queue_cas_write_index_scacq_screl_callback(const hsa_queue_t* queue, uint64_t expected, uint64_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_cas_write_index_scacq_screl;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    uint64_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_cas_write_index_scacq_screl.queue = queue;
    Args.hsa_queue_cas_write_index_scacq_screl.expected = expected;
    Args.hsa_queue_cas_write_index_scacq_screl.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_queue_cas_write_index_scacq_screl_fn(Args.hsa_queue_cas_write_index_scacq_screl.queue, Args.hsa_queue_cas_write_index_scacq_screl.expected, Args.hsa_queue_cas_write_index_scacq_screl.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_cas_write_index_scacq_screl_fn(queue, expected, value);
  }
}

static uint64_t hsa_queue_cas_write_index_scacquire_callback(const hsa_queue_t* queue, uint64_t expected, uint64_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_cas_write_index_scacquire;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    uint64_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_cas_write_index_scacquire.queue = queue;
    Args.hsa_queue_cas_write_index_scacquire.expected = expected;
    Args.hsa_queue_cas_write_index_scacquire.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_queue_cas_write_index_scacquire_fn(Args.hsa_queue_cas_write_index_scacquire.queue, Args.hsa_queue_cas_write_index_scacquire.expected, Args.hsa_queue_cas_write_index_scacquire.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_cas_write_index_scacquire_fn(queue, expected, value);
  }
}

static uint64_t hsa_queue_cas_write_index_relaxed_callback(const hsa_queue_t* queue, uint64_t expected, uint64_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_cas_write_index_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    uint64_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_cas_write_index_relaxed.queue = queue;
    Args.hsa_queue_cas_write_index_relaxed.expected = expected;
    Args.hsa_queue_cas_write_index_relaxed.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_queue_cas_write_index_relaxed_fn(Args.hsa_queue_cas_write_index_relaxed.queue, Args.hsa_queue_cas_write_index_relaxed.expected, Args.hsa_queue_cas_write_index_relaxed.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_cas_write_index_relaxed_fn(queue, expected, value);
  }
}

static uint64_t hsa_queue_cas_write_index_screlease_callback(const hsa_queue_t* queue, uint64_t expected, uint64_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_cas_write_index_screlease;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    uint64_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_cas_write_index_screlease.queue = queue;
    Args.hsa_queue_cas_write_index_screlease.expected = expected;
    Args.hsa_queue_cas_write_index_screlease.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_queue_cas_write_index_screlease_fn(Args.hsa_queue_cas_write_index_screlease.queue, Args.hsa_queue_cas_write_index_screlease.expected, Args.hsa_queue_cas_write_index_screlease.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_cas_write_index_screlease_fn(queue, expected, value);
  }
}

static uint64_t hsa_queue_add_write_index_scacq_screl_callback(const hsa_queue_t* queue, uint64_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_add_write_index_scacq_screl;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    uint64_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_add_write_index_scacq_screl.queue = queue;
    Args.hsa_queue_add_write_index_scacq_screl.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_queue_add_write_index_scacq_screl_fn(Args.hsa_queue_add_write_index_scacq_screl.queue, Args.hsa_queue_add_write_index_scacq_screl.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_add_write_index_scacq_screl_fn(queue, value);
  }
}

static uint64_t hsa_queue_add_write_index_scacquire_callback(const hsa_queue_t* queue, uint64_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_add_write_index_scacquire;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    uint64_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_add_write_index_scacquire.queue = queue;
    Args.hsa_queue_add_write_index_scacquire.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_queue_add_write_index_scacquire_fn(Args.hsa_queue_add_write_index_scacquire.queue, Args.hsa_queue_add_write_index_scacquire.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_add_write_index_scacquire_fn(queue, value);
  }
}

static uint64_t hsa_queue_add_write_index_relaxed_callback(const hsa_queue_t* queue, uint64_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_add_write_index_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    uint64_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_add_write_index_relaxed.queue = queue;
    Args.hsa_queue_add_write_index_relaxed.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_queue_add_write_index_relaxed_fn(Args.hsa_queue_add_write_index_relaxed.queue, Args.hsa_queue_add_write_index_relaxed.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_add_write_index_relaxed_fn(queue, value);
  }
}

static uint64_t hsa_queue_add_write_index_screlease_callback(const hsa_queue_t* queue, uint64_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_add_write_index_screlease;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    uint64_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_add_write_index_screlease.queue = queue;
    Args.hsa_queue_add_write_index_screlease.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_queue_add_write_index_screlease_fn(Args.hsa_queue_add_write_index_screlease.queue, Args.hsa_queue_add_write_index_screlease.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_add_write_index_screlease_fn(queue, value);
  }
}

static void hsa_queue_store_read_index_relaxed_callback(const hsa_queue_t* queue, uint64_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_store_read_index_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_store_read_index_relaxed.queue = queue;
    Args.hsa_queue_store_read_index_relaxed.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_queue_store_read_index_relaxed_fn(Args.hsa_queue_store_read_index_relaxed.queue, Args.hsa_queue_store_read_index_relaxed.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_store_read_index_relaxed_fn(queue, value);
  }
}

static void hsa_queue_store_read_index_screlease_callback(const hsa_queue_t* queue, uint64_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_queue_store_read_index_screlease;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_queue_store_read_index_screlease.queue = queue;
    Args.hsa_queue_store_read_index_screlease.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_queue_store_read_index_screlease_fn(Args.hsa_queue_store_read_index_screlease.queue, Args.hsa_queue_store_read_index_screlease.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_queue_store_read_index_screlease_fn(queue, value);
  }
}

static hsa_status_t hsa_agent_iterate_regions_callback(hsa_agent_t agent, hsa_status_t (* callback)(hsa_region_t region, void* data), void* data) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_agent_iterate_regions;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_agent_iterate_regions.agent = agent;
    Args.hsa_agent_iterate_regions.callback = callback;
    Args.hsa_agent_iterate_regions.data = data;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_agent_iterate_regions_fn(Args.hsa_agent_iterate_regions.agent, Args.hsa_agent_iterate_regions.callback, Args.hsa_agent_iterate_regions.data);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_agent_iterate_regions_fn(agent, callback, data);
  }
}

static hsa_status_t hsa_region_get_info_callback(hsa_region_t region, hsa_region_info_t attribute, void* value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_region_get_info;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_region_get_info.region = region;
    Args.hsa_region_get_info.attribute = attribute;
    Args.hsa_region_get_info.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_region_get_info_fn(Args.hsa_region_get_info.region, Args.hsa_region_get_info.attribute, Args.hsa_region_get_info.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_region_get_info_fn(region, attribute, value);
  }
}

static hsa_status_t hsa_agent_get_exception_policies_callback(hsa_agent_t agent, hsa_profile_t profile, uint16_t* mask) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_agent_get_exception_policies;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_agent_get_exception_policies.agent = agent;
    Args.hsa_agent_get_exception_policies.profile = profile;
    Args.hsa_agent_get_exception_policies.mask = mask;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_agent_get_exception_policies_fn(Args.hsa_agent_get_exception_policies.agent, Args.hsa_agent_get_exception_policies.profile, Args.hsa_agent_get_exception_policies.mask);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_agent_get_exception_policies_fn(agent, profile, mask);
  }
}

static hsa_status_t hsa_agent_extension_supported_callback(uint16_t extension, hsa_agent_t agent, uint16_t version_major, uint16_t version_minor, bool* result) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_agent_extension_supported;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_agent_extension_supported.extension = extension;
    Args.hsa_agent_extension_supported.agent = agent;
    Args.hsa_agent_extension_supported.version_major = version_major;
    Args.hsa_agent_extension_supported.version_minor = version_minor;
    Args.hsa_agent_extension_supported.result = result;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_agent_extension_supported_fn(Args.hsa_agent_extension_supported.extension, Args.hsa_agent_extension_supported.agent, Args.hsa_agent_extension_supported.version_major, Args.hsa_agent_extension_supported.version_minor, Args.hsa_agent_extension_supported.result);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_agent_extension_supported_fn(extension, agent, version_major, version_minor, result);
  }
}

static hsa_status_t hsa_memory_register_callback(void* ptr, size_t size) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_memory_register;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_memory_register.ptr = ptr;
    Args.hsa_memory_register.size = size;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_memory_register_fn(Args.hsa_memory_register.ptr, Args.hsa_memory_register.size);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_memory_register_fn(ptr, size);
  }
}

static hsa_status_t hsa_memory_deregister_callback(void* ptr, size_t size) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_memory_deregister;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_memory_deregister.ptr = ptr;
    Args.hsa_memory_deregister.size = size;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_memory_deregister_fn(Args.hsa_memory_deregister.ptr, Args.hsa_memory_deregister.size);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_memory_deregister_fn(ptr, size);
  }
}

static hsa_status_t hsa_memory_allocate_callback(hsa_region_t region, size_t size, void** ptr) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_memory_allocate;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_memory_allocate.region = region;
    Args.hsa_memory_allocate.size = size;
    Args.hsa_memory_allocate.ptr = ptr;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_memory_allocate_fn(Args.hsa_memory_allocate.region, Args.hsa_memory_allocate.size, Args.hsa_memory_allocate.ptr);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_memory_allocate_fn(region, size, ptr);
  }
}

static hsa_status_t hsa_memory_free_callback(void* ptr) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_memory_free;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_memory_free.ptr = ptr;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_memory_free_fn(Args.hsa_memory_free.ptr);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_memory_free_fn(ptr);
  }
}

static hsa_status_t hsa_memory_copy_callback(void* dst, const void* src, size_t size) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_memory_copy;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_memory_copy.dst = dst;
    Args.hsa_memory_copy.src = src;
    Args.hsa_memory_copy.size = size;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_memory_copy_fn(Args.hsa_memory_copy.dst, Args.hsa_memory_copy.src, Args.hsa_memory_copy.size);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_memory_copy_fn(dst, src, size);
  }
}

static hsa_status_t hsa_memory_assign_agent_callback(void* ptr, hsa_agent_t agent, hsa_access_permission_t access) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_memory_assign_agent;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_memory_assign_agent.ptr = ptr;
    Args.hsa_memory_assign_agent.agent = agent;
    Args.hsa_memory_assign_agent.access = access;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_memory_assign_agent_fn(Args.hsa_memory_assign_agent.ptr, Args.hsa_memory_assign_agent.agent, Args.hsa_memory_assign_agent.access);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_memory_assign_agent_fn(ptr, agent, access);
  }
}

static hsa_status_t hsa_signal_create_callback(hsa_signal_value_t initial_value, uint32_t num_consumers, const hsa_agent_t* consumers, hsa_signal_t* signal) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_create;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_create.initial_value = initial_value;
    Args.hsa_signal_create.num_consumers = num_consumers;
    Args.hsa_signal_create.consumers = consumers;
    Args.hsa_signal_create.signal = signal;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_create_fn(Args.hsa_signal_create.initial_value, Args.hsa_signal_create.num_consumers, Args.hsa_signal_create.consumers, Args.hsa_signal_create.signal);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_create_fn(initial_value, num_consumers, consumers, signal);
  }
}

static hsa_status_t hsa_signal_destroy_callback(hsa_signal_t signal) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_destroy;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_destroy.signal = signal;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_destroy_fn(Args.hsa_signal_destroy.signal);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_destroy_fn(signal);
  }
}

static hsa_signal_value_t hsa_signal_load_relaxed_callback(hsa_signal_t signal) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_load_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_signal_value_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_load_relaxed.signal = signal;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_load_relaxed_fn(Args.hsa_signal_load_relaxed.signal);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_load_relaxed_fn(signal);
  }
}

static hsa_signal_value_t hsa_signal_load_scacquire_callback(hsa_signal_t signal) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_load_scacquire;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_signal_value_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_load_scacquire.signal = signal;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_load_scacquire_fn(Args.hsa_signal_load_scacquire.signal);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_load_scacquire_fn(signal);
  }
}

static void hsa_signal_store_relaxed_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_store_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_store_relaxed.signal = signal;
    Args.hsa_signal_store_relaxed.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_store_relaxed_fn(Args.hsa_signal_store_relaxed.signal, Args.hsa_signal_store_relaxed.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_store_relaxed_fn(signal, value);
  }
}

static void hsa_signal_store_screlease_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_store_screlease;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_store_screlease.signal = signal;
    Args.hsa_signal_store_screlease.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_store_screlease_fn(Args.hsa_signal_store_screlease.signal, Args.hsa_signal_store_screlease.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_store_screlease_fn(signal, value);
  }
}

static hsa_signal_value_t hsa_signal_wait_relaxed_callback(hsa_signal_t signal, hsa_signal_condition_t condition, hsa_signal_value_t compare_value, uint64_t timeout_hint, hsa_wait_state_t wait_state_hint) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_wait_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_signal_value_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_wait_relaxed.signal = signal;
    Args.hsa_signal_wait_relaxed.condition = condition;
    Args.hsa_signal_wait_relaxed.compare_value = compare_value;
    Args.hsa_signal_wait_relaxed.timeout_hint = timeout_hint;
    Args.hsa_signal_wait_relaxed.wait_state_hint = wait_state_hint;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_wait_relaxed_fn(Args.hsa_signal_wait_relaxed.signal, Args.hsa_signal_wait_relaxed.condition, Args.hsa_signal_wait_relaxed.compare_value, Args.hsa_signal_wait_relaxed.timeout_hint, Args.hsa_signal_wait_relaxed.wait_state_hint);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_wait_relaxed_fn(signal, condition, compare_value, timeout_hint, wait_state_hint);
  }
}

static hsa_signal_value_t hsa_signal_wait_scacquire_callback(hsa_signal_t signal, hsa_signal_condition_t condition, hsa_signal_value_t compare_value, uint64_t timeout_hint, hsa_wait_state_t wait_state_hint) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_wait_scacquire;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_signal_value_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_wait_scacquire.signal = signal;
    Args.hsa_signal_wait_scacquire.condition = condition;
    Args.hsa_signal_wait_scacquire.compare_value = compare_value;
    Args.hsa_signal_wait_scacquire.timeout_hint = timeout_hint;
    Args.hsa_signal_wait_scacquire.wait_state_hint = wait_state_hint;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_wait_scacquire_fn(Args.hsa_signal_wait_scacquire.signal, Args.hsa_signal_wait_scacquire.condition, Args.hsa_signal_wait_scacquire.compare_value, Args.hsa_signal_wait_scacquire.timeout_hint, Args.hsa_signal_wait_scacquire.wait_state_hint);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_wait_scacquire_fn(signal, condition, compare_value, timeout_hint, wait_state_hint);
  }
}

static void hsa_signal_and_relaxed_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_and_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_and_relaxed.signal = signal;
    Args.hsa_signal_and_relaxed.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_and_relaxed_fn(Args.hsa_signal_and_relaxed.signal, Args.hsa_signal_and_relaxed.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_and_relaxed_fn(signal, value);
  }
}

static void hsa_signal_and_scacquire_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_and_scacquire;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_and_scacquire.signal = signal;
    Args.hsa_signal_and_scacquire.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_and_scacquire_fn(Args.hsa_signal_and_scacquire.signal, Args.hsa_signal_and_scacquire.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_and_scacquire_fn(signal, value);
  }
}

static void hsa_signal_and_screlease_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_and_screlease;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_and_screlease.signal = signal;
    Args.hsa_signal_and_screlease.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_and_screlease_fn(Args.hsa_signal_and_screlease.signal, Args.hsa_signal_and_screlease.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_and_screlease_fn(signal, value);
  }
}

static void hsa_signal_and_scacq_screl_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_and_scacq_screl;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_and_scacq_screl.signal = signal;
    Args.hsa_signal_and_scacq_screl.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_and_scacq_screl_fn(Args.hsa_signal_and_scacq_screl.signal, Args.hsa_signal_and_scacq_screl.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_and_scacq_screl_fn(signal, value);
  }
}

static void hsa_signal_or_relaxed_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_or_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_or_relaxed.signal = signal;
    Args.hsa_signal_or_relaxed.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_or_relaxed_fn(Args.hsa_signal_or_relaxed.signal, Args.hsa_signal_or_relaxed.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_or_relaxed_fn(signal, value);
  }
}

static void hsa_signal_or_scacquire_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_or_scacquire;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_or_scacquire.signal = signal;
    Args.hsa_signal_or_scacquire.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_or_scacquire_fn(Args.hsa_signal_or_scacquire.signal, Args.hsa_signal_or_scacquire.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_or_scacquire_fn(signal, value);
  }
}

static void hsa_signal_or_screlease_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_or_screlease;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_or_screlease.signal = signal;
    Args.hsa_signal_or_screlease.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_or_screlease_fn(Args.hsa_signal_or_screlease.signal, Args.hsa_signal_or_screlease.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_or_screlease_fn(signal, value);
  }
}

static void hsa_signal_or_scacq_screl_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_or_scacq_screl;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_or_scacq_screl.signal = signal;
    Args.hsa_signal_or_scacq_screl.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_or_scacq_screl_fn(Args.hsa_signal_or_scacq_screl.signal, Args.hsa_signal_or_scacq_screl.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_or_scacq_screl_fn(signal, value);
  }
}

static void hsa_signal_xor_relaxed_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_xor_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_xor_relaxed.signal = signal;
    Args.hsa_signal_xor_relaxed.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_xor_relaxed_fn(Args.hsa_signal_xor_relaxed.signal, Args.hsa_signal_xor_relaxed.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_xor_relaxed_fn(signal, value);
  }
}

static void hsa_signal_xor_scacquire_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_xor_scacquire;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_xor_scacquire.signal = signal;
    Args.hsa_signal_xor_scacquire.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_xor_scacquire_fn(Args.hsa_signal_xor_scacquire.signal, Args.hsa_signal_xor_scacquire.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_xor_scacquire_fn(signal, value);
  }
}

static void hsa_signal_xor_screlease_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_xor_screlease;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_xor_screlease.signal = signal;
    Args.hsa_signal_xor_screlease.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_xor_screlease_fn(Args.hsa_signal_xor_screlease.signal, Args.hsa_signal_xor_screlease.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_xor_screlease_fn(signal, value);
  }
}

static void hsa_signal_xor_scacq_screl_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_xor_scacq_screl;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_xor_scacq_screl.signal = signal;
    Args.hsa_signal_xor_scacq_screl.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_xor_scacq_screl_fn(Args.hsa_signal_xor_scacq_screl.signal, Args.hsa_signal_xor_scacq_screl.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_xor_scacq_screl_fn(signal, value);
  }
}

static hsa_signal_value_t hsa_signal_exchange_relaxed_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_exchange_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_signal_value_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_exchange_relaxed.signal = signal;
    Args.hsa_signal_exchange_relaxed.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_exchange_relaxed_fn(Args.hsa_signal_exchange_relaxed.signal, Args.hsa_signal_exchange_relaxed.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_exchange_relaxed_fn(signal, value);
  }
}

static hsa_signal_value_t hsa_signal_exchange_scacquire_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_exchange_scacquire;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_signal_value_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_exchange_scacquire.signal = signal;
    Args.hsa_signal_exchange_scacquire.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_exchange_scacquire_fn(Args.hsa_signal_exchange_scacquire.signal, Args.hsa_signal_exchange_scacquire.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_exchange_scacquire_fn(signal, value);
  }
}

static hsa_signal_value_t hsa_signal_exchange_screlease_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_exchange_screlease;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_signal_value_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_exchange_screlease.signal = signal;
    Args.hsa_signal_exchange_screlease.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_exchange_screlease_fn(Args.hsa_signal_exchange_screlease.signal, Args.hsa_signal_exchange_screlease.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_exchange_screlease_fn(signal, value);
  }
}

static hsa_signal_value_t hsa_signal_exchange_scacq_screl_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_exchange_scacq_screl;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_signal_value_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_exchange_scacq_screl.signal = signal;
    Args.hsa_signal_exchange_scacq_screl.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_exchange_scacq_screl_fn(Args.hsa_signal_exchange_scacq_screl.signal, Args.hsa_signal_exchange_scacq_screl.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_exchange_scacq_screl_fn(signal, value);
  }
}

static void hsa_signal_add_relaxed_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_add_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_add_relaxed.signal = signal;
    Args.hsa_signal_add_relaxed.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_add_relaxed_fn(Args.hsa_signal_add_relaxed.signal, Args.hsa_signal_add_relaxed.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_add_relaxed_fn(signal, value);
  }
}

static void hsa_signal_add_scacquire_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_add_scacquire;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_add_scacquire.signal = signal;
    Args.hsa_signal_add_scacquire.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_add_scacquire_fn(Args.hsa_signal_add_scacquire.signal, Args.hsa_signal_add_scacquire.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_add_scacquire_fn(signal, value);
  }
}

static void hsa_signal_add_screlease_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_add_screlease;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_add_screlease.signal = signal;
    Args.hsa_signal_add_screlease.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_add_screlease_fn(Args.hsa_signal_add_screlease.signal, Args.hsa_signal_add_screlease.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_add_screlease_fn(signal, value);
  }
}

static void hsa_signal_add_scacq_screl_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_add_scacq_screl;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_add_scacq_screl.signal = signal;
    Args.hsa_signal_add_scacq_screl.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_add_scacq_screl_fn(Args.hsa_signal_add_scacq_screl.signal, Args.hsa_signal_add_scacq_screl.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_add_scacq_screl_fn(signal, value);
  }
}

static void hsa_signal_subtract_relaxed_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_subtract_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_subtract_relaxed.signal = signal;
    Args.hsa_signal_subtract_relaxed.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_subtract_relaxed_fn(Args.hsa_signal_subtract_relaxed.signal, Args.hsa_signal_subtract_relaxed.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_subtract_relaxed_fn(signal, value);
  }
}

static void hsa_signal_subtract_scacquire_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_subtract_scacquire;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_subtract_scacquire.signal = signal;
    Args.hsa_signal_subtract_scacquire.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_subtract_scacquire_fn(Args.hsa_signal_subtract_scacquire.signal, Args.hsa_signal_subtract_scacquire.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_subtract_scacquire_fn(signal, value);
  }
}

static void hsa_signal_subtract_screlease_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_subtract_screlease;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_subtract_screlease.signal = signal;
    Args.hsa_signal_subtract_screlease.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_subtract_screlease_fn(Args.hsa_signal_subtract_screlease.signal, Args.hsa_signal_subtract_screlease.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_subtract_screlease_fn(signal, value);
  }
}

static void hsa_signal_subtract_scacq_screl_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_subtract_scacq_screl;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_subtract_scacq_screl.signal = signal;
    Args.hsa_signal_subtract_scacq_screl.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_subtract_scacq_screl_fn(Args.hsa_signal_subtract_scacq_screl.signal, Args.hsa_signal_subtract_scacq_screl.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_subtract_scacq_screl_fn(signal, value);
  }
}

static hsa_signal_value_t hsa_signal_cas_relaxed_callback(hsa_signal_t signal, hsa_signal_value_t expected, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_cas_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_signal_value_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_cas_relaxed.signal = signal;
    Args.hsa_signal_cas_relaxed.expected = expected;
    Args.hsa_signal_cas_relaxed.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_cas_relaxed_fn(Args.hsa_signal_cas_relaxed.signal, Args.hsa_signal_cas_relaxed.expected, Args.hsa_signal_cas_relaxed.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_cas_relaxed_fn(signal, expected, value);
  }
}

static hsa_signal_value_t hsa_signal_cas_scacquire_callback(hsa_signal_t signal, hsa_signal_value_t expected, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_cas_scacquire;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_signal_value_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_cas_scacquire.signal = signal;
    Args.hsa_signal_cas_scacquire.expected = expected;
    Args.hsa_signal_cas_scacquire.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_cas_scacquire_fn(Args.hsa_signal_cas_scacquire.signal, Args.hsa_signal_cas_scacquire.expected, Args.hsa_signal_cas_scacquire.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_cas_scacquire_fn(signal, expected, value);
  }
}

static hsa_signal_value_t hsa_signal_cas_screlease_callback(hsa_signal_t signal, hsa_signal_value_t expected, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_cas_screlease;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_signal_value_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_cas_screlease.signal = signal;
    Args.hsa_signal_cas_screlease.expected = expected;
    Args.hsa_signal_cas_screlease.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_cas_screlease_fn(Args.hsa_signal_cas_screlease.signal, Args.hsa_signal_cas_screlease.expected, Args.hsa_signal_cas_screlease.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_cas_screlease_fn(signal, expected, value);
  }
}

static hsa_signal_value_t hsa_signal_cas_scacq_screl_callback(hsa_signal_t signal, hsa_signal_value_t expected, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_cas_scacq_screl;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_signal_value_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_cas_scacq_screl.signal = signal;
    Args.hsa_signal_cas_scacq_screl.expected = expected;
    Args.hsa_signal_cas_scacq_screl.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_cas_scacq_screl_fn(Args.hsa_signal_cas_scacq_screl.signal, Args.hsa_signal_cas_scacq_screl.expected, Args.hsa_signal_cas_scacq_screl.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_cas_scacq_screl_fn(signal, expected, value);
  }
}

static hsa_status_t hsa_isa_from_name_callback(const char* name, hsa_isa_t* isa) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_isa_from_name;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_isa_from_name.name = name;
    Args.hsa_isa_from_name.isa = isa;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_isa_from_name_fn(Args.hsa_isa_from_name.name, Args.hsa_isa_from_name.isa);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_isa_from_name_fn(name, isa);
  }
}

static hsa_status_t hsa_isa_get_info_callback(hsa_isa_t isa, hsa_isa_info_t attribute, uint32_t index, void* value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_isa_get_info;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_isa_get_info.isa = isa;
    Args.hsa_isa_get_info.attribute = attribute;
    Args.hsa_isa_get_info.index = index;
    Args.hsa_isa_get_info.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_isa_get_info_fn(Args.hsa_isa_get_info.isa, Args.hsa_isa_get_info.attribute, Args.hsa_isa_get_info.index, Args.hsa_isa_get_info.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_isa_get_info_fn(isa, attribute, index, value);
  }
}

static hsa_status_t hsa_isa_compatible_callback(hsa_isa_t code_object_isa, hsa_isa_t agent_isa, bool* result) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_isa_compatible;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_isa_compatible.code_object_isa = code_object_isa;
    Args.hsa_isa_compatible.agent_isa = agent_isa;
    Args.hsa_isa_compatible.result = result;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_isa_compatible_fn(Args.hsa_isa_compatible.code_object_isa, Args.hsa_isa_compatible.agent_isa, Args.hsa_isa_compatible.result);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_isa_compatible_fn(code_object_isa, agent_isa, result);
  }
}

static hsa_status_t hsa_code_object_serialize_callback(hsa_code_object_t code_object, hsa_status_t (* alloc_callback)(size_t size, hsa_callback_data_t data, void** address), hsa_callback_data_t callback_data, const char* options, void** serialized_code_object, size_t* serialized_code_object_size) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_code_object_serialize;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_code_object_serialize.code_object = code_object;
    Args.hsa_code_object_serialize.alloc_callback = alloc_callback;
    Args.hsa_code_object_serialize.callback_data = callback_data;
    Args.hsa_code_object_serialize.options = options;
    Args.hsa_code_object_serialize.serialized_code_object = serialized_code_object;
    Args.hsa_code_object_serialize.serialized_code_object_size = serialized_code_object_size;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_code_object_serialize_fn(Args.hsa_code_object_serialize.code_object, Args.hsa_code_object_serialize.alloc_callback, Args.hsa_code_object_serialize.callback_data, Args.hsa_code_object_serialize.options, Args.hsa_code_object_serialize.serialized_code_object, Args.hsa_code_object_serialize.serialized_code_object_size);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_code_object_serialize_fn(code_object, alloc_callback, callback_data, options, serialized_code_object, serialized_code_object_size);
  }
}

static hsa_status_t hsa_code_object_deserialize_callback(void* serialized_code_object, size_t serialized_code_object_size, const char* options, hsa_code_object_t* code_object) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_code_object_deserialize;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_code_object_deserialize.serialized_code_object = serialized_code_object;
    Args.hsa_code_object_deserialize.serialized_code_object_size = serialized_code_object_size;
    Args.hsa_code_object_deserialize.options = options;
    Args.hsa_code_object_deserialize.code_object = code_object;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_code_object_deserialize_fn(Args.hsa_code_object_deserialize.serialized_code_object, Args.hsa_code_object_deserialize.serialized_code_object_size, Args.hsa_code_object_deserialize.options, Args.hsa_code_object_deserialize.code_object);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_code_object_deserialize_fn(serialized_code_object, serialized_code_object_size, options, code_object);
  }
}

static hsa_status_t hsa_code_object_destroy_callback(hsa_code_object_t code_object) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_code_object_destroy;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_code_object_destroy.code_object = code_object;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_code_object_destroy_fn(Args.hsa_code_object_destroy.code_object);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_code_object_destroy_fn(code_object);
  }
}

static hsa_status_t hsa_code_object_get_info_callback(hsa_code_object_t code_object, hsa_code_object_info_t attribute, void* value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_code_object_get_info;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_code_object_get_info.code_object = code_object;
    Args.hsa_code_object_get_info.attribute = attribute;
    Args.hsa_code_object_get_info.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_code_object_get_info_fn(Args.hsa_code_object_get_info.code_object, Args.hsa_code_object_get_info.attribute, Args.hsa_code_object_get_info.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_code_object_get_info_fn(code_object, attribute, value);
  }
}

static hsa_status_t hsa_code_object_get_symbol_callback(hsa_code_object_t code_object, const char* symbol_name, hsa_code_symbol_t* symbol) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_code_object_get_symbol;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_code_object_get_symbol.code_object = code_object;
    Args.hsa_code_object_get_symbol.symbol_name = symbol_name;
    Args.hsa_code_object_get_symbol.symbol = symbol;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_code_object_get_symbol_fn(Args.hsa_code_object_get_symbol.code_object, Args.hsa_code_object_get_symbol.symbol_name, Args.hsa_code_object_get_symbol.symbol);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_code_object_get_symbol_fn(code_object, symbol_name, symbol);
  }
}

static hsa_status_t hsa_code_symbol_get_info_callback(hsa_code_symbol_t code_symbol, hsa_code_symbol_info_t attribute, void* value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_code_symbol_get_info;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_code_symbol_get_info.code_symbol = code_symbol;
    Args.hsa_code_symbol_get_info.attribute = attribute;
    Args.hsa_code_symbol_get_info.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_code_symbol_get_info_fn(Args.hsa_code_symbol_get_info.code_symbol, Args.hsa_code_symbol_get_info.attribute, Args.hsa_code_symbol_get_info.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_code_symbol_get_info_fn(code_symbol, attribute, value);
  }
}

static hsa_status_t hsa_code_object_iterate_symbols_callback(hsa_code_object_t code_object, hsa_status_t (* callback)(hsa_code_object_t code_object, hsa_code_symbol_t symbol, void* data), void* data) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_code_object_iterate_symbols;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_code_object_iterate_symbols.code_object = code_object;
    Args.hsa_code_object_iterate_symbols.callback = callback;
    Args.hsa_code_object_iterate_symbols.data = data;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_code_object_iterate_symbols_fn(Args.hsa_code_object_iterate_symbols.code_object, Args.hsa_code_object_iterate_symbols.callback, Args.hsa_code_object_iterate_symbols.data);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_code_object_iterate_symbols_fn(code_object, callback, data);
  }
}

static hsa_status_t hsa_executable_create_callback(hsa_profile_t profile, hsa_executable_state_t executable_state, const char* options, hsa_executable_t* executable) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_create;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_create.profile = profile;
    Args.hsa_executable_create.executable_state = executable_state;
    Args.hsa_executable_create.options = options;
    Args.hsa_executable_create.executable = executable;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_create_fn(Args.hsa_executable_create.profile, Args.hsa_executable_create.executable_state, Args.hsa_executable_create.options, Args.hsa_executable_create.executable);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_create_fn(profile, executable_state, options, executable);
  }
}

static hsa_status_t hsa_executable_destroy_callback(hsa_executable_t executable) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_destroy;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_destroy.executable = executable;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_destroy_fn(Args.hsa_executable_destroy.executable);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_destroy_fn(executable);
  }
}

static hsa_status_t hsa_executable_load_code_object_callback(hsa_executable_t executable, hsa_agent_t agent, hsa_code_object_t code_object, const char* options) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_load_code_object;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_load_code_object.executable = executable;
    Args.hsa_executable_load_code_object.agent = agent;
    Args.hsa_executable_load_code_object.code_object = code_object;
    Args.hsa_executable_load_code_object.options = options;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_load_code_object_fn(Args.hsa_executable_load_code_object.executable, Args.hsa_executable_load_code_object.agent, Args.hsa_executable_load_code_object.code_object, Args.hsa_executable_load_code_object.options);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_load_code_object_fn(executable, agent, code_object, options);
  }
}

static hsa_status_t hsa_executable_freeze_callback(hsa_executable_t executable, const char* options) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_freeze;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_freeze.executable = executable;
    Args.hsa_executable_freeze.options = options;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_freeze_fn(Args.hsa_executable_freeze.executable, Args.hsa_executable_freeze.options);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_freeze_fn(executable, options);
  }
}

static hsa_status_t hsa_executable_get_info_callback(hsa_executable_t executable, hsa_executable_info_t attribute, void* value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_get_info;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_get_info.executable = executable;
    Args.hsa_executable_get_info.attribute = attribute;
    Args.hsa_executable_get_info.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_get_info_fn(Args.hsa_executable_get_info.executable, Args.hsa_executable_get_info.attribute, Args.hsa_executable_get_info.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_get_info_fn(executable, attribute, value);
  }
}

static hsa_status_t hsa_executable_global_variable_define_callback(hsa_executable_t executable, const char* variable_name, void* address) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_global_variable_define;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_global_variable_define.executable = executable;
    Args.hsa_executable_global_variable_define.variable_name = variable_name;
    Args.hsa_executable_global_variable_define.address = address;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_global_variable_define_fn(Args.hsa_executable_global_variable_define.executable, Args.hsa_executable_global_variable_define.variable_name, Args.hsa_executable_global_variable_define.address);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_global_variable_define_fn(executable, variable_name, address);
  }
}

static hsa_status_t hsa_executable_agent_global_variable_define_callback(hsa_executable_t executable, hsa_agent_t agent, const char* variable_name, void* address) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_agent_global_variable_define;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_agent_global_variable_define.executable = executable;
    Args.hsa_executable_agent_global_variable_define.agent = agent;
    Args.hsa_executable_agent_global_variable_define.variable_name = variable_name;
    Args.hsa_executable_agent_global_variable_define.address = address;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_agent_global_variable_define_fn(Args.hsa_executable_agent_global_variable_define.executable, Args.hsa_executable_agent_global_variable_define.agent, Args.hsa_executable_agent_global_variable_define.variable_name, Args.hsa_executable_agent_global_variable_define.address);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_agent_global_variable_define_fn(executable, agent, variable_name, address);
  }
}

static hsa_status_t hsa_executable_readonly_variable_define_callback(hsa_executable_t executable, hsa_agent_t agent, const char* variable_name, void* address) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_readonly_variable_define;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_readonly_variable_define.executable = executable;
    Args.hsa_executable_readonly_variable_define.agent = agent;
    Args.hsa_executable_readonly_variable_define.variable_name = variable_name;
    Args.hsa_executable_readonly_variable_define.address = address;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_readonly_variable_define_fn(Args.hsa_executable_readonly_variable_define.executable, Args.hsa_executable_readonly_variable_define.agent, Args.hsa_executable_readonly_variable_define.variable_name, Args.hsa_executable_readonly_variable_define.address);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_readonly_variable_define_fn(executable, agent, variable_name, address);
  }
}

static hsa_status_t hsa_executable_validate_callback(hsa_executable_t executable, uint32_t* result) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_validate;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_validate.executable = executable;
    Args.hsa_executable_validate.result = result;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_validate_fn(Args.hsa_executable_validate.executable, Args.hsa_executable_validate.result);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_validate_fn(executable, result);
  }
}

static hsa_status_t hsa_executable_get_symbol_callback(hsa_executable_t executable, const char* module_name, const char* symbol_name, hsa_agent_t agent, int32_t call_convention, hsa_executable_symbol_t* symbol) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_get_symbol;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_get_symbol.executable = executable;
    Args.hsa_executable_get_symbol.module_name = module_name;
    Args.hsa_executable_get_symbol.symbol_name = symbol_name;
    Args.hsa_executable_get_symbol.agent = agent;
    Args.hsa_executable_get_symbol.call_convention = call_convention;
    Args.hsa_executable_get_symbol.symbol = symbol;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_get_symbol_fn(Args.hsa_executable_get_symbol.executable, Args.hsa_executable_get_symbol.module_name, Args.hsa_executable_get_symbol.symbol_name, Args.hsa_executable_get_symbol.agent, Args.hsa_executable_get_symbol.call_convention, Args.hsa_executable_get_symbol.symbol);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_get_symbol_fn(executable, module_name, symbol_name, agent, call_convention, symbol);
  }
}

static hsa_status_t hsa_executable_symbol_get_info_callback(hsa_executable_symbol_t executable_symbol, hsa_executable_symbol_info_t attribute, void* value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_symbol_get_info;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_symbol_get_info.executable_symbol = executable_symbol;
    Args.hsa_executable_symbol_get_info.attribute = attribute;
    Args.hsa_executable_symbol_get_info.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_symbol_get_info_fn(Args.hsa_executable_symbol_get_info.executable_symbol, Args.hsa_executable_symbol_get_info.attribute, Args.hsa_executable_symbol_get_info.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_symbol_get_info_fn(executable_symbol, attribute, value);
  }
}

static hsa_status_t hsa_executable_iterate_symbols_callback(hsa_executable_t executable, hsa_status_t (* callback)(hsa_executable_t exec, hsa_executable_symbol_t symbol, void* data), void* data) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_iterate_symbols;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_iterate_symbols.executable = executable;
    Args.hsa_executable_iterate_symbols.callback = callback;
    Args.hsa_executable_iterate_symbols.data = data;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_iterate_symbols_fn(Args.hsa_executable_iterate_symbols.executable, Args.hsa_executable_iterate_symbols.callback, Args.hsa_executable_iterate_symbols.data);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_iterate_symbols_fn(executable, callback, data);
  }
}

static hsa_status_t hsa_status_string_callback(hsa_status_t status, const char** status_string) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_status_string;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_status_string.status = status;
    Args.hsa_status_string.status_string = status_string;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_status_string_fn(Args.hsa_status_string.status, Args.hsa_status_string.status_string);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_status_string_fn(status, status_string);
  }
}

static hsa_status_t hsa_extension_get_name_callback(uint16_t extension, const char** name) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_extension_get_name;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_extension_get_name.extension = extension;
    Args.hsa_extension_get_name.name = name;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_extension_get_name_fn(Args.hsa_extension_get_name.extension, Args.hsa_extension_get_name.name);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_extension_get_name_fn(extension, name);
  }
}

static hsa_status_t hsa_system_major_extension_supported_callback(uint16_t extension, uint16_t version_major, uint16_t* version_minor, bool* result) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_system_major_extension_supported;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_system_major_extension_supported.extension = extension;
    Args.hsa_system_major_extension_supported.version_major = version_major;
    Args.hsa_system_major_extension_supported.version_minor = version_minor;
    Args.hsa_system_major_extension_supported.result = result;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_system_major_extension_supported_fn(Args.hsa_system_major_extension_supported.extension, Args.hsa_system_major_extension_supported.version_major, Args.hsa_system_major_extension_supported.version_minor, Args.hsa_system_major_extension_supported.result);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_system_major_extension_supported_fn(extension, version_major, version_minor, result);
  }
}

static hsa_status_t hsa_system_get_major_extension_table_callback(uint16_t extension, uint16_t version_major, size_t table_length, void* table) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_system_get_major_extension_table;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_system_get_major_extension_table.extension = extension;
    Args.hsa_system_get_major_extension_table.version_major = version_major;
    Args.hsa_system_get_major_extension_table.table_length = table_length;
    Args.hsa_system_get_major_extension_table.table = table;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_system_get_major_extension_table_fn(Args.hsa_system_get_major_extension_table.extension, Args.hsa_system_get_major_extension_table.version_major, Args.hsa_system_get_major_extension_table.table_length, Args.hsa_system_get_major_extension_table.table);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_system_get_major_extension_table_fn(extension, version_major, table_length, table);
  }
}

static hsa_status_t hsa_agent_major_extension_supported_callback(uint16_t extension, hsa_agent_t agent, uint16_t version_major, uint16_t* version_minor, bool* result) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_agent_major_extension_supported;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_agent_major_extension_supported.extension = extension;
    Args.hsa_agent_major_extension_supported.agent = agent;
    Args.hsa_agent_major_extension_supported.version_major = version_major;
    Args.hsa_agent_major_extension_supported.version_minor = version_minor;
    Args.hsa_agent_major_extension_supported.result = result;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_agent_major_extension_supported_fn(Args.hsa_agent_major_extension_supported.extension, Args.hsa_agent_major_extension_supported.agent, Args.hsa_agent_major_extension_supported.version_major, Args.hsa_agent_major_extension_supported.version_minor, Args.hsa_agent_major_extension_supported.result);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_agent_major_extension_supported_fn(extension, agent, version_major, version_minor, result);
  }
}

static hsa_status_t hsa_cache_get_info_callback(hsa_cache_t cache, hsa_cache_info_t attribute, void* value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_cache_get_info;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_cache_get_info.cache = cache;
    Args.hsa_cache_get_info.attribute = attribute;
    Args.hsa_cache_get_info.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_cache_get_info_fn(Args.hsa_cache_get_info.cache, Args.hsa_cache_get_info.attribute, Args.hsa_cache_get_info.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_cache_get_info_fn(cache, attribute, value);
  }
}

static hsa_status_t hsa_agent_iterate_caches_callback(hsa_agent_t agent, hsa_status_t (* callback)(hsa_cache_t cache, void* data), void* data) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_agent_iterate_caches;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_agent_iterate_caches.agent = agent;
    Args.hsa_agent_iterate_caches.callback = callback;
    Args.hsa_agent_iterate_caches.data = data;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_agent_iterate_caches_fn(Args.hsa_agent_iterate_caches.agent, Args.hsa_agent_iterate_caches.callback, Args.hsa_agent_iterate_caches.data);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_agent_iterate_caches_fn(agent, callback, data);
  }
}

static void hsa_signal_silent_store_relaxed_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_silent_store_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_silent_store_relaxed.signal = signal;
    Args.hsa_signal_silent_store_relaxed.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_silent_store_relaxed_fn(Args.hsa_signal_silent_store_relaxed.signal, Args.hsa_signal_silent_store_relaxed.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_silent_store_relaxed_fn(signal, value);
  }
}

static void hsa_signal_silent_store_screlease_callback(hsa_signal_t signal, hsa_signal_value_t value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_silent_store_screlease;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_silent_store_screlease.signal = signal;
    Args.hsa_signal_silent_store_screlease.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
       HsaInterceptor.getSavedHsaTables().core.hsa_signal_silent_store_screlease_fn(Args.hsa_signal_silent_store_screlease.signal, Args.hsa_signal_silent_store_screlease.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_silent_store_screlease_fn(signal, value);
  }
}

static hsa_status_t hsa_signal_group_create_callback(uint32_t num_signals, const hsa_signal_t* signals, uint32_t num_consumers, const hsa_agent_t* consumers, hsa_signal_group_t* signal_group) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_group_create;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_group_create.num_signals = num_signals;
    Args.hsa_signal_group_create.signals = signals;
    Args.hsa_signal_group_create.num_consumers = num_consumers;
    Args.hsa_signal_group_create.consumers = consumers;
    Args.hsa_signal_group_create.signal_group = signal_group;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_group_create_fn(Args.hsa_signal_group_create.num_signals, Args.hsa_signal_group_create.signals, Args.hsa_signal_group_create.num_consumers, Args.hsa_signal_group_create.consumers, Args.hsa_signal_group_create.signal_group);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_group_create_fn(num_signals, signals, num_consumers, consumers, signal_group);
  }
}

static hsa_status_t hsa_signal_group_destroy_callback(hsa_signal_group_t signal_group) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_group_destroy;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_group_destroy.signal_group = signal_group;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_group_destroy_fn(Args.hsa_signal_group_destroy.signal_group);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_group_destroy_fn(signal_group);
  }
}

static hsa_status_t hsa_signal_group_wait_any_scacquire_callback(hsa_signal_group_t signal_group, const hsa_signal_condition_t* conditions, const hsa_signal_value_t* compare_values, hsa_wait_state_t wait_state_hint, hsa_signal_t* signal, hsa_signal_value_t* value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_group_wait_any_scacquire;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_group_wait_any_scacquire.signal_group = signal_group;
    Args.hsa_signal_group_wait_any_scacquire.conditions = conditions;
    Args.hsa_signal_group_wait_any_scacquire.compare_values = compare_values;
    Args.hsa_signal_group_wait_any_scacquire.wait_state_hint = wait_state_hint;
    Args.hsa_signal_group_wait_any_scacquire.signal = signal;
    Args.hsa_signal_group_wait_any_scacquire.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_group_wait_any_scacquire_fn(Args.hsa_signal_group_wait_any_scacquire.signal_group, Args.hsa_signal_group_wait_any_scacquire.conditions, Args.hsa_signal_group_wait_any_scacquire.compare_values, Args.hsa_signal_group_wait_any_scacquire.wait_state_hint, Args.hsa_signal_group_wait_any_scacquire.signal, Args.hsa_signal_group_wait_any_scacquire.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_group_wait_any_scacquire_fn(signal_group, conditions, compare_values, wait_state_hint, signal, value);
  }
}

static hsa_status_t hsa_signal_group_wait_any_relaxed_callback(hsa_signal_group_t signal_group, const hsa_signal_condition_t* conditions, const hsa_signal_value_t* compare_values, hsa_wait_state_t wait_state_hint, hsa_signal_t* signal, hsa_signal_value_t* value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_signal_group_wait_any_relaxed;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_signal_group_wait_any_relaxed.signal_group = signal_group;
    Args.hsa_signal_group_wait_any_relaxed.conditions = conditions;
    Args.hsa_signal_group_wait_any_relaxed.compare_values = compare_values;
    Args.hsa_signal_group_wait_any_relaxed.wait_state_hint = wait_state_hint;
    Args.hsa_signal_group_wait_any_relaxed.signal = signal;
    Args.hsa_signal_group_wait_any_relaxed.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_signal_group_wait_any_relaxed_fn(Args.hsa_signal_group_wait_any_relaxed.signal_group, Args.hsa_signal_group_wait_any_relaxed.conditions, Args.hsa_signal_group_wait_any_relaxed.compare_values, Args.hsa_signal_group_wait_any_relaxed.wait_state_hint, Args.hsa_signal_group_wait_any_relaxed.signal, Args.hsa_signal_group_wait_any_relaxed.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_signal_group_wait_any_relaxed_fn(signal_group, conditions, compare_values, wait_state_hint, signal, value);
  }
}

static hsa_status_t hsa_agent_iterate_isas_callback(hsa_agent_t agent, hsa_status_t (* callback)(hsa_isa_t isa, void* data), void* data) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_agent_iterate_isas;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_agent_iterate_isas.agent = agent;
    Args.hsa_agent_iterate_isas.callback = callback;
    Args.hsa_agent_iterate_isas.data = data;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_agent_iterate_isas_fn(Args.hsa_agent_iterate_isas.agent, Args.hsa_agent_iterate_isas.callback, Args.hsa_agent_iterate_isas.data);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_agent_iterate_isas_fn(agent, callback, data);
  }
}

static hsa_status_t hsa_isa_get_info_alt_callback(hsa_isa_t isa, hsa_isa_info_t attribute, void* value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_isa_get_info_alt;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_isa_get_info_alt.isa = isa;
    Args.hsa_isa_get_info_alt.attribute = attribute;
    Args.hsa_isa_get_info_alt.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_isa_get_info_alt_fn(Args.hsa_isa_get_info_alt.isa, Args.hsa_isa_get_info_alt.attribute, Args.hsa_isa_get_info_alt.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_isa_get_info_alt_fn(isa, attribute, value);
  }
}

static hsa_status_t hsa_isa_get_exception_policies_callback(hsa_isa_t isa, hsa_profile_t profile, uint16_t* mask) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_isa_get_exception_policies;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_isa_get_exception_policies.isa = isa;
    Args.hsa_isa_get_exception_policies.profile = profile;
    Args.hsa_isa_get_exception_policies.mask = mask;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_isa_get_exception_policies_fn(Args.hsa_isa_get_exception_policies.isa, Args.hsa_isa_get_exception_policies.profile, Args.hsa_isa_get_exception_policies.mask);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_isa_get_exception_policies_fn(isa, profile, mask);
  }
}

static hsa_status_t hsa_isa_get_round_method_callback(hsa_isa_t isa, hsa_fp_type_t fp_type, hsa_flush_mode_t flush_mode, hsa_round_method_t* round_method) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_isa_get_round_method;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_isa_get_round_method.isa = isa;
    Args.hsa_isa_get_round_method.fp_type = fp_type;
    Args.hsa_isa_get_round_method.flush_mode = flush_mode;
    Args.hsa_isa_get_round_method.round_method = round_method;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_isa_get_round_method_fn(Args.hsa_isa_get_round_method.isa, Args.hsa_isa_get_round_method.fp_type, Args.hsa_isa_get_round_method.flush_mode, Args.hsa_isa_get_round_method.round_method);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_isa_get_round_method_fn(isa, fp_type, flush_mode, round_method);
  }
}

static hsa_status_t hsa_wavefront_get_info_callback(hsa_wavefront_t wavefront, hsa_wavefront_info_t attribute, void* value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_wavefront_get_info;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_wavefront_get_info.wavefront = wavefront;
    Args.hsa_wavefront_get_info.attribute = attribute;
    Args.hsa_wavefront_get_info.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_wavefront_get_info_fn(Args.hsa_wavefront_get_info.wavefront, Args.hsa_wavefront_get_info.attribute, Args.hsa_wavefront_get_info.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_wavefront_get_info_fn(wavefront, attribute, value);
  }
}

static hsa_status_t hsa_isa_iterate_wavefronts_callback(hsa_isa_t isa, hsa_status_t (* callback)(hsa_wavefront_t wavefront, void* data), void* data) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_isa_iterate_wavefronts;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_isa_iterate_wavefronts.isa = isa;
    Args.hsa_isa_iterate_wavefronts.callback = callback;
    Args.hsa_isa_iterate_wavefronts.data = data;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_isa_iterate_wavefronts_fn(Args.hsa_isa_iterate_wavefronts.isa, Args.hsa_isa_iterate_wavefronts.callback, Args.hsa_isa_iterate_wavefronts.data);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_isa_iterate_wavefronts_fn(isa, callback, data);
  }
}

static hsa_status_t hsa_code_object_get_symbol_from_name_callback(hsa_code_object_t code_object, const char* module_name, const char* symbol_name, hsa_code_symbol_t* symbol) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_code_object_get_symbol_from_name;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_code_object_get_symbol_from_name.code_object = code_object;
    Args.hsa_code_object_get_symbol_from_name.module_name = module_name;
    Args.hsa_code_object_get_symbol_from_name.symbol_name = symbol_name;
    Args.hsa_code_object_get_symbol_from_name.symbol = symbol;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_code_object_get_symbol_from_name_fn(Args.hsa_code_object_get_symbol_from_name.code_object, Args.hsa_code_object_get_symbol_from_name.module_name, Args.hsa_code_object_get_symbol_from_name.symbol_name, Args.hsa_code_object_get_symbol_from_name.symbol);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_code_object_get_symbol_from_name_fn(code_object, module_name, symbol_name, symbol);
  }
}

static hsa_status_t hsa_code_object_reader_create_from_file_callback(hsa_file_t file, hsa_code_object_reader_t* code_object_reader) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_code_object_reader_create_from_file;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_code_object_reader_create_from_file.file = file;
    Args.hsa_code_object_reader_create_from_file.code_object_reader = code_object_reader;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_code_object_reader_create_from_file_fn(Args.hsa_code_object_reader_create_from_file.file, Args.hsa_code_object_reader_create_from_file.code_object_reader);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_code_object_reader_create_from_file_fn(file, code_object_reader);
  }
}

static hsa_status_t hsa_code_object_reader_create_from_memory_callback(const void* code_object, size_t size, hsa_code_object_reader_t* code_object_reader) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_code_object_reader_create_from_memory;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_code_object_reader_create_from_memory.code_object = code_object;
    Args.hsa_code_object_reader_create_from_memory.size = size;
    Args.hsa_code_object_reader_create_from_memory.code_object_reader = code_object_reader;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_code_object_reader_create_from_memory_fn(Args.hsa_code_object_reader_create_from_memory.code_object, Args.hsa_code_object_reader_create_from_memory.size, Args.hsa_code_object_reader_create_from_memory.code_object_reader);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_code_object_reader_create_from_memory_fn(code_object, size, code_object_reader);
  }
}

static hsa_status_t hsa_code_object_reader_destroy_callback(hsa_code_object_reader_t code_object_reader) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_code_object_reader_destroy;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_code_object_reader_destroy.code_object_reader = code_object_reader;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_code_object_reader_destroy_fn(Args.hsa_code_object_reader_destroy.code_object_reader);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_code_object_reader_destroy_fn(code_object_reader);
  }
}

static hsa_status_t hsa_executable_create_alt_callback(hsa_profile_t profile, hsa_default_float_rounding_mode_t default_float_rounding_mode, const char* options, hsa_executable_t* executable) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_create_alt;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_create_alt.profile = profile;
    Args.hsa_executable_create_alt.default_float_rounding_mode = default_float_rounding_mode;
    Args.hsa_executable_create_alt.options = options;
    Args.hsa_executable_create_alt.executable = executable;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_create_alt_fn(Args.hsa_executable_create_alt.profile, Args.hsa_executable_create_alt.default_float_rounding_mode, Args.hsa_executable_create_alt.options, Args.hsa_executable_create_alt.executable);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_create_alt_fn(profile, default_float_rounding_mode, options, executable);
  }
}

static hsa_status_t hsa_executable_load_program_code_object_callback(hsa_executable_t executable, hsa_code_object_reader_t code_object_reader, const char* options, hsa_loaded_code_object_t* loaded_code_object) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_load_program_code_object;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_load_program_code_object.executable = executable;
    Args.hsa_executable_load_program_code_object.code_object_reader = code_object_reader;
    Args.hsa_executable_load_program_code_object.options = options;
    Args.hsa_executable_load_program_code_object.loaded_code_object = loaded_code_object;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_load_program_code_object_fn(Args.hsa_executable_load_program_code_object.executable, Args.hsa_executable_load_program_code_object.code_object_reader, Args.hsa_executable_load_program_code_object.options, Args.hsa_executable_load_program_code_object.loaded_code_object);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_load_program_code_object_fn(executable, code_object_reader, options, loaded_code_object);
  }
}

static hsa_status_t hsa_executable_load_agent_code_object_callback(hsa_executable_t executable, hsa_agent_t agent, hsa_code_object_reader_t code_object_reader, const char* options, hsa_loaded_code_object_t* loaded_code_object) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_load_agent_code_object;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_load_agent_code_object.executable = executable;
    Args.hsa_executable_load_agent_code_object.agent = agent;
    Args.hsa_executable_load_agent_code_object.code_object_reader = code_object_reader;
    Args.hsa_executable_load_agent_code_object.options = options;
    Args.hsa_executable_load_agent_code_object.loaded_code_object = loaded_code_object;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_load_agent_code_object_fn(Args.hsa_executable_load_agent_code_object.executable, Args.hsa_executable_load_agent_code_object.agent, Args.hsa_executable_load_agent_code_object.code_object_reader, Args.hsa_executable_load_agent_code_object.options, Args.hsa_executable_load_agent_code_object.loaded_code_object);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_load_agent_code_object_fn(executable, agent, code_object_reader, options, loaded_code_object);
  }
}

static hsa_status_t hsa_executable_validate_alt_callback(hsa_executable_t executable, const char* options, uint32_t* result) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_validate_alt;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_validate_alt.executable = executable;
    Args.hsa_executable_validate_alt.options = options;
    Args.hsa_executable_validate_alt.result = result;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_validate_alt_fn(Args.hsa_executable_validate_alt.executable, Args.hsa_executable_validate_alt.options, Args.hsa_executable_validate_alt.result);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_validate_alt_fn(executable, options, result);
  }
}

static hsa_status_t hsa_executable_get_symbol_by_name_callback(hsa_executable_t executable, const char* symbol_name, const hsa_agent_t* agent, hsa_executable_symbol_t* symbol) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_get_symbol_by_name;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_get_symbol_by_name.executable = executable;
    Args.hsa_executable_get_symbol_by_name.symbol_name = symbol_name;
    Args.hsa_executable_get_symbol_by_name.agent = agent;
    Args.hsa_executable_get_symbol_by_name.symbol = symbol;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_get_symbol_by_name_fn(Args.hsa_executable_get_symbol_by_name.executable, Args.hsa_executable_get_symbol_by_name.symbol_name, Args.hsa_executable_get_symbol_by_name.agent, Args.hsa_executable_get_symbol_by_name.symbol);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_get_symbol_by_name_fn(executable, symbol_name, agent, symbol);
  }
}

static hsa_status_t hsa_executable_iterate_agent_symbols_callback(hsa_executable_t executable, hsa_agent_t agent, hsa_status_t (* callback)(hsa_executable_t exec, hsa_agent_t agent, hsa_executable_symbol_t symbol, void* data), void* data) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_iterate_agent_symbols;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_iterate_agent_symbols.executable = executable;
    Args.hsa_executable_iterate_agent_symbols.agent = agent;
    Args.hsa_executable_iterate_agent_symbols.callback = callback;
    Args.hsa_executable_iterate_agent_symbols.data = data;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_iterate_agent_symbols_fn(Args.hsa_executable_iterate_agent_symbols.executable, Args.hsa_executable_iterate_agent_symbols.agent, Args.hsa_executable_iterate_agent_symbols.callback, Args.hsa_executable_iterate_agent_symbols.data);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_iterate_agent_symbols_fn(executable, agent, callback, data);
  }
}

static hsa_status_t hsa_executable_iterate_program_symbols_callback(hsa_executable_t executable, hsa_status_t (* callback)(hsa_executable_t exec, hsa_executable_symbol_t symbol, void* data), void* data) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_executable_iterate_program_symbols;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_executable_iterate_program_symbols.executable = executable;
    Args.hsa_executable_iterate_program_symbols.callback = callback;
    Args.hsa_executable_iterate_program_symbols.data = data;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().core.hsa_executable_iterate_program_symbols_fn(Args.hsa_executable_iterate_program_symbols.executable, Args.hsa_executable_iterate_program_symbols.callback, Args.hsa_executable_iterate_program_symbols.data);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().core.hsa_executable_iterate_program_symbols_fn(executable, callback, data);
  }
}

static hsa_status_t hsa_amd_coherency_get_type_callback(hsa_agent_t agent, hsa_amd_coherency_type_t* type) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_coherency_get_type;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_coherency_get_type.agent = agent;
    Args.hsa_amd_coherency_get_type.type = type;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_coherency_get_type_fn(Args.hsa_amd_coherency_get_type.agent, Args.hsa_amd_coherency_get_type.type);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_coherency_get_type_fn(agent, type);
  }
}

static hsa_status_t hsa_amd_coherency_set_type_callback(hsa_agent_t agent, hsa_amd_coherency_type_t type) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_coherency_set_type;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_coherency_set_type.agent = agent;
    Args.hsa_amd_coherency_set_type.type = type;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_coherency_set_type_fn(Args.hsa_amd_coherency_set_type.agent, Args.hsa_amd_coherency_set_type.type);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_coherency_set_type_fn(agent, type);
  }
}

static hsa_status_t hsa_amd_profiling_set_profiler_enabled_callback(hsa_queue_t* queue, int enable) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_profiling_set_profiler_enabled;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_profiling_set_profiler_enabled.queue = queue;
    Args.hsa_amd_profiling_set_profiler_enabled.enable = enable;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_profiling_set_profiler_enabled_fn(Args.hsa_amd_profiling_set_profiler_enabled.queue, Args.hsa_amd_profiling_set_profiler_enabled.enable);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_profiling_set_profiler_enabled_fn(queue, enable);
  }
}

static hsa_status_t hsa_amd_profiling_async_copy_enable_callback(bool enable) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_profiling_async_copy_enable;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_profiling_async_copy_enable.enable = enable;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_profiling_async_copy_enable_fn(Args.hsa_amd_profiling_async_copy_enable.enable);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_profiling_async_copy_enable_fn(enable);
  }
}

static hsa_status_t hsa_amd_profiling_get_dispatch_time_callback(hsa_agent_t agent, hsa_signal_t signal, hsa_amd_profiling_dispatch_time_t* time) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_profiling_get_dispatch_time;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_profiling_get_dispatch_time.agent = agent;
    Args.hsa_amd_profiling_get_dispatch_time.signal = signal;
    Args.hsa_amd_profiling_get_dispatch_time.time = time;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_profiling_get_dispatch_time_fn(Args.hsa_amd_profiling_get_dispatch_time.agent, Args.hsa_amd_profiling_get_dispatch_time.signal, Args.hsa_amd_profiling_get_dispatch_time.time);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_profiling_get_dispatch_time_fn(agent, signal, time);
  }
}

static hsa_status_t hsa_amd_profiling_get_async_copy_time_callback(hsa_signal_t signal, hsa_amd_profiling_async_copy_time_t* time) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_profiling_get_async_copy_time;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_profiling_get_async_copy_time.signal = signal;
    Args.hsa_amd_profiling_get_async_copy_time.time = time;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_profiling_get_async_copy_time_fn(Args.hsa_amd_profiling_get_async_copy_time.signal, Args.hsa_amd_profiling_get_async_copy_time.time);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_profiling_get_async_copy_time_fn(signal, time);
  }
}

static hsa_status_t hsa_amd_profiling_convert_tick_to_system_domain_callback(hsa_agent_t agent, uint64_t agent_tick, uint64_t* system_tick) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_profiling_convert_tick_to_system_domain;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_profiling_convert_tick_to_system_domain.agent = agent;
    Args.hsa_amd_profiling_convert_tick_to_system_domain.agent_tick = agent_tick;
    Args.hsa_amd_profiling_convert_tick_to_system_domain.system_tick = system_tick;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_profiling_convert_tick_to_system_domain_fn(Args.hsa_amd_profiling_convert_tick_to_system_domain.agent, Args.hsa_amd_profiling_convert_tick_to_system_domain.agent_tick, Args.hsa_amd_profiling_convert_tick_to_system_domain.system_tick);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_profiling_convert_tick_to_system_domain_fn(agent, agent_tick, system_tick);
  }
}

static hsa_status_t hsa_amd_signal_async_handler_callback(hsa_signal_t signal, hsa_signal_condition_t cond, hsa_signal_value_t value, hsa_amd_signal_handler handler, void* arg) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_signal_async_handler;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_signal_async_handler.signal = signal;
    Args.hsa_amd_signal_async_handler.cond = cond;
    Args.hsa_amd_signal_async_handler.value = value;
    Args.hsa_amd_signal_async_handler.handler = handler;
    Args.hsa_amd_signal_async_handler.arg = arg;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_signal_async_handler_fn(Args.hsa_amd_signal_async_handler.signal, Args.hsa_amd_signal_async_handler.cond, Args.hsa_amd_signal_async_handler.value, Args.hsa_amd_signal_async_handler.handler, Args.hsa_amd_signal_async_handler.arg);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_signal_async_handler_fn(signal, cond, value, handler, arg);
  }
}

static hsa_status_t hsa_amd_async_function_callback(void (* callback)(void* arg), void* arg) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_async_function;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_async_function.callback = callback;
    Args.hsa_amd_async_function.arg = arg;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_async_function_fn(Args.hsa_amd_async_function.callback, Args.hsa_amd_async_function.arg);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_async_function_fn(callback, arg);
  }
}

static uint32_t hsa_amd_signal_wait_any_callback(uint32_t signal_count, hsa_signal_t* signals, hsa_signal_condition_t* conds, hsa_signal_value_t* values, uint64_t timeout_hint, hsa_wait_state_t wait_hint, hsa_signal_value_t* satisfying_value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_signal_wait_any;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    uint32_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_signal_wait_any.signal_count = signal_count;
    Args.hsa_amd_signal_wait_any.signals = signals;
    Args.hsa_amd_signal_wait_any.conds = conds;
    Args.hsa_amd_signal_wait_any.values = values;
    Args.hsa_amd_signal_wait_any.timeout_hint = timeout_hint;
    Args.hsa_amd_signal_wait_any.wait_hint = wait_hint;
    Args.hsa_amd_signal_wait_any.satisfying_value = satisfying_value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_signal_wait_any_fn(Args.hsa_amd_signal_wait_any.signal_count, Args.hsa_amd_signal_wait_any.signals, Args.hsa_amd_signal_wait_any.conds, Args.hsa_amd_signal_wait_any.values, Args.hsa_amd_signal_wait_any.timeout_hint, Args.hsa_amd_signal_wait_any.wait_hint, Args.hsa_amd_signal_wait_any.satisfying_value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_signal_wait_any_fn(signal_count, signals, conds, values, timeout_hint, wait_hint, satisfying_value);
  }
}

static hsa_status_t hsa_amd_queue_cu_set_mask_callback(const hsa_queue_t* queue, uint32_t num_cu_mask_count, const uint32_t* cu_mask) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_queue_cu_set_mask;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_queue_cu_set_mask.queue = queue;
    Args.hsa_amd_queue_cu_set_mask.num_cu_mask_count = num_cu_mask_count;
    Args.hsa_amd_queue_cu_set_mask.cu_mask = cu_mask;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_queue_cu_set_mask_fn(Args.hsa_amd_queue_cu_set_mask.queue, Args.hsa_amd_queue_cu_set_mask.num_cu_mask_count, Args.hsa_amd_queue_cu_set_mask.cu_mask);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_queue_cu_set_mask_fn(queue, num_cu_mask_count, cu_mask);
  }
}

static hsa_status_t hsa_amd_memory_pool_get_info_callback(hsa_amd_memory_pool_t memory_pool, hsa_amd_memory_pool_info_t attribute, void* value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_memory_pool_get_info;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_memory_pool_get_info.memory_pool = memory_pool;
    Args.hsa_amd_memory_pool_get_info.attribute = attribute;
    Args.hsa_amd_memory_pool_get_info.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_pool_get_info_fn(Args.hsa_amd_memory_pool_get_info.memory_pool, Args.hsa_amd_memory_pool_get_info.attribute, Args.hsa_amd_memory_pool_get_info.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_pool_get_info_fn(memory_pool, attribute, value);
  }
}

static hsa_status_t hsa_amd_agent_iterate_memory_pools_callback(hsa_agent_t agent, hsa_status_t (* callback)(hsa_amd_memory_pool_t memory_pool, void* data), void* data) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_agent_iterate_memory_pools;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_agent_iterate_memory_pools.agent = agent;
    Args.hsa_amd_agent_iterate_memory_pools.callback = callback;
    Args.hsa_amd_agent_iterate_memory_pools.data = data;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_agent_iterate_memory_pools_fn(Args.hsa_amd_agent_iterate_memory_pools.agent, Args.hsa_amd_agent_iterate_memory_pools.callback, Args.hsa_amd_agent_iterate_memory_pools.data);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_agent_iterate_memory_pools_fn(agent, callback, data);
  }
}

static hsa_status_t hsa_amd_memory_pool_allocate_callback(hsa_amd_memory_pool_t memory_pool, size_t size, uint32_t flags, void** ptr) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_memory_pool_allocate;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_memory_pool_allocate.memory_pool = memory_pool;
    Args.hsa_amd_memory_pool_allocate.size = size;
    Args.hsa_amd_memory_pool_allocate.flags = flags;
    Args.hsa_amd_memory_pool_allocate.ptr = ptr;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_pool_allocate_fn(Args.hsa_amd_memory_pool_allocate.memory_pool, Args.hsa_amd_memory_pool_allocate.size, Args.hsa_amd_memory_pool_allocate.flags, Args.hsa_amd_memory_pool_allocate.ptr);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_pool_allocate_fn(memory_pool, size, flags, ptr);
  }
}

static hsa_status_t hsa_amd_memory_pool_free_callback(void* ptr) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_memory_pool_free;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_memory_pool_free.ptr = ptr;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_pool_free_fn(Args.hsa_amd_memory_pool_free.ptr);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_pool_free_fn(ptr);
  }
}

static hsa_status_t hsa_amd_memory_async_copy_callback(void* dst, hsa_agent_t dst_agent, const void* src, hsa_agent_t src_agent, size_t size, uint32_t num_dep_signals, const hsa_signal_t* dep_signals, hsa_signal_t completion_signal) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_memory_async_copy;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_memory_async_copy.dst = dst;
    Args.hsa_amd_memory_async_copy.dst_agent = dst_agent;
    Args.hsa_amd_memory_async_copy.src = src;
    Args.hsa_amd_memory_async_copy.src_agent = src_agent;
    Args.hsa_amd_memory_async_copy.size = size;
    Args.hsa_amd_memory_async_copy.num_dep_signals = num_dep_signals;
    Args.hsa_amd_memory_async_copy.dep_signals = dep_signals;
    Args.hsa_amd_memory_async_copy.completion_signal = completion_signal;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_async_copy_fn(Args.hsa_amd_memory_async_copy.dst, Args.hsa_amd_memory_async_copy.dst_agent, Args.hsa_amd_memory_async_copy.src, Args.hsa_amd_memory_async_copy.src_agent, Args.hsa_amd_memory_async_copy.size, Args.hsa_amd_memory_async_copy.num_dep_signals, Args.hsa_amd_memory_async_copy.dep_signals, Args.hsa_amd_memory_async_copy.completion_signal);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_async_copy_fn(dst, dst_agent, src, src_agent, size, num_dep_signals, dep_signals, completion_signal);
  }
}

static hsa_status_t hsa_amd_memory_async_copy_on_engine_callback(void* dst, hsa_agent_t dst_agent, const void* src, hsa_agent_t src_agent, size_t size, uint32_t num_dep_signals, const hsa_signal_t* dep_signals, hsa_signal_t completion_signal, hsa_amd_sdma_engine_id_t engine_id, bool force_copy_on_sdma) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_memory_async_copy_on_engine;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_memory_async_copy_on_engine.dst = dst;
    Args.hsa_amd_memory_async_copy_on_engine.dst_agent = dst_agent;
    Args.hsa_amd_memory_async_copy_on_engine.src = src;
    Args.hsa_amd_memory_async_copy_on_engine.src_agent = src_agent;
    Args.hsa_amd_memory_async_copy_on_engine.size = size;
    Args.hsa_amd_memory_async_copy_on_engine.num_dep_signals = num_dep_signals;
    Args.hsa_amd_memory_async_copy_on_engine.dep_signals = dep_signals;
    Args.hsa_amd_memory_async_copy_on_engine.completion_signal = completion_signal;
    Args.hsa_amd_memory_async_copy_on_engine.engine_id = engine_id;
    Args.hsa_amd_memory_async_copy_on_engine.force_copy_on_sdma = force_copy_on_sdma;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_async_copy_on_engine_fn(Args.hsa_amd_memory_async_copy_on_engine.dst, Args.hsa_amd_memory_async_copy_on_engine.dst_agent, Args.hsa_amd_memory_async_copy_on_engine.src, Args.hsa_amd_memory_async_copy_on_engine.src_agent, Args.hsa_amd_memory_async_copy_on_engine.size, Args.hsa_amd_memory_async_copy_on_engine.num_dep_signals, Args.hsa_amd_memory_async_copy_on_engine.dep_signals, Args.hsa_amd_memory_async_copy_on_engine.completion_signal, Args.hsa_amd_memory_async_copy_on_engine.engine_id, Args.hsa_amd_memory_async_copy_on_engine.force_copy_on_sdma);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_async_copy_on_engine_fn(dst, dst_agent, src, src_agent, size, num_dep_signals, dep_signals, completion_signal, engine_id, force_copy_on_sdma);
  }
}

static hsa_status_t hsa_amd_memory_copy_engine_status_callback(hsa_agent_t dst_agent, hsa_agent_t src_agent, uint32_t* engine_ids_mask) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_memory_copy_engine_status;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_memory_copy_engine_status.dst_agent = dst_agent;
    Args.hsa_amd_memory_copy_engine_status.src_agent = src_agent;
    Args.hsa_amd_memory_copy_engine_status.engine_ids_mask = engine_ids_mask;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_copy_engine_status_fn(Args.hsa_amd_memory_copy_engine_status.dst_agent, Args.hsa_amd_memory_copy_engine_status.src_agent, Args.hsa_amd_memory_copy_engine_status.engine_ids_mask);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_copy_engine_status_fn(dst_agent, src_agent, engine_ids_mask);
  }
}

static hsa_status_t hsa_amd_agent_memory_pool_get_info_callback(hsa_agent_t agent, hsa_amd_memory_pool_t memory_pool, hsa_amd_agent_memory_pool_info_t attribute, void* value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_agent_memory_pool_get_info;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_agent_memory_pool_get_info.agent = agent;
    Args.hsa_amd_agent_memory_pool_get_info.memory_pool = memory_pool;
    Args.hsa_amd_agent_memory_pool_get_info.attribute = attribute;
    Args.hsa_amd_agent_memory_pool_get_info.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_agent_memory_pool_get_info_fn(Args.hsa_amd_agent_memory_pool_get_info.agent, Args.hsa_amd_agent_memory_pool_get_info.memory_pool, Args.hsa_amd_agent_memory_pool_get_info.attribute, Args.hsa_amd_agent_memory_pool_get_info.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_agent_memory_pool_get_info_fn(agent, memory_pool, attribute, value);
  }
}

static hsa_status_t hsa_amd_agents_allow_access_callback(uint32_t num_agents, const hsa_agent_t* agents, const uint32_t* flags, const void* ptr) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_agents_allow_access;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_agents_allow_access.num_agents = num_agents;
    Args.hsa_amd_agents_allow_access.agents = agents;
    Args.hsa_amd_agents_allow_access.flags = flags;
    Args.hsa_amd_agents_allow_access.ptr = ptr;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_agents_allow_access_fn(Args.hsa_amd_agents_allow_access.num_agents, Args.hsa_amd_agents_allow_access.agents, Args.hsa_amd_agents_allow_access.flags, Args.hsa_amd_agents_allow_access.ptr);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_agents_allow_access_fn(num_agents, agents, flags, ptr);
  }
}

static hsa_status_t hsa_amd_memory_pool_can_migrate_callback(hsa_amd_memory_pool_t src_memory_pool, hsa_amd_memory_pool_t dst_memory_pool, bool* result) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_memory_pool_can_migrate;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_memory_pool_can_migrate.src_memory_pool = src_memory_pool;
    Args.hsa_amd_memory_pool_can_migrate.dst_memory_pool = dst_memory_pool;
    Args.hsa_amd_memory_pool_can_migrate.result = result;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_pool_can_migrate_fn(Args.hsa_amd_memory_pool_can_migrate.src_memory_pool, Args.hsa_amd_memory_pool_can_migrate.dst_memory_pool, Args.hsa_amd_memory_pool_can_migrate.result);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_pool_can_migrate_fn(src_memory_pool, dst_memory_pool, result);
  }
}

static hsa_status_t hsa_amd_memory_migrate_callback(const void* ptr, hsa_amd_memory_pool_t memory_pool, uint32_t flags) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_memory_migrate;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_memory_migrate.ptr = ptr;
    Args.hsa_amd_memory_migrate.memory_pool = memory_pool;
    Args.hsa_amd_memory_migrate.flags = flags;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_migrate_fn(Args.hsa_amd_memory_migrate.ptr, Args.hsa_amd_memory_migrate.memory_pool, Args.hsa_amd_memory_migrate.flags);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_migrate_fn(ptr, memory_pool, flags);
  }
}

static hsa_status_t hsa_amd_memory_lock_callback(void* host_ptr, size_t size, hsa_agent_t* agents, int num_agent, void** agent_ptr) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_memory_lock;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_memory_lock.host_ptr = host_ptr;
    Args.hsa_amd_memory_lock.size = size;
    Args.hsa_amd_memory_lock.agents = agents;
    Args.hsa_amd_memory_lock.num_agent = num_agent;
    Args.hsa_amd_memory_lock.agent_ptr = agent_ptr;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_lock_fn(Args.hsa_amd_memory_lock.host_ptr, Args.hsa_amd_memory_lock.size, Args.hsa_amd_memory_lock.agents, Args.hsa_amd_memory_lock.num_agent, Args.hsa_amd_memory_lock.agent_ptr);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_lock_fn(host_ptr, size, agents, num_agent, agent_ptr);
  }
}

static hsa_status_t hsa_amd_memory_unlock_callback(void* host_ptr) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_memory_unlock;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_memory_unlock.host_ptr = host_ptr;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_unlock_fn(Args.hsa_amd_memory_unlock.host_ptr);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_unlock_fn(host_ptr);
  }
}

static hsa_status_t hsa_amd_memory_fill_callback(void* ptr, uint32_t value, size_t count) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_memory_fill;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_memory_fill.ptr = ptr;
    Args.hsa_amd_memory_fill.value = value;
    Args.hsa_amd_memory_fill.count = count;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_fill_fn(Args.hsa_amd_memory_fill.ptr, Args.hsa_amd_memory_fill.value, Args.hsa_amd_memory_fill.count);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_fill_fn(ptr, value, count);
  }
}

static hsa_status_t hsa_amd_interop_map_buffer_callback(uint32_t num_agents, hsa_agent_t* agents, int interop_handle, uint32_t flags, size_t* size, void** ptr, size_t* metadata_size, const void** metadata) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_interop_map_buffer;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_interop_map_buffer.num_agents = num_agents;
    Args.hsa_amd_interop_map_buffer.agents = agents;
    Args.hsa_amd_interop_map_buffer.interop_handle = interop_handle;
    Args.hsa_amd_interop_map_buffer.flags = flags;
    Args.hsa_amd_interop_map_buffer.size = size;
    Args.hsa_amd_interop_map_buffer.ptr = ptr;
    Args.hsa_amd_interop_map_buffer.metadata_size = metadata_size;
    Args.hsa_amd_interop_map_buffer.metadata = metadata;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_interop_map_buffer_fn(Args.hsa_amd_interop_map_buffer.num_agents, Args.hsa_amd_interop_map_buffer.agents, Args.hsa_amd_interop_map_buffer.interop_handle, Args.hsa_amd_interop_map_buffer.flags, Args.hsa_amd_interop_map_buffer.size, Args.hsa_amd_interop_map_buffer.ptr, Args.hsa_amd_interop_map_buffer.metadata_size, Args.hsa_amd_interop_map_buffer.metadata);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_interop_map_buffer_fn(num_agents, agents, interop_handle, flags, size, ptr, metadata_size, metadata);
  }
}

static hsa_status_t hsa_amd_interop_unmap_buffer_callback(void* ptr) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_interop_unmap_buffer;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_interop_unmap_buffer.ptr = ptr;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_interop_unmap_buffer_fn(Args.hsa_amd_interop_unmap_buffer.ptr);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_interop_unmap_buffer_fn(ptr);
  }
}

static hsa_status_t hsa_amd_image_create_callback(hsa_agent_t agent, const hsa_ext_image_descriptor_t* image_descriptor, const hsa_amd_image_descriptor_t* image_layout, const void* image_data, hsa_access_permission_t access_permission, hsa_ext_image_t* image) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_image_create;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_image_create.agent = agent;
    Args.hsa_amd_image_create.image_descriptor = image_descriptor;
    Args.hsa_amd_image_create.image_layout = image_layout;
    Args.hsa_amd_image_create.image_data = image_data;
    Args.hsa_amd_image_create.access_permission = access_permission;
    Args.hsa_amd_image_create.image = image;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_image_create_fn(Args.hsa_amd_image_create.agent, Args.hsa_amd_image_create.image_descriptor, Args.hsa_amd_image_create.image_layout, Args.hsa_amd_image_create.image_data, Args.hsa_amd_image_create.access_permission, Args.hsa_amd_image_create.image);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_image_create_fn(agent, image_descriptor, image_layout, image_data, access_permission, image);
  }
}

static hsa_status_t hsa_amd_pointer_info_callback(const void* ptr, hsa_amd_pointer_info_t* info, void* (* alloc)(size_t), uint32_t* num_agents_accessible, hsa_agent_t** accessible) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_pointer_info;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_pointer_info.ptr = ptr;
    Args.hsa_amd_pointer_info.info = info;
    Args.hsa_amd_pointer_info.alloc = alloc;
    Args.hsa_amd_pointer_info.num_agents_accessible = num_agents_accessible;
    Args.hsa_amd_pointer_info.accessible = accessible;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_pointer_info_fn(Args.hsa_amd_pointer_info.ptr, Args.hsa_amd_pointer_info.info, Args.hsa_amd_pointer_info.alloc, Args.hsa_amd_pointer_info.num_agents_accessible, Args.hsa_amd_pointer_info.accessible);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_pointer_info_fn(ptr, info, alloc, num_agents_accessible, accessible);
  }
}

static hsa_status_t hsa_amd_pointer_info_set_userdata_callback(const void* ptr, void* userdata) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_pointer_info_set_userdata;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_pointer_info_set_userdata.ptr = ptr;
    Args.hsa_amd_pointer_info_set_userdata.userdata = userdata;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_pointer_info_set_userdata_fn(Args.hsa_amd_pointer_info_set_userdata.ptr, Args.hsa_amd_pointer_info_set_userdata.userdata);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_pointer_info_set_userdata_fn(ptr, userdata);
  }
}

static hsa_status_t hsa_amd_ipc_memory_create_callback(void* ptr, size_t len, hsa_amd_ipc_memory_t* handle) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_ipc_memory_create;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_ipc_memory_create.ptr = ptr;
    Args.hsa_amd_ipc_memory_create.len = len;
    Args.hsa_amd_ipc_memory_create.handle = handle;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_ipc_memory_create_fn(Args.hsa_amd_ipc_memory_create.ptr, Args.hsa_amd_ipc_memory_create.len, Args.hsa_amd_ipc_memory_create.handle);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_ipc_memory_create_fn(ptr, len, handle);
  }
}

static hsa_status_t hsa_amd_ipc_memory_attach_callback(const hsa_amd_ipc_memory_t* handle, size_t len, uint32_t num_agents, const hsa_agent_t* mapping_agents, void** mapped_ptr) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_ipc_memory_attach;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_ipc_memory_attach.handle = handle;
    Args.hsa_amd_ipc_memory_attach.len = len;
    Args.hsa_amd_ipc_memory_attach.num_agents = num_agents;
    Args.hsa_amd_ipc_memory_attach.mapping_agents = mapping_agents;
    Args.hsa_amd_ipc_memory_attach.mapped_ptr = mapped_ptr;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_ipc_memory_attach_fn(Args.hsa_amd_ipc_memory_attach.handle, Args.hsa_amd_ipc_memory_attach.len, Args.hsa_amd_ipc_memory_attach.num_agents, Args.hsa_amd_ipc_memory_attach.mapping_agents, Args.hsa_amd_ipc_memory_attach.mapped_ptr);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_ipc_memory_attach_fn(handle, len, num_agents, mapping_agents, mapped_ptr);
  }
}

static hsa_status_t hsa_amd_ipc_memory_detach_callback(void* mapped_ptr) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_ipc_memory_detach;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_ipc_memory_detach.mapped_ptr = mapped_ptr;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_ipc_memory_detach_fn(Args.hsa_amd_ipc_memory_detach.mapped_ptr);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_ipc_memory_detach_fn(mapped_ptr);
  }
}

static hsa_status_t hsa_amd_signal_create_callback(hsa_signal_value_t initial_value, uint32_t num_consumers, const hsa_agent_t* consumers, uint64_t attributes, hsa_signal_t* signal) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_signal_create;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_signal_create.initial_value = initial_value;
    Args.hsa_amd_signal_create.num_consumers = num_consumers;
    Args.hsa_amd_signal_create.consumers = consumers;
    Args.hsa_amd_signal_create.attributes = attributes;
    Args.hsa_amd_signal_create.signal = signal;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_signal_create_fn(Args.hsa_amd_signal_create.initial_value, Args.hsa_amd_signal_create.num_consumers, Args.hsa_amd_signal_create.consumers, Args.hsa_amd_signal_create.attributes, Args.hsa_amd_signal_create.signal);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_signal_create_fn(initial_value, num_consumers, consumers, attributes, signal);
  }
}

static hsa_status_t hsa_amd_ipc_signal_create_callback(hsa_signal_t signal, hsa_amd_ipc_signal_t* handle) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_ipc_signal_create;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_ipc_signal_create.signal = signal;
    Args.hsa_amd_ipc_signal_create.handle = handle;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_ipc_signal_create_fn(Args.hsa_amd_ipc_signal_create.signal, Args.hsa_amd_ipc_signal_create.handle);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_ipc_signal_create_fn(signal, handle);
  }
}

static hsa_status_t hsa_amd_ipc_signal_attach_callback(const hsa_amd_ipc_signal_t* handle, hsa_signal_t* signal) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_ipc_signal_attach;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_ipc_signal_attach.handle = handle;
    Args.hsa_amd_ipc_signal_attach.signal = signal;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_ipc_signal_attach_fn(Args.hsa_amd_ipc_signal_attach.handle, Args.hsa_amd_ipc_signal_attach.signal);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_ipc_signal_attach_fn(handle, signal);
  }
}

static hsa_status_t hsa_amd_register_system_event_handler_callback(hsa_amd_system_event_callback_t callback, void* data) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_register_system_event_handler;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_register_system_event_handler.callback = callback;
    Args.hsa_amd_register_system_event_handler.data = data;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_register_system_event_handler_fn(Args.hsa_amd_register_system_event_handler.callback, Args.hsa_amd_register_system_event_handler.data);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_register_system_event_handler_fn(callback, data);
  }
}

static hsa_status_t hsa_amd_queue_intercept_create_callback(hsa_agent_t agent_handle, uint32_t size, hsa_queue_type32_t type, void (* callback)(hsa_status_t status, hsa_queue_t* source, void* data), void* data, uint32_t private_segment_size, uint32_t group_segment_size, hsa_queue_t** queue) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_queue_intercept_create;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_queue_intercept_create.agent_handle = agent_handle;
    Args.hsa_amd_queue_intercept_create.size = size;
    Args.hsa_amd_queue_intercept_create.type = type;
    Args.hsa_amd_queue_intercept_create.callback = callback;
    Args.hsa_amd_queue_intercept_create.data = data;
    Args.hsa_amd_queue_intercept_create.private_segment_size = private_segment_size;
    Args.hsa_amd_queue_intercept_create.group_segment_size = group_segment_size;
    Args.hsa_amd_queue_intercept_create.queue = queue;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_queue_intercept_create_fn(Args.hsa_amd_queue_intercept_create.agent_handle, Args.hsa_amd_queue_intercept_create.size, Args.hsa_amd_queue_intercept_create.type, Args.hsa_amd_queue_intercept_create.callback, Args.hsa_amd_queue_intercept_create.data, Args.hsa_amd_queue_intercept_create.private_segment_size, Args.hsa_amd_queue_intercept_create.group_segment_size, Args.hsa_amd_queue_intercept_create.queue);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_queue_intercept_create_fn(agent_handle, size, type, callback, data, private_segment_size, group_segment_size, queue);
  }
}

static hsa_status_t hsa_amd_queue_intercept_register_callback(hsa_queue_t* queue, hsa_amd_queue_intercept_handler callback, void* user_data) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_queue_intercept_register;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_queue_intercept_register.queue = queue;
    Args.hsa_amd_queue_intercept_register.callback = callback;
    Args.hsa_amd_queue_intercept_register.user_data = user_data;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_queue_intercept_register_fn(Args.hsa_amd_queue_intercept_register.queue, Args.hsa_amd_queue_intercept_register.callback, Args.hsa_amd_queue_intercept_register.user_data);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_queue_intercept_register_fn(queue, callback, user_data);
  }
}

static hsa_status_t hsa_amd_queue_set_priority_callback(hsa_queue_t* queue, hsa_amd_queue_priority_t priority) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_queue_set_priority;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_queue_set_priority.queue = queue;
    Args.hsa_amd_queue_set_priority.priority = priority;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_queue_set_priority_fn(Args.hsa_amd_queue_set_priority.queue, Args.hsa_amd_queue_set_priority.priority);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_queue_set_priority_fn(queue, priority);
  }
}

static hsa_status_t hsa_amd_memory_async_copy_rect_callback(const hsa_pitched_ptr_t* dst, const hsa_dim3_t* dst_offset, const hsa_pitched_ptr_t* src, const hsa_dim3_t* src_offset, const hsa_dim3_t* range, hsa_agent_t copy_agent, hsa_amd_copy_direction_t dir, uint32_t num_dep_signals, const hsa_signal_t* dep_signals, hsa_signal_t completion_signal) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_memory_async_copy_rect;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_memory_async_copy_rect.dst = dst;
    Args.hsa_amd_memory_async_copy_rect.dst_offset = dst_offset;
    Args.hsa_amd_memory_async_copy_rect.src = src;
    Args.hsa_amd_memory_async_copy_rect.src_offset = src_offset;
    Args.hsa_amd_memory_async_copy_rect.range = range;
    Args.hsa_amd_memory_async_copy_rect.copy_agent = copy_agent;
    Args.hsa_amd_memory_async_copy_rect.dir = dir;
    Args.hsa_amd_memory_async_copy_rect.num_dep_signals = num_dep_signals;
    Args.hsa_amd_memory_async_copy_rect.dep_signals = dep_signals;
    Args.hsa_amd_memory_async_copy_rect.completion_signal = completion_signal;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_async_copy_rect_fn(Args.hsa_amd_memory_async_copy_rect.dst, Args.hsa_amd_memory_async_copy_rect.dst_offset, Args.hsa_amd_memory_async_copy_rect.src, Args.hsa_amd_memory_async_copy_rect.src_offset, Args.hsa_amd_memory_async_copy_rect.range, Args.hsa_amd_memory_async_copy_rect.copy_agent, Args.hsa_amd_memory_async_copy_rect.dir, Args.hsa_amd_memory_async_copy_rect.num_dep_signals, Args.hsa_amd_memory_async_copy_rect.dep_signals, Args.hsa_amd_memory_async_copy_rect.completion_signal);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_async_copy_rect_fn(dst, dst_offset, src, src_offset, range, copy_agent, dir, num_dep_signals, dep_signals, completion_signal);
  }
}

static hsa_status_t hsa_amd_runtime_queue_create_register_callback(hsa_amd_runtime_queue_notifier callback, void* user_data) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_runtime_queue_create_register;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_runtime_queue_create_register.callback = callback;
    Args.hsa_amd_runtime_queue_create_register.user_data = user_data;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_runtime_queue_create_register_fn(Args.hsa_amd_runtime_queue_create_register.callback, Args.hsa_amd_runtime_queue_create_register.user_data);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_runtime_queue_create_register_fn(callback, user_data);
  }
}

static hsa_status_t hsa_amd_memory_lock_to_pool_callback(void* host_ptr, size_t size, hsa_agent_t* agents, int num_agent, hsa_amd_memory_pool_t pool, uint32_t flags, void** agent_ptr) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_memory_lock_to_pool;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_memory_lock_to_pool.host_ptr = host_ptr;
    Args.hsa_amd_memory_lock_to_pool.size = size;
    Args.hsa_amd_memory_lock_to_pool.agents = agents;
    Args.hsa_amd_memory_lock_to_pool.num_agent = num_agent;
    Args.hsa_amd_memory_lock_to_pool.pool = pool;
    Args.hsa_amd_memory_lock_to_pool.flags = flags;
    Args.hsa_amd_memory_lock_to_pool.agent_ptr = agent_ptr;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_lock_to_pool_fn(Args.hsa_amd_memory_lock_to_pool.host_ptr, Args.hsa_amd_memory_lock_to_pool.size, Args.hsa_amd_memory_lock_to_pool.agents, Args.hsa_amd_memory_lock_to_pool.num_agent, Args.hsa_amd_memory_lock_to_pool.pool, Args.hsa_amd_memory_lock_to_pool.flags, Args.hsa_amd_memory_lock_to_pool.agent_ptr);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_memory_lock_to_pool_fn(host_ptr, size, agents, num_agent, pool, flags, agent_ptr);
  }
}

static hsa_status_t hsa_amd_register_deallocation_callback_callback(void* ptr, hsa_amd_deallocation_callback_t callback, void* user_data) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_register_deallocation_callback;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_register_deallocation_callback.ptr = ptr;
    Args.hsa_amd_register_deallocation_callback.callback = callback;
    Args.hsa_amd_register_deallocation_callback.user_data = user_data;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_register_deallocation_callback_fn(Args.hsa_amd_register_deallocation_callback.ptr, Args.hsa_amd_register_deallocation_callback.callback, Args.hsa_amd_register_deallocation_callback.user_data);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_register_deallocation_callback_fn(ptr, callback, user_data);
  }
}

static hsa_status_t hsa_amd_deregister_deallocation_callback_callback(void* ptr, hsa_amd_deallocation_callback_t callback) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_deregister_deallocation_callback;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_deregister_deallocation_callback.ptr = ptr;
    Args.hsa_amd_deregister_deallocation_callback.callback = callback;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_deregister_deallocation_callback_fn(Args.hsa_amd_deregister_deallocation_callback.ptr, Args.hsa_amd_deregister_deallocation_callback.callback);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_deregister_deallocation_callback_fn(ptr, callback);
  }
}

static hsa_status_t hsa_amd_signal_value_pointer_callback(hsa_signal_t signal, volatile hsa_signal_value_t** value_ptr) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_signal_value_pointer;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_signal_value_pointer.signal = signal;
    Args.hsa_amd_signal_value_pointer.value_ptr = value_ptr;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_signal_value_pointer_fn(Args.hsa_amd_signal_value_pointer.signal, Args.hsa_amd_signal_value_pointer.value_ptr);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_signal_value_pointer_fn(signal, value_ptr);
  }
}

static hsa_status_t hsa_amd_svm_attributes_set_callback(void* ptr, size_t size, hsa_amd_svm_attribute_pair_t* attribute_list, size_t attribute_count) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_svm_attributes_set;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_svm_attributes_set.ptr = ptr;
    Args.hsa_amd_svm_attributes_set.size = size;
    Args.hsa_amd_svm_attributes_set.attribute_list = attribute_list;
    Args.hsa_amd_svm_attributes_set.attribute_count = attribute_count;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_svm_attributes_set_fn(Args.hsa_amd_svm_attributes_set.ptr, Args.hsa_amd_svm_attributes_set.size, Args.hsa_amd_svm_attributes_set.attribute_list, Args.hsa_amd_svm_attributes_set.attribute_count);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_svm_attributes_set_fn(ptr, size, attribute_list, attribute_count);
  }
}

static hsa_status_t hsa_amd_svm_attributes_get_callback(void* ptr, size_t size, hsa_amd_svm_attribute_pair_t* attribute_list, size_t attribute_count) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_svm_attributes_get;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_svm_attributes_get.ptr = ptr;
    Args.hsa_amd_svm_attributes_get.size = size;
    Args.hsa_amd_svm_attributes_get.attribute_list = attribute_list;
    Args.hsa_amd_svm_attributes_get.attribute_count = attribute_count;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_svm_attributes_get_fn(Args.hsa_amd_svm_attributes_get.ptr, Args.hsa_amd_svm_attributes_get.size, Args.hsa_amd_svm_attributes_get.attribute_list, Args.hsa_amd_svm_attributes_get.attribute_count);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_svm_attributes_get_fn(ptr, size, attribute_list, attribute_count);
  }
}

static hsa_status_t hsa_amd_svm_prefetch_async_callback(void* ptr, size_t size, hsa_agent_t agent, uint32_t num_dep_signals, const hsa_signal_t* dep_signals, hsa_signal_t completion_signal) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_svm_prefetch_async;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_svm_prefetch_async.ptr = ptr;
    Args.hsa_amd_svm_prefetch_async.size = size;
    Args.hsa_amd_svm_prefetch_async.agent = agent;
    Args.hsa_amd_svm_prefetch_async.num_dep_signals = num_dep_signals;
    Args.hsa_amd_svm_prefetch_async.dep_signals = dep_signals;
    Args.hsa_amd_svm_prefetch_async.completion_signal = completion_signal;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_svm_prefetch_async_fn(Args.hsa_amd_svm_prefetch_async.ptr, Args.hsa_amd_svm_prefetch_async.size, Args.hsa_amd_svm_prefetch_async.agent, Args.hsa_amd_svm_prefetch_async.num_dep_signals, Args.hsa_amd_svm_prefetch_async.dep_signals, Args.hsa_amd_svm_prefetch_async.completion_signal);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_svm_prefetch_async_fn(ptr, size, agent, num_dep_signals, dep_signals, completion_signal);
  }
}

static hsa_status_t hsa_amd_spm_acquire_callback(hsa_agent_t preferred_agent) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_spm_acquire;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_spm_acquire.preferred_agent = preferred_agent;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_spm_acquire_fn(Args.hsa_amd_spm_acquire.preferred_agent);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_spm_acquire_fn(preferred_agent);
  }
}

static hsa_status_t hsa_amd_spm_release_callback(hsa_agent_t preferred_agent) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_spm_release;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_spm_release.preferred_agent = preferred_agent;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_spm_release_fn(Args.hsa_amd_spm_release.preferred_agent);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_spm_release_fn(preferred_agent);
  }
}

static hsa_status_t hsa_amd_spm_set_dest_buffer_callback(hsa_agent_t preferred_agent, size_t size_in_bytes, uint32_t* timeout, uint32_t* size_copied, void* dest, bool* is_data_loss) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_spm_set_dest_buffer;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_spm_set_dest_buffer.preferred_agent = preferred_agent;
    Args.hsa_amd_spm_set_dest_buffer.size_in_bytes = size_in_bytes;
    Args.hsa_amd_spm_set_dest_buffer.timeout = timeout;
    Args.hsa_amd_spm_set_dest_buffer.size_copied = size_copied;
    Args.hsa_amd_spm_set_dest_buffer.dest = dest;
    Args.hsa_amd_spm_set_dest_buffer.is_data_loss = is_data_loss;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_spm_set_dest_buffer_fn(Args.hsa_amd_spm_set_dest_buffer.preferred_agent, Args.hsa_amd_spm_set_dest_buffer.size_in_bytes, Args.hsa_amd_spm_set_dest_buffer.timeout, Args.hsa_amd_spm_set_dest_buffer.size_copied, Args.hsa_amd_spm_set_dest_buffer.dest, Args.hsa_amd_spm_set_dest_buffer.is_data_loss);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_spm_set_dest_buffer_fn(preferred_agent, size_in_bytes, timeout, size_copied, dest, is_data_loss);
  }
}

static hsa_status_t hsa_amd_queue_cu_get_mask_callback(const hsa_queue_t* queue, uint32_t num_cu_mask_count, uint32_t* cu_mask) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_queue_cu_get_mask;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_queue_cu_get_mask.queue = queue;
    Args.hsa_amd_queue_cu_get_mask.num_cu_mask_count = num_cu_mask_count;
    Args.hsa_amd_queue_cu_get_mask.cu_mask = cu_mask;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_queue_cu_get_mask_fn(Args.hsa_amd_queue_cu_get_mask.queue, Args.hsa_amd_queue_cu_get_mask.num_cu_mask_count, Args.hsa_amd_queue_cu_get_mask.cu_mask);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_queue_cu_get_mask_fn(queue, num_cu_mask_count, cu_mask);
  }
}

static hsa_status_t hsa_amd_portable_export_dmabuf_callback(const void* ptr, size_t size, int* dmabuf, uint64_t* offset) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_portable_export_dmabuf;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_portable_export_dmabuf.ptr = ptr;
    Args.hsa_amd_portable_export_dmabuf.size = size;
    Args.hsa_amd_portable_export_dmabuf.dmabuf = dmabuf;
    Args.hsa_amd_portable_export_dmabuf.offset = offset;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_portable_export_dmabuf_fn(Args.hsa_amd_portable_export_dmabuf.ptr, Args.hsa_amd_portable_export_dmabuf.size, Args.hsa_amd_portable_export_dmabuf.dmabuf, Args.hsa_amd_portable_export_dmabuf.offset);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_portable_export_dmabuf_fn(ptr, size, dmabuf, offset);
  }
}

static hsa_status_t hsa_amd_portable_close_dmabuf_callback(int dmabuf) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_portable_close_dmabuf;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_portable_close_dmabuf.dmabuf = dmabuf;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_portable_close_dmabuf_fn(Args.hsa_amd_portable_close_dmabuf.dmabuf);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_portable_close_dmabuf_fn(dmabuf);
  }
}

static hsa_status_t hsa_amd_vmem_address_reserve_callback(void** va, size_t size, uint64_t address, uint64_t flags) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_vmem_address_reserve;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_vmem_address_reserve.va = va;
    Args.hsa_amd_vmem_address_reserve.size = size;
    Args.hsa_amd_vmem_address_reserve.address = address;
    Args.hsa_amd_vmem_address_reserve.flags = flags;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_address_reserve_fn(Args.hsa_amd_vmem_address_reserve.va, Args.hsa_amd_vmem_address_reserve.size, Args.hsa_amd_vmem_address_reserve.address, Args.hsa_amd_vmem_address_reserve.flags);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_address_reserve_fn(va, size, address, flags);
  }
}

static hsa_status_t hsa_amd_vmem_address_free_callback(void* va, size_t size) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_vmem_address_free;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_vmem_address_free.va = va;
    Args.hsa_amd_vmem_address_free.size = size;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_address_free_fn(Args.hsa_amd_vmem_address_free.va, Args.hsa_amd_vmem_address_free.size);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_address_free_fn(va, size);
  }
}

static hsa_status_t hsa_amd_vmem_handle_create_callback(hsa_amd_memory_pool_t pool, size_t size, hsa_amd_memory_type_t type, uint64_t flags, hsa_amd_vmem_alloc_handle_t* memory_handle) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_vmem_handle_create;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_vmem_handle_create.pool = pool;
    Args.hsa_amd_vmem_handle_create.size = size;
    Args.hsa_amd_vmem_handle_create.type = type;
    Args.hsa_amd_vmem_handle_create.flags = flags;
    Args.hsa_amd_vmem_handle_create.memory_handle = memory_handle;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_handle_create_fn(Args.hsa_amd_vmem_handle_create.pool, Args.hsa_amd_vmem_handle_create.size, Args.hsa_amd_vmem_handle_create.type, Args.hsa_amd_vmem_handle_create.flags, Args.hsa_amd_vmem_handle_create.memory_handle);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_handle_create_fn(pool, size, type, flags, memory_handle);
  }
}

static hsa_status_t hsa_amd_vmem_handle_release_callback(hsa_amd_vmem_alloc_handle_t memory_handle) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_vmem_handle_release;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_vmem_handle_release.memory_handle = memory_handle;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_handle_release_fn(Args.hsa_amd_vmem_handle_release.memory_handle);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_handle_release_fn(memory_handle);
  }
}

static hsa_status_t hsa_amd_vmem_map_callback(void* va, size_t size, size_t in_offset, hsa_amd_vmem_alloc_handle_t memory_handle, uint64_t flags) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_vmem_map;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_vmem_map.va = va;
    Args.hsa_amd_vmem_map.size = size;
    Args.hsa_amd_vmem_map.in_offset = in_offset;
    Args.hsa_amd_vmem_map.memory_handle = memory_handle;
    Args.hsa_amd_vmem_map.flags = flags;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_map_fn(Args.hsa_amd_vmem_map.va, Args.hsa_amd_vmem_map.size, Args.hsa_amd_vmem_map.in_offset, Args.hsa_amd_vmem_map.memory_handle, Args.hsa_amd_vmem_map.flags);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_map_fn(va, size, in_offset, memory_handle, flags);
  }
}

static hsa_status_t hsa_amd_vmem_unmap_callback(void* va, size_t size) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_vmem_unmap;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_vmem_unmap.va = va;
    Args.hsa_amd_vmem_unmap.size = size;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_unmap_fn(Args.hsa_amd_vmem_unmap.va, Args.hsa_amd_vmem_unmap.size);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_unmap_fn(va, size);
  }
}

static hsa_status_t hsa_amd_vmem_set_access_callback(void* va, size_t size, const hsa_amd_memory_access_desc_t* desc, size_t desc_cnt) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_vmem_set_access;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_vmem_set_access.va = va;
    Args.hsa_amd_vmem_set_access.size = size;
    Args.hsa_amd_vmem_set_access.desc = desc;
    Args.hsa_amd_vmem_set_access.desc_cnt = desc_cnt;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_set_access_fn(Args.hsa_amd_vmem_set_access.va, Args.hsa_amd_vmem_set_access.size, Args.hsa_amd_vmem_set_access.desc, Args.hsa_amd_vmem_set_access.desc_cnt);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_set_access_fn(va, size, desc, desc_cnt);
  }
}

static hsa_status_t hsa_amd_vmem_get_access_callback(void* va, hsa_access_permission_t* perms, hsa_agent_t agent_handle) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_vmem_get_access;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_vmem_get_access.va = va;
    Args.hsa_amd_vmem_get_access.perms = perms;
    Args.hsa_amd_vmem_get_access.agent_handle = agent_handle;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_get_access_fn(Args.hsa_amd_vmem_get_access.va, Args.hsa_amd_vmem_get_access.perms, Args.hsa_amd_vmem_get_access.agent_handle);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_get_access_fn(va, perms, agent_handle);
  }
}

static hsa_status_t hsa_amd_vmem_export_shareable_handle_callback(int* dmabuf_fd, hsa_amd_vmem_alloc_handle_t handle, uint64_t flags) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_vmem_export_shareable_handle;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_vmem_export_shareable_handle.dmabuf_fd = dmabuf_fd;
    Args.hsa_amd_vmem_export_shareable_handle.handle = handle;
    Args.hsa_amd_vmem_export_shareable_handle.flags = flags;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_export_shareable_handle_fn(Args.hsa_amd_vmem_export_shareable_handle.dmabuf_fd, Args.hsa_amd_vmem_export_shareable_handle.handle, Args.hsa_amd_vmem_export_shareable_handle.flags);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_export_shareable_handle_fn(dmabuf_fd, handle, flags);
  }
}

static hsa_status_t hsa_amd_vmem_import_shareable_handle_callback(int dmabuf_fd, hsa_amd_vmem_alloc_handle_t* handle) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_vmem_import_shareable_handle;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_vmem_import_shareable_handle.dmabuf_fd = dmabuf_fd;
    Args.hsa_amd_vmem_import_shareable_handle.handle = handle;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_import_shareable_handle_fn(Args.hsa_amd_vmem_import_shareable_handle.dmabuf_fd, Args.hsa_amd_vmem_import_shareable_handle.handle);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_import_shareable_handle_fn(dmabuf_fd, handle);
  }
}

static hsa_status_t hsa_amd_vmem_retain_alloc_handle_callback(hsa_amd_vmem_alloc_handle_t* memory_handle, void* addr) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_vmem_retain_alloc_handle;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_vmem_retain_alloc_handle.memory_handle = memory_handle;
    Args.hsa_amd_vmem_retain_alloc_handle.addr = addr;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_retain_alloc_handle_fn(Args.hsa_amd_vmem_retain_alloc_handle.memory_handle, Args.hsa_amd_vmem_retain_alloc_handle.addr);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_retain_alloc_handle_fn(memory_handle, addr);
  }
}

static hsa_status_t hsa_amd_vmem_get_alloc_properties_from_handle_callback(hsa_amd_vmem_alloc_handle_t memory_handle, hsa_amd_memory_pool_t* pool, hsa_amd_memory_type_t* type) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_amd_vmem_get_alloc_properties_from_handle;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_amd_vmem_get_alloc_properties_from_handle.memory_handle = memory_handle;
    Args.hsa_amd_vmem_get_alloc_properties_from_handle.pool = pool;
    Args.hsa_amd_vmem_get_alloc_properties_from_handle.type = type;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_get_alloc_properties_from_handle_fn(Args.hsa_amd_vmem_get_alloc_properties_from_handle.memory_handle, Args.hsa_amd_vmem_get_alloc_properties_from_handle.pool, Args.hsa_amd_vmem_get_alloc_properties_from_handle.type);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().amd_ext.hsa_amd_vmem_get_alloc_properties_from_handle_fn(memory_handle, pool, type);
  }
}

static hsa_status_t hsa_ext_image_get_capability_callback(hsa_agent_t agent, hsa_ext_image_geometry_t geometry, const hsa_ext_image_format_t* image_format, uint32_t* capability_mask) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_image_get_capability;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_image_get_capability.agent = agent;
    Args.hsa_ext_image_get_capability.geometry = geometry;
    Args.hsa_ext_image_get_capability.image_format = image_format;
    Args.hsa_ext_image_get_capability.capability_mask = capability_mask;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_get_capability_fn(Args.hsa_ext_image_get_capability.agent, Args.hsa_ext_image_get_capability.geometry, Args.hsa_ext_image_get_capability.image_format, Args.hsa_ext_image_get_capability.capability_mask);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_get_capability_fn(agent, geometry, image_format, capability_mask);
  }
}

static hsa_status_t hsa_ext_image_data_get_info_callback(hsa_agent_t agent, const hsa_ext_image_descriptor_t* image_descriptor, hsa_access_permission_t access_permission, hsa_ext_image_data_info_t* image_data_info) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_image_data_get_info;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_image_data_get_info.agent = agent;
    Args.hsa_ext_image_data_get_info.image_descriptor = image_descriptor;
    Args.hsa_ext_image_data_get_info.access_permission = access_permission;
    Args.hsa_ext_image_data_get_info.image_data_info = image_data_info;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_data_get_info_fn(Args.hsa_ext_image_data_get_info.agent, Args.hsa_ext_image_data_get_info.image_descriptor, Args.hsa_ext_image_data_get_info.access_permission, Args.hsa_ext_image_data_get_info.image_data_info);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_data_get_info_fn(agent, image_descriptor, access_permission, image_data_info);
  }
}

static hsa_status_t hsa_ext_image_create_callback(hsa_agent_t agent, const hsa_ext_image_descriptor_t* image_descriptor, const void* image_data, hsa_access_permission_t access_permission, hsa_ext_image_t* image) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_image_create;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_image_create.agent = agent;
    Args.hsa_ext_image_create.image_descriptor = image_descriptor;
    Args.hsa_ext_image_create.image_data = image_data;
    Args.hsa_ext_image_create.access_permission = access_permission;
    Args.hsa_ext_image_create.image = image;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_create_fn(Args.hsa_ext_image_create.agent, Args.hsa_ext_image_create.image_descriptor, Args.hsa_ext_image_create.image_data, Args.hsa_ext_image_create.access_permission, Args.hsa_ext_image_create.image);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_create_fn(agent, image_descriptor, image_data, access_permission, image);
  }
}

static hsa_status_t hsa_ext_image_import_callback(hsa_agent_t agent, const void* src_memory, size_t src_row_pitch, size_t src_slice_pitch, hsa_ext_image_t dst_image, const hsa_ext_image_region_t* image_region) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_image_import;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_image_import.agent = agent;
    Args.hsa_ext_image_import.src_memory = src_memory;
    Args.hsa_ext_image_import.src_row_pitch = src_row_pitch;
    Args.hsa_ext_image_import.src_slice_pitch = src_slice_pitch;
    Args.hsa_ext_image_import.dst_image = dst_image;
    Args.hsa_ext_image_import.image_region = image_region;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_import_fn(Args.hsa_ext_image_import.agent, Args.hsa_ext_image_import.src_memory, Args.hsa_ext_image_import.src_row_pitch, Args.hsa_ext_image_import.src_slice_pitch, Args.hsa_ext_image_import.dst_image, Args.hsa_ext_image_import.image_region);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_import_fn(agent, src_memory, src_row_pitch, src_slice_pitch, dst_image, image_region);
  }
}

static hsa_status_t hsa_ext_image_export_callback(hsa_agent_t agent, hsa_ext_image_t src_image, void* dst_memory, size_t dst_row_pitch, size_t dst_slice_pitch, const hsa_ext_image_region_t* image_region) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_image_export;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_image_export.agent = agent;
    Args.hsa_ext_image_export.src_image = src_image;
    Args.hsa_ext_image_export.dst_memory = dst_memory;
    Args.hsa_ext_image_export.dst_row_pitch = dst_row_pitch;
    Args.hsa_ext_image_export.dst_slice_pitch = dst_slice_pitch;
    Args.hsa_ext_image_export.image_region = image_region;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_export_fn(Args.hsa_ext_image_export.agent, Args.hsa_ext_image_export.src_image, Args.hsa_ext_image_export.dst_memory, Args.hsa_ext_image_export.dst_row_pitch, Args.hsa_ext_image_export.dst_slice_pitch, Args.hsa_ext_image_export.image_region);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_export_fn(agent, src_image, dst_memory, dst_row_pitch, dst_slice_pitch, image_region);
  }
}

static hsa_status_t hsa_ext_image_copy_callback(hsa_agent_t agent, hsa_ext_image_t src_image, const hsa_dim3_t* src_offset, hsa_ext_image_t dst_image, const hsa_dim3_t* dst_offset, const hsa_dim3_t* range) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_image_copy;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_image_copy.agent = agent;
    Args.hsa_ext_image_copy.src_image = src_image;
    Args.hsa_ext_image_copy.src_offset = src_offset;
    Args.hsa_ext_image_copy.dst_image = dst_image;
    Args.hsa_ext_image_copy.dst_offset = dst_offset;
    Args.hsa_ext_image_copy.range = range;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_copy_fn(Args.hsa_ext_image_copy.agent, Args.hsa_ext_image_copy.src_image, Args.hsa_ext_image_copy.src_offset, Args.hsa_ext_image_copy.dst_image, Args.hsa_ext_image_copy.dst_offset, Args.hsa_ext_image_copy.range);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_copy_fn(agent, src_image, src_offset, dst_image, dst_offset, range);
  }
}

static hsa_status_t hsa_ext_image_clear_callback(hsa_agent_t agent, hsa_ext_image_t image, const void* data, const hsa_ext_image_region_t* image_region) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_image_clear;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_image_clear.agent = agent;
    Args.hsa_ext_image_clear.image = image;
    Args.hsa_ext_image_clear.data = data;
    Args.hsa_ext_image_clear.image_region = image_region;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_clear_fn(Args.hsa_ext_image_clear.agent, Args.hsa_ext_image_clear.image, Args.hsa_ext_image_clear.data, Args.hsa_ext_image_clear.image_region);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_clear_fn(agent, image, data, image_region);
  }
}

static hsa_status_t hsa_ext_image_destroy_callback(hsa_agent_t agent, hsa_ext_image_t image) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_image_destroy;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_image_destroy.agent = agent;
    Args.hsa_ext_image_destroy.image = image;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_destroy_fn(Args.hsa_ext_image_destroy.agent, Args.hsa_ext_image_destroy.image);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_destroy_fn(agent, image);
  }
}

static hsa_status_t hsa_ext_sampler_create_callback(hsa_agent_t agent, const hsa_ext_sampler_descriptor_t* sampler_descriptor, hsa_ext_sampler_t* sampler) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_sampler_create;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_sampler_create.agent = agent;
    Args.hsa_ext_sampler_create.sampler_descriptor = sampler_descriptor;
    Args.hsa_ext_sampler_create.sampler = sampler;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_sampler_create_fn(Args.hsa_ext_sampler_create.agent, Args.hsa_ext_sampler_create.sampler_descriptor, Args.hsa_ext_sampler_create.sampler);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_sampler_create_fn(agent, sampler_descriptor, sampler);
  }
}

static hsa_status_t hsa_ext_sampler_destroy_callback(hsa_agent_t agent, hsa_ext_sampler_t sampler) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_sampler_destroy;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_sampler_destroy.agent = agent;
    Args.hsa_ext_sampler_destroy.sampler = sampler;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_sampler_destroy_fn(Args.hsa_ext_sampler_destroy.agent, Args.hsa_ext_sampler_destroy.sampler);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_sampler_destroy_fn(agent, sampler);
  }
}

static hsa_status_t hsa_ext_image_get_capability_with_layout_callback(hsa_agent_t agent, hsa_ext_image_geometry_t geometry, const hsa_ext_image_format_t* image_format, hsa_ext_image_data_layout_t image_data_layout, uint32_t* capability_mask) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_image_get_capability_with_layout;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_image_get_capability_with_layout.agent = agent;
    Args.hsa_ext_image_get_capability_with_layout.geometry = geometry;
    Args.hsa_ext_image_get_capability_with_layout.image_format = image_format;
    Args.hsa_ext_image_get_capability_with_layout.image_data_layout = image_data_layout;
    Args.hsa_ext_image_get_capability_with_layout.capability_mask = capability_mask;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_get_capability_with_layout_fn(Args.hsa_ext_image_get_capability_with_layout.agent, Args.hsa_ext_image_get_capability_with_layout.geometry, Args.hsa_ext_image_get_capability_with_layout.image_format, Args.hsa_ext_image_get_capability_with_layout.image_data_layout, Args.hsa_ext_image_get_capability_with_layout.capability_mask);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_get_capability_with_layout_fn(agent, geometry, image_format, image_data_layout, capability_mask);
  }
}

static hsa_status_t hsa_ext_image_data_get_info_with_layout_callback(hsa_agent_t agent, const hsa_ext_image_descriptor_t* image_descriptor, hsa_access_permission_t access_permission, hsa_ext_image_data_layout_t image_data_layout, size_t image_data_row_pitch, size_t image_data_slice_pitch, hsa_ext_image_data_info_t* image_data_info) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_image_data_get_info_with_layout;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_image_data_get_info_with_layout.agent = agent;
    Args.hsa_ext_image_data_get_info_with_layout.image_descriptor = image_descriptor;
    Args.hsa_ext_image_data_get_info_with_layout.access_permission = access_permission;
    Args.hsa_ext_image_data_get_info_with_layout.image_data_layout = image_data_layout;
    Args.hsa_ext_image_data_get_info_with_layout.image_data_row_pitch = image_data_row_pitch;
    Args.hsa_ext_image_data_get_info_with_layout.image_data_slice_pitch = image_data_slice_pitch;
    Args.hsa_ext_image_data_get_info_with_layout.image_data_info = image_data_info;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_data_get_info_with_layout_fn(Args.hsa_ext_image_data_get_info_with_layout.agent, Args.hsa_ext_image_data_get_info_with_layout.image_descriptor, Args.hsa_ext_image_data_get_info_with_layout.access_permission, Args.hsa_ext_image_data_get_info_with_layout.image_data_layout, Args.hsa_ext_image_data_get_info_with_layout.image_data_row_pitch, Args.hsa_ext_image_data_get_info_with_layout.image_data_slice_pitch, Args.hsa_ext_image_data_get_info_with_layout.image_data_info);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_data_get_info_with_layout_fn(agent, image_descriptor, access_permission, image_data_layout, image_data_row_pitch, image_data_slice_pitch, image_data_info);
  }
}

static hsa_status_t hsa_ext_image_create_with_layout_callback(hsa_agent_t agent, const hsa_ext_image_descriptor_t* image_descriptor, const void* image_data, hsa_access_permission_t access_permission, hsa_ext_image_data_layout_t image_data_layout, size_t image_data_row_pitch, size_t image_data_slice_pitch, hsa_ext_image_t* image) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_image_create_with_layout;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_image_create_with_layout.agent = agent;
    Args.hsa_ext_image_create_with_layout.image_descriptor = image_descriptor;
    Args.hsa_ext_image_create_with_layout.image_data = image_data;
    Args.hsa_ext_image_create_with_layout.access_permission = access_permission;
    Args.hsa_ext_image_create_with_layout.image_data_layout = image_data_layout;
    Args.hsa_ext_image_create_with_layout.image_data_row_pitch = image_data_row_pitch;
    Args.hsa_ext_image_create_with_layout.image_data_slice_pitch = image_data_slice_pitch;
    Args.hsa_ext_image_create_with_layout.image = image;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_create_with_layout_fn(Args.hsa_ext_image_create_with_layout.agent, Args.hsa_ext_image_create_with_layout.image_descriptor, Args.hsa_ext_image_create_with_layout.image_data, Args.hsa_ext_image_create_with_layout.access_permission, Args.hsa_ext_image_create_with_layout.image_data_layout, Args.hsa_ext_image_create_with_layout.image_data_row_pitch, Args.hsa_ext_image_create_with_layout.image_data_slice_pitch, Args.hsa_ext_image_create_with_layout.image);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().image_ext.hsa_ext_image_create_with_layout_fn(agent, image_descriptor, image_data, access_permission, image_data_layout, image_data_row_pitch, image_data_slice_pitch, image);
  }
}

static hsa_status_t hsa_ext_program_create_callback(hsa_machine_model_t machine_model, hsa_profile_t profile, hsa_default_float_rounding_mode_t default_float_rounding_mode, const char* options, hsa_ext_program_t* program) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_program_create;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_program_create.machine_model = machine_model;
    Args.hsa_ext_program_create.profile = profile;
    Args.hsa_ext_program_create.default_float_rounding_mode = default_float_rounding_mode;
    Args.hsa_ext_program_create.options = options;
    Args.hsa_ext_program_create.program = program;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().finalizer_ext.hsa_ext_program_create_fn(Args.hsa_ext_program_create.machine_model, Args.hsa_ext_program_create.profile, Args.hsa_ext_program_create.default_float_rounding_mode, Args.hsa_ext_program_create.options, Args.hsa_ext_program_create.program);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().finalizer_ext.hsa_ext_program_create_fn(machine_model, profile, default_float_rounding_mode, options, program);
  }
}

static hsa_status_t hsa_ext_program_destroy_callback(hsa_ext_program_t program) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_program_destroy;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_program_destroy.program = program;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().finalizer_ext.hsa_ext_program_destroy_fn(Args.hsa_ext_program_destroy.program);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().finalizer_ext.hsa_ext_program_destroy_fn(program);
  }
}

static hsa_status_t hsa_ext_program_add_module_callback(hsa_ext_program_t program, hsa_ext_module_t module) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_program_add_module;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_program_add_module.program = program;
    Args.hsa_ext_program_add_module.module = module;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().finalizer_ext.hsa_ext_program_add_module_fn(Args.hsa_ext_program_add_module.program, Args.hsa_ext_program_add_module.module);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().finalizer_ext.hsa_ext_program_add_module_fn(program, module);
  }
}

static hsa_status_t hsa_ext_program_iterate_modules_callback(hsa_ext_program_t program, hsa_status_t (* callback)(hsa_ext_program_t program, hsa_ext_module_t module, void* data), void* data) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_program_iterate_modules;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_program_iterate_modules.program = program;
    Args.hsa_ext_program_iterate_modules.callback = callback;
    Args.hsa_ext_program_iterate_modules.data = data;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().finalizer_ext.hsa_ext_program_iterate_modules_fn(Args.hsa_ext_program_iterate_modules.program, Args.hsa_ext_program_iterate_modules.callback, Args.hsa_ext_program_iterate_modules.data);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().finalizer_ext.hsa_ext_program_iterate_modules_fn(program, callback, data);
  }
}

static hsa_status_t hsa_ext_program_get_info_callback(hsa_ext_program_t program, hsa_ext_program_info_t attribute, void* value) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_program_get_info;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_program_get_info.program = program;
    Args.hsa_ext_program_get_info.attribute = attribute;
    Args.hsa_ext_program_get_info.value = value;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().finalizer_ext.hsa_ext_program_get_info_fn(Args.hsa_ext_program_get_info.program, Args.hsa_ext_program_get_info.attribute, Args.hsa_ext_program_get_info.value);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().finalizer_ext.hsa_ext_program_get_info_fn(program, attribute, value);
  }
}

static hsa_status_t hsa_ext_program_finalize_callback(hsa_ext_program_t program, hsa_isa_t isa, int32_t call_convention, hsa_ext_control_directives_t control_directives, const char* options, hsa_code_object_type_t code_object_type, hsa_code_object_t* code_object) {
  auto& HsaInterceptor = luthier::hsa::Interceptor::instance();
  auto ApiId = luthier::hsa::HSA_API_EVT_ID_hsa_ext_program_finalize;
  bool IsUserCallbackEnabled = HsaInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HsaInterceptor.isInternalCallbackEnabled(ApiId); 
  bool IsCallbackTempEnabled = HsaInterceptor.isCallbackTempEnabled();
  bool ShouldCallback = (IsUserCallbackEnabled || IsInternalCallbackEnabled) && IsCallbackTempEnabled;
  if (ShouldCallback) {
    hsa_status_t Out{};
    auto& HsaUserCallback = HsaInterceptor.getUserCallback();
    auto& HsaInternalCallback = HsaInterceptor.getInternalCallback();
    luthier::hsa::ApiEvtArgs Args;
    bool SkipFunction{false};
    Args.hsa_ext_program_finalize.program = program;
    Args.hsa_ext_program_finalize.isa = isa;
    Args.hsa_ext_program_finalize.call_convention = call_convention;
    Args.hsa_ext_program_finalize.control_directives = control_directives;
    Args.hsa_ext_program_finalize.options = options;
    Args.hsa_ext_program_finalize.code_object_type = code_object_type;
    Args.hsa_ext_program_finalize.code_object = code_object;
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HsaInterceptor.getSavedHsaTables().finalizer_ext.hsa_ext_program_finalize_fn(Args.hsa_ext_program_finalize.program, Args.hsa_ext_program_finalize.isa, Args.hsa_ext_program_finalize.call_convention, Args.hsa_ext_program_finalize.control_directives, Args.hsa_ext_program_finalize.options, Args.hsa_ext_program_finalize.code_object_type, Args.hsa_ext_program_finalize.code_object);
    if (IsUserCallbackEnabled)
      HsaUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HsaInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HsaInterceptor.getSavedHsaTables().finalizer_ext.hsa_ext_program_finalize_fn(program, isa, call_convention, control_directives, options, code_object_type, code_object);
  }
}


void luthier::hsa::Interceptor::installCoreApiTableWrappers(CoreApiTable *Table) {
	SavedTables.core = *Table;
	Table->hsa_init_fn = hsa_init_callback;
	Table->hsa_shut_down_fn = hsa_shut_down_callback;
	Table->hsa_system_get_info_fn = hsa_system_get_info_callback;
	Table->hsa_system_extension_supported_fn = hsa_system_extension_supported_callback;
	Table->hsa_system_get_extension_table_fn = hsa_system_get_extension_table_callback;
	Table->hsa_iterate_agents_fn = hsa_iterate_agents_callback;
	Table->hsa_agent_get_info_fn = hsa_agent_get_info_callback;
	Table->hsa_queue_create_fn = hsa_queue_create_callback;
	Table->hsa_soft_queue_create_fn = hsa_soft_queue_create_callback;
	Table->hsa_queue_destroy_fn = hsa_queue_destroy_callback;
	Table->hsa_queue_inactivate_fn = hsa_queue_inactivate_callback;
	Table->hsa_queue_load_read_index_scacquire_fn = hsa_queue_load_read_index_scacquire_callback;
	Table->hsa_queue_load_read_index_relaxed_fn = hsa_queue_load_read_index_relaxed_callback;
	Table->hsa_queue_load_write_index_scacquire_fn = hsa_queue_load_write_index_scacquire_callback;
	Table->hsa_queue_load_write_index_relaxed_fn = hsa_queue_load_write_index_relaxed_callback;
	Table->hsa_queue_store_write_index_relaxed_fn = hsa_queue_store_write_index_relaxed_callback;
	Table->hsa_queue_store_write_index_screlease_fn = hsa_queue_store_write_index_screlease_callback;
	Table->hsa_queue_cas_write_index_scacq_screl_fn = hsa_queue_cas_write_index_scacq_screl_callback;
	Table->hsa_queue_cas_write_index_scacquire_fn = hsa_queue_cas_write_index_scacquire_callback;
	Table->hsa_queue_cas_write_index_relaxed_fn = hsa_queue_cas_write_index_relaxed_callback;
	Table->hsa_queue_cas_write_index_screlease_fn = hsa_queue_cas_write_index_screlease_callback;
	Table->hsa_queue_add_write_index_scacq_screl_fn = hsa_queue_add_write_index_scacq_screl_callback;
	Table->hsa_queue_add_write_index_scacquire_fn = hsa_queue_add_write_index_scacquire_callback;
	Table->hsa_queue_add_write_index_relaxed_fn = hsa_queue_add_write_index_relaxed_callback;
	Table->hsa_queue_add_write_index_screlease_fn = hsa_queue_add_write_index_screlease_callback;
	Table->hsa_queue_store_read_index_relaxed_fn = hsa_queue_store_read_index_relaxed_callback;
	Table->hsa_queue_store_read_index_screlease_fn = hsa_queue_store_read_index_screlease_callback;
	Table->hsa_agent_iterate_regions_fn = hsa_agent_iterate_regions_callback;
	Table->hsa_region_get_info_fn = hsa_region_get_info_callback;
	Table->hsa_agent_get_exception_policies_fn = hsa_agent_get_exception_policies_callback;
	Table->hsa_agent_extension_supported_fn = hsa_agent_extension_supported_callback;
	Table->hsa_memory_register_fn = hsa_memory_register_callback;
	Table->hsa_memory_deregister_fn = hsa_memory_deregister_callback;
	Table->hsa_memory_allocate_fn = hsa_memory_allocate_callback;
	Table->hsa_memory_free_fn = hsa_memory_free_callback;
	Table->hsa_memory_copy_fn = hsa_memory_copy_callback;
	Table->hsa_memory_assign_agent_fn = hsa_memory_assign_agent_callback;
	Table->hsa_signal_create_fn = hsa_signal_create_callback;
	Table->hsa_signal_destroy_fn = hsa_signal_destroy_callback;
	Table->hsa_signal_load_relaxed_fn = hsa_signal_load_relaxed_callback;
	Table->hsa_signal_load_scacquire_fn = hsa_signal_load_scacquire_callback;
	Table->hsa_signal_store_relaxed_fn = hsa_signal_store_relaxed_callback;
	Table->hsa_signal_store_screlease_fn = hsa_signal_store_screlease_callback;
	Table->hsa_signal_wait_relaxed_fn = hsa_signal_wait_relaxed_callback;
	Table->hsa_signal_wait_scacquire_fn = hsa_signal_wait_scacquire_callback;
	Table->hsa_signal_and_relaxed_fn = hsa_signal_and_relaxed_callback;
	Table->hsa_signal_and_scacquire_fn = hsa_signal_and_scacquire_callback;
	Table->hsa_signal_and_screlease_fn = hsa_signal_and_screlease_callback;
	Table->hsa_signal_and_scacq_screl_fn = hsa_signal_and_scacq_screl_callback;
	Table->hsa_signal_or_relaxed_fn = hsa_signal_or_relaxed_callback;
	Table->hsa_signal_or_scacquire_fn = hsa_signal_or_scacquire_callback;
	Table->hsa_signal_or_screlease_fn = hsa_signal_or_screlease_callback;
	Table->hsa_signal_or_scacq_screl_fn = hsa_signal_or_scacq_screl_callback;
	Table->hsa_signal_xor_relaxed_fn = hsa_signal_xor_relaxed_callback;
	Table->hsa_signal_xor_scacquire_fn = hsa_signal_xor_scacquire_callback;
	Table->hsa_signal_xor_screlease_fn = hsa_signal_xor_screlease_callback;
	Table->hsa_signal_xor_scacq_screl_fn = hsa_signal_xor_scacq_screl_callback;
	Table->hsa_signal_exchange_relaxed_fn = hsa_signal_exchange_relaxed_callback;
	Table->hsa_signal_exchange_scacquire_fn = hsa_signal_exchange_scacquire_callback;
	Table->hsa_signal_exchange_screlease_fn = hsa_signal_exchange_screlease_callback;
	Table->hsa_signal_exchange_scacq_screl_fn = hsa_signal_exchange_scacq_screl_callback;
	Table->hsa_signal_add_relaxed_fn = hsa_signal_add_relaxed_callback;
	Table->hsa_signal_add_scacquire_fn = hsa_signal_add_scacquire_callback;
	Table->hsa_signal_add_screlease_fn = hsa_signal_add_screlease_callback;
	Table->hsa_signal_add_scacq_screl_fn = hsa_signal_add_scacq_screl_callback;
	Table->hsa_signal_subtract_relaxed_fn = hsa_signal_subtract_relaxed_callback;
	Table->hsa_signal_subtract_scacquire_fn = hsa_signal_subtract_scacquire_callback;
	Table->hsa_signal_subtract_screlease_fn = hsa_signal_subtract_screlease_callback;
	Table->hsa_signal_subtract_scacq_screl_fn = hsa_signal_subtract_scacq_screl_callback;
	Table->hsa_signal_cas_relaxed_fn = hsa_signal_cas_relaxed_callback;
	Table->hsa_signal_cas_scacquire_fn = hsa_signal_cas_scacquire_callback;
	Table->hsa_signal_cas_screlease_fn = hsa_signal_cas_screlease_callback;
	Table->hsa_signal_cas_scacq_screl_fn = hsa_signal_cas_scacq_screl_callback;
	Table->hsa_isa_from_name_fn = hsa_isa_from_name_callback;
	Table->hsa_isa_get_info_fn = hsa_isa_get_info_callback;
	Table->hsa_isa_compatible_fn = hsa_isa_compatible_callback;
	Table->hsa_code_object_serialize_fn = hsa_code_object_serialize_callback;
	Table->hsa_code_object_deserialize_fn = hsa_code_object_deserialize_callback;
	Table->hsa_code_object_destroy_fn = hsa_code_object_destroy_callback;
	Table->hsa_code_object_get_info_fn = hsa_code_object_get_info_callback;
	Table->hsa_code_object_get_symbol_fn = hsa_code_object_get_symbol_callback;
	Table->hsa_code_symbol_get_info_fn = hsa_code_symbol_get_info_callback;
	Table->hsa_code_object_iterate_symbols_fn = hsa_code_object_iterate_symbols_callback;
	Table->hsa_executable_create_fn = hsa_executable_create_callback;
	Table->hsa_executable_destroy_fn = hsa_executable_destroy_callback;
	Table->hsa_executable_load_code_object_fn = hsa_executable_load_code_object_callback;
	Table->hsa_executable_freeze_fn = hsa_executable_freeze_callback;
	Table->hsa_executable_get_info_fn = hsa_executable_get_info_callback;
	Table->hsa_executable_global_variable_define_fn = hsa_executable_global_variable_define_callback;
	Table->hsa_executable_agent_global_variable_define_fn = hsa_executable_agent_global_variable_define_callback;
	Table->hsa_executable_readonly_variable_define_fn = hsa_executable_readonly_variable_define_callback;
	Table->hsa_executable_validate_fn = hsa_executable_validate_callback;
	Table->hsa_executable_get_symbol_fn = hsa_executable_get_symbol_callback;
	Table->hsa_executable_symbol_get_info_fn = hsa_executable_symbol_get_info_callback;
	Table->hsa_executable_iterate_symbols_fn = hsa_executable_iterate_symbols_callback;
	Table->hsa_status_string_fn = hsa_status_string_callback;
	Table->hsa_extension_get_name_fn = hsa_extension_get_name_callback;
	Table->hsa_system_major_extension_supported_fn = hsa_system_major_extension_supported_callback;
	Table->hsa_system_get_major_extension_table_fn = hsa_system_get_major_extension_table_callback;
	Table->hsa_agent_major_extension_supported_fn = hsa_agent_major_extension_supported_callback;
	Table->hsa_cache_get_info_fn = hsa_cache_get_info_callback;
	Table->hsa_agent_iterate_caches_fn = hsa_agent_iterate_caches_callback;
	Table->hsa_signal_silent_store_relaxed_fn = hsa_signal_silent_store_relaxed_callback;
	Table->hsa_signal_silent_store_screlease_fn = hsa_signal_silent_store_screlease_callback;
	Table->hsa_signal_group_create_fn = hsa_signal_group_create_callback;
	Table->hsa_signal_group_destroy_fn = hsa_signal_group_destroy_callback;
	Table->hsa_signal_group_wait_any_scacquire_fn = hsa_signal_group_wait_any_scacquire_callback;
	Table->hsa_signal_group_wait_any_relaxed_fn = hsa_signal_group_wait_any_relaxed_callback;
	Table->hsa_agent_iterate_isas_fn = hsa_agent_iterate_isas_callback;
	Table->hsa_isa_get_info_alt_fn = hsa_isa_get_info_alt_callback;
	Table->hsa_isa_get_exception_policies_fn = hsa_isa_get_exception_policies_callback;
	Table->hsa_isa_get_round_method_fn = hsa_isa_get_round_method_callback;
	Table->hsa_wavefront_get_info_fn = hsa_wavefront_get_info_callback;
	Table->hsa_isa_iterate_wavefronts_fn = hsa_isa_iterate_wavefronts_callback;
	Table->hsa_code_object_get_symbol_from_name_fn = hsa_code_object_get_symbol_from_name_callback;
	Table->hsa_code_object_reader_create_from_file_fn = hsa_code_object_reader_create_from_file_callback;
	Table->hsa_code_object_reader_create_from_memory_fn = hsa_code_object_reader_create_from_memory_callback;
	Table->hsa_code_object_reader_destroy_fn = hsa_code_object_reader_destroy_callback;
	Table->hsa_executable_create_alt_fn = hsa_executable_create_alt_callback;
	Table->hsa_executable_load_program_code_object_fn = hsa_executable_load_program_code_object_callback;
	Table->hsa_executable_load_agent_code_object_fn = hsa_executable_load_agent_code_object_callback;
	Table->hsa_executable_validate_alt_fn = hsa_executable_validate_alt_callback;
	Table->hsa_executable_get_symbol_by_name_fn = hsa_executable_get_symbol_by_name_callback;
	Table->hsa_executable_iterate_agent_symbols_fn = hsa_executable_iterate_agent_symbols_callback;
	Table->hsa_executable_iterate_program_symbols_fn = hsa_executable_iterate_program_symbols_callback;
};

void luthier::hsa::Interceptor::installAmdExtTableWrappers(AmdExtTable *Table) {
	SavedTables.amd_ext = *Table;
	Table->hsa_amd_coherency_get_type_fn = hsa_amd_coherency_get_type_callback;
	Table->hsa_amd_coherency_set_type_fn = hsa_amd_coherency_set_type_callback;
	Table->hsa_amd_profiling_set_profiler_enabled_fn = hsa_amd_profiling_set_profiler_enabled_callback;
	Table->hsa_amd_profiling_async_copy_enable_fn = hsa_amd_profiling_async_copy_enable_callback;
	Table->hsa_amd_profiling_get_dispatch_time_fn = hsa_amd_profiling_get_dispatch_time_callback;
	Table->hsa_amd_profiling_get_async_copy_time_fn = hsa_amd_profiling_get_async_copy_time_callback;
	Table->hsa_amd_profiling_convert_tick_to_system_domain_fn = hsa_amd_profiling_convert_tick_to_system_domain_callback;
	Table->hsa_amd_signal_async_handler_fn = hsa_amd_signal_async_handler_callback;
	Table->hsa_amd_async_function_fn = hsa_amd_async_function_callback;
	Table->hsa_amd_signal_wait_any_fn = hsa_amd_signal_wait_any_callback;
	Table->hsa_amd_queue_cu_set_mask_fn = hsa_amd_queue_cu_set_mask_callback;
	Table->hsa_amd_memory_pool_get_info_fn = hsa_amd_memory_pool_get_info_callback;
	Table->hsa_amd_agent_iterate_memory_pools_fn = hsa_amd_agent_iterate_memory_pools_callback;
	Table->hsa_amd_memory_pool_allocate_fn = hsa_amd_memory_pool_allocate_callback;
	Table->hsa_amd_memory_pool_free_fn = hsa_amd_memory_pool_free_callback;
	Table->hsa_amd_memory_async_copy_fn = hsa_amd_memory_async_copy_callback;
	Table->hsa_amd_memory_async_copy_on_engine_fn = hsa_amd_memory_async_copy_on_engine_callback;
	Table->hsa_amd_memory_copy_engine_status_fn = hsa_amd_memory_copy_engine_status_callback;
	Table->hsa_amd_agent_memory_pool_get_info_fn = hsa_amd_agent_memory_pool_get_info_callback;
	Table->hsa_amd_agents_allow_access_fn = hsa_amd_agents_allow_access_callback;
	Table->hsa_amd_memory_pool_can_migrate_fn = hsa_amd_memory_pool_can_migrate_callback;
	Table->hsa_amd_memory_migrate_fn = hsa_amd_memory_migrate_callback;
	Table->hsa_amd_memory_lock_fn = hsa_amd_memory_lock_callback;
	Table->hsa_amd_memory_unlock_fn = hsa_amd_memory_unlock_callback;
	Table->hsa_amd_memory_fill_fn = hsa_amd_memory_fill_callback;
	Table->hsa_amd_interop_map_buffer_fn = hsa_amd_interop_map_buffer_callback;
	Table->hsa_amd_interop_unmap_buffer_fn = hsa_amd_interop_unmap_buffer_callback;
	Table->hsa_amd_image_create_fn = hsa_amd_image_create_callback;
	Table->hsa_amd_pointer_info_fn = hsa_amd_pointer_info_callback;
	Table->hsa_amd_pointer_info_set_userdata_fn = hsa_amd_pointer_info_set_userdata_callback;
	Table->hsa_amd_ipc_memory_create_fn = hsa_amd_ipc_memory_create_callback;
	Table->hsa_amd_ipc_memory_attach_fn = hsa_amd_ipc_memory_attach_callback;
	Table->hsa_amd_ipc_memory_detach_fn = hsa_amd_ipc_memory_detach_callback;
	Table->hsa_amd_signal_create_fn = hsa_amd_signal_create_callback;
	Table->hsa_amd_ipc_signal_create_fn = hsa_amd_ipc_signal_create_callback;
	Table->hsa_amd_ipc_signal_attach_fn = hsa_amd_ipc_signal_attach_callback;
	Table->hsa_amd_register_system_event_handler_fn = hsa_amd_register_system_event_handler_callback;
	Table->hsa_amd_queue_intercept_create_fn = hsa_amd_queue_intercept_create_callback;
	Table->hsa_amd_queue_intercept_register_fn = hsa_amd_queue_intercept_register_callback;
	Table->hsa_amd_queue_set_priority_fn = hsa_amd_queue_set_priority_callback;
	Table->hsa_amd_memory_async_copy_rect_fn = hsa_amd_memory_async_copy_rect_callback;
	Table->hsa_amd_runtime_queue_create_register_fn = hsa_amd_runtime_queue_create_register_callback;
	Table->hsa_amd_memory_lock_to_pool_fn = hsa_amd_memory_lock_to_pool_callback;
	Table->hsa_amd_register_deallocation_callback_fn = hsa_amd_register_deallocation_callback_callback;
	Table->hsa_amd_deregister_deallocation_callback_fn = hsa_amd_deregister_deallocation_callback_callback;
	Table->hsa_amd_signal_value_pointer_fn = hsa_amd_signal_value_pointer_callback;
	Table->hsa_amd_svm_attributes_set_fn = hsa_amd_svm_attributes_set_callback;
	Table->hsa_amd_svm_attributes_get_fn = hsa_amd_svm_attributes_get_callback;
	Table->hsa_amd_svm_prefetch_async_fn = hsa_amd_svm_prefetch_async_callback;
	Table->hsa_amd_spm_acquire_fn = hsa_amd_spm_acquire_callback;
	Table->hsa_amd_spm_release_fn = hsa_amd_spm_release_callback;
	Table->hsa_amd_spm_set_dest_buffer_fn = hsa_amd_spm_set_dest_buffer_callback;
	Table->hsa_amd_queue_cu_get_mask_fn = hsa_amd_queue_cu_get_mask_callback;
	Table->hsa_amd_portable_export_dmabuf_fn = hsa_amd_portable_export_dmabuf_callback;
	Table->hsa_amd_portable_close_dmabuf_fn = hsa_amd_portable_close_dmabuf_callback;
	Table->hsa_amd_vmem_address_reserve_fn = hsa_amd_vmem_address_reserve_callback;
	Table->hsa_amd_vmem_address_free_fn = hsa_amd_vmem_address_free_callback;
	Table->hsa_amd_vmem_handle_create_fn = hsa_amd_vmem_handle_create_callback;
	Table->hsa_amd_vmem_handle_release_fn = hsa_amd_vmem_handle_release_callback;
	Table->hsa_amd_vmem_map_fn = hsa_amd_vmem_map_callback;
	Table->hsa_amd_vmem_unmap_fn = hsa_amd_vmem_unmap_callback;
	Table->hsa_amd_vmem_set_access_fn = hsa_amd_vmem_set_access_callback;
	Table->hsa_amd_vmem_get_access_fn = hsa_amd_vmem_get_access_callback;
	Table->hsa_amd_vmem_export_shareable_handle_fn = hsa_amd_vmem_export_shareable_handle_callback;
	Table->hsa_amd_vmem_import_shareable_handle_fn = hsa_amd_vmem_import_shareable_handle_callback;
	Table->hsa_amd_vmem_retain_alloc_handle_fn = hsa_amd_vmem_retain_alloc_handle_callback;
	Table->hsa_amd_vmem_get_alloc_properties_from_handle_fn = hsa_amd_vmem_get_alloc_properties_from_handle_callback;
};

void luthier::hsa::Interceptor::installImageExtTableWrappers(ImageExtTable *Table) {
	SavedTables.image_ext = *Table;
	Table->hsa_ext_image_get_capability_fn = hsa_ext_image_get_capability_callback;
	Table->hsa_ext_image_data_get_info_fn = hsa_ext_image_data_get_info_callback;
	Table->hsa_ext_image_create_fn = hsa_ext_image_create_callback;
	Table->hsa_ext_image_import_fn = hsa_ext_image_import_callback;
	Table->hsa_ext_image_export_fn = hsa_ext_image_export_callback;
	Table->hsa_ext_image_copy_fn = hsa_ext_image_copy_callback;
	Table->hsa_ext_image_clear_fn = hsa_ext_image_clear_callback;
	Table->hsa_ext_image_destroy_fn = hsa_ext_image_destroy_callback;
	Table->hsa_ext_sampler_create_fn = hsa_ext_sampler_create_callback;
	Table->hsa_ext_sampler_destroy_fn = hsa_ext_sampler_destroy_callback;
	Table->hsa_ext_image_get_capability_with_layout_fn = hsa_ext_image_get_capability_with_layout_callback;
	Table->hsa_ext_image_data_get_info_with_layout_fn = hsa_ext_image_data_get_info_with_layout_callback;
	Table->hsa_ext_image_create_with_layout_fn = hsa_ext_image_create_with_layout_callback;
};

void luthier::hsa::Interceptor::installFinalizerExtTableWrappers(FinalizerExtTable *Table) {
	SavedTables.finalizer_ext = *Table;
	Table->hsa_ext_program_create_fn = hsa_ext_program_create_callback;
	Table->hsa_ext_program_destroy_fn = hsa_ext_program_destroy_callback;
	Table->hsa_ext_program_add_module_fn = hsa_ext_program_add_module_callback;
	Table->hsa_ext_program_iterate_modules_fn = hsa_ext_program_iterate_modules_callback;
	Table->hsa_ext_program_get_info_fn = hsa_ext_program_get_info_callback;
	Table->hsa_ext_program_finalize_fn = hsa_ext_program_finalize_callback;
};

// NOLINTEND
