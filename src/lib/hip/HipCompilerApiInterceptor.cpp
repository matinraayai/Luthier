// NOLINTBEGIN
/* Generated by hip_intercept_gen.py. DO NOT EDIT! */
#include "hip/HipCompilerApiInterceptor.hpp"
#include "luthier/types.h"
#include "luthier/hip_trace_api.h"

template <>
luthier::hip::HipCompilerApiInterceptor
    *luthier::Singleton<luthier::hip::HipCompilerApiInterceptor>::Instance{nullptr};
    
static hipError_t __hipPopCallConfiguration_wrapper(dim3* gridDim, dim3* blockDim, size_t* sharedMem, hipStream_t* stream) {
  auto& HipInterceptor = luthier::hip::HipCompilerApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_COMPILER_API_EVT_ID___hipPopCallConfiguration;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.__hipPopCallConfiguration.gridDim = gridDim;
    Args.__hipPopCallConfiguration.blockDim = blockDim;
    Args.__hipPopCallConfiguration.sharedMem = sharedMem;
    Args.__hipPopCallConfiguration.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().__hipPopCallConfiguration_fn(Args.__hipPopCallConfiguration.gridDim, Args.__hipPopCallConfiguration.blockDim, Args.__hipPopCallConfiguration.sharedMem, Args.__hipPopCallConfiguration.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().__hipPopCallConfiguration_fn(gridDim, blockDim, sharedMem, stream);
  }
}

static hipError_t __hipPushCallConfiguration_wrapper(dim3 gridDim, dim3 blockDim, size_t sharedMem, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipCompilerApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_COMPILER_API_EVT_ID___hipPushCallConfiguration;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.__hipPushCallConfiguration.gridDim.x = gridDim.x;
    Args.__hipPushCallConfiguration.gridDim.y = gridDim.y;
    Args.__hipPushCallConfiguration.gridDim.z = gridDim.z;                    
    Args.__hipPushCallConfiguration.blockDim.x = blockDim.x;
    Args.__hipPushCallConfiguration.blockDim.y = blockDim.y;
    Args.__hipPushCallConfiguration.blockDim.z = blockDim.z;                    
    Args.__hipPushCallConfiguration.sharedMem = sharedMem;
    Args.__hipPushCallConfiguration.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().__hipPushCallConfiguration_fn(*reinterpret_cast<dim3*>(&Args.__hipPushCallConfiguration.gridDim), *reinterpret_cast<dim3*>(&Args.__hipPushCallConfiguration.blockDim), Args.__hipPushCallConfiguration.sharedMem, Args.__hipPushCallConfiguration.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().__hipPushCallConfiguration_fn(gridDim, blockDim, sharedMem, stream);
  }
}

static void** __hipRegisterFatBinary_wrapper(const void* data) {
  auto& HipInterceptor = luthier::hip::HipCompilerApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_COMPILER_API_EVT_ID___hipRegisterFatBinary;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    void** Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.__hipRegisterFatBinary.data = data;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().__hipRegisterFatBinary_fn(Args.__hipRegisterFatBinary.data);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().__hipRegisterFatBinary_fn(data);
  }
}

static void __hipRegisterFunction_wrapper(void** modules, const void* hostFunction, char* deviceFunction, const char* deviceName, unsigned int threadLimit, uint3* tid, uint3* bid, dim3* blockDim, dim3* gridDim, int* wSize) {
  auto& HipInterceptor = luthier::hip::HipCompilerApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_COMPILER_API_EVT_ID___hipRegisterFunction;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.__hipRegisterFunction.modules = modules;
    Args.__hipRegisterFunction.hostFunction = hostFunction;
    Args.__hipRegisterFunction.deviceFunction = deviceFunction;
    Args.__hipRegisterFunction.deviceName = deviceName;
    Args.__hipRegisterFunction.threadLimit = threadLimit;
    Args.__hipRegisterFunction.tid = tid;
    Args.__hipRegisterFunction.bid = bid;
    Args.__hipRegisterFunction.blockDim = blockDim;
    Args.__hipRegisterFunction.gridDim = gridDim;
    Args.__hipRegisterFunction.wSize = wSize;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
 HipInterceptor.getSavedApiTableContainer().__hipRegisterFunction_fn(Args.__hipRegisterFunction.modules, Args.__hipRegisterFunction.hostFunction, Args.__hipRegisterFunction.deviceFunction, Args.__hipRegisterFunction.deviceName, Args.__hipRegisterFunction.threadLimit, Args.__hipRegisterFunction.tid, Args.__hipRegisterFunction.bid, Args.__hipRegisterFunction.blockDim, Args.__hipRegisterFunction.gridDim, Args.__hipRegisterFunction.wSize);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().__hipRegisterFunction_fn(modules, hostFunction, deviceFunction, deviceName, threadLimit, tid, bid, blockDim, gridDim, wSize);
  }
}

static void __hipRegisterManagedVar_wrapper(void* hipModule, void** pointer, void* init_value, const char* name, size_t size, unsigned align) {
  auto& HipInterceptor = luthier::hip::HipCompilerApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_COMPILER_API_EVT_ID___hipRegisterManagedVar;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.__hipRegisterManagedVar.hipModule = hipModule;
    Args.__hipRegisterManagedVar.pointer = pointer;
    Args.__hipRegisterManagedVar.init_value = init_value;
    Args.__hipRegisterManagedVar.name = name;
    Args.__hipRegisterManagedVar.size = size;
    Args.__hipRegisterManagedVar.align = align;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
 HipInterceptor.getSavedApiTableContainer().__hipRegisterManagedVar_fn(Args.__hipRegisterManagedVar.hipModule, Args.__hipRegisterManagedVar.pointer, Args.__hipRegisterManagedVar.init_value, Args.__hipRegisterManagedVar.name, Args.__hipRegisterManagedVar.size, Args.__hipRegisterManagedVar.align);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().__hipRegisterManagedVar_fn(hipModule, pointer, init_value, name, size, align);
  }
}

static void __hipRegisterSurface_wrapper(void** modules, void* var, char* hostVar, char* deviceVar, int type, int ext) {
  auto& HipInterceptor = luthier::hip::HipCompilerApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_COMPILER_API_EVT_ID___hipRegisterSurface;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.__hipRegisterSurface.modules = modules;
    Args.__hipRegisterSurface.var = var;
    Args.__hipRegisterSurface.hostVar = hostVar;
    Args.__hipRegisterSurface.deviceVar = deviceVar;
    Args.__hipRegisterSurface.type = type;
    Args.__hipRegisterSurface.ext = ext;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
 HipInterceptor.getSavedApiTableContainer().__hipRegisterSurface_fn(Args.__hipRegisterSurface.modules, Args.__hipRegisterSurface.var, Args.__hipRegisterSurface.hostVar, Args.__hipRegisterSurface.deviceVar, Args.__hipRegisterSurface.type, Args.__hipRegisterSurface.ext);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().__hipRegisterSurface_fn(modules, var, hostVar, deviceVar, type, ext);
  }
}

static void __hipRegisterTexture_wrapper(void** modules, void* var, char* hostVar, char* deviceVar, int type, int norm, int ext) {
  auto& HipInterceptor = luthier::hip::HipCompilerApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_COMPILER_API_EVT_ID___hipRegisterTexture;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.__hipRegisterTexture.modules = modules;
    Args.__hipRegisterTexture.var = var;
    Args.__hipRegisterTexture.hostVar = hostVar;
    Args.__hipRegisterTexture.deviceVar = deviceVar;
    Args.__hipRegisterTexture.type = type;
    Args.__hipRegisterTexture.norm = norm;
    Args.__hipRegisterTexture.ext = ext;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
 HipInterceptor.getSavedApiTableContainer().__hipRegisterTexture_fn(Args.__hipRegisterTexture.modules, Args.__hipRegisterTexture.var, Args.__hipRegisterTexture.hostVar, Args.__hipRegisterTexture.deviceVar, Args.__hipRegisterTexture.type, Args.__hipRegisterTexture.norm, Args.__hipRegisterTexture.ext);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().__hipRegisterTexture_fn(modules, var, hostVar, deviceVar, type, norm, ext);
  }
}

static void __hipRegisterVar_wrapper(void** modules, void* var, char* hostVar, char* deviceVar, int ext, size_t size, int constant, int global) {
  auto& HipInterceptor = luthier::hip::HipCompilerApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_COMPILER_API_EVT_ID___hipRegisterVar;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.__hipRegisterVar.modules = modules;
    Args.__hipRegisterVar.var = var;
    Args.__hipRegisterVar.hostVar = hostVar;
    Args.__hipRegisterVar.deviceVar = deviceVar;
    Args.__hipRegisterVar.ext = ext;
    Args.__hipRegisterVar.size = size;
    Args.__hipRegisterVar.constant = constant;
    Args.__hipRegisterVar.global = global;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
 HipInterceptor.getSavedApiTableContainer().__hipRegisterVar_fn(Args.__hipRegisterVar.modules, Args.__hipRegisterVar.var, Args.__hipRegisterVar.hostVar, Args.__hipRegisterVar.deviceVar, Args.__hipRegisterVar.ext, Args.__hipRegisterVar.size, Args.__hipRegisterVar.constant, Args.__hipRegisterVar.global);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().__hipRegisterVar_fn(modules, var, hostVar, deviceVar, ext, size, constant, global);
  }
}

static void __hipUnregisterFatBinary_wrapper(void** modules) {
  auto& HipInterceptor = luthier::hip::HipCompilerApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_COMPILER_API_EVT_ID___hipUnregisterFatBinary;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.__hipUnregisterFatBinary.modules = modules;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
 HipInterceptor.getSavedApiTableContainer().__hipUnregisterFatBinary_fn(Args.__hipUnregisterFatBinary.modules);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().__hipUnregisterFatBinary_fn(modules);
  }
}

static void switch___hipPopCallConfiguration_wrapper(HipCompilerDispatchTable *RuntimeApiTable, 
    const HipCompilerDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->__hipPopCallConfiguration_fn = __hipPopCallConfiguration_wrapper;
  else
    RuntimeApiTable->__hipPopCallConfiguration_fn = SavedApiTable.__hipPopCallConfiguration_fn;
}

static void switch___hipPushCallConfiguration_wrapper(HipCompilerDispatchTable *RuntimeApiTable, 
    const HipCompilerDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->__hipPushCallConfiguration_fn = __hipPushCallConfiguration_wrapper;
  else
    RuntimeApiTable->__hipPushCallConfiguration_fn = SavedApiTable.__hipPushCallConfiguration_fn;
}

static void switch___hipRegisterFatBinary_wrapper(HipCompilerDispatchTable *RuntimeApiTable, 
    const HipCompilerDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->__hipRegisterFatBinary_fn = __hipRegisterFatBinary_wrapper;
  else
    RuntimeApiTable->__hipRegisterFatBinary_fn = SavedApiTable.__hipRegisterFatBinary_fn;
}

static void switch___hipRegisterFunction_wrapper(HipCompilerDispatchTable *RuntimeApiTable, 
    const HipCompilerDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->__hipRegisterFunction_fn = __hipRegisterFunction_wrapper;
  else
    RuntimeApiTable->__hipRegisterFunction_fn = SavedApiTable.__hipRegisterFunction_fn;
}

static void switch___hipRegisterManagedVar_wrapper(HipCompilerDispatchTable *RuntimeApiTable, 
    const HipCompilerDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->__hipRegisterManagedVar_fn = __hipRegisterManagedVar_wrapper;
  else
    RuntimeApiTable->__hipRegisterManagedVar_fn = SavedApiTable.__hipRegisterManagedVar_fn;
}

static void switch___hipRegisterSurface_wrapper(HipCompilerDispatchTable *RuntimeApiTable, 
    const HipCompilerDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->__hipRegisterSurface_fn = __hipRegisterSurface_wrapper;
  else
    RuntimeApiTable->__hipRegisterSurface_fn = SavedApiTable.__hipRegisterSurface_fn;
}

static void switch___hipRegisterTexture_wrapper(HipCompilerDispatchTable *RuntimeApiTable, 
    const HipCompilerDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->__hipRegisterTexture_fn = __hipRegisterTexture_wrapper;
  else
    RuntimeApiTable->__hipRegisterTexture_fn = SavedApiTable.__hipRegisterTexture_fn;
}

static void switch___hipRegisterVar_wrapper(HipCompilerDispatchTable *RuntimeApiTable, 
    const HipCompilerDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->__hipRegisterVar_fn = __hipRegisterVar_wrapper;
  else
    RuntimeApiTable->__hipRegisterVar_fn = SavedApiTable.__hipRegisterVar_fn;
}

static void switch___hipUnregisterFatBinary_wrapper(HipCompilerDispatchTable *RuntimeApiTable, 
    const HipCompilerDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->__hipUnregisterFatBinary_fn = __hipUnregisterFatBinary_wrapper;
  else
    RuntimeApiTable->__hipUnregisterFatBinary_fn = SavedApiTable.__hipUnregisterFatBinary_fn;
}

static bool is___hipPopCallConfiguration_wrapper_installed(HipCompilerDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->__hipPopCallConfiguration_fn == __hipPopCallConfiguration_wrapper;
}

static bool is___hipPushCallConfiguration_wrapper_installed(HipCompilerDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->__hipPushCallConfiguration_fn == __hipPushCallConfiguration_wrapper;
}

static bool is___hipRegisterFatBinary_wrapper_installed(HipCompilerDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->__hipRegisterFatBinary_fn == __hipRegisterFatBinary_wrapper;
}

static bool is___hipRegisterFunction_wrapper_installed(HipCompilerDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->__hipRegisterFunction_fn == __hipRegisterFunction_wrapper;
}

static bool is___hipRegisterManagedVar_wrapper_installed(HipCompilerDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->__hipRegisterManagedVar_fn == __hipRegisterManagedVar_wrapper;
}

static bool is___hipRegisterSurface_wrapper_installed(HipCompilerDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->__hipRegisterSurface_fn == __hipRegisterSurface_wrapper;
}

static bool is___hipRegisterTexture_wrapper_installed(HipCompilerDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->__hipRegisterTexture_fn == __hipRegisterTexture_wrapper;
}

static bool is___hipRegisterVar_wrapper_installed(HipCompilerDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->__hipRegisterVar_fn == __hipRegisterVar_wrapper;
}

static bool is___hipUnregisterFatBinary_wrapper_installed(HipCompilerDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->__hipUnregisterFatBinary_fn == __hipUnregisterFatBinary_wrapper;
}

static constexpr void (*HipCompilerWrapperSwitchFunctionsMap[])(HipCompilerDispatchTable *, const HipCompilerDispatchTable &, bool) {
  switch___hipPopCallConfiguration_wrapper,
  switch___hipPushCallConfiguration_wrapper,
  switch___hipRegisterFatBinary_wrapper,
  switch___hipRegisterFunction_wrapper,
  switch___hipRegisterManagedVar_wrapper,
  switch___hipRegisterSurface_wrapper,
  switch___hipRegisterTexture_wrapper,
  switch___hipRegisterVar_wrapper,
  switch___hipUnregisterFatBinary_wrapper,
};static constexpr bool (*HipCompilerWrapperInstallationCheckFunctionsMap[]) (HipCompilerDispatchTable *) {
  is___hipPopCallConfiguration_wrapper_installed,
  is___hipPushCallConfiguration_wrapper_installed,
  is___hipRegisterFatBinary_wrapper_installed,
  is___hipRegisterFunction_wrapper_installed,
  is___hipRegisterManagedVar_wrapper_installed,
  is___hipRegisterSurface_wrapper_installed,
  is___hipRegisterTexture_wrapper_installed,
  is___hipRegisterVar_wrapper_installed,
  is___hipUnregisterFatBinary_wrapper_installed,
};
llvm::Error luthier::hip::HipCompilerApiInterceptor::enableUserCallback(ApiEvtID Op) {
  LUTHIER_RETURN_ON_ERROR(LUTHIER_ASSERTION(Status != WAITING_FOR_API_TABLE));
  LUTHIER_RETURN_ON_ERROR(
     LUTHIER_ARGUMENT_ERROR_CHECK(
        static_cast<unsigned int>(HIP_COMPILER_API_EVT_ID_FIRST) <= static_cast<unsigned int>(Op))); 
  LUTHIER_RETURN_ON_ERROR(
     LUTHIER_ARGUMENT_ERROR_CHECK(
        static_cast<unsigned int>(HIP_COMPILER_API_EVT_ID_LAST) >= static_cast<unsigned int>(Op)));
  unsigned int OpIdx = static_cast<unsigned int>(Op) - 
                       static_cast<unsigned int>(HIP_COMPILER_API_EVT_ID_FIRST);
  if (Status != FROZEN)
    HipCompilerWrapperSwitchFunctionsMap[OpIdx](RuntimeApiTable, SavedRuntimeApiTable, true);
  else {
    LUTHIER_RETURN_ON_ERROR(LUTHIER_ASSERTION(!HipCompilerWrapperInstallationCheckFunctionsMap[OpIdx](RuntimeApiTable)));
  };
  EnabledUserOps.insert(Op);
  return llvm::Error::success();
}

llvm::Error luthier::hip::HipCompilerApiInterceptor::disableUserCallback(ApiEvtID Op) {
  LUTHIER_RETURN_ON_ERROR(LUTHIER_ASSERTION(Status != WAITING_FOR_API_TABLE));
  LUTHIER_RETURN_ON_ERROR(
     LUTHIER_ARGUMENT_ERROR_CHECK(
        static_cast<unsigned int>(HIP_COMPILER_API_EVT_ID_FIRST) <= static_cast<unsigned int>(Op))); 
  LUTHIER_RETURN_ON_ERROR(
     LUTHIER_ARGUMENT_ERROR_CHECK(
        static_cast<unsigned int>(HIP_COMPILER_API_EVT_ID_LAST) >= static_cast<unsigned int>(Op)));
  EnabledUserOps.erase(Op);
  if (Status != FROZEN && !EnabledInternalOps.contains(Op)) {
    unsigned int OpIdx = static_cast<unsigned int>(Op) - 
                   static_cast<unsigned int>(HIP_COMPILER_API_EVT_ID_FIRST);
    HipCompilerWrapperSwitchFunctionsMap[OpIdx](RuntimeApiTable, SavedRuntimeApiTable, false);
  }
    
  return llvm::Error::success();
}

llvm::Error luthier::hip::HipCompilerApiInterceptor::enableInternalCallback(ApiEvtID Op) {
  LUTHIER_RETURN_ON_ERROR(LUTHIER_ASSERTION(Status != WAITING_FOR_API_TABLE));
  LUTHIER_RETURN_ON_ERROR(
     LUTHIER_ARGUMENT_ERROR_CHECK(
        static_cast<unsigned int>(HIP_COMPILER_API_EVT_ID_FIRST) <= static_cast<unsigned int>(Op))); 
  LUTHIER_RETURN_ON_ERROR(
     LUTHIER_ARGUMENT_ERROR_CHECK(
        static_cast<unsigned int>(HIP_COMPILER_API_EVT_ID_LAST) >= static_cast<unsigned int>(Op)));
  unsigned int OpIdx = static_cast<unsigned int>(Op) - 
                       static_cast<unsigned int>(HIP_COMPILER_API_EVT_ID_FIRST);
  if (Status != FROZEN)
    HipCompilerWrapperSwitchFunctionsMap[OpIdx](RuntimeApiTable, SavedRuntimeApiTable, true);
  else {
    LUTHIER_RETURN_ON_ERROR(LUTHIER_ASSERTION(!HipCompilerWrapperInstallationCheckFunctionsMap[OpIdx](RuntimeApiTable)));
  };
  EnabledInternalOps.insert(Op);
  return llvm::Error::success();
}

llvm::Error luthier::hip::HipCompilerApiInterceptor::disableInternalCallback(ApiEvtID Op) {
  LUTHIER_RETURN_ON_ERROR(LUTHIER_ASSERTION(Status != WAITING_FOR_API_TABLE));
  LUTHIER_RETURN_ON_ERROR(
     LUTHIER_ARGUMENT_ERROR_CHECK(
        static_cast<unsigned int>(HIP_COMPILER_API_EVT_ID_FIRST) <= static_cast<unsigned int>(Op))); 
  LUTHIER_RETURN_ON_ERROR(
     LUTHIER_ARGUMENT_ERROR_CHECK(
        static_cast<unsigned int>(HIP_COMPILER_API_EVT_ID_LAST) >= static_cast<unsigned int>(Op)));
  EnabledInternalOps.erase(Op);
  if (Status != FROZEN && !EnabledInternalOps.contains(Op)) {
    unsigned int OpIdx = static_cast<unsigned int>(Op) - 
                   static_cast<unsigned int>(HIP_COMPILER_API_EVT_ID_FIRST);
    HipCompilerWrapperSwitchFunctionsMap[OpIdx](RuntimeApiTable, SavedRuntimeApiTable, false);
  }
  return llvm::Error::success();
}
// NOLINTEND
