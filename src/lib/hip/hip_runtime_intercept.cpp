// NOLINTBEGIN
/* Generated by hip_intercept_gen.py. DO NOT EDIT! */
#include "hip/HipRuntimeApiInterceptor.hpp"
#include "luthier/types.h"
#include "luthier/hip_trace_api.h"

template <>
luthier::hip::HipRuntimeApiInterceptor
    *luthier::Singleton<luthier::hip::HipRuntimeApiInterceptor>::Instance{nullptr};
    
static const char* hipApiName_wrapper(uint32_t id) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipApiName;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    const char* Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipApiName.id = id;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipApiName_fn(Args.hipApiName.id);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipApiName_fn(id);
  }
}

static hipError_t hipArray3DCreate_wrapper(hipArray_t* array, const HIP_ARRAY3D_DESCRIPTOR* pAllocateArray) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipArray3DCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipArray3DCreate.array = array;
    Args.hipArray3DCreate.pAllocateArray = pAllocateArray;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipArray3DCreate_fn(Args.hipArray3DCreate.array, Args.hipArray3DCreate.pAllocateArray);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipArray3DCreate_fn(array, pAllocateArray);
  }
}

static hipError_t hipArray3DGetDescriptor_wrapper(HIP_ARRAY3D_DESCRIPTOR* pArrayDescriptor, hipArray_t array) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipArray3DGetDescriptor;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipArray3DGetDescriptor.pArrayDescriptor = pArrayDescriptor;
    Args.hipArray3DGetDescriptor.array = array;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipArray3DGetDescriptor_fn(Args.hipArray3DGetDescriptor.pArrayDescriptor, Args.hipArray3DGetDescriptor.array);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipArray3DGetDescriptor_fn(pArrayDescriptor, array);
  }
}

static hipError_t hipArrayCreate_wrapper(hipArray_t* pHandle, const HIP_ARRAY_DESCRIPTOR* pAllocateArray) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipArrayCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipArrayCreate.pHandle = pHandle;
    Args.hipArrayCreate.pAllocateArray = pAllocateArray;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipArrayCreate_fn(Args.hipArrayCreate.pHandle, Args.hipArrayCreate.pAllocateArray);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipArrayCreate_fn(pHandle, pAllocateArray);
  }
}

static hipError_t hipArrayDestroy_wrapper(hipArray_t array) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipArrayDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipArrayDestroy.array = array;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipArrayDestroy_fn(Args.hipArrayDestroy.array);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipArrayDestroy_fn(array);
  }
}

static hipError_t hipArrayGetDescriptor_wrapper(HIP_ARRAY_DESCRIPTOR* pArrayDescriptor, hipArray_t array) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipArrayGetDescriptor;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipArrayGetDescriptor.pArrayDescriptor = pArrayDescriptor;
    Args.hipArrayGetDescriptor.array = array;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipArrayGetDescriptor_fn(Args.hipArrayGetDescriptor.pArrayDescriptor, Args.hipArrayGetDescriptor.array);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipArrayGetDescriptor_fn(pArrayDescriptor, array);
  }
}

static hipError_t hipArrayGetInfo_wrapper(hipChannelFormatDesc* desc, hipExtent* extent, unsigned int* flags, hipArray_t array) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipArrayGetInfo;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipArrayGetInfo.desc = desc;
    Args.hipArrayGetInfo.extent = extent;
    Args.hipArrayGetInfo.flags = flags;
    Args.hipArrayGetInfo.array = array;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipArrayGetInfo_fn(Args.hipArrayGetInfo.desc, Args.hipArrayGetInfo.extent, Args.hipArrayGetInfo.flags, Args.hipArrayGetInfo.array);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipArrayGetInfo_fn(desc, extent, flags, array);
  }
}

static hipError_t hipBindTexture_wrapper(size_t* offset, const textureReference* tex, const void* devPtr, const hipChannelFormatDesc* desc, size_t size) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipBindTexture;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipBindTexture.offset = offset;
    Args.hipBindTexture.tex = tex;
    Args.hipBindTexture.devPtr = devPtr;
    Args.hipBindTexture.desc = desc;
    Args.hipBindTexture.size = size;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipBindTexture_fn(Args.hipBindTexture.offset, Args.hipBindTexture.tex, Args.hipBindTexture.devPtr, Args.hipBindTexture.desc, Args.hipBindTexture.size);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipBindTexture_fn(offset, tex, devPtr, desc, size);
  }
}

static hipError_t hipBindTexture2D_wrapper(size_t* offset, const textureReference* tex, const void* devPtr, const hipChannelFormatDesc* desc, size_t width, size_t height, size_t pitch) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipBindTexture2D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipBindTexture2D.offset = offset;
    Args.hipBindTexture2D.tex = tex;
    Args.hipBindTexture2D.devPtr = devPtr;
    Args.hipBindTexture2D.desc = desc;
    Args.hipBindTexture2D.width = width;
    Args.hipBindTexture2D.height = height;
    Args.hipBindTexture2D.pitch = pitch;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipBindTexture2D_fn(Args.hipBindTexture2D.offset, Args.hipBindTexture2D.tex, Args.hipBindTexture2D.devPtr, Args.hipBindTexture2D.desc, Args.hipBindTexture2D.width, Args.hipBindTexture2D.height, Args.hipBindTexture2D.pitch);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipBindTexture2D_fn(offset, tex, devPtr, desc, width, height, pitch);
  }
}

static hipError_t hipBindTextureToArray_wrapper(const textureReference* tex, hipArray_const_t array, const hipChannelFormatDesc* desc) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipBindTextureToArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipBindTextureToArray.tex = tex;
    Args.hipBindTextureToArray.array = array;
    Args.hipBindTextureToArray.desc = desc;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipBindTextureToArray_fn(Args.hipBindTextureToArray.tex, Args.hipBindTextureToArray.array, Args.hipBindTextureToArray.desc);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipBindTextureToArray_fn(tex, array, desc);
  }
}

static hipError_t hipBindTextureToMipmappedArray_wrapper(const textureReference* tex, hipMipmappedArray_const_t mipmappedArray, const hipChannelFormatDesc* desc) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipBindTextureToMipmappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipBindTextureToMipmappedArray.tex = tex;
    Args.hipBindTextureToMipmappedArray.mipmappedArray = mipmappedArray;
    Args.hipBindTextureToMipmappedArray.desc = desc;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipBindTextureToMipmappedArray_fn(Args.hipBindTextureToMipmappedArray.tex, Args.hipBindTextureToMipmappedArray.mipmappedArray, Args.hipBindTextureToMipmappedArray.desc);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipBindTextureToMipmappedArray_fn(tex, mipmappedArray, desc);
  }
}

static hipError_t hipChooseDevice_wrapper(int* device, const hipDeviceProp_t* prop) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipChooseDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipChooseDevice.device = device;
    Args.hipChooseDevice.prop = prop;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipChooseDevice_fn(Args.hipChooseDevice.device, Args.hipChooseDevice.prop);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipChooseDevice_fn(device, prop);
  }
}

static hipError_t hipChooseDeviceR0000_wrapper(int* device, const hipDeviceProp_tR0000* properties) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipChooseDeviceR0000;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipChooseDeviceR0000.device = device;
    Args.hipChooseDeviceR0000.properties = properties;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipChooseDeviceR0000_fn(Args.hipChooseDeviceR0000.device, Args.hipChooseDeviceR0000.properties);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipChooseDeviceR0000_fn(device, properties);
  }
}

static hipError_t hipConfigureCall_wrapper(dim3 gridDim, dim3 blockDim, size_t sharedMem, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipConfigureCall;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipConfigureCall.gridDim.x = gridDim.x;
    Args.hipConfigureCall.gridDim.y = gridDim.y;
    Args.hipConfigureCall.gridDim.z = gridDim.z;                    
    Args.hipConfigureCall.blockDim.x = blockDim.x;
    Args.hipConfigureCall.blockDim.y = blockDim.y;
    Args.hipConfigureCall.blockDim.z = blockDim.z;                    
    Args.hipConfigureCall.sharedMem = sharedMem;
    Args.hipConfigureCall.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipConfigureCall_fn(*reinterpret_cast<dim3*>(&Args.hipConfigureCall.gridDim), *reinterpret_cast<dim3*>(&Args.hipConfigureCall.blockDim), Args.hipConfigureCall.sharedMem, Args.hipConfigureCall.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipConfigureCall_fn(gridDim, blockDim, sharedMem, stream);
  }
}

static hipError_t hipCreateSurfaceObject_wrapper(hipSurfaceObject_t* pSurfObject, const hipResourceDesc* pResDesc) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCreateSurfaceObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCreateSurfaceObject.pSurfObject = pSurfObject;
    Args.hipCreateSurfaceObject.pResDesc = pResDesc;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCreateSurfaceObject_fn(Args.hipCreateSurfaceObject.pSurfObject, Args.hipCreateSurfaceObject.pResDesc);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCreateSurfaceObject_fn(pSurfObject, pResDesc);
  }
}

static hipError_t hipCreateTextureObject_wrapper(hipTextureObject_t* pTexObject, const hipResourceDesc* pResDesc, const hipTextureDesc* pTexDesc, const struct hipResourceViewDesc* pResViewDesc) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCreateTextureObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCreateTextureObject.pTexObject = pTexObject;
    Args.hipCreateTextureObject.pResDesc = pResDesc;
    Args.hipCreateTextureObject.pTexDesc = pTexDesc;
    Args.hipCreateTextureObject.pResViewDesc = pResViewDesc;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCreateTextureObject_fn(Args.hipCreateTextureObject.pTexObject, Args.hipCreateTextureObject.pResDesc, Args.hipCreateTextureObject.pTexDesc, Args.hipCreateTextureObject.pResViewDesc);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCreateTextureObject_fn(pTexObject, pResDesc, pTexDesc, pResViewDesc);
  }
}

static hipError_t hipCtxCreate_wrapper(hipCtx_t* ctx, unsigned int flags, hipDevice_t device) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCtxCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCtxCreate.ctx = ctx;
    Args.hipCtxCreate.flags = flags;
    Args.hipCtxCreate.device = device;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCtxCreate_fn(Args.hipCtxCreate.ctx, Args.hipCtxCreate.flags, Args.hipCtxCreate.device);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCtxCreate_fn(ctx, flags, device);
  }
}

static hipError_t hipCtxDestroy_wrapper(hipCtx_t ctx) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCtxDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCtxDestroy.ctx = ctx;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCtxDestroy_fn(Args.hipCtxDestroy.ctx);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCtxDestroy_fn(ctx);
  }
}

static hipError_t hipCtxDisablePeerAccess_wrapper(hipCtx_t peerCtx) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCtxDisablePeerAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCtxDisablePeerAccess.peerCtx = peerCtx;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCtxDisablePeerAccess_fn(Args.hipCtxDisablePeerAccess.peerCtx);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCtxDisablePeerAccess_fn(peerCtx);
  }
}

static hipError_t hipCtxEnablePeerAccess_wrapper(hipCtx_t peerCtx, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCtxEnablePeerAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCtxEnablePeerAccess.peerCtx = peerCtx;
    Args.hipCtxEnablePeerAccess.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCtxEnablePeerAccess_fn(Args.hipCtxEnablePeerAccess.peerCtx, Args.hipCtxEnablePeerAccess.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCtxEnablePeerAccess_fn(peerCtx, flags);
  }
}

static hipError_t hipCtxGetApiVersion_wrapper(hipCtx_t ctx, int* apiVersion) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCtxGetApiVersion;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCtxGetApiVersion.ctx = ctx;
    Args.hipCtxGetApiVersion.apiVersion = apiVersion;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCtxGetApiVersion_fn(Args.hipCtxGetApiVersion.ctx, Args.hipCtxGetApiVersion.apiVersion);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCtxGetApiVersion_fn(ctx, apiVersion);
  }
}

static hipError_t hipCtxGetCacheConfig_wrapper(hipFuncCache_t* cacheConfig) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCtxGetCacheConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCtxGetCacheConfig.cacheConfig = cacheConfig;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCtxGetCacheConfig_fn(Args.hipCtxGetCacheConfig.cacheConfig);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCtxGetCacheConfig_fn(cacheConfig);
  }
}

static hipError_t hipCtxGetCurrent_wrapper(hipCtx_t* ctx) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCtxGetCurrent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCtxGetCurrent.ctx = ctx;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCtxGetCurrent_fn(Args.hipCtxGetCurrent.ctx);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCtxGetCurrent_fn(ctx);
  }
}

static hipError_t hipCtxGetDevice_wrapper(hipDevice_t* device) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCtxGetDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCtxGetDevice.device = device;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCtxGetDevice_fn(Args.hipCtxGetDevice.device);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCtxGetDevice_fn(device);
  }
}

static hipError_t hipCtxGetFlags_wrapper(unsigned int* flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCtxGetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCtxGetFlags.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCtxGetFlags_fn(Args.hipCtxGetFlags.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCtxGetFlags_fn(flags);
  }
}

static hipError_t hipCtxGetSharedMemConfig_wrapper(hipSharedMemConfig* pConfig) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCtxGetSharedMemConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCtxGetSharedMemConfig.pConfig = pConfig;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCtxGetSharedMemConfig_fn(Args.hipCtxGetSharedMemConfig.pConfig);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCtxGetSharedMemConfig_fn(pConfig);
  }
}

static hipError_t hipCtxPopCurrent_wrapper(hipCtx_t* ctx) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCtxPopCurrent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCtxPopCurrent.ctx = ctx;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCtxPopCurrent_fn(Args.hipCtxPopCurrent.ctx);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCtxPopCurrent_fn(ctx);
  }
}

static hipError_t hipCtxPushCurrent_wrapper(hipCtx_t ctx) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCtxPushCurrent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCtxPushCurrent.ctx = ctx;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCtxPushCurrent_fn(Args.hipCtxPushCurrent.ctx);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCtxPushCurrent_fn(ctx);
  }
}

static hipError_t hipCtxSetCacheConfig_wrapper(hipFuncCache_t cacheConfig) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCtxSetCacheConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCtxSetCacheConfig.cacheConfig = cacheConfig;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCtxSetCacheConfig_fn(Args.hipCtxSetCacheConfig.cacheConfig);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCtxSetCacheConfig_fn(cacheConfig);
  }
}

static hipError_t hipCtxSetCurrent_wrapper(hipCtx_t ctx) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCtxSetCurrent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCtxSetCurrent.ctx = ctx;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCtxSetCurrent_fn(Args.hipCtxSetCurrent.ctx);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCtxSetCurrent_fn(ctx);
  }
}

static hipError_t hipCtxSetSharedMemConfig_wrapper(hipSharedMemConfig config) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCtxSetSharedMemConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCtxSetSharedMemConfig.config = config;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCtxSetSharedMemConfig_fn(Args.hipCtxSetSharedMemConfig.config);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCtxSetSharedMemConfig_fn(config);
  }
}

static hipError_t hipCtxSynchronize_wrapper() {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCtxSynchronize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCtxSynchronize_fn();
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCtxSynchronize_fn();
  }
}

static hipError_t hipDestroyExternalMemory_wrapper(hipExternalMemory_t extMem) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDestroyExternalMemory;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDestroyExternalMemory.extMem = extMem;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDestroyExternalMemory_fn(Args.hipDestroyExternalMemory.extMem);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDestroyExternalMemory_fn(extMem);
  }
}

static hipError_t hipDestroyExternalSemaphore_wrapper(hipExternalSemaphore_t extSem) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDestroyExternalSemaphore;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDestroyExternalSemaphore.extSem = extSem;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDestroyExternalSemaphore_fn(Args.hipDestroyExternalSemaphore.extSem);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDestroyExternalSemaphore_fn(extSem);
  }
}

static hipError_t hipDestroySurfaceObject_wrapper(hipSurfaceObject_t surfaceObject) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDestroySurfaceObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDestroySurfaceObject.surfaceObject = surfaceObject;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDestroySurfaceObject_fn(Args.hipDestroySurfaceObject.surfaceObject);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDestroySurfaceObject_fn(surfaceObject);
  }
}

static hipError_t hipDestroyTextureObject_wrapper(hipTextureObject_t textureObject) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDestroyTextureObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDestroyTextureObject.textureObject = textureObject;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDestroyTextureObject_fn(Args.hipDestroyTextureObject.textureObject);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDestroyTextureObject_fn(textureObject);
  }
}

static hipError_t hipDeviceCanAccessPeer_wrapper(int* canAccessPeer, int deviceId, int peerDeviceId) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceCanAccessPeer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceCanAccessPeer.canAccessPeer = canAccessPeer;
    Args.hipDeviceCanAccessPeer.deviceId = deviceId;
    Args.hipDeviceCanAccessPeer.peerDeviceId = peerDeviceId;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceCanAccessPeer_fn(Args.hipDeviceCanAccessPeer.canAccessPeer, Args.hipDeviceCanAccessPeer.deviceId, Args.hipDeviceCanAccessPeer.peerDeviceId);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceCanAccessPeer_fn(canAccessPeer, deviceId, peerDeviceId);
  }
}

static hipError_t hipDeviceComputeCapability_wrapper(int* major, int* minor, hipDevice_t device) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceComputeCapability;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceComputeCapability.major = major;
    Args.hipDeviceComputeCapability.minor = minor;
    Args.hipDeviceComputeCapability.device = device;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceComputeCapability_fn(Args.hipDeviceComputeCapability.major, Args.hipDeviceComputeCapability.minor, Args.hipDeviceComputeCapability.device);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceComputeCapability_fn(major, minor, device);
  }
}

static hipError_t hipDeviceDisablePeerAccess_wrapper(int peerDeviceId) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceDisablePeerAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceDisablePeerAccess.peerDeviceId = peerDeviceId;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceDisablePeerAccess_fn(Args.hipDeviceDisablePeerAccess.peerDeviceId);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceDisablePeerAccess_fn(peerDeviceId);
  }
}

static hipError_t hipDeviceEnablePeerAccess_wrapper(int peerDeviceId, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceEnablePeerAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceEnablePeerAccess.peerDeviceId = peerDeviceId;
    Args.hipDeviceEnablePeerAccess.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceEnablePeerAccess_fn(Args.hipDeviceEnablePeerAccess.peerDeviceId, Args.hipDeviceEnablePeerAccess.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceEnablePeerAccess_fn(peerDeviceId, flags);
  }
}

static hipError_t hipDeviceGet_wrapper(hipDevice_t* device, int ordinal) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceGet;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceGet.device = device;
    Args.hipDeviceGet.ordinal = ordinal;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceGet_fn(Args.hipDeviceGet.device, Args.hipDeviceGet.ordinal);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceGet_fn(device, ordinal);
  }
}

static hipError_t hipDeviceGetAttribute_wrapper(int* pi, hipDeviceAttribute_t attr, int deviceId) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceGetAttribute.pi = pi;
    Args.hipDeviceGetAttribute.attr = attr;
    Args.hipDeviceGetAttribute.deviceId = deviceId;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceGetAttribute_fn(Args.hipDeviceGetAttribute.pi, Args.hipDeviceGetAttribute.attr, Args.hipDeviceGetAttribute.deviceId);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceGetAttribute_fn(pi, attr, deviceId);
  }
}

static hipError_t hipDeviceGetByPCIBusId_wrapper(int* device, const char* pciBusId) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceGetByPCIBusId;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceGetByPCIBusId.device = device;
    Args.hipDeviceGetByPCIBusId.pciBusId = pciBusId;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceGetByPCIBusId_fn(Args.hipDeviceGetByPCIBusId.device, Args.hipDeviceGetByPCIBusId.pciBusId);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceGetByPCIBusId_fn(device, pciBusId);
  }
}

static hipError_t hipDeviceGetCacheConfig_wrapper(hipFuncCache_t* cacheConfig) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceGetCacheConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceGetCacheConfig.cacheConfig = cacheConfig;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceGetCacheConfig_fn(Args.hipDeviceGetCacheConfig.cacheConfig);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceGetCacheConfig_fn(cacheConfig);
  }
}

static hipError_t hipDeviceGetDefaultMemPool_wrapper(hipMemPool_t* mem_pool, int device) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceGetDefaultMemPool;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceGetDefaultMemPool.mem_pool = mem_pool;
    Args.hipDeviceGetDefaultMemPool.device = device;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceGetDefaultMemPool_fn(Args.hipDeviceGetDefaultMemPool.mem_pool, Args.hipDeviceGetDefaultMemPool.device);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceGetDefaultMemPool_fn(mem_pool, device);
  }
}

static hipError_t hipDeviceGetGraphMemAttribute_wrapper(int device, hipGraphMemAttributeType attr, void* value) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceGetGraphMemAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceGetGraphMemAttribute.device = device;
    Args.hipDeviceGetGraphMemAttribute.attr = attr;
    Args.hipDeviceGetGraphMemAttribute.value = value;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceGetGraphMemAttribute_fn(Args.hipDeviceGetGraphMemAttribute.device, Args.hipDeviceGetGraphMemAttribute.attr, Args.hipDeviceGetGraphMemAttribute.value);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceGetGraphMemAttribute_fn(device, attr, value);
  }
}

static hipError_t hipDeviceGetLimit_wrapper(size_t* pValue, enum hipLimit_t limit) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceGetLimit;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceGetLimit.pValue = pValue;
    Args.hipDeviceGetLimit.limit = limit;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceGetLimit_fn(Args.hipDeviceGetLimit.pValue, Args.hipDeviceGetLimit.limit);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceGetLimit_fn(pValue, limit);
  }
}

static hipError_t hipDeviceGetMemPool_wrapper(hipMemPool_t* mem_pool, int device) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceGetMemPool;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceGetMemPool.mem_pool = mem_pool;
    Args.hipDeviceGetMemPool.device = device;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceGetMemPool_fn(Args.hipDeviceGetMemPool.mem_pool, Args.hipDeviceGetMemPool.device);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceGetMemPool_fn(mem_pool, device);
  }
}

static hipError_t hipDeviceGetName_wrapper(char* name, int len, hipDevice_t device) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceGetName;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceGetName.name = name;
    Args.hipDeviceGetName.len = len;
    Args.hipDeviceGetName.device = device;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceGetName_fn(Args.hipDeviceGetName.name, Args.hipDeviceGetName.len, Args.hipDeviceGetName.device);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceGetName_fn(name, len, device);
  }
}

static hipError_t hipDeviceGetP2PAttribute_wrapper(int* value, hipDeviceP2PAttr attr, int srcDevice, int dstDevice) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceGetP2PAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceGetP2PAttribute.value = value;
    Args.hipDeviceGetP2PAttribute.attr = attr;
    Args.hipDeviceGetP2PAttribute.srcDevice = srcDevice;
    Args.hipDeviceGetP2PAttribute.dstDevice = dstDevice;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceGetP2PAttribute_fn(Args.hipDeviceGetP2PAttribute.value, Args.hipDeviceGetP2PAttribute.attr, Args.hipDeviceGetP2PAttribute.srcDevice, Args.hipDeviceGetP2PAttribute.dstDevice);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceGetP2PAttribute_fn(value, attr, srcDevice, dstDevice);
  }
}

static hipError_t hipDeviceGetPCIBusId_wrapper(char* pciBusId, int len, int device) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceGetPCIBusId;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceGetPCIBusId.pciBusId = pciBusId;
    Args.hipDeviceGetPCIBusId.len = len;
    Args.hipDeviceGetPCIBusId.device = device;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceGetPCIBusId_fn(Args.hipDeviceGetPCIBusId.pciBusId, Args.hipDeviceGetPCIBusId.len, Args.hipDeviceGetPCIBusId.device);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceGetPCIBusId_fn(pciBusId, len, device);
  }
}

static hipError_t hipDeviceGetSharedMemConfig_wrapper(hipSharedMemConfig* pConfig) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceGetSharedMemConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceGetSharedMemConfig.pConfig = pConfig;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceGetSharedMemConfig_fn(Args.hipDeviceGetSharedMemConfig.pConfig);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceGetSharedMemConfig_fn(pConfig);
  }
}

static hipError_t hipDeviceGetStreamPriorityRange_wrapper(int* leastPriority, int* greatestPriority) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceGetStreamPriorityRange;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceGetStreamPriorityRange.leastPriority = leastPriority;
    Args.hipDeviceGetStreamPriorityRange.greatestPriority = greatestPriority;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceGetStreamPriorityRange_fn(Args.hipDeviceGetStreamPriorityRange.leastPriority, Args.hipDeviceGetStreamPriorityRange.greatestPriority);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceGetStreamPriorityRange_fn(leastPriority, greatestPriority);
  }
}

static hipError_t hipDeviceGetUuid_wrapper(hipUUID* uuid, hipDevice_t device) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceGetUuid;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceGetUuid.uuid = uuid;
    Args.hipDeviceGetUuid.device = device;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceGetUuid_fn(Args.hipDeviceGetUuid.uuid, Args.hipDeviceGetUuid.device);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceGetUuid_fn(uuid, device);
  }
}

static hipError_t hipDeviceGraphMemTrim_wrapper(int device) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceGraphMemTrim;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceGraphMemTrim.device = device;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceGraphMemTrim_fn(Args.hipDeviceGraphMemTrim.device);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceGraphMemTrim_fn(device);
  }
}

static hipError_t hipDevicePrimaryCtxGetState_wrapper(hipDevice_t dev, unsigned int* flags, int* active) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDevicePrimaryCtxGetState;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDevicePrimaryCtxGetState.dev = dev;
    Args.hipDevicePrimaryCtxGetState.flags = flags;
    Args.hipDevicePrimaryCtxGetState.active = active;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDevicePrimaryCtxGetState_fn(Args.hipDevicePrimaryCtxGetState.dev, Args.hipDevicePrimaryCtxGetState.flags, Args.hipDevicePrimaryCtxGetState.active);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDevicePrimaryCtxGetState_fn(dev, flags, active);
  }
}

static hipError_t hipDevicePrimaryCtxRelease_wrapper(hipDevice_t dev) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDevicePrimaryCtxRelease;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDevicePrimaryCtxRelease.dev = dev;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDevicePrimaryCtxRelease_fn(Args.hipDevicePrimaryCtxRelease.dev);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDevicePrimaryCtxRelease_fn(dev);
  }
}

static hipError_t hipDevicePrimaryCtxReset_wrapper(hipDevice_t dev) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDevicePrimaryCtxReset;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDevicePrimaryCtxReset.dev = dev;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDevicePrimaryCtxReset_fn(Args.hipDevicePrimaryCtxReset.dev);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDevicePrimaryCtxReset_fn(dev);
  }
}

static hipError_t hipDevicePrimaryCtxRetain_wrapper(hipCtx_t* pctx, hipDevice_t dev) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDevicePrimaryCtxRetain;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDevicePrimaryCtxRetain.pctx = pctx;
    Args.hipDevicePrimaryCtxRetain.dev = dev;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDevicePrimaryCtxRetain_fn(Args.hipDevicePrimaryCtxRetain.pctx, Args.hipDevicePrimaryCtxRetain.dev);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDevicePrimaryCtxRetain_fn(pctx, dev);
  }
}

static hipError_t hipDevicePrimaryCtxSetFlags_wrapper(hipDevice_t dev, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDevicePrimaryCtxSetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDevicePrimaryCtxSetFlags.dev = dev;
    Args.hipDevicePrimaryCtxSetFlags.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDevicePrimaryCtxSetFlags_fn(Args.hipDevicePrimaryCtxSetFlags.dev, Args.hipDevicePrimaryCtxSetFlags.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDevicePrimaryCtxSetFlags_fn(dev, flags);
  }
}

static hipError_t hipDeviceReset_wrapper() {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceReset;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceReset_fn();
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceReset_fn();
  }
}

static hipError_t hipDeviceSetCacheConfig_wrapper(hipFuncCache_t cacheConfig) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceSetCacheConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceSetCacheConfig.cacheConfig = cacheConfig;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceSetCacheConfig_fn(Args.hipDeviceSetCacheConfig.cacheConfig);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceSetCacheConfig_fn(cacheConfig);
  }
}

static hipError_t hipDeviceSetGraphMemAttribute_wrapper(int device, hipGraphMemAttributeType attr, void* value) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceSetGraphMemAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceSetGraphMemAttribute.device = device;
    Args.hipDeviceSetGraphMemAttribute.attr = attr;
    Args.hipDeviceSetGraphMemAttribute.value = value;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceSetGraphMemAttribute_fn(Args.hipDeviceSetGraphMemAttribute.device, Args.hipDeviceSetGraphMemAttribute.attr, Args.hipDeviceSetGraphMemAttribute.value);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceSetGraphMemAttribute_fn(device, attr, value);
  }
}

static hipError_t hipDeviceSetLimit_wrapper(enum hipLimit_t limit, size_t value) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceSetLimit;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceSetLimit.limit = limit;
    Args.hipDeviceSetLimit.value = value;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceSetLimit_fn(Args.hipDeviceSetLimit.limit, Args.hipDeviceSetLimit.value);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceSetLimit_fn(limit, value);
  }
}

static hipError_t hipDeviceSetMemPool_wrapper(int device, hipMemPool_t mem_pool) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceSetMemPool;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceSetMemPool.device = device;
    Args.hipDeviceSetMemPool.mem_pool = mem_pool;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceSetMemPool_fn(Args.hipDeviceSetMemPool.device, Args.hipDeviceSetMemPool.mem_pool);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceSetMemPool_fn(device, mem_pool);
  }
}

static hipError_t hipDeviceSetSharedMemConfig_wrapper(hipSharedMemConfig config) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceSetSharedMemConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceSetSharedMemConfig.config = config;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceSetSharedMemConfig_fn(Args.hipDeviceSetSharedMemConfig.config);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceSetSharedMemConfig_fn(config);
  }
}

static hipError_t hipDeviceSynchronize_wrapper() {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceSynchronize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceSynchronize_fn();
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceSynchronize_fn();
  }
}

static hipError_t hipDeviceTotalMem_wrapper(size_t* bytes, hipDevice_t device) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDeviceTotalMem;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDeviceTotalMem.bytes = bytes;
    Args.hipDeviceTotalMem.device = device;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDeviceTotalMem_fn(Args.hipDeviceTotalMem.bytes, Args.hipDeviceTotalMem.device);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDeviceTotalMem_fn(bytes, device);
  }
}

static hipError_t hipDriverGetVersion_wrapper(int* driverVersion) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDriverGetVersion;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDriverGetVersion.driverVersion = driverVersion;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDriverGetVersion_fn(Args.hipDriverGetVersion.driverVersion);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDriverGetVersion_fn(driverVersion);
  }
}

static hipError_t hipDrvGetErrorName_wrapper(hipError_t hipError, const char** errorString) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDrvGetErrorName;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDrvGetErrorName.hipError = hipError;
    Args.hipDrvGetErrorName.errorString = errorString;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDrvGetErrorName_fn(Args.hipDrvGetErrorName.hipError, Args.hipDrvGetErrorName.errorString);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDrvGetErrorName_fn(hipError, errorString);
  }
}

static hipError_t hipDrvGetErrorString_wrapper(hipError_t hipError, const char** errorString) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDrvGetErrorString;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDrvGetErrorString.hipError = hipError;
    Args.hipDrvGetErrorString.errorString = errorString;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDrvGetErrorString_fn(Args.hipDrvGetErrorString.hipError, Args.hipDrvGetErrorString.errorString);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDrvGetErrorString_fn(hipError, errorString);
  }
}

static hipError_t hipDrvGraphAddMemcpyNode_wrapper(hipGraphNode_t* phGraphNode, hipGraph_t hGraph, const hipGraphNode_t* dependencies, size_t numDependencies, const HIP_MEMCPY3D* copyParams, hipCtx_t ctx) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDrvGraphAddMemcpyNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDrvGraphAddMemcpyNode.phGraphNode = phGraphNode;
    Args.hipDrvGraphAddMemcpyNode.hGraph = hGraph;
    Args.hipDrvGraphAddMemcpyNode.dependencies = dependencies;
    Args.hipDrvGraphAddMemcpyNode.numDependencies = numDependencies;
    Args.hipDrvGraphAddMemcpyNode.copyParams = copyParams;
    Args.hipDrvGraphAddMemcpyNode.ctx = ctx;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDrvGraphAddMemcpyNode_fn(Args.hipDrvGraphAddMemcpyNode.phGraphNode, Args.hipDrvGraphAddMemcpyNode.hGraph, Args.hipDrvGraphAddMemcpyNode.dependencies, Args.hipDrvGraphAddMemcpyNode.numDependencies, Args.hipDrvGraphAddMemcpyNode.copyParams, Args.hipDrvGraphAddMemcpyNode.ctx);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDrvGraphAddMemcpyNode_fn(phGraphNode, hGraph, dependencies, numDependencies, copyParams, ctx);
  }
}

static hipError_t hipDrvMemcpy2DUnaligned_wrapper(const hip_Memcpy2D* pCopy) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDrvMemcpy2DUnaligned;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDrvMemcpy2DUnaligned.pCopy = pCopy;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDrvMemcpy2DUnaligned_fn(Args.hipDrvMemcpy2DUnaligned.pCopy);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDrvMemcpy2DUnaligned_fn(pCopy);
  }
}

static hipError_t hipDrvMemcpy3D_wrapper(const HIP_MEMCPY3D* pCopy) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDrvMemcpy3D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDrvMemcpy3D.pCopy = pCopy;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDrvMemcpy3D_fn(Args.hipDrvMemcpy3D.pCopy);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDrvMemcpy3D_fn(pCopy);
  }
}

static hipError_t hipDrvMemcpy3DAsync_wrapper(const HIP_MEMCPY3D* pCopy, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDrvMemcpy3DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDrvMemcpy3DAsync.pCopy = pCopy;
    Args.hipDrvMemcpy3DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDrvMemcpy3DAsync_fn(Args.hipDrvMemcpy3DAsync.pCopy, Args.hipDrvMemcpy3DAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDrvMemcpy3DAsync_fn(pCopy, stream);
  }
}

static hipError_t hipDrvPointerGetAttributes_wrapper(unsigned int numAttributes, hipPointer_attribute* attributes, void** data, hipDeviceptr_t ptr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDrvPointerGetAttributes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDrvPointerGetAttributes.numAttributes = numAttributes;
    Args.hipDrvPointerGetAttributes.attributes = attributes;
    Args.hipDrvPointerGetAttributes.data = data;
    Args.hipDrvPointerGetAttributes.ptr = ptr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDrvPointerGetAttributes_fn(Args.hipDrvPointerGetAttributes.numAttributes, Args.hipDrvPointerGetAttributes.attributes, Args.hipDrvPointerGetAttributes.data, Args.hipDrvPointerGetAttributes.ptr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDrvPointerGetAttributes_fn(numAttributes, attributes, data, ptr);
  }
}

static hipError_t hipEventCreate_wrapper(hipEvent_t* event) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipEventCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipEventCreate.event = event;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipEventCreate_fn(Args.hipEventCreate.event);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipEventCreate_fn(event);
  }
}

static hipError_t hipEventCreateWithFlags_wrapper(hipEvent_t* event, unsigned flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipEventCreateWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipEventCreateWithFlags.event = event;
    Args.hipEventCreateWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipEventCreateWithFlags_fn(Args.hipEventCreateWithFlags.event, Args.hipEventCreateWithFlags.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipEventCreateWithFlags_fn(event, flags);
  }
}

static hipError_t hipEventDestroy_wrapper(hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipEventDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipEventDestroy.event = event;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipEventDestroy_fn(Args.hipEventDestroy.event);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipEventDestroy_fn(event);
  }
}

static hipError_t hipEventElapsedTime_wrapper(float* ms, hipEvent_t start, hipEvent_t stop) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipEventElapsedTime;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipEventElapsedTime.ms = ms;
    Args.hipEventElapsedTime.start = start;
    Args.hipEventElapsedTime.stop = stop;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipEventElapsedTime_fn(Args.hipEventElapsedTime.ms, Args.hipEventElapsedTime.start, Args.hipEventElapsedTime.stop);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipEventElapsedTime_fn(ms, start, stop);
  }
}

static hipError_t hipEventQuery_wrapper(hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipEventQuery;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipEventQuery.event = event;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipEventQuery_fn(Args.hipEventQuery.event);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipEventQuery_fn(event);
  }
}

static hipError_t hipEventRecord_wrapper(hipEvent_t event, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipEventRecord;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipEventRecord.event = event;
    Args.hipEventRecord.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipEventRecord_fn(Args.hipEventRecord.event, Args.hipEventRecord.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipEventRecord_fn(event, stream);
  }
}

static hipError_t hipEventSynchronize_wrapper(hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipEventSynchronize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipEventSynchronize.event = event;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipEventSynchronize_fn(Args.hipEventSynchronize.event);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipEventSynchronize_fn(event);
  }
}

static hipError_t hipExtGetLinkTypeAndHopCount_wrapper(int device1, int device2, uint32_t* linktype, uint32_t* hopcount) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipExtGetLinkTypeAndHopCount;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipExtGetLinkTypeAndHopCount.device1 = device1;
    Args.hipExtGetLinkTypeAndHopCount.device2 = device2;
    Args.hipExtGetLinkTypeAndHopCount.linktype = linktype;
    Args.hipExtGetLinkTypeAndHopCount.hopcount = hopcount;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipExtGetLinkTypeAndHopCount_fn(Args.hipExtGetLinkTypeAndHopCount.device1, Args.hipExtGetLinkTypeAndHopCount.device2, Args.hipExtGetLinkTypeAndHopCount.linktype, Args.hipExtGetLinkTypeAndHopCount.hopcount);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipExtGetLinkTypeAndHopCount_fn(device1, device2, linktype, hopcount);
  }
}

static hipError_t hipExtLaunchKernel_wrapper(const void* function_address, dim3 numBlocks, dim3 dimBlocks, void** args, size_t sharedMemBytes, hipStream_t stream, hipEvent_t startEvent, hipEvent_t stopEvent, int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipExtLaunchKernel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipExtLaunchKernel.function_address = function_address;
    Args.hipExtLaunchKernel.numBlocks.x = numBlocks.x;
    Args.hipExtLaunchKernel.numBlocks.y = numBlocks.y;
    Args.hipExtLaunchKernel.numBlocks.z = numBlocks.z;                    
    Args.hipExtLaunchKernel.dimBlocks.x = dimBlocks.x;
    Args.hipExtLaunchKernel.dimBlocks.y = dimBlocks.y;
    Args.hipExtLaunchKernel.dimBlocks.z = dimBlocks.z;                    
    Args.hipExtLaunchKernel.args = args;
    Args.hipExtLaunchKernel.sharedMemBytes = sharedMemBytes;
    Args.hipExtLaunchKernel.stream = stream;
    Args.hipExtLaunchKernel.startEvent = startEvent;
    Args.hipExtLaunchKernel.stopEvent = stopEvent;
    Args.hipExtLaunchKernel.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipExtLaunchKernel_fn(Args.hipExtLaunchKernel.function_address, *reinterpret_cast<dim3*>(&Args.hipExtLaunchKernel.numBlocks), *reinterpret_cast<dim3*>(&Args.hipExtLaunchKernel.dimBlocks), Args.hipExtLaunchKernel.args, Args.hipExtLaunchKernel.sharedMemBytes, Args.hipExtLaunchKernel.stream, Args.hipExtLaunchKernel.startEvent, Args.hipExtLaunchKernel.stopEvent, Args.hipExtLaunchKernel.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipExtLaunchKernel_fn(function_address, numBlocks, dimBlocks, args, sharedMemBytes, stream, startEvent, stopEvent, flags);
  }
}

static hipError_t hipExtLaunchMultiKernelMultiDevice_wrapper(hipLaunchParams* launchParamsList, int numDevices, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipExtLaunchMultiKernelMultiDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipExtLaunchMultiKernelMultiDevice.launchParamsList = launchParamsList;
    Args.hipExtLaunchMultiKernelMultiDevice.numDevices = numDevices;
    Args.hipExtLaunchMultiKernelMultiDevice.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipExtLaunchMultiKernelMultiDevice_fn(Args.hipExtLaunchMultiKernelMultiDevice.launchParamsList, Args.hipExtLaunchMultiKernelMultiDevice.numDevices, Args.hipExtLaunchMultiKernelMultiDevice.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipExtLaunchMultiKernelMultiDevice_fn(launchParamsList, numDevices, flags);
  }
}

static hipError_t hipExtMallocWithFlags_wrapper(void** ptr, size_t sizeBytes, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipExtMallocWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipExtMallocWithFlags.ptr = ptr;
    Args.hipExtMallocWithFlags.sizeBytes = sizeBytes;
    Args.hipExtMallocWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipExtMallocWithFlags_fn(Args.hipExtMallocWithFlags.ptr, Args.hipExtMallocWithFlags.sizeBytes, Args.hipExtMallocWithFlags.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipExtMallocWithFlags_fn(ptr, sizeBytes, flags);
  }
}

static hipError_t hipExtStreamCreateWithCUMask_wrapper(hipStream_t* stream, uint32_t cuMaskSize, const uint32_t* cuMask) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipExtStreamCreateWithCUMask;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipExtStreamCreateWithCUMask.stream = stream;
    Args.hipExtStreamCreateWithCUMask.cuMaskSize = cuMaskSize;
    Args.hipExtStreamCreateWithCUMask.cuMask = cuMask;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipExtStreamCreateWithCUMask_fn(Args.hipExtStreamCreateWithCUMask.stream, Args.hipExtStreamCreateWithCUMask.cuMaskSize, Args.hipExtStreamCreateWithCUMask.cuMask);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipExtStreamCreateWithCUMask_fn(stream, cuMaskSize, cuMask);
  }
}

static hipError_t hipExtStreamGetCUMask_wrapper(hipStream_t stream, uint32_t cuMaskSize, uint32_t* cuMask) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipExtStreamGetCUMask;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipExtStreamGetCUMask.stream = stream;
    Args.hipExtStreamGetCUMask.cuMaskSize = cuMaskSize;
    Args.hipExtStreamGetCUMask.cuMask = cuMask;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipExtStreamGetCUMask_fn(Args.hipExtStreamGetCUMask.stream, Args.hipExtStreamGetCUMask.cuMaskSize, Args.hipExtStreamGetCUMask.cuMask);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipExtStreamGetCUMask_fn(stream, cuMaskSize, cuMask);
  }
}

static hipError_t hipExternalMemoryGetMappedBuffer_wrapper(void** devPtr, hipExternalMemory_t extMem, const hipExternalMemoryBufferDesc* bufferDesc) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipExternalMemoryGetMappedBuffer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipExternalMemoryGetMappedBuffer.devPtr = devPtr;
    Args.hipExternalMemoryGetMappedBuffer.extMem = extMem;
    Args.hipExternalMemoryGetMappedBuffer.bufferDesc = bufferDesc;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipExternalMemoryGetMappedBuffer_fn(Args.hipExternalMemoryGetMappedBuffer.devPtr, Args.hipExternalMemoryGetMappedBuffer.extMem, Args.hipExternalMemoryGetMappedBuffer.bufferDesc);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipExternalMemoryGetMappedBuffer_fn(devPtr, extMem, bufferDesc);
  }
}

static hipError_t hipFree_wrapper(void* ptr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipFree;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipFree.ptr = ptr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipFree_fn(Args.hipFree.ptr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipFree_fn(ptr);
  }
}

static hipError_t hipFreeArray_wrapper(hipArray_t array) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipFreeArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipFreeArray.array = array;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipFreeArray_fn(Args.hipFreeArray.array);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipFreeArray_fn(array);
  }
}

static hipError_t hipFreeAsync_wrapper(void* dev_ptr, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipFreeAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipFreeAsync.dev_ptr = dev_ptr;
    Args.hipFreeAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipFreeAsync_fn(Args.hipFreeAsync.dev_ptr, Args.hipFreeAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipFreeAsync_fn(dev_ptr, stream);
  }
}

static hipError_t hipFreeHost_wrapper(void* ptr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipFreeHost;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipFreeHost.ptr = ptr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipFreeHost_fn(Args.hipFreeHost.ptr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipFreeHost_fn(ptr);
  }
}

static hipError_t hipFreeMipmappedArray_wrapper(hipMipmappedArray_t mipmappedArray) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipFreeMipmappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipFreeMipmappedArray.mipmappedArray = mipmappedArray;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipFreeMipmappedArray_fn(Args.hipFreeMipmappedArray.mipmappedArray);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipFreeMipmappedArray_fn(mipmappedArray);
  }
}

static hipError_t hipFuncGetAttribute_wrapper(int* value, hipFunction_attribute attrib, hipFunction_t hfunc) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipFuncGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipFuncGetAttribute.value = value;
    Args.hipFuncGetAttribute.attrib = attrib;
    Args.hipFuncGetAttribute.hfunc = hfunc;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipFuncGetAttribute_fn(Args.hipFuncGetAttribute.value, Args.hipFuncGetAttribute.attrib, Args.hipFuncGetAttribute.hfunc);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipFuncGetAttribute_fn(value, attrib, hfunc);
  }
}

static hipError_t hipFuncGetAttributes_wrapper(struct hipFuncAttributes* attr, const void* func) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipFuncGetAttributes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipFuncGetAttributes.attr = attr;
    Args.hipFuncGetAttributes.func = func;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipFuncGetAttributes_fn(Args.hipFuncGetAttributes.attr, Args.hipFuncGetAttributes.func);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipFuncGetAttributes_fn(attr, func);
  }
}

static hipError_t hipFuncSetAttribute_wrapper(const void* func, hipFuncAttribute attr, int value) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipFuncSetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipFuncSetAttribute.func = func;
    Args.hipFuncSetAttribute.attr = attr;
    Args.hipFuncSetAttribute.value = value;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipFuncSetAttribute_fn(Args.hipFuncSetAttribute.func, Args.hipFuncSetAttribute.attr, Args.hipFuncSetAttribute.value);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipFuncSetAttribute_fn(func, attr, value);
  }
}

static hipError_t hipFuncSetCacheConfig_wrapper(const void* func, hipFuncCache_t config) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipFuncSetCacheConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipFuncSetCacheConfig.func = func;
    Args.hipFuncSetCacheConfig.config = config;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipFuncSetCacheConfig_fn(Args.hipFuncSetCacheConfig.func, Args.hipFuncSetCacheConfig.config);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipFuncSetCacheConfig_fn(func, config);
  }
}

static hipError_t hipFuncSetSharedMemConfig_wrapper(const void* func, hipSharedMemConfig config) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipFuncSetSharedMemConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipFuncSetSharedMemConfig.func = func;
    Args.hipFuncSetSharedMemConfig.config = config;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipFuncSetSharedMemConfig_fn(Args.hipFuncSetSharedMemConfig.func, Args.hipFuncSetSharedMemConfig.config);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipFuncSetSharedMemConfig_fn(func, config);
  }
}

static hipError_t hipGLGetDevices_wrapper(unsigned int* pHipDeviceCount, int* pHipDevices, unsigned int hipDeviceCount, hipGLDeviceList deviceList) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGLGetDevices;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGLGetDevices.pHipDeviceCount = pHipDeviceCount;
    Args.hipGLGetDevices.pHipDevices = pHipDevices;
    Args.hipGLGetDevices.hipDeviceCount = hipDeviceCount;
    Args.hipGLGetDevices.deviceList = deviceList;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGLGetDevices_fn(Args.hipGLGetDevices.pHipDeviceCount, Args.hipGLGetDevices.pHipDevices, Args.hipGLGetDevices.hipDeviceCount, Args.hipGLGetDevices.deviceList);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGLGetDevices_fn(pHipDeviceCount, pHipDevices, hipDeviceCount, deviceList);
  }
}

static hipError_t hipGetChannelDesc_wrapper(hipChannelFormatDesc* desc, hipArray_const_t array) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetChannelDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetChannelDesc.desc = desc;
    Args.hipGetChannelDesc.array = array;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetChannelDesc_fn(Args.hipGetChannelDesc.desc, Args.hipGetChannelDesc.array);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetChannelDesc_fn(desc, array);
  }
}

static hipError_t hipGetDevice_wrapper(int* deviceId) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetDevice.deviceId = deviceId;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetDevice_fn(Args.hipGetDevice.deviceId);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetDevice_fn(deviceId);
  }
}

static hipError_t hipGetDeviceCount_wrapper(int* count) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetDeviceCount;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetDeviceCount.count = count;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetDeviceCount_fn(Args.hipGetDeviceCount.count);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetDeviceCount_fn(count);
  }
}

static hipError_t hipGetDeviceFlags_wrapper(unsigned int* flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetDeviceFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetDeviceFlags.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetDeviceFlags_fn(Args.hipGetDeviceFlags.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetDeviceFlags_fn(flags);
  }
}

static hipError_t hipGetDevicePropertiesR0600_wrapper(hipDeviceProp_tR0600* prop, int device) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetDevicePropertiesR0600;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetDevicePropertiesR0600.prop = prop;
    Args.hipGetDevicePropertiesR0600.device = device;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetDevicePropertiesR0600_fn(Args.hipGetDevicePropertiesR0600.prop, Args.hipGetDevicePropertiesR0600.device);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetDevicePropertiesR0600_fn(prop, device);
  }
}

static hipError_t hipGetDevicePropertiesR0000_wrapper(hipDeviceProp_tR0000* prop, int device) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetDevicePropertiesR0000;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetDevicePropertiesR0000.prop = prop;
    Args.hipGetDevicePropertiesR0000.device = device;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetDevicePropertiesR0000_fn(Args.hipGetDevicePropertiesR0000.prop, Args.hipGetDevicePropertiesR0000.device);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetDevicePropertiesR0000_fn(prop, device);
  }
}

static const char* hipGetErrorName_wrapper(hipError_t hip_error) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetErrorName;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    const char* Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetErrorName.hip_error = hip_error;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetErrorName_fn(Args.hipGetErrorName.hip_error);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetErrorName_fn(hip_error);
  }
}

static const char* hipGetErrorString_wrapper(hipError_t hipError) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetErrorString;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    const char* Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetErrorString.hipError = hipError;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetErrorString_fn(Args.hipGetErrorString.hipError);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetErrorString_fn(hipError);
  }
}

static hipError_t hipGetLastError_wrapper() {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetLastError;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetLastError_fn();
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetLastError_fn();
  }
}

static hipError_t hipGetMipmappedArrayLevel_wrapper(hipArray_t* levelArray, hipMipmappedArray_const_t mipmappedArray, unsigned int level) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetMipmappedArrayLevel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetMipmappedArrayLevel.levelArray = levelArray;
    Args.hipGetMipmappedArrayLevel.mipmappedArray = mipmappedArray;
    Args.hipGetMipmappedArrayLevel.level = level;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetMipmappedArrayLevel_fn(Args.hipGetMipmappedArrayLevel.levelArray, Args.hipGetMipmappedArrayLevel.mipmappedArray, Args.hipGetMipmappedArrayLevel.level);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetMipmappedArrayLevel_fn(levelArray, mipmappedArray, level);
  }
}

static hipError_t hipGetSymbolAddress_wrapper(void** devPtr, const void* symbol) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetSymbolAddress;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetSymbolAddress.devPtr = devPtr;
    Args.hipGetSymbolAddress.symbol = symbol;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetSymbolAddress_fn(Args.hipGetSymbolAddress.devPtr, Args.hipGetSymbolAddress.symbol);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetSymbolAddress_fn(devPtr, symbol);
  }
}

static hipError_t hipGetSymbolSize_wrapper(size_t* size, const void* symbol) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetSymbolSize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetSymbolSize.size = size;
    Args.hipGetSymbolSize.symbol = symbol;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetSymbolSize_fn(Args.hipGetSymbolSize.size, Args.hipGetSymbolSize.symbol);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetSymbolSize_fn(size, symbol);
  }
}

static hipError_t hipGetTextureAlignmentOffset_wrapper(size_t* offset, const textureReference* texref) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetTextureAlignmentOffset;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetTextureAlignmentOffset.offset = offset;
    Args.hipGetTextureAlignmentOffset.texref = texref;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetTextureAlignmentOffset_fn(Args.hipGetTextureAlignmentOffset.offset, Args.hipGetTextureAlignmentOffset.texref);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetTextureAlignmentOffset_fn(offset, texref);
  }
}

static hipError_t hipGetTextureObjectResourceDesc_wrapper(hipResourceDesc* pResDesc, hipTextureObject_t textureObject) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetTextureObjectResourceDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetTextureObjectResourceDesc.pResDesc = pResDesc;
    Args.hipGetTextureObjectResourceDesc.textureObject = textureObject;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetTextureObjectResourceDesc_fn(Args.hipGetTextureObjectResourceDesc.pResDesc, Args.hipGetTextureObjectResourceDesc.textureObject);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetTextureObjectResourceDesc_fn(pResDesc, textureObject);
  }
}

static hipError_t hipGetTextureObjectResourceViewDesc_wrapper(struct hipResourceViewDesc* pResViewDesc, hipTextureObject_t textureObject) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetTextureObjectResourceViewDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetTextureObjectResourceViewDesc.pResViewDesc = pResViewDesc;
    Args.hipGetTextureObjectResourceViewDesc.textureObject = textureObject;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetTextureObjectResourceViewDesc_fn(Args.hipGetTextureObjectResourceViewDesc.pResViewDesc, Args.hipGetTextureObjectResourceViewDesc.textureObject);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetTextureObjectResourceViewDesc_fn(pResViewDesc, textureObject);
  }
}

static hipError_t hipGetTextureObjectTextureDesc_wrapper(hipTextureDesc* pTexDesc, hipTextureObject_t textureObject) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetTextureObjectTextureDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetTextureObjectTextureDesc.pTexDesc = pTexDesc;
    Args.hipGetTextureObjectTextureDesc.textureObject = textureObject;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetTextureObjectTextureDesc_fn(Args.hipGetTextureObjectTextureDesc.pTexDesc, Args.hipGetTextureObjectTextureDesc.textureObject);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetTextureObjectTextureDesc_fn(pTexDesc, textureObject);
  }
}

static hipError_t hipGetTextureReference_wrapper(const textureReference** texref, const void* symbol) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetTextureReference;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetTextureReference.texref = texref;
    Args.hipGetTextureReference.symbol = symbol;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetTextureReference_fn(Args.hipGetTextureReference.texref, Args.hipGetTextureReference.symbol);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetTextureReference_fn(texref, symbol);
  }
}

static hipError_t hipGraphAddChildGraphNode_wrapper(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, hipGraph_t childGraph) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphAddChildGraphNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphAddChildGraphNode.pGraphNode = pGraphNode;
    Args.hipGraphAddChildGraphNode.graph = graph;
    Args.hipGraphAddChildGraphNode.pDependencies = pDependencies;
    Args.hipGraphAddChildGraphNode.numDependencies = numDependencies;
    Args.hipGraphAddChildGraphNode.childGraph = childGraph;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphAddChildGraphNode_fn(Args.hipGraphAddChildGraphNode.pGraphNode, Args.hipGraphAddChildGraphNode.graph, Args.hipGraphAddChildGraphNode.pDependencies, Args.hipGraphAddChildGraphNode.numDependencies, Args.hipGraphAddChildGraphNode.childGraph);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphAddChildGraphNode_fn(pGraphNode, graph, pDependencies, numDependencies, childGraph);
  }
}

static hipError_t hipGraphAddDependencies_wrapper(hipGraph_t graph, const hipGraphNode_t* from, const hipGraphNode_t* to, size_t numDependencies) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphAddDependencies;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphAddDependencies.graph = graph;
    Args.hipGraphAddDependencies.from = from;
    Args.hipGraphAddDependencies.to = to;
    Args.hipGraphAddDependencies.numDependencies = numDependencies;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphAddDependencies_fn(Args.hipGraphAddDependencies.graph, Args.hipGraphAddDependencies.from, Args.hipGraphAddDependencies.to, Args.hipGraphAddDependencies.numDependencies);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphAddDependencies_fn(graph, from, to, numDependencies);
  }
}

static hipError_t hipGraphAddEmptyNode_wrapper(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphAddEmptyNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphAddEmptyNode.pGraphNode = pGraphNode;
    Args.hipGraphAddEmptyNode.graph = graph;
    Args.hipGraphAddEmptyNode.pDependencies = pDependencies;
    Args.hipGraphAddEmptyNode.numDependencies = numDependencies;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphAddEmptyNode_fn(Args.hipGraphAddEmptyNode.pGraphNode, Args.hipGraphAddEmptyNode.graph, Args.hipGraphAddEmptyNode.pDependencies, Args.hipGraphAddEmptyNode.numDependencies);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphAddEmptyNode_fn(pGraphNode, graph, pDependencies, numDependencies);
  }
}

static hipError_t hipGraphAddEventRecordNode_wrapper(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphAddEventRecordNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphAddEventRecordNode.pGraphNode = pGraphNode;
    Args.hipGraphAddEventRecordNode.graph = graph;
    Args.hipGraphAddEventRecordNode.pDependencies = pDependencies;
    Args.hipGraphAddEventRecordNode.numDependencies = numDependencies;
    Args.hipGraphAddEventRecordNode.event = event;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphAddEventRecordNode_fn(Args.hipGraphAddEventRecordNode.pGraphNode, Args.hipGraphAddEventRecordNode.graph, Args.hipGraphAddEventRecordNode.pDependencies, Args.hipGraphAddEventRecordNode.numDependencies, Args.hipGraphAddEventRecordNode.event);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphAddEventRecordNode_fn(pGraphNode, graph, pDependencies, numDependencies, event);
  }
}

static hipError_t hipGraphAddEventWaitNode_wrapper(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphAddEventWaitNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphAddEventWaitNode.pGraphNode = pGraphNode;
    Args.hipGraphAddEventWaitNode.graph = graph;
    Args.hipGraphAddEventWaitNode.pDependencies = pDependencies;
    Args.hipGraphAddEventWaitNode.numDependencies = numDependencies;
    Args.hipGraphAddEventWaitNode.event = event;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphAddEventWaitNode_fn(Args.hipGraphAddEventWaitNode.pGraphNode, Args.hipGraphAddEventWaitNode.graph, Args.hipGraphAddEventWaitNode.pDependencies, Args.hipGraphAddEventWaitNode.numDependencies, Args.hipGraphAddEventWaitNode.event);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphAddEventWaitNode_fn(pGraphNode, graph, pDependencies, numDependencies, event);
  }
}

static hipError_t hipGraphAddHostNode_wrapper(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const hipHostNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphAddHostNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphAddHostNode.pGraphNode = pGraphNode;
    Args.hipGraphAddHostNode.graph = graph;
    Args.hipGraphAddHostNode.pDependencies = pDependencies;
    Args.hipGraphAddHostNode.numDependencies = numDependencies;
    Args.hipGraphAddHostNode.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphAddHostNode_fn(Args.hipGraphAddHostNode.pGraphNode, Args.hipGraphAddHostNode.graph, Args.hipGraphAddHostNode.pDependencies, Args.hipGraphAddHostNode.numDependencies, Args.hipGraphAddHostNode.pNodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphAddHostNode_fn(pGraphNode, graph, pDependencies, numDependencies, pNodeParams);
  }
}

static hipError_t hipGraphAddKernelNode_wrapper(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const hipKernelNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphAddKernelNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphAddKernelNode.pGraphNode = pGraphNode;
    Args.hipGraphAddKernelNode.graph = graph;
    Args.hipGraphAddKernelNode.pDependencies = pDependencies;
    Args.hipGraphAddKernelNode.numDependencies = numDependencies;
    Args.hipGraphAddKernelNode.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphAddKernelNode_fn(Args.hipGraphAddKernelNode.pGraphNode, Args.hipGraphAddKernelNode.graph, Args.hipGraphAddKernelNode.pDependencies, Args.hipGraphAddKernelNode.numDependencies, Args.hipGraphAddKernelNode.pNodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphAddKernelNode_fn(pGraphNode, graph, pDependencies, numDependencies, pNodeParams);
  }
}

static hipError_t hipGraphAddMemAllocNode_wrapper(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, hipMemAllocNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphAddMemAllocNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphAddMemAllocNode.pGraphNode = pGraphNode;
    Args.hipGraphAddMemAllocNode.graph = graph;
    Args.hipGraphAddMemAllocNode.pDependencies = pDependencies;
    Args.hipGraphAddMemAllocNode.numDependencies = numDependencies;
    Args.hipGraphAddMemAllocNode.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphAddMemAllocNode_fn(Args.hipGraphAddMemAllocNode.pGraphNode, Args.hipGraphAddMemAllocNode.graph, Args.hipGraphAddMemAllocNode.pDependencies, Args.hipGraphAddMemAllocNode.numDependencies, Args.hipGraphAddMemAllocNode.pNodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphAddMemAllocNode_fn(pGraphNode, graph, pDependencies, numDependencies, pNodeParams);
  }
}

static hipError_t hipGraphAddMemFreeNode_wrapper(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, void* dev_ptr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphAddMemFreeNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphAddMemFreeNode.pGraphNode = pGraphNode;
    Args.hipGraphAddMemFreeNode.graph = graph;
    Args.hipGraphAddMemFreeNode.pDependencies = pDependencies;
    Args.hipGraphAddMemFreeNode.numDependencies = numDependencies;
    Args.hipGraphAddMemFreeNode.dev_ptr = dev_ptr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphAddMemFreeNode_fn(Args.hipGraphAddMemFreeNode.pGraphNode, Args.hipGraphAddMemFreeNode.graph, Args.hipGraphAddMemFreeNode.pDependencies, Args.hipGraphAddMemFreeNode.numDependencies, Args.hipGraphAddMemFreeNode.dev_ptr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphAddMemFreeNode_fn(pGraphNode, graph, pDependencies, numDependencies, dev_ptr);
  }
}

static hipError_t hipGraphAddMemcpyNode_wrapper(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const hipMemcpy3DParms* pCopyParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphAddMemcpyNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphAddMemcpyNode.pGraphNode = pGraphNode;
    Args.hipGraphAddMemcpyNode.graph = graph;
    Args.hipGraphAddMemcpyNode.pDependencies = pDependencies;
    Args.hipGraphAddMemcpyNode.numDependencies = numDependencies;
    Args.hipGraphAddMemcpyNode.pCopyParams = pCopyParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphAddMemcpyNode_fn(Args.hipGraphAddMemcpyNode.pGraphNode, Args.hipGraphAddMemcpyNode.graph, Args.hipGraphAddMemcpyNode.pDependencies, Args.hipGraphAddMemcpyNode.numDependencies, Args.hipGraphAddMemcpyNode.pCopyParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphAddMemcpyNode_fn(pGraphNode, graph, pDependencies, numDependencies, pCopyParams);
  }
}

static hipError_t hipGraphAddMemcpyNode1D_wrapper(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, void* dst, const void* src, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphAddMemcpyNode1D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphAddMemcpyNode1D.pGraphNode = pGraphNode;
    Args.hipGraphAddMemcpyNode1D.graph = graph;
    Args.hipGraphAddMemcpyNode1D.pDependencies = pDependencies;
    Args.hipGraphAddMemcpyNode1D.numDependencies = numDependencies;
    Args.hipGraphAddMemcpyNode1D.dst = dst;
    Args.hipGraphAddMemcpyNode1D.src = src;
    Args.hipGraphAddMemcpyNode1D.count = count;
    Args.hipGraphAddMemcpyNode1D.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphAddMemcpyNode1D_fn(Args.hipGraphAddMemcpyNode1D.pGraphNode, Args.hipGraphAddMemcpyNode1D.graph, Args.hipGraphAddMemcpyNode1D.pDependencies, Args.hipGraphAddMemcpyNode1D.numDependencies, Args.hipGraphAddMemcpyNode1D.dst, Args.hipGraphAddMemcpyNode1D.src, Args.hipGraphAddMemcpyNode1D.count, Args.hipGraphAddMemcpyNode1D.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphAddMemcpyNode1D_fn(pGraphNode, graph, pDependencies, numDependencies, dst, src, count, kind);
  }
}

static hipError_t hipGraphAddMemcpyNodeFromSymbol_wrapper(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, void* dst, const void* symbol, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphAddMemcpyNodeFromSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphAddMemcpyNodeFromSymbol.pGraphNode = pGraphNode;
    Args.hipGraphAddMemcpyNodeFromSymbol.graph = graph;
    Args.hipGraphAddMemcpyNodeFromSymbol.pDependencies = pDependencies;
    Args.hipGraphAddMemcpyNodeFromSymbol.numDependencies = numDependencies;
    Args.hipGraphAddMemcpyNodeFromSymbol.dst = dst;
    Args.hipGraphAddMemcpyNodeFromSymbol.symbol = symbol;
    Args.hipGraphAddMemcpyNodeFromSymbol.count = count;
    Args.hipGraphAddMemcpyNodeFromSymbol.offset = offset;
    Args.hipGraphAddMemcpyNodeFromSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphAddMemcpyNodeFromSymbol_fn(Args.hipGraphAddMemcpyNodeFromSymbol.pGraphNode, Args.hipGraphAddMemcpyNodeFromSymbol.graph, Args.hipGraphAddMemcpyNodeFromSymbol.pDependencies, Args.hipGraphAddMemcpyNodeFromSymbol.numDependencies, Args.hipGraphAddMemcpyNodeFromSymbol.dst, Args.hipGraphAddMemcpyNodeFromSymbol.symbol, Args.hipGraphAddMemcpyNodeFromSymbol.count, Args.hipGraphAddMemcpyNodeFromSymbol.offset, Args.hipGraphAddMemcpyNodeFromSymbol.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphAddMemcpyNodeFromSymbol_fn(pGraphNode, graph, pDependencies, numDependencies, dst, symbol, count, offset, kind);
  }
}

static hipError_t hipGraphAddMemcpyNodeToSymbol_wrapper(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const void* symbol, const void* src, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphAddMemcpyNodeToSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphAddMemcpyNodeToSymbol.pGraphNode = pGraphNode;
    Args.hipGraphAddMemcpyNodeToSymbol.graph = graph;
    Args.hipGraphAddMemcpyNodeToSymbol.pDependencies = pDependencies;
    Args.hipGraphAddMemcpyNodeToSymbol.numDependencies = numDependencies;
    Args.hipGraphAddMemcpyNodeToSymbol.symbol = symbol;
    Args.hipGraphAddMemcpyNodeToSymbol.src = src;
    Args.hipGraphAddMemcpyNodeToSymbol.count = count;
    Args.hipGraphAddMemcpyNodeToSymbol.offset = offset;
    Args.hipGraphAddMemcpyNodeToSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphAddMemcpyNodeToSymbol_fn(Args.hipGraphAddMemcpyNodeToSymbol.pGraphNode, Args.hipGraphAddMemcpyNodeToSymbol.graph, Args.hipGraphAddMemcpyNodeToSymbol.pDependencies, Args.hipGraphAddMemcpyNodeToSymbol.numDependencies, Args.hipGraphAddMemcpyNodeToSymbol.symbol, Args.hipGraphAddMemcpyNodeToSymbol.src, Args.hipGraphAddMemcpyNodeToSymbol.count, Args.hipGraphAddMemcpyNodeToSymbol.offset, Args.hipGraphAddMemcpyNodeToSymbol.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphAddMemcpyNodeToSymbol_fn(pGraphNode, graph, pDependencies, numDependencies, symbol, src, count, offset, kind);
  }
}

static hipError_t hipGraphAddMemsetNode_wrapper(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const hipMemsetParams* pMemsetParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphAddMemsetNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphAddMemsetNode.pGraphNode = pGraphNode;
    Args.hipGraphAddMemsetNode.graph = graph;
    Args.hipGraphAddMemsetNode.pDependencies = pDependencies;
    Args.hipGraphAddMemsetNode.numDependencies = numDependencies;
    Args.hipGraphAddMemsetNode.pMemsetParams = pMemsetParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphAddMemsetNode_fn(Args.hipGraphAddMemsetNode.pGraphNode, Args.hipGraphAddMemsetNode.graph, Args.hipGraphAddMemsetNode.pDependencies, Args.hipGraphAddMemsetNode.numDependencies, Args.hipGraphAddMemsetNode.pMemsetParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphAddMemsetNode_fn(pGraphNode, graph, pDependencies, numDependencies, pMemsetParams);
  }
}

static hipError_t hipGraphChildGraphNodeGetGraph_wrapper(hipGraphNode_t node, hipGraph_t* pGraph) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphChildGraphNodeGetGraph;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphChildGraphNodeGetGraph.node = node;
    Args.hipGraphChildGraphNodeGetGraph.pGraph = pGraph;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphChildGraphNodeGetGraph_fn(Args.hipGraphChildGraphNodeGetGraph.node, Args.hipGraphChildGraphNodeGetGraph.pGraph);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphChildGraphNodeGetGraph_fn(node, pGraph);
  }
}

static hipError_t hipGraphClone_wrapper(hipGraph_t* pGraphClone, hipGraph_t originalGraph) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphClone;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphClone.pGraphClone = pGraphClone;
    Args.hipGraphClone.originalGraph = originalGraph;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphClone_fn(Args.hipGraphClone.pGraphClone, Args.hipGraphClone.originalGraph);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphClone_fn(pGraphClone, originalGraph);
  }
}

static hipError_t hipGraphCreate_wrapper(hipGraph_t* pGraph, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphCreate.pGraph = pGraph;
    Args.hipGraphCreate.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphCreate_fn(Args.hipGraphCreate.pGraph, Args.hipGraphCreate.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphCreate_fn(pGraph, flags);
  }
}

static hipError_t hipGraphDebugDotPrint_wrapper(hipGraph_t graph, const char* path, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphDebugDotPrint;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphDebugDotPrint.graph = graph;
    Args.hipGraphDebugDotPrint.path = path;
    Args.hipGraphDebugDotPrint.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphDebugDotPrint_fn(Args.hipGraphDebugDotPrint.graph, Args.hipGraphDebugDotPrint.path, Args.hipGraphDebugDotPrint.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphDebugDotPrint_fn(graph, path, flags);
  }
}

static hipError_t hipGraphDestroy_wrapper(hipGraph_t graph) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphDestroy.graph = graph;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphDestroy_fn(Args.hipGraphDestroy.graph);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphDestroy_fn(graph);
  }
}

static hipError_t hipGraphDestroyNode_wrapper(hipGraphNode_t node) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphDestroyNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphDestroyNode.node = node;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphDestroyNode_fn(Args.hipGraphDestroyNode.node);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphDestroyNode_fn(node);
  }
}

static hipError_t hipGraphEventRecordNodeGetEvent_wrapper(hipGraphNode_t node, hipEvent_t* event_out) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphEventRecordNodeGetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphEventRecordNodeGetEvent.node = node;
    Args.hipGraphEventRecordNodeGetEvent.event_out = event_out;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphEventRecordNodeGetEvent_fn(Args.hipGraphEventRecordNodeGetEvent.node, Args.hipGraphEventRecordNodeGetEvent.event_out);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphEventRecordNodeGetEvent_fn(node, event_out);
  }
}

static hipError_t hipGraphEventRecordNodeSetEvent_wrapper(hipGraphNode_t node, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphEventRecordNodeSetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphEventRecordNodeSetEvent.node = node;
    Args.hipGraphEventRecordNodeSetEvent.event = event;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphEventRecordNodeSetEvent_fn(Args.hipGraphEventRecordNodeSetEvent.node, Args.hipGraphEventRecordNodeSetEvent.event);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphEventRecordNodeSetEvent_fn(node, event);
  }
}

static hipError_t hipGraphEventWaitNodeGetEvent_wrapper(hipGraphNode_t node, hipEvent_t* event_out) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphEventWaitNodeGetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphEventWaitNodeGetEvent.node = node;
    Args.hipGraphEventWaitNodeGetEvent.event_out = event_out;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphEventWaitNodeGetEvent_fn(Args.hipGraphEventWaitNodeGetEvent.node, Args.hipGraphEventWaitNodeGetEvent.event_out);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphEventWaitNodeGetEvent_fn(node, event_out);
  }
}

static hipError_t hipGraphEventWaitNodeSetEvent_wrapper(hipGraphNode_t node, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphEventWaitNodeSetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphEventWaitNodeSetEvent.node = node;
    Args.hipGraphEventWaitNodeSetEvent.event = event;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphEventWaitNodeSetEvent_fn(Args.hipGraphEventWaitNodeSetEvent.node, Args.hipGraphEventWaitNodeSetEvent.event);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphEventWaitNodeSetEvent_fn(node, event);
  }
}

static hipError_t hipGraphExecChildGraphNodeSetParams_wrapper(hipGraphExec_t hGraphExec, hipGraphNode_t node, hipGraph_t childGraph) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExecChildGraphNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExecChildGraphNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecChildGraphNodeSetParams.node = node;
    Args.hipGraphExecChildGraphNodeSetParams.childGraph = childGraph;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExecChildGraphNodeSetParams_fn(Args.hipGraphExecChildGraphNodeSetParams.hGraphExec, Args.hipGraphExecChildGraphNodeSetParams.node, Args.hipGraphExecChildGraphNodeSetParams.childGraph);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExecChildGraphNodeSetParams_fn(hGraphExec, node, childGraph);
  }
}

static hipError_t hipGraphExecDestroy_wrapper(hipGraphExec_t graphExec) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExecDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExecDestroy.graphExec = graphExec;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExecDestroy_fn(Args.hipGraphExecDestroy.graphExec);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExecDestroy_fn(graphExec);
  }
}

static hipError_t hipGraphExecEventRecordNodeSetEvent_wrapper(hipGraphExec_t hGraphExec, hipGraphNode_t hNode, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExecEventRecordNodeSetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExecEventRecordNodeSetEvent.hGraphExec = hGraphExec;
    Args.hipGraphExecEventRecordNodeSetEvent.hNode = hNode;
    Args.hipGraphExecEventRecordNodeSetEvent.event = event;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExecEventRecordNodeSetEvent_fn(Args.hipGraphExecEventRecordNodeSetEvent.hGraphExec, Args.hipGraphExecEventRecordNodeSetEvent.hNode, Args.hipGraphExecEventRecordNodeSetEvent.event);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExecEventRecordNodeSetEvent_fn(hGraphExec, hNode, event);
  }
}

static hipError_t hipGraphExecEventWaitNodeSetEvent_wrapper(hipGraphExec_t hGraphExec, hipGraphNode_t hNode, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExecEventWaitNodeSetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExecEventWaitNodeSetEvent.hGraphExec = hGraphExec;
    Args.hipGraphExecEventWaitNodeSetEvent.hNode = hNode;
    Args.hipGraphExecEventWaitNodeSetEvent.event = event;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExecEventWaitNodeSetEvent_fn(Args.hipGraphExecEventWaitNodeSetEvent.hGraphExec, Args.hipGraphExecEventWaitNodeSetEvent.hNode, Args.hipGraphExecEventWaitNodeSetEvent.event);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExecEventWaitNodeSetEvent_fn(hGraphExec, hNode, event);
  }
}

static hipError_t hipGraphExecHostNodeSetParams_wrapper(hipGraphExec_t hGraphExec, hipGraphNode_t node, const hipHostNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExecHostNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExecHostNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecHostNodeSetParams.node = node;
    Args.hipGraphExecHostNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExecHostNodeSetParams_fn(Args.hipGraphExecHostNodeSetParams.hGraphExec, Args.hipGraphExecHostNodeSetParams.node, Args.hipGraphExecHostNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExecHostNodeSetParams_fn(hGraphExec, node, pNodeParams);
  }
}

static hipError_t hipGraphExecKernelNodeSetParams_wrapper(hipGraphExec_t hGraphExec, hipGraphNode_t node, const hipKernelNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExecKernelNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExecKernelNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecKernelNodeSetParams.node = node;
    Args.hipGraphExecKernelNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExecKernelNodeSetParams_fn(Args.hipGraphExecKernelNodeSetParams.hGraphExec, Args.hipGraphExecKernelNodeSetParams.node, Args.hipGraphExecKernelNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExecKernelNodeSetParams_fn(hGraphExec, node, pNodeParams);
  }
}

static hipError_t hipGraphExecMemcpyNodeSetParams_wrapper(hipGraphExec_t hGraphExec, hipGraphNode_t node, hipMemcpy3DParms* pNodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExecMemcpyNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExecMemcpyNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecMemcpyNodeSetParams.node = node;
    Args.hipGraphExecMemcpyNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExecMemcpyNodeSetParams_fn(Args.hipGraphExecMemcpyNodeSetParams.hGraphExec, Args.hipGraphExecMemcpyNodeSetParams.node, Args.hipGraphExecMemcpyNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExecMemcpyNodeSetParams_fn(hGraphExec, node, pNodeParams);
  }
}

static hipError_t hipGraphExecMemcpyNodeSetParams1D_wrapper(hipGraphExec_t hGraphExec, hipGraphNode_t node, void* dst, const void* src, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExecMemcpyNodeSetParams1D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExecMemcpyNodeSetParams1D.hGraphExec = hGraphExec;
    Args.hipGraphExecMemcpyNodeSetParams1D.node = node;
    Args.hipGraphExecMemcpyNodeSetParams1D.dst = dst;
    Args.hipGraphExecMemcpyNodeSetParams1D.src = src;
    Args.hipGraphExecMemcpyNodeSetParams1D.count = count;
    Args.hipGraphExecMemcpyNodeSetParams1D.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExecMemcpyNodeSetParams1D_fn(Args.hipGraphExecMemcpyNodeSetParams1D.hGraphExec, Args.hipGraphExecMemcpyNodeSetParams1D.node, Args.hipGraphExecMemcpyNodeSetParams1D.dst, Args.hipGraphExecMemcpyNodeSetParams1D.src, Args.hipGraphExecMemcpyNodeSetParams1D.count, Args.hipGraphExecMemcpyNodeSetParams1D.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExecMemcpyNodeSetParams1D_fn(hGraphExec, node, dst, src, count, kind);
  }
}

static hipError_t hipGraphExecMemcpyNodeSetParamsFromSymbol_wrapper(hipGraphExec_t hGraphExec, hipGraphNode_t node, void* dst, const void* symbol, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExecMemcpyNodeSetParamsFromSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.hGraphExec = hGraphExec;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.node = node;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.dst = dst;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.symbol = symbol;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.count = count;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.offset = offset;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExecMemcpyNodeSetParamsFromSymbol_fn(Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.hGraphExec, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.node, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.dst, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.symbol, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.count, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.offset, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExecMemcpyNodeSetParamsFromSymbol_fn(hGraphExec, node, dst, symbol, count, offset, kind);
  }
}

static hipError_t hipGraphExecMemcpyNodeSetParamsToSymbol_wrapper(hipGraphExec_t hGraphExec, hipGraphNode_t node, const void* symbol, const void* src, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExecMemcpyNodeSetParamsToSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.hGraphExec = hGraphExec;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.node = node;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.symbol = symbol;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.src = src;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.count = count;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.offset = offset;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExecMemcpyNodeSetParamsToSymbol_fn(Args.hipGraphExecMemcpyNodeSetParamsToSymbol.hGraphExec, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.node, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.symbol, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.src, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.count, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.offset, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExecMemcpyNodeSetParamsToSymbol_fn(hGraphExec, node, symbol, src, count, offset, kind);
  }
}

static hipError_t hipGraphExecMemsetNodeSetParams_wrapper(hipGraphExec_t hGraphExec, hipGraphNode_t node, const hipMemsetParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExecMemsetNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExecMemsetNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecMemsetNodeSetParams.node = node;
    Args.hipGraphExecMemsetNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExecMemsetNodeSetParams_fn(Args.hipGraphExecMemsetNodeSetParams.hGraphExec, Args.hipGraphExecMemsetNodeSetParams.node, Args.hipGraphExecMemsetNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExecMemsetNodeSetParams_fn(hGraphExec, node, pNodeParams);
  }
}

static hipError_t hipGraphExecUpdate_wrapper(hipGraphExec_t hGraphExec, hipGraph_t hGraph, hipGraphNode_t* hErrorNode_out, hipGraphExecUpdateResult* updateResult_out) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExecUpdate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExecUpdate.hGraphExec = hGraphExec;
    Args.hipGraphExecUpdate.hGraph = hGraph;
    Args.hipGraphExecUpdate.hErrorNode_out = hErrorNode_out;
    Args.hipGraphExecUpdate.updateResult_out = updateResult_out;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExecUpdate_fn(Args.hipGraphExecUpdate.hGraphExec, Args.hipGraphExecUpdate.hGraph, Args.hipGraphExecUpdate.hErrorNode_out, Args.hipGraphExecUpdate.updateResult_out);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExecUpdate_fn(hGraphExec, hGraph, hErrorNode_out, updateResult_out);
  }
}

static hipError_t hipGraphGetEdges_wrapper(hipGraph_t graph, hipGraphNode_t* from, hipGraphNode_t* to, size_t* numEdges) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphGetEdges;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphGetEdges.graph = graph;
    Args.hipGraphGetEdges.from = from;
    Args.hipGraphGetEdges.to = to;
    Args.hipGraphGetEdges.numEdges = numEdges;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphGetEdges_fn(Args.hipGraphGetEdges.graph, Args.hipGraphGetEdges.from, Args.hipGraphGetEdges.to, Args.hipGraphGetEdges.numEdges);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphGetEdges_fn(graph, from, to, numEdges);
  }
}

static hipError_t hipGraphGetNodes_wrapper(hipGraph_t graph, hipGraphNode_t* nodes, size_t* numNodes) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphGetNodes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphGetNodes.graph = graph;
    Args.hipGraphGetNodes.nodes = nodes;
    Args.hipGraphGetNodes.numNodes = numNodes;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphGetNodes_fn(Args.hipGraphGetNodes.graph, Args.hipGraphGetNodes.nodes, Args.hipGraphGetNodes.numNodes);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphGetNodes_fn(graph, nodes, numNodes);
  }
}

static hipError_t hipGraphGetRootNodes_wrapper(hipGraph_t graph, hipGraphNode_t* pRootNodes, size_t* pNumRootNodes) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphGetRootNodes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphGetRootNodes.graph = graph;
    Args.hipGraphGetRootNodes.pRootNodes = pRootNodes;
    Args.hipGraphGetRootNodes.pNumRootNodes = pNumRootNodes;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphGetRootNodes_fn(Args.hipGraphGetRootNodes.graph, Args.hipGraphGetRootNodes.pRootNodes, Args.hipGraphGetRootNodes.pNumRootNodes);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphGetRootNodes_fn(graph, pRootNodes, pNumRootNodes);
  }
}

static hipError_t hipGraphHostNodeGetParams_wrapper(hipGraphNode_t node, hipHostNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphHostNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphHostNodeGetParams.node = node;
    Args.hipGraphHostNodeGetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphHostNodeGetParams_fn(Args.hipGraphHostNodeGetParams.node, Args.hipGraphHostNodeGetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphHostNodeGetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphHostNodeSetParams_wrapper(hipGraphNode_t node, const hipHostNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphHostNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphHostNodeSetParams.node = node;
    Args.hipGraphHostNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphHostNodeSetParams_fn(Args.hipGraphHostNodeSetParams.node, Args.hipGraphHostNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphHostNodeSetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphInstantiate_wrapper(hipGraphExec_t* pGraphExec, hipGraph_t graph, hipGraphNode_t* pErrorNode, char* pLogBuffer, size_t bufferSize) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphInstantiate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphInstantiate.pGraphExec = pGraphExec;
    Args.hipGraphInstantiate.graph = graph;
    Args.hipGraphInstantiate.pErrorNode = pErrorNode;
    Args.hipGraphInstantiate.pLogBuffer = pLogBuffer;
    Args.hipGraphInstantiate.bufferSize = bufferSize;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphInstantiate_fn(Args.hipGraphInstantiate.pGraphExec, Args.hipGraphInstantiate.graph, Args.hipGraphInstantiate.pErrorNode, Args.hipGraphInstantiate.pLogBuffer, Args.hipGraphInstantiate.bufferSize);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphInstantiate_fn(pGraphExec, graph, pErrorNode, pLogBuffer, bufferSize);
  }
}

static hipError_t hipGraphInstantiateWithFlags_wrapper(hipGraphExec_t* pGraphExec, hipGraph_t graph, unsigned long long flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphInstantiateWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphInstantiateWithFlags.pGraphExec = pGraphExec;
    Args.hipGraphInstantiateWithFlags.graph = graph;
    Args.hipGraphInstantiateWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphInstantiateWithFlags_fn(Args.hipGraphInstantiateWithFlags.pGraphExec, Args.hipGraphInstantiateWithFlags.graph, Args.hipGraphInstantiateWithFlags.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphInstantiateWithFlags_fn(pGraphExec, graph, flags);
  }
}

static hipError_t hipGraphKernelNodeCopyAttributes_wrapper(hipGraphNode_t hSrc, hipGraphNode_t hDst) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphKernelNodeCopyAttributes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphKernelNodeCopyAttributes.hSrc = hSrc;
    Args.hipGraphKernelNodeCopyAttributes.hDst = hDst;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphKernelNodeCopyAttributes_fn(Args.hipGraphKernelNodeCopyAttributes.hSrc, Args.hipGraphKernelNodeCopyAttributes.hDst);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphKernelNodeCopyAttributes_fn(hSrc, hDst);
  }
}

static hipError_t hipGraphKernelNodeGetAttribute_wrapper(hipGraphNode_t hNode, hipKernelNodeAttrID attr, hipKernelNodeAttrValue* value) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphKernelNodeGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphKernelNodeGetAttribute.hNode = hNode;
    Args.hipGraphKernelNodeGetAttribute.attr = attr;
    Args.hipGraphKernelNodeGetAttribute.value = value;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphKernelNodeGetAttribute_fn(Args.hipGraphKernelNodeGetAttribute.hNode, Args.hipGraphKernelNodeGetAttribute.attr, Args.hipGraphKernelNodeGetAttribute.value);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphKernelNodeGetAttribute_fn(hNode, attr, value);
  }
}

static hipError_t hipGraphKernelNodeGetParams_wrapper(hipGraphNode_t node, hipKernelNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphKernelNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphKernelNodeGetParams.node = node;
    Args.hipGraphKernelNodeGetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphKernelNodeGetParams_fn(Args.hipGraphKernelNodeGetParams.node, Args.hipGraphKernelNodeGetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphKernelNodeGetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphKernelNodeSetAttribute_wrapper(hipGraphNode_t hNode, hipKernelNodeAttrID attr, const hipKernelNodeAttrValue* value) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphKernelNodeSetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphKernelNodeSetAttribute.hNode = hNode;
    Args.hipGraphKernelNodeSetAttribute.attr = attr;
    Args.hipGraphKernelNodeSetAttribute.value = value;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphKernelNodeSetAttribute_fn(Args.hipGraphKernelNodeSetAttribute.hNode, Args.hipGraphKernelNodeSetAttribute.attr, Args.hipGraphKernelNodeSetAttribute.value);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphKernelNodeSetAttribute_fn(hNode, attr, value);
  }
}

static hipError_t hipGraphKernelNodeSetParams_wrapper(hipGraphNode_t node, const hipKernelNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphKernelNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphKernelNodeSetParams.node = node;
    Args.hipGraphKernelNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphKernelNodeSetParams_fn(Args.hipGraphKernelNodeSetParams.node, Args.hipGraphKernelNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphKernelNodeSetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphLaunch_wrapper(hipGraphExec_t graphExec, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphLaunch;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphLaunch.graphExec = graphExec;
    Args.hipGraphLaunch.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphLaunch_fn(Args.hipGraphLaunch.graphExec, Args.hipGraphLaunch.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphLaunch_fn(graphExec, stream);
  }
}

static hipError_t hipGraphMemAllocNodeGetParams_wrapper(hipGraphNode_t node, hipMemAllocNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphMemAllocNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphMemAllocNodeGetParams.node = node;
    Args.hipGraphMemAllocNodeGetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphMemAllocNodeGetParams_fn(Args.hipGraphMemAllocNodeGetParams.node, Args.hipGraphMemAllocNodeGetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphMemAllocNodeGetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphMemFreeNodeGetParams_wrapper(hipGraphNode_t node, void* dev_ptr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphMemFreeNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphMemFreeNodeGetParams.node = node;
    Args.hipGraphMemFreeNodeGetParams.dev_ptr = dev_ptr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphMemFreeNodeGetParams_fn(Args.hipGraphMemFreeNodeGetParams.node, Args.hipGraphMemFreeNodeGetParams.dev_ptr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphMemFreeNodeGetParams_fn(node, dev_ptr);
  }
}

static hipError_t hipGraphMemcpyNodeGetParams_wrapper(hipGraphNode_t node, hipMemcpy3DParms* pNodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphMemcpyNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphMemcpyNodeGetParams.node = node;
    Args.hipGraphMemcpyNodeGetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphMemcpyNodeGetParams_fn(Args.hipGraphMemcpyNodeGetParams.node, Args.hipGraphMemcpyNodeGetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphMemcpyNodeGetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphMemcpyNodeSetParams_wrapper(hipGraphNode_t node, const hipMemcpy3DParms* pNodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphMemcpyNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphMemcpyNodeSetParams.node = node;
    Args.hipGraphMemcpyNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphMemcpyNodeSetParams_fn(Args.hipGraphMemcpyNodeSetParams.node, Args.hipGraphMemcpyNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphMemcpyNodeSetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphMemcpyNodeSetParams1D_wrapper(hipGraphNode_t node, void* dst, const void* src, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphMemcpyNodeSetParams1D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphMemcpyNodeSetParams1D.node = node;
    Args.hipGraphMemcpyNodeSetParams1D.dst = dst;
    Args.hipGraphMemcpyNodeSetParams1D.src = src;
    Args.hipGraphMemcpyNodeSetParams1D.count = count;
    Args.hipGraphMemcpyNodeSetParams1D.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphMemcpyNodeSetParams1D_fn(Args.hipGraphMemcpyNodeSetParams1D.node, Args.hipGraphMemcpyNodeSetParams1D.dst, Args.hipGraphMemcpyNodeSetParams1D.src, Args.hipGraphMemcpyNodeSetParams1D.count, Args.hipGraphMemcpyNodeSetParams1D.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphMemcpyNodeSetParams1D_fn(node, dst, src, count, kind);
  }
}

static hipError_t hipGraphMemcpyNodeSetParamsFromSymbol_wrapper(hipGraphNode_t node, void* dst, const void* symbol, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphMemcpyNodeSetParamsFromSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.node = node;
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.dst = dst;
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.symbol = symbol;
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.count = count;
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.offset = offset;
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphMemcpyNodeSetParamsFromSymbol_fn(Args.hipGraphMemcpyNodeSetParamsFromSymbol.node, Args.hipGraphMemcpyNodeSetParamsFromSymbol.dst, Args.hipGraphMemcpyNodeSetParamsFromSymbol.symbol, Args.hipGraphMemcpyNodeSetParamsFromSymbol.count, Args.hipGraphMemcpyNodeSetParamsFromSymbol.offset, Args.hipGraphMemcpyNodeSetParamsFromSymbol.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphMemcpyNodeSetParamsFromSymbol_fn(node, dst, symbol, count, offset, kind);
  }
}

static hipError_t hipGraphMemcpyNodeSetParamsToSymbol_wrapper(hipGraphNode_t node, const void* symbol, const void* src, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphMemcpyNodeSetParamsToSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphMemcpyNodeSetParamsToSymbol.node = node;
    Args.hipGraphMemcpyNodeSetParamsToSymbol.symbol = symbol;
    Args.hipGraphMemcpyNodeSetParamsToSymbol.src = src;
    Args.hipGraphMemcpyNodeSetParamsToSymbol.count = count;
    Args.hipGraphMemcpyNodeSetParamsToSymbol.offset = offset;
    Args.hipGraphMemcpyNodeSetParamsToSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphMemcpyNodeSetParamsToSymbol_fn(Args.hipGraphMemcpyNodeSetParamsToSymbol.node, Args.hipGraphMemcpyNodeSetParamsToSymbol.symbol, Args.hipGraphMemcpyNodeSetParamsToSymbol.src, Args.hipGraphMemcpyNodeSetParamsToSymbol.count, Args.hipGraphMemcpyNodeSetParamsToSymbol.offset, Args.hipGraphMemcpyNodeSetParamsToSymbol.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphMemcpyNodeSetParamsToSymbol_fn(node, symbol, src, count, offset, kind);
  }
}

static hipError_t hipGraphMemsetNodeGetParams_wrapper(hipGraphNode_t node, hipMemsetParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphMemsetNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphMemsetNodeGetParams.node = node;
    Args.hipGraphMemsetNodeGetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphMemsetNodeGetParams_fn(Args.hipGraphMemsetNodeGetParams.node, Args.hipGraphMemsetNodeGetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphMemsetNodeGetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphMemsetNodeSetParams_wrapper(hipGraphNode_t node, const hipMemsetParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphMemsetNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphMemsetNodeSetParams.node = node;
    Args.hipGraphMemsetNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphMemsetNodeSetParams_fn(Args.hipGraphMemsetNodeSetParams.node, Args.hipGraphMemsetNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphMemsetNodeSetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphNodeFindInClone_wrapper(hipGraphNode_t* pNode, hipGraphNode_t originalNode, hipGraph_t clonedGraph) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphNodeFindInClone;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphNodeFindInClone.pNode = pNode;
    Args.hipGraphNodeFindInClone.originalNode = originalNode;
    Args.hipGraphNodeFindInClone.clonedGraph = clonedGraph;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphNodeFindInClone_fn(Args.hipGraphNodeFindInClone.pNode, Args.hipGraphNodeFindInClone.originalNode, Args.hipGraphNodeFindInClone.clonedGraph);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphNodeFindInClone_fn(pNode, originalNode, clonedGraph);
  }
}

static hipError_t hipGraphNodeGetDependencies_wrapper(hipGraphNode_t node, hipGraphNode_t* pDependencies, size_t* pNumDependencies) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphNodeGetDependencies;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphNodeGetDependencies.node = node;
    Args.hipGraphNodeGetDependencies.pDependencies = pDependencies;
    Args.hipGraphNodeGetDependencies.pNumDependencies = pNumDependencies;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphNodeGetDependencies_fn(Args.hipGraphNodeGetDependencies.node, Args.hipGraphNodeGetDependencies.pDependencies, Args.hipGraphNodeGetDependencies.pNumDependencies);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphNodeGetDependencies_fn(node, pDependencies, pNumDependencies);
  }
}

static hipError_t hipGraphNodeGetDependentNodes_wrapper(hipGraphNode_t node, hipGraphNode_t* pDependentNodes, size_t* pNumDependentNodes) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphNodeGetDependentNodes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphNodeGetDependentNodes.node = node;
    Args.hipGraphNodeGetDependentNodes.pDependentNodes = pDependentNodes;
    Args.hipGraphNodeGetDependentNodes.pNumDependentNodes = pNumDependentNodes;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphNodeGetDependentNodes_fn(Args.hipGraphNodeGetDependentNodes.node, Args.hipGraphNodeGetDependentNodes.pDependentNodes, Args.hipGraphNodeGetDependentNodes.pNumDependentNodes);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphNodeGetDependentNodes_fn(node, pDependentNodes, pNumDependentNodes);
  }
}

static hipError_t hipGraphNodeGetEnabled_wrapper(hipGraphExec_t hGraphExec, hipGraphNode_t hNode, unsigned int* isEnabled) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphNodeGetEnabled;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphNodeGetEnabled.hGraphExec = hGraphExec;
    Args.hipGraphNodeGetEnabled.hNode = hNode;
    Args.hipGraphNodeGetEnabled.isEnabled = isEnabled;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphNodeGetEnabled_fn(Args.hipGraphNodeGetEnabled.hGraphExec, Args.hipGraphNodeGetEnabled.hNode, Args.hipGraphNodeGetEnabled.isEnabled);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphNodeGetEnabled_fn(hGraphExec, hNode, isEnabled);
  }
}

static hipError_t hipGraphNodeGetType_wrapper(hipGraphNode_t node, hipGraphNodeType* pType) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphNodeGetType;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphNodeGetType.node = node;
    Args.hipGraphNodeGetType.pType = pType;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphNodeGetType_fn(Args.hipGraphNodeGetType.node, Args.hipGraphNodeGetType.pType);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphNodeGetType_fn(node, pType);
  }
}

static hipError_t hipGraphNodeSetEnabled_wrapper(hipGraphExec_t hGraphExec, hipGraphNode_t hNode, unsigned int isEnabled) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphNodeSetEnabled;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphNodeSetEnabled.hGraphExec = hGraphExec;
    Args.hipGraphNodeSetEnabled.hNode = hNode;
    Args.hipGraphNodeSetEnabled.isEnabled = isEnabled;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphNodeSetEnabled_fn(Args.hipGraphNodeSetEnabled.hGraphExec, Args.hipGraphNodeSetEnabled.hNode, Args.hipGraphNodeSetEnabled.isEnabled);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphNodeSetEnabled_fn(hGraphExec, hNode, isEnabled);
  }
}

static hipError_t hipGraphReleaseUserObject_wrapper(hipGraph_t graph, hipUserObject_t object, unsigned int count) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphReleaseUserObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphReleaseUserObject.graph = graph;
    Args.hipGraphReleaseUserObject.object = object;
    Args.hipGraphReleaseUserObject.count = count;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphReleaseUserObject_fn(Args.hipGraphReleaseUserObject.graph, Args.hipGraphReleaseUserObject.object, Args.hipGraphReleaseUserObject.count);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphReleaseUserObject_fn(graph, object, count);
  }
}

static hipError_t hipGraphRemoveDependencies_wrapper(hipGraph_t graph, const hipGraphNode_t* from, const hipGraphNode_t* to, size_t numDependencies) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphRemoveDependencies;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphRemoveDependencies.graph = graph;
    Args.hipGraphRemoveDependencies.from = from;
    Args.hipGraphRemoveDependencies.to = to;
    Args.hipGraphRemoveDependencies.numDependencies = numDependencies;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphRemoveDependencies_fn(Args.hipGraphRemoveDependencies.graph, Args.hipGraphRemoveDependencies.from, Args.hipGraphRemoveDependencies.to, Args.hipGraphRemoveDependencies.numDependencies);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphRemoveDependencies_fn(graph, from, to, numDependencies);
  }
}

static hipError_t hipGraphRetainUserObject_wrapper(hipGraph_t graph, hipUserObject_t object, unsigned int count, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphRetainUserObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphRetainUserObject.graph = graph;
    Args.hipGraphRetainUserObject.object = object;
    Args.hipGraphRetainUserObject.count = count;
    Args.hipGraphRetainUserObject.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphRetainUserObject_fn(Args.hipGraphRetainUserObject.graph, Args.hipGraphRetainUserObject.object, Args.hipGraphRetainUserObject.count, Args.hipGraphRetainUserObject.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphRetainUserObject_fn(graph, object, count, flags);
  }
}

static hipError_t hipGraphUpload_wrapper(hipGraphExec_t graphExec, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphUpload;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphUpload.graphExec = graphExec;
    Args.hipGraphUpload.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphUpload_fn(Args.hipGraphUpload.graphExec, Args.hipGraphUpload.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphUpload_fn(graphExec, stream);
  }
}

static hipError_t hipGraphicsGLRegisterBuffer_wrapper(hipGraphicsResource** resource, GLuint buffer, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphicsGLRegisterBuffer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphicsGLRegisterBuffer.resource = resource;
    Args.hipGraphicsGLRegisterBuffer.buffer = buffer;
    Args.hipGraphicsGLRegisterBuffer.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphicsGLRegisterBuffer_fn(Args.hipGraphicsGLRegisterBuffer.resource, Args.hipGraphicsGLRegisterBuffer.buffer, Args.hipGraphicsGLRegisterBuffer.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphicsGLRegisterBuffer_fn(resource, buffer, flags);
  }
}

static hipError_t hipGraphicsGLRegisterImage_wrapper(hipGraphicsResource** resource, GLuint image, GLenum target, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphicsGLRegisterImage;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphicsGLRegisterImage.resource = resource;
    Args.hipGraphicsGLRegisterImage.image = image;
    Args.hipGraphicsGLRegisterImage.target = target;
    Args.hipGraphicsGLRegisterImage.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphicsGLRegisterImage_fn(Args.hipGraphicsGLRegisterImage.resource, Args.hipGraphicsGLRegisterImage.image, Args.hipGraphicsGLRegisterImage.target, Args.hipGraphicsGLRegisterImage.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphicsGLRegisterImage_fn(resource, image, target, flags);
  }
}

static hipError_t hipGraphicsMapResources_wrapper(int count, hipGraphicsResource_t* resources, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphicsMapResources;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphicsMapResources.count = count;
    Args.hipGraphicsMapResources.resources = resources;
    Args.hipGraphicsMapResources.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphicsMapResources_fn(Args.hipGraphicsMapResources.count, Args.hipGraphicsMapResources.resources, Args.hipGraphicsMapResources.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphicsMapResources_fn(count, resources, stream);
  }
}

static hipError_t hipGraphicsResourceGetMappedPointer_wrapper(void** devPtr, size_t* size, hipGraphicsResource_t resource) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphicsResourceGetMappedPointer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphicsResourceGetMappedPointer.devPtr = devPtr;
    Args.hipGraphicsResourceGetMappedPointer.size = size;
    Args.hipGraphicsResourceGetMappedPointer.resource = resource;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphicsResourceGetMappedPointer_fn(Args.hipGraphicsResourceGetMappedPointer.devPtr, Args.hipGraphicsResourceGetMappedPointer.size, Args.hipGraphicsResourceGetMappedPointer.resource);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphicsResourceGetMappedPointer_fn(devPtr, size, resource);
  }
}

static hipError_t hipGraphicsSubResourceGetMappedArray_wrapper(hipArray_t* array, hipGraphicsResource_t resource, unsigned int arrayIndex, unsigned int mipLevel) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphicsSubResourceGetMappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphicsSubResourceGetMappedArray.array = array;
    Args.hipGraphicsSubResourceGetMappedArray.resource = resource;
    Args.hipGraphicsSubResourceGetMappedArray.arrayIndex = arrayIndex;
    Args.hipGraphicsSubResourceGetMappedArray.mipLevel = mipLevel;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphicsSubResourceGetMappedArray_fn(Args.hipGraphicsSubResourceGetMappedArray.array, Args.hipGraphicsSubResourceGetMappedArray.resource, Args.hipGraphicsSubResourceGetMappedArray.arrayIndex, Args.hipGraphicsSubResourceGetMappedArray.mipLevel);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphicsSubResourceGetMappedArray_fn(array, resource, arrayIndex, mipLevel);
  }
}

static hipError_t hipGraphicsUnmapResources_wrapper(int count, hipGraphicsResource_t* resources, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphicsUnmapResources;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphicsUnmapResources.count = count;
    Args.hipGraphicsUnmapResources.resources = resources;
    Args.hipGraphicsUnmapResources.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphicsUnmapResources_fn(Args.hipGraphicsUnmapResources.count, Args.hipGraphicsUnmapResources.resources, Args.hipGraphicsUnmapResources.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphicsUnmapResources_fn(count, resources, stream);
  }
}

static hipError_t hipGraphicsUnregisterResource_wrapper(hipGraphicsResource_t resource) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphicsUnregisterResource;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphicsUnregisterResource.resource = resource;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphicsUnregisterResource_fn(Args.hipGraphicsUnregisterResource.resource);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphicsUnregisterResource_fn(resource);
  }
}

static hipError_t hipHostAlloc_wrapper(void** ptr, size_t size, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipHostAlloc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipHostAlloc.ptr = ptr;
    Args.hipHostAlloc.size = size;
    Args.hipHostAlloc.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipHostAlloc_fn(Args.hipHostAlloc.ptr, Args.hipHostAlloc.size, Args.hipHostAlloc.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipHostAlloc_fn(ptr, size, flags);
  }
}

static hipError_t hipHostFree_wrapper(void* ptr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipHostFree;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipHostFree.ptr = ptr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipHostFree_fn(Args.hipHostFree.ptr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipHostFree_fn(ptr);
  }
}

static hipError_t hipHostGetDevicePointer_wrapper(void** devPtr, void* hstPtr, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipHostGetDevicePointer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipHostGetDevicePointer.devPtr = devPtr;
    Args.hipHostGetDevicePointer.hstPtr = hstPtr;
    Args.hipHostGetDevicePointer.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipHostGetDevicePointer_fn(Args.hipHostGetDevicePointer.devPtr, Args.hipHostGetDevicePointer.hstPtr, Args.hipHostGetDevicePointer.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipHostGetDevicePointer_fn(devPtr, hstPtr, flags);
  }
}

static hipError_t hipHostGetFlags_wrapper(unsigned int* flagsPtr, void* hostPtr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipHostGetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipHostGetFlags.flagsPtr = flagsPtr;
    Args.hipHostGetFlags.hostPtr = hostPtr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipHostGetFlags_fn(Args.hipHostGetFlags.flagsPtr, Args.hipHostGetFlags.hostPtr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipHostGetFlags_fn(flagsPtr, hostPtr);
  }
}

static hipError_t hipHostMalloc_wrapper(void** ptr, size_t size, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipHostMalloc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipHostMalloc.ptr = ptr;
    Args.hipHostMalloc.size = size;
    Args.hipHostMalloc.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipHostMalloc_fn(Args.hipHostMalloc.ptr, Args.hipHostMalloc.size, Args.hipHostMalloc.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipHostMalloc_fn(ptr, size, flags);
  }
}

static hipError_t hipHostRegister_wrapper(void* hostPtr, size_t sizeBytes, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipHostRegister;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipHostRegister.hostPtr = hostPtr;
    Args.hipHostRegister.sizeBytes = sizeBytes;
    Args.hipHostRegister.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipHostRegister_fn(Args.hipHostRegister.hostPtr, Args.hipHostRegister.sizeBytes, Args.hipHostRegister.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipHostRegister_fn(hostPtr, sizeBytes, flags);
  }
}

static hipError_t hipHostUnregister_wrapper(void* hostPtr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipHostUnregister;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipHostUnregister.hostPtr = hostPtr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipHostUnregister_fn(Args.hipHostUnregister.hostPtr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipHostUnregister_fn(hostPtr);
  }
}

static hipError_t hipImportExternalMemory_wrapper(hipExternalMemory_t* extMem_out, const hipExternalMemoryHandleDesc* memHandleDesc) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipImportExternalMemory;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipImportExternalMemory.extMem_out = extMem_out;
    Args.hipImportExternalMemory.memHandleDesc = memHandleDesc;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipImportExternalMemory_fn(Args.hipImportExternalMemory.extMem_out, Args.hipImportExternalMemory.memHandleDesc);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipImportExternalMemory_fn(extMem_out, memHandleDesc);
  }
}

static hipError_t hipImportExternalSemaphore_wrapper(hipExternalSemaphore_t* extSem_out, const hipExternalSemaphoreHandleDesc* semHandleDesc) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipImportExternalSemaphore;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipImportExternalSemaphore.extSem_out = extSem_out;
    Args.hipImportExternalSemaphore.semHandleDesc = semHandleDesc;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipImportExternalSemaphore_fn(Args.hipImportExternalSemaphore.extSem_out, Args.hipImportExternalSemaphore.semHandleDesc);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipImportExternalSemaphore_fn(extSem_out, semHandleDesc);
  }
}

static hipError_t hipInit_wrapper(unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipInit;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipInit.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipInit_fn(Args.hipInit.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipInit_fn(flags);
  }
}

static hipError_t hipIpcCloseMemHandle_wrapper(void* devPtr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipIpcCloseMemHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipIpcCloseMemHandle.devPtr = devPtr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipIpcCloseMemHandle_fn(Args.hipIpcCloseMemHandle.devPtr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipIpcCloseMemHandle_fn(devPtr);
  }
}

static hipError_t hipIpcGetEventHandle_wrapper(hipIpcEventHandle_t* handle, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipIpcGetEventHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipIpcGetEventHandle.handle = handle;
    Args.hipIpcGetEventHandle.event = event;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipIpcGetEventHandle_fn(Args.hipIpcGetEventHandle.handle, Args.hipIpcGetEventHandle.event);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipIpcGetEventHandle_fn(handle, event);
  }
}

static hipError_t hipIpcGetMemHandle_wrapper(hipIpcMemHandle_t* handle, void* devPtr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipIpcGetMemHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipIpcGetMemHandle.handle = handle;
    Args.hipIpcGetMemHandle.devPtr = devPtr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipIpcGetMemHandle_fn(Args.hipIpcGetMemHandle.handle, Args.hipIpcGetMemHandle.devPtr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipIpcGetMemHandle_fn(handle, devPtr);
  }
}

static hipError_t hipIpcOpenEventHandle_wrapper(hipEvent_t* event, hipIpcEventHandle_t handle) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipIpcOpenEventHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipIpcOpenEventHandle.event = event;
    Args.hipIpcOpenEventHandle.handle = handle;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipIpcOpenEventHandle_fn(Args.hipIpcOpenEventHandle.event, Args.hipIpcOpenEventHandle.handle);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipIpcOpenEventHandle_fn(event, handle);
  }
}

static hipError_t hipIpcOpenMemHandle_wrapper(void** devPtr, hipIpcMemHandle_t handle, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipIpcOpenMemHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipIpcOpenMemHandle.devPtr = devPtr;
    Args.hipIpcOpenMemHandle.handle = handle;
    Args.hipIpcOpenMemHandle.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipIpcOpenMemHandle_fn(Args.hipIpcOpenMemHandle.devPtr, Args.hipIpcOpenMemHandle.handle, Args.hipIpcOpenMemHandle.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipIpcOpenMemHandle_fn(devPtr, handle, flags);
  }
}

static const char* hipKernelNameRef_wrapper(const hipFunction_t f) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipKernelNameRef;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    const char* Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipKernelNameRef.f = f;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipKernelNameRef_fn(Args.hipKernelNameRef.f);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipKernelNameRef_fn(f);
  }
}

static const char* hipKernelNameRefByPtr_wrapper(const void* hostFunction, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipKernelNameRefByPtr;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    const char* Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipKernelNameRefByPtr.hostFunction = hostFunction;
    Args.hipKernelNameRefByPtr.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipKernelNameRefByPtr_fn(Args.hipKernelNameRefByPtr.hostFunction, Args.hipKernelNameRefByPtr.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipKernelNameRefByPtr_fn(hostFunction, stream);
  }
}

static hipError_t hipLaunchByPtr_wrapper(const void* func) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipLaunchByPtr;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipLaunchByPtr.func = func;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipLaunchByPtr_fn(Args.hipLaunchByPtr.func);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipLaunchByPtr_fn(func);
  }
}

static hipError_t hipLaunchCooperativeKernel_wrapper(const void* f, dim3 gridDim, dim3 blockDimX, void** kernelParams, unsigned int sharedMemBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipLaunchCooperativeKernel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipLaunchCooperativeKernel.f = f;
    Args.hipLaunchCooperativeKernel.gridDim.x = gridDim.x;
    Args.hipLaunchCooperativeKernel.gridDim.y = gridDim.y;
    Args.hipLaunchCooperativeKernel.gridDim.z = gridDim.z;                    
    Args.hipLaunchCooperativeKernel.blockDimX.x = blockDimX.x;
    Args.hipLaunchCooperativeKernel.blockDimX.y = blockDimX.y;
    Args.hipLaunchCooperativeKernel.blockDimX.z = blockDimX.z;                    
    Args.hipLaunchCooperativeKernel.kernelParams = kernelParams;
    Args.hipLaunchCooperativeKernel.sharedMemBytes = sharedMemBytes;
    Args.hipLaunchCooperativeKernel.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipLaunchCooperativeKernel_fn(Args.hipLaunchCooperativeKernel.f, *reinterpret_cast<dim3*>(&Args.hipLaunchCooperativeKernel.gridDim), *reinterpret_cast<dim3*>(&Args.hipLaunchCooperativeKernel.blockDimX), Args.hipLaunchCooperativeKernel.kernelParams, Args.hipLaunchCooperativeKernel.sharedMemBytes, Args.hipLaunchCooperativeKernel.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipLaunchCooperativeKernel_fn(f, gridDim, blockDimX, kernelParams, sharedMemBytes, stream);
  }
}

static hipError_t hipLaunchCooperativeKernelMultiDevice_wrapper(hipLaunchParams* launchParamsList, int numDevices, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipLaunchCooperativeKernelMultiDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipLaunchCooperativeKernelMultiDevice.launchParamsList = launchParamsList;
    Args.hipLaunchCooperativeKernelMultiDevice.numDevices = numDevices;
    Args.hipLaunchCooperativeKernelMultiDevice.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipLaunchCooperativeKernelMultiDevice_fn(Args.hipLaunchCooperativeKernelMultiDevice.launchParamsList, Args.hipLaunchCooperativeKernelMultiDevice.numDevices, Args.hipLaunchCooperativeKernelMultiDevice.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipLaunchCooperativeKernelMultiDevice_fn(launchParamsList, numDevices, flags);
  }
}

static hipError_t hipLaunchHostFunc_wrapper(hipStream_t stream, hipHostFn_t fn, void* userData) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipLaunchHostFunc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipLaunchHostFunc.stream = stream;
    Args.hipLaunchHostFunc.fn = fn;
    Args.hipLaunchHostFunc.userData = userData;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipLaunchHostFunc_fn(Args.hipLaunchHostFunc.stream, Args.hipLaunchHostFunc.fn, Args.hipLaunchHostFunc.userData);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipLaunchHostFunc_fn(stream, fn, userData);
  }
}

static hipError_t hipLaunchKernel_wrapper(const void* function_address, dim3 numBlocks, dim3 dimBlocks, void** args, size_t sharedMemBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipLaunchKernel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipLaunchKernel.function_address = function_address;
    Args.hipLaunchKernel.numBlocks.x = numBlocks.x;
    Args.hipLaunchKernel.numBlocks.y = numBlocks.y;
    Args.hipLaunchKernel.numBlocks.z = numBlocks.z;                    
    Args.hipLaunchKernel.dimBlocks.x = dimBlocks.x;
    Args.hipLaunchKernel.dimBlocks.y = dimBlocks.y;
    Args.hipLaunchKernel.dimBlocks.z = dimBlocks.z;                    
    Args.hipLaunchKernel.args = args;
    Args.hipLaunchKernel.sharedMemBytes = sharedMemBytes;
    Args.hipLaunchKernel.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipLaunchKernel_fn(Args.hipLaunchKernel.function_address, *reinterpret_cast<dim3*>(&Args.hipLaunchKernel.numBlocks), *reinterpret_cast<dim3*>(&Args.hipLaunchKernel.dimBlocks), Args.hipLaunchKernel.args, Args.hipLaunchKernel.sharedMemBytes, Args.hipLaunchKernel.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipLaunchKernel_fn(function_address, numBlocks, dimBlocks, args, sharedMemBytes, stream);
  }
}

static hipError_t hipMalloc_wrapper(void** ptr, size_t size) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMalloc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMalloc.ptr = ptr;
    Args.hipMalloc.size = size;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMalloc_fn(Args.hipMalloc.ptr, Args.hipMalloc.size);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMalloc_fn(ptr, size);
  }
}

static hipError_t hipMalloc3D_wrapper(hipPitchedPtr* pitchedDevPtr, hipExtent extent) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMalloc3D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMalloc3D.pitchedDevPtr = pitchedDevPtr;
    Args.hipMalloc3D.extent = extent;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMalloc3D_fn(Args.hipMalloc3D.pitchedDevPtr, Args.hipMalloc3D.extent);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMalloc3D_fn(pitchedDevPtr, extent);
  }
}

static hipError_t hipMalloc3DArray_wrapper(hipArray_t* array, const struct hipChannelFormatDesc* desc, struct hipExtent extent, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMalloc3DArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMalloc3DArray.array = array;
    Args.hipMalloc3DArray.desc = desc;
    Args.hipMalloc3DArray.extent = extent;
    Args.hipMalloc3DArray.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMalloc3DArray_fn(Args.hipMalloc3DArray.array, Args.hipMalloc3DArray.desc, Args.hipMalloc3DArray.extent, Args.hipMalloc3DArray.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMalloc3DArray_fn(array, desc, extent, flags);
  }
}

static hipError_t hipMallocArray_wrapper(hipArray_t* array, const hipChannelFormatDesc* desc, size_t width, size_t height, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMallocArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMallocArray.array = array;
    Args.hipMallocArray.desc = desc;
    Args.hipMallocArray.width = width;
    Args.hipMallocArray.height = height;
    Args.hipMallocArray.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMallocArray_fn(Args.hipMallocArray.array, Args.hipMallocArray.desc, Args.hipMallocArray.width, Args.hipMallocArray.height, Args.hipMallocArray.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMallocArray_fn(array, desc, width, height, flags);
  }
}

static hipError_t hipMallocAsync_wrapper(void** dev_ptr, size_t size, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMallocAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMallocAsync.dev_ptr = dev_ptr;
    Args.hipMallocAsync.size = size;
    Args.hipMallocAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMallocAsync_fn(Args.hipMallocAsync.dev_ptr, Args.hipMallocAsync.size, Args.hipMallocAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMallocAsync_fn(dev_ptr, size, stream);
  }
}

static hipError_t hipMallocFromPoolAsync_wrapper(void** dev_ptr, size_t size, hipMemPool_t mem_pool, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMallocFromPoolAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMallocFromPoolAsync.dev_ptr = dev_ptr;
    Args.hipMallocFromPoolAsync.size = size;
    Args.hipMallocFromPoolAsync.mem_pool = mem_pool;
    Args.hipMallocFromPoolAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMallocFromPoolAsync_fn(Args.hipMallocFromPoolAsync.dev_ptr, Args.hipMallocFromPoolAsync.size, Args.hipMallocFromPoolAsync.mem_pool, Args.hipMallocFromPoolAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMallocFromPoolAsync_fn(dev_ptr, size, mem_pool, stream);
  }
}

static hipError_t hipMallocHost_wrapper(void** ptr, size_t size) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMallocHost;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMallocHost.ptr = ptr;
    Args.hipMallocHost.size = size;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMallocHost_fn(Args.hipMallocHost.ptr, Args.hipMallocHost.size);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMallocHost_fn(ptr, size);
  }
}

static hipError_t hipMallocManaged_wrapper(void** dev_ptr, size_t size, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMallocManaged;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMallocManaged.dev_ptr = dev_ptr;
    Args.hipMallocManaged.size = size;
    Args.hipMallocManaged.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMallocManaged_fn(Args.hipMallocManaged.dev_ptr, Args.hipMallocManaged.size, Args.hipMallocManaged.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMallocManaged_fn(dev_ptr, size, flags);
  }
}

static hipError_t hipMallocMipmappedArray_wrapper(hipMipmappedArray_t* mipmappedArray, const struct hipChannelFormatDesc* desc, struct hipExtent extent, unsigned int numLevels, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMallocMipmappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMallocMipmappedArray.mipmappedArray = mipmappedArray;
    Args.hipMallocMipmappedArray.desc = desc;
    Args.hipMallocMipmappedArray.extent = extent;
    Args.hipMallocMipmappedArray.numLevels = numLevels;
    Args.hipMallocMipmappedArray.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMallocMipmappedArray_fn(Args.hipMallocMipmappedArray.mipmappedArray, Args.hipMallocMipmappedArray.desc, Args.hipMallocMipmappedArray.extent, Args.hipMallocMipmappedArray.numLevels, Args.hipMallocMipmappedArray.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMallocMipmappedArray_fn(mipmappedArray, desc, extent, numLevels, flags);
  }
}

static hipError_t hipMallocPitch_wrapper(void** ptr, size_t* pitch, size_t width, size_t height) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMallocPitch;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMallocPitch.ptr = ptr;
    Args.hipMallocPitch.pitch = pitch;
    Args.hipMallocPitch.width = width;
    Args.hipMallocPitch.height = height;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMallocPitch_fn(Args.hipMallocPitch.ptr, Args.hipMallocPitch.pitch, Args.hipMallocPitch.width, Args.hipMallocPitch.height);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMallocPitch_fn(ptr, pitch, width, height);
  }
}

static hipError_t hipMemAddressFree_wrapper(void* devPtr, size_t size) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemAddressFree;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemAddressFree.devPtr = devPtr;
    Args.hipMemAddressFree.size = size;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemAddressFree_fn(Args.hipMemAddressFree.devPtr, Args.hipMemAddressFree.size);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemAddressFree_fn(devPtr, size);
  }
}

static hipError_t hipMemAddressReserve_wrapper(void** ptr, size_t size, size_t alignment, void* addr, unsigned long long flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemAddressReserve;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemAddressReserve.ptr = ptr;
    Args.hipMemAddressReserve.size = size;
    Args.hipMemAddressReserve.alignment = alignment;
    Args.hipMemAddressReserve.addr = addr;
    Args.hipMemAddressReserve.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemAddressReserve_fn(Args.hipMemAddressReserve.ptr, Args.hipMemAddressReserve.size, Args.hipMemAddressReserve.alignment, Args.hipMemAddressReserve.addr, Args.hipMemAddressReserve.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemAddressReserve_fn(ptr, size, alignment, addr, flags);
  }
}

static hipError_t hipMemAdvise_wrapper(const void* dev_ptr, size_t count, hipMemoryAdvise advice, int device) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemAdvise;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemAdvise.dev_ptr = dev_ptr;
    Args.hipMemAdvise.count = count;
    Args.hipMemAdvise.advice = advice;
    Args.hipMemAdvise.device = device;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemAdvise_fn(Args.hipMemAdvise.dev_ptr, Args.hipMemAdvise.count, Args.hipMemAdvise.advice, Args.hipMemAdvise.device);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemAdvise_fn(dev_ptr, count, advice, device);
  }
}

static hipError_t hipMemAllocHost_wrapper(void** ptr, size_t size) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemAllocHost;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemAllocHost.ptr = ptr;
    Args.hipMemAllocHost.size = size;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemAllocHost_fn(Args.hipMemAllocHost.ptr, Args.hipMemAllocHost.size);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemAllocHost_fn(ptr, size);
  }
}

static hipError_t hipMemAllocPitch_wrapper(hipDeviceptr_t* dptr, size_t* pitch, size_t widthInBytes, size_t height, unsigned int elementSizeBytes) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemAllocPitch;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemAllocPitch.dptr = dptr;
    Args.hipMemAllocPitch.pitch = pitch;
    Args.hipMemAllocPitch.widthInBytes = widthInBytes;
    Args.hipMemAllocPitch.height = height;
    Args.hipMemAllocPitch.elementSizeBytes = elementSizeBytes;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemAllocPitch_fn(Args.hipMemAllocPitch.dptr, Args.hipMemAllocPitch.pitch, Args.hipMemAllocPitch.widthInBytes, Args.hipMemAllocPitch.height, Args.hipMemAllocPitch.elementSizeBytes);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemAllocPitch_fn(dptr, pitch, widthInBytes, height, elementSizeBytes);
  }
}

static hipError_t hipMemCreate_wrapper(hipMemGenericAllocationHandle_t* handle, size_t size, const hipMemAllocationProp* prop, unsigned long long flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemCreate.handle = handle;
    Args.hipMemCreate.size = size;
    Args.hipMemCreate.prop = prop;
    Args.hipMemCreate.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemCreate_fn(Args.hipMemCreate.handle, Args.hipMemCreate.size, Args.hipMemCreate.prop, Args.hipMemCreate.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemCreate_fn(handle, size, prop, flags);
  }
}

static hipError_t hipMemExportToShareableHandle_wrapper(void* shareableHandle, hipMemGenericAllocationHandle_t handle, hipMemAllocationHandleType handleType, unsigned long long flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemExportToShareableHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemExportToShareableHandle.shareableHandle = shareableHandle;
    Args.hipMemExportToShareableHandle.handle = handle;
    Args.hipMemExportToShareableHandle.handleType = handleType;
    Args.hipMemExportToShareableHandle.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemExportToShareableHandle_fn(Args.hipMemExportToShareableHandle.shareableHandle, Args.hipMemExportToShareableHandle.handle, Args.hipMemExportToShareableHandle.handleType, Args.hipMemExportToShareableHandle.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemExportToShareableHandle_fn(shareableHandle, handle, handleType, flags);
  }
}

static hipError_t hipMemGetAccess_wrapper(unsigned long long* flags, const hipMemLocation* location, void* ptr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemGetAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemGetAccess.flags = flags;
    Args.hipMemGetAccess.location = location;
    Args.hipMemGetAccess.ptr = ptr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemGetAccess_fn(Args.hipMemGetAccess.flags, Args.hipMemGetAccess.location, Args.hipMemGetAccess.ptr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemGetAccess_fn(flags, location, ptr);
  }
}

static hipError_t hipMemGetAddressRange_wrapper(hipDeviceptr_t* pbase, size_t* psize, hipDeviceptr_t dptr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemGetAddressRange;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemGetAddressRange.pbase = pbase;
    Args.hipMemGetAddressRange.psize = psize;
    Args.hipMemGetAddressRange.dptr = dptr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemGetAddressRange_fn(Args.hipMemGetAddressRange.pbase, Args.hipMemGetAddressRange.psize, Args.hipMemGetAddressRange.dptr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemGetAddressRange_fn(pbase, psize, dptr);
  }
}

static hipError_t hipMemGetAllocationGranularity_wrapper(size_t* granularity, const hipMemAllocationProp* prop, hipMemAllocationGranularity_flags option) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemGetAllocationGranularity;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemGetAllocationGranularity.granularity = granularity;
    Args.hipMemGetAllocationGranularity.prop = prop;
    Args.hipMemGetAllocationGranularity.option = option;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemGetAllocationGranularity_fn(Args.hipMemGetAllocationGranularity.granularity, Args.hipMemGetAllocationGranularity.prop, Args.hipMemGetAllocationGranularity.option);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemGetAllocationGranularity_fn(granularity, prop, option);
  }
}

static hipError_t hipMemGetAllocationPropertiesFromHandle_wrapper(hipMemAllocationProp* prop, hipMemGenericAllocationHandle_t handle) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemGetAllocationPropertiesFromHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemGetAllocationPropertiesFromHandle.prop = prop;
    Args.hipMemGetAllocationPropertiesFromHandle.handle = handle;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemGetAllocationPropertiesFromHandle_fn(Args.hipMemGetAllocationPropertiesFromHandle.prop, Args.hipMemGetAllocationPropertiesFromHandle.handle);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemGetAllocationPropertiesFromHandle_fn(prop, handle);
  }
}

static hipError_t hipMemGetInfo_wrapper(size_t* free, size_t* total) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemGetInfo;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemGetInfo.free = free;
    Args.hipMemGetInfo.total = total;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemGetInfo_fn(Args.hipMemGetInfo.free, Args.hipMemGetInfo.total);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemGetInfo_fn(free, total);
  }
}

static hipError_t hipMemImportFromShareableHandle_wrapper(hipMemGenericAllocationHandle_t* handle, void* osHandle, hipMemAllocationHandleType shHandleType) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemImportFromShareableHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemImportFromShareableHandle.handle = handle;
    Args.hipMemImportFromShareableHandle.osHandle = osHandle;
    Args.hipMemImportFromShareableHandle.shHandleType = shHandleType;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemImportFromShareableHandle_fn(Args.hipMemImportFromShareableHandle.handle, Args.hipMemImportFromShareableHandle.osHandle, Args.hipMemImportFromShareableHandle.shHandleType);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemImportFromShareableHandle_fn(handle, osHandle, shHandleType);
  }
}

static hipError_t hipMemMap_wrapper(void* ptr, size_t size, size_t offset, hipMemGenericAllocationHandle_t handle, unsigned long long flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemMap;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemMap.ptr = ptr;
    Args.hipMemMap.size = size;
    Args.hipMemMap.offset = offset;
    Args.hipMemMap.handle = handle;
    Args.hipMemMap.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemMap_fn(Args.hipMemMap.ptr, Args.hipMemMap.size, Args.hipMemMap.offset, Args.hipMemMap.handle, Args.hipMemMap.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemMap_fn(ptr, size, offset, handle, flags);
  }
}

static hipError_t hipMemMapArrayAsync_wrapper(hipArrayMapInfo* mapInfoList, unsigned int count, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemMapArrayAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemMapArrayAsync.mapInfoList = mapInfoList;
    Args.hipMemMapArrayAsync.count = count;
    Args.hipMemMapArrayAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemMapArrayAsync_fn(Args.hipMemMapArrayAsync.mapInfoList, Args.hipMemMapArrayAsync.count, Args.hipMemMapArrayAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemMapArrayAsync_fn(mapInfoList, count, stream);
  }
}

static hipError_t hipMemPoolCreate_wrapper(hipMemPool_t* mem_pool, const hipMemPoolProps* pool_props) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemPoolCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemPoolCreate.mem_pool = mem_pool;
    Args.hipMemPoolCreate.pool_props = pool_props;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemPoolCreate_fn(Args.hipMemPoolCreate.mem_pool, Args.hipMemPoolCreate.pool_props);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemPoolCreate_fn(mem_pool, pool_props);
  }
}

static hipError_t hipMemPoolDestroy_wrapper(hipMemPool_t mem_pool) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemPoolDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemPoolDestroy.mem_pool = mem_pool;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemPoolDestroy_fn(Args.hipMemPoolDestroy.mem_pool);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemPoolDestroy_fn(mem_pool);
  }
}

static hipError_t hipMemPoolExportPointer_wrapper(hipMemPoolPtrExportData* export_data, void* dev_ptr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemPoolExportPointer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemPoolExportPointer.export_data = export_data;
    Args.hipMemPoolExportPointer.dev_ptr = dev_ptr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemPoolExportPointer_fn(Args.hipMemPoolExportPointer.export_data, Args.hipMemPoolExportPointer.dev_ptr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemPoolExportPointer_fn(export_data, dev_ptr);
  }
}

static hipError_t hipMemPoolExportToShareableHandle_wrapper(void* shared_handle, hipMemPool_t mem_pool, hipMemAllocationHandleType handle_type, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemPoolExportToShareableHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemPoolExportToShareableHandle.shared_handle = shared_handle;
    Args.hipMemPoolExportToShareableHandle.mem_pool = mem_pool;
    Args.hipMemPoolExportToShareableHandle.handle_type = handle_type;
    Args.hipMemPoolExportToShareableHandle.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemPoolExportToShareableHandle_fn(Args.hipMemPoolExportToShareableHandle.shared_handle, Args.hipMemPoolExportToShareableHandle.mem_pool, Args.hipMemPoolExportToShareableHandle.handle_type, Args.hipMemPoolExportToShareableHandle.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemPoolExportToShareableHandle_fn(shared_handle, mem_pool, handle_type, flags);
  }
}

static hipError_t hipMemPoolGetAccess_wrapper(hipMemAccessFlags* flags, hipMemPool_t mem_pool, hipMemLocation* location) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemPoolGetAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemPoolGetAccess.flags = flags;
    Args.hipMemPoolGetAccess.mem_pool = mem_pool;
    Args.hipMemPoolGetAccess.location = location;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemPoolGetAccess_fn(Args.hipMemPoolGetAccess.flags, Args.hipMemPoolGetAccess.mem_pool, Args.hipMemPoolGetAccess.location);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemPoolGetAccess_fn(flags, mem_pool, location);
  }
}

static hipError_t hipMemPoolGetAttribute_wrapper(hipMemPool_t mem_pool, hipMemPoolAttr attr, void* value) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemPoolGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemPoolGetAttribute.mem_pool = mem_pool;
    Args.hipMemPoolGetAttribute.attr = attr;
    Args.hipMemPoolGetAttribute.value = value;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemPoolGetAttribute_fn(Args.hipMemPoolGetAttribute.mem_pool, Args.hipMemPoolGetAttribute.attr, Args.hipMemPoolGetAttribute.value);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemPoolGetAttribute_fn(mem_pool, attr, value);
  }
}

static hipError_t hipMemPoolImportFromShareableHandle_wrapper(hipMemPool_t* mem_pool, void* shared_handle, hipMemAllocationHandleType handle_type, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemPoolImportFromShareableHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemPoolImportFromShareableHandle.mem_pool = mem_pool;
    Args.hipMemPoolImportFromShareableHandle.shared_handle = shared_handle;
    Args.hipMemPoolImportFromShareableHandle.handle_type = handle_type;
    Args.hipMemPoolImportFromShareableHandle.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemPoolImportFromShareableHandle_fn(Args.hipMemPoolImportFromShareableHandle.mem_pool, Args.hipMemPoolImportFromShareableHandle.shared_handle, Args.hipMemPoolImportFromShareableHandle.handle_type, Args.hipMemPoolImportFromShareableHandle.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemPoolImportFromShareableHandle_fn(mem_pool, shared_handle, handle_type, flags);
  }
}

static hipError_t hipMemPoolImportPointer_wrapper(void** dev_ptr, hipMemPool_t mem_pool, hipMemPoolPtrExportData* export_data) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemPoolImportPointer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemPoolImportPointer.dev_ptr = dev_ptr;
    Args.hipMemPoolImportPointer.mem_pool = mem_pool;
    Args.hipMemPoolImportPointer.export_data = export_data;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemPoolImportPointer_fn(Args.hipMemPoolImportPointer.dev_ptr, Args.hipMemPoolImportPointer.mem_pool, Args.hipMemPoolImportPointer.export_data);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemPoolImportPointer_fn(dev_ptr, mem_pool, export_data);
  }
}

static hipError_t hipMemPoolSetAccess_wrapper(hipMemPool_t mem_pool, const hipMemAccessDesc* desc_list, size_t count) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemPoolSetAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemPoolSetAccess.mem_pool = mem_pool;
    Args.hipMemPoolSetAccess.desc_list = desc_list;
    Args.hipMemPoolSetAccess.count = count;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemPoolSetAccess_fn(Args.hipMemPoolSetAccess.mem_pool, Args.hipMemPoolSetAccess.desc_list, Args.hipMemPoolSetAccess.count);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemPoolSetAccess_fn(mem_pool, desc_list, count);
  }
}

static hipError_t hipMemPoolSetAttribute_wrapper(hipMemPool_t mem_pool, hipMemPoolAttr attr, void* value) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemPoolSetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemPoolSetAttribute.mem_pool = mem_pool;
    Args.hipMemPoolSetAttribute.attr = attr;
    Args.hipMemPoolSetAttribute.value = value;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemPoolSetAttribute_fn(Args.hipMemPoolSetAttribute.mem_pool, Args.hipMemPoolSetAttribute.attr, Args.hipMemPoolSetAttribute.value);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemPoolSetAttribute_fn(mem_pool, attr, value);
  }
}

static hipError_t hipMemPoolTrimTo_wrapper(hipMemPool_t mem_pool, size_t min_bytes_to_hold) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemPoolTrimTo;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemPoolTrimTo.mem_pool = mem_pool;
    Args.hipMemPoolTrimTo.min_bytes_to_hold = min_bytes_to_hold;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemPoolTrimTo_fn(Args.hipMemPoolTrimTo.mem_pool, Args.hipMemPoolTrimTo.min_bytes_to_hold);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemPoolTrimTo_fn(mem_pool, min_bytes_to_hold);
  }
}

static hipError_t hipMemPrefetchAsync_wrapper(const void* dev_ptr, size_t count, int device, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemPrefetchAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemPrefetchAsync.dev_ptr = dev_ptr;
    Args.hipMemPrefetchAsync.count = count;
    Args.hipMemPrefetchAsync.device = device;
    Args.hipMemPrefetchAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemPrefetchAsync_fn(Args.hipMemPrefetchAsync.dev_ptr, Args.hipMemPrefetchAsync.count, Args.hipMemPrefetchAsync.device, Args.hipMemPrefetchAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemPrefetchAsync_fn(dev_ptr, count, device, stream);
  }
}

static hipError_t hipMemPtrGetInfo_wrapper(void* ptr, size_t* size) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemPtrGetInfo;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemPtrGetInfo.ptr = ptr;
    Args.hipMemPtrGetInfo.size = size;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemPtrGetInfo_fn(Args.hipMemPtrGetInfo.ptr, Args.hipMemPtrGetInfo.size);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemPtrGetInfo_fn(ptr, size);
  }
}

static hipError_t hipMemRangeGetAttribute_wrapper(void* data, size_t data_size, hipMemRangeAttribute attribute, const void* dev_ptr, size_t count) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemRangeGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemRangeGetAttribute.data = data;
    Args.hipMemRangeGetAttribute.data_size = data_size;
    Args.hipMemRangeGetAttribute.attribute = attribute;
    Args.hipMemRangeGetAttribute.dev_ptr = dev_ptr;
    Args.hipMemRangeGetAttribute.count = count;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemRangeGetAttribute_fn(Args.hipMemRangeGetAttribute.data, Args.hipMemRangeGetAttribute.data_size, Args.hipMemRangeGetAttribute.attribute, Args.hipMemRangeGetAttribute.dev_ptr, Args.hipMemRangeGetAttribute.count);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemRangeGetAttribute_fn(data, data_size, attribute, dev_ptr, count);
  }
}

static hipError_t hipMemRangeGetAttributes_wrapper(void** data, size_t* data_sizes, hipMemRangeAttribute* attributes, size_t num_attributes, const void* dev_ptr, size_t count) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemRangeGetAttributes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemRangeGetAttributes.data = data;
    Args.hipMemRangeGetAttributes.data_sizes = data_sizes;
    Args.hipMemRangeGetAttributes.attributes = attributes;
    Args.hipMemRangeGetAttributes.num_attributes = num_attributes;
    Args.hipMemRangeGetAttributes.dev_ptr = dev_ptr;
    Args.hipMemRangeGetAttributes.count = count;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemRangeGetAttributes_fn(Args.hipMemRangeGetAttributes.data, Args.hipMemRangeGetAttributes.data_sizes, Args.hipMemRangeGetAttributes.attributes, Args.hipMemRangeGetAttributes.num_attributes, Args.hipMemRangeGetAttributes.dev_ptr, Args.hipMemRangeGetAttributes.count);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemRangeGetAttributes_fn(data, data_sizes, attributes, num_attributes, dev_ptr, count);
  }
}

static hipError_t hipMemRelease_wrapper(hipMemGenericAllocationHandle_t handle) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemRelease;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemRelease.handle = handle;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemRelease_fn(Args.hipMemRelease.handle);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemRelease_fn(handle);
  }
}

static hipError_t hipMemRetainAllocationHandle_wrapper(hipMemGenericAllocationHandle_t* handle, void* addr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemRetainAllocationHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemRetainAllocationHandle.handle = handle;
    Args.hipMemRetainAllocationHandle.addr = addr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemRetainAllocationHandle_fn(Args.hipMemRetainAllocationHandle.handle, Args.hipMemRetainAllocationHandle.addr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemRetainAllocationHandle_fn(handle, addr);
  }
}

static hipError_t hipMemSetAccess_wrapper(void* ptr, size_t size, const hipMemAccessDesc* desc, size_t count) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemSetAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemSetAccess.ptr = ptr;
    Args.hipMemSetAccess.size = size;
    Args.hipMemSetAccess.desc = desc;
    Args.hipMemSetAccess.count = count;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemSetAccess_fn(Args.hipMemSetAccess.ptr, Args.hipMemSetAccess.size, Args.hipMemSetAccess.desc, Args.hipMemSetAccess.count);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemSetAccess_fn(ptr, size, desc, count);
  }
}

static hipError_t hipMemUnmap_wrapper(void* ptr, size_t size) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemUnmap;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemUnmap.ptr = ptr;
    Args.hipMemUnmap.size = size;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemUnmap_fn(Args.hipMemUnmap.ptr, Args.hipMemUnmap.size);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemUnmap_fn(ptr, size);
  }
}

static hipError_t hipMemcpy_wrapper(void* dst, const void* src, size_t sizeBytes, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy.dst = dst;
    Args.hipMemcpy.src = src;
    Args.hipMemcpy.sizeBytes = sizeBytes;
    Args.hipMemcpy.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy_fn(Args.hipMemcpy.dst, Args.hipMemcpy.src, Args.hipMemcpy.sizeBytes, Args.hipMemcpy.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy_fn(dst, src, sizeBytes, kind);
  }
}

static hipError_t hipMemcpy2D_wrapper(void* dst, size_t dpitch, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy2D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy2D.dst = dst;
    Args.hipMemcpy2D.dpitch = dpitch;
    Args.hipMemcpy2D.src = src;
    Args.hipMemcpy2D.spitch = spitch;
    Args.hipMemcpy2D.width = width;
    Args.hipMemcpy2D.height = height;
    Args.hipMemcpy2D.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy2D_fn(Args.hipMemcpy2D.dst, Args.hipMemcpy2D.dpitch, Args.hipMemcpy2D.src, Args.hipMemcpy2D.spitch, Args.hipMemcpy2D.width, Args.hipMemcpy2D.height, Args.hipMemcpy2D.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy2D_fn(dst, dpitch, src, spitch, width, height, kind);
  }
}

static hipError_t hipMemcpy2DAsync_wrapper(void* dst, size_t dpitch, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy2DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy2DAsync.dst = dst;
    Args.hipMemcpy2DAsync.dpitch = dpitch;
    Args.hipMemcpy2DAsync.src = src;
    Args.hipMemcpy2DAsync.spitch = spitch;
    Args.hipMemcpy2DAsync.width = width;
    Args.hipMemcpy2DAsync.height = height;
    Args.hipMemcpy2DAsync.kind = kind;
    Args.hipMemcpy2DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy2DAsync_fn(Args.hipMemcpy2DAsync.dst, Args.hipMemcpy2DAsync.dpitch, Args.hipMemcpy2DAsync.src, Args.hipMemcpy2DAsync.spitch, Args.hipMemcpy2DAsync.width, Args.hipMemcpy2DAsync.height, Args.hipMemcpy2DAsync.kind, Args.hipMemcpy2DAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy2DAsync_fn(dst, dpitch, src, spitch, width, height, kind, stream);
  }
}

static hipError_t hipMemcpy2DFromArray_wrapper(void* dst, size_t dpitch, hipArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy2DFromArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy2DFromArray.dst = dst;
    Args.hipMemcpy2DFromArray.dpitch = dpitch;
    Args.hipMemcpy2DFromArray.src = src;
    Args.hipMemcpy2DFromArray.wOffset = wOffset;
    Args.hipMemcpy2DFromArray.hOffset = hOffset;
    Args.hipMemcpy2DFromArray.width = width;
    Args.hipMemcpy2DFromArray.height = height;
    Args.hipMemcpy2DFromArray.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy2DFromArray_fn(Args.hipMemcpy2DFromArray.dst, Args.hipMemcpy2DFromArray.dpitch, Args.hipMemcpy2DFromArray.src, Args.hipMemcpy2DFromArray.wOffset, Args.hipMemcpy2DFromArray.hOffset, Args.hipMemcpy2DFromArray.width, Args.hipMemcpy2DFromArray.height, Args.hipMemcpy2DFromArray.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy2DFromArray_fn(dst, dpitch, src, wOffset, hOffset, width, height, kind);
  }
}

static hipError_t hipMemcpy2DFromArrayAsync_wrapper(void* dst, size_t dpitch, hipArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy2DFromArrayAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy2DFromArrayAsync.dst = dst;
    Args.hipMemcpy2DFromArrayAsync.dpitch = dpitch;
    Args.hipMemcpy2DFromArrayAsync.src = src;
    Args.hipMemcpy2DFromArrayAsync.wOffset = wOffset;
    Args.hipMemcpy2DFromArrayAsync.hOffset = hOffset;
    Args.hipMemcpy2DFromArrayAsync.width = width;
    Args.hipMemcpy2DFromArrayAsync.height = height;
    Args.hipMemcpy2DFromArrayAsync.kind = kind;
    Args.hipMemcpy2DFromArrayAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy2DFromArrayAsync_fn(Args.hipMemcpy2DFromArrayAsync.dst, Args.hipMemcpy2DFromArrayAsync.dpitch, Args.hipMemcpy2DFromArrayAsync.src, Args.hipMemcpy2DFromArrayAsync.wOffset, Args.hipMemcpy2DFromArrayAsync.hOffset, Args.hipMemcpy2DFromArrayAsync.width, Args.hipMemcpy2DFromArrayAsync.height, Args.hipMemcpy2DFromArrayAsync.kind, Args.hipMemcpy2DFromArrayAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy2DFromArrayAsync_fn(dst, dpitch, src, wOffset, hOffset, width, height, kind, stream);
  }
}

static hipError_t hipMemcpy2DToArray_wrapper(hipArray_t dst, size_t wOffset, size_t hOffset, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy2DToArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy2DToArray.dst = dst;
    Args.hipMemcpy2DToArray.wOffset = wOffset;
    Args.hipMemcpy2DToArray.hOffset = hOffset;
    Args.hipMemcpy2DToArray.src = src;
    Args.hipMemcpy2DToArray.spitch = spitch;
    Args.hipMemcpy2DToArray.width = width;
    Args.hipMemcpy2DToArray.height = height;
    Args.hipMemcpy2DToArray.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy2DToArray_fn(Args.hipMemcpy2DToArray.dst, Args.hipMemcpy2DToArray.wOffset, Args.hipMemcpy2DToArray.hOffset, Args.hipMemcpy2DToArray.src, Args.hipMemcpy2DToArray.spitch, Args.hipMemcpy2DToArray.width, Args.hipMemcpy2DToArray.height, Args.hipMemcpy2DToArray.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy2DToArray_fn(dst, wOffset, hOffset, src, spitch, width, height, kind);
  }
}

static hipError_t hipMemcpy2DToArrayAsync_wrapper(hipArray_t dst, size_t wOffset, size_t hOffset, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy2DToArrayAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy2DToArrayAsync.dst = dst;
    Args.hipMemcpy2DToArrayAsync.wOffset = wOffset;
    Args.hipMemcpy2DToArrayAsync.hOffset = hOffset;
    Args.hipMemcpy2DToArrayAsync.src = src;
    Args.hipMemcpy2DToArrayAsync.spitch = spitch;
    Args.hipMemcpy2DToArrayAsync.width = width;
    Args.hipMemcpy2DToArrayAsync.height = height;
    Args.hipMemcpy2DToArrayAsync.kind = kind;
    Args.hipMemcpy2DToArrayAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy2DToArrayAsync_fn(Args.hipMemcpy2DToArrayAsync.dst, Args.hipMemcpy2DToArrayAsync.wOffset, Args.hipMemcpy2DToArrayAsync.hOffset, Args.hipMemcpy2DToArrayAsync.src, Args.hipMemcpy2DToArrayAsync.spitch, Args.hipMemcpy2DToArrayAsync.width, Args.hipMemcpy2DToArrayAsync.height, Args.hipMemcpy2DToArrayAsync.kind, Args.hipMemcpy2DToArrayAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy2DToArrayAsync_fn(dst, wOffset, hOffset, src, spitch, width, height, kind, stream);
  }
}

static hipError_t hipMemcpy3D_wrapper(const struct hipMemcpy3DParms* p) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy3D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy3D.p = p;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy3D_fn(Args.hipMemcpy3D.p);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy3D_fn(p);
  }
}

static hipError_t hipMemcpy3DAsync_wrapper(const struct hipMemcpy3DParms* p, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy3DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy3DAsync.p = p;
    Args.hipMemcpy3DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy3DAsync_fn(Args.hipMemcpy3DAsync.p, Args.hipMemcpy3DAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy3DAsync_fn(p, stream);
  }
}

static hipError_t hipMemcpyAsync_wrapper(void* dst, const void* src, size_t sizeBytes, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyAsync.dst = dst;
    Args.hipMemcpyAsync.src = src;
    Args.hipMemcpyAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyAsync.kind = kind;
    Args.hipMemcpyAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyAsync_fn(Args.hipMemcpyAsync.dst, Args.hipMemcpyAsync.src, Args.hipMemcpyAsync.sizeBytes, Args.hipMemcpyAsync.kind, Args.hipMemcpyAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyAsync_fn(dst, src, sizeBytes, kind, stream);
  }
}

static hipError_t hipMemcpyAtoH_wrapper(void* dst, hipArray_t srcArray, size_t srcOffset, size_t count) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyAtoH;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyAtoH.dst = dst;
    Args.hipMemcpyAtoH.srcArray = srcArray;
    Args.hipMemcpyAtoH.srcOffset = srcOffset;
    Args.hipMemcpyAtoH.count = count;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyAtoH_fn(Args.hipMemcpyAtoH.dst, Args.hipMemcpyAtoH.srcArray, Args.hipMemcpyAtoH.srcOffset, Args.hipMemcpyAtoH.count);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyAtoH_fn(dst, srcArray, srcOffset, count);
  }
}

static hipError_t hipMemcpyDtoD_wrapper(hipDeviceptr_t dst, hipDeviceptr_t src, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyDtoD;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyDtoD.dst = dst;
    Args.hipMemcpyDtoD.src = src;
    Args.hipMemcpyDtoD.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyDtoD_fn(Args.hipMemcpyDtoD.dst, Args.hipMemcpyDtoD.src, Args.hipMemcpyDtoD.sizeBytes);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyDtoD_fn(dst, src, sizeBytes);
  }
}

static hipError_t hipMemcpyDtoDAsync_wrapper(hipDeviceptr_t dst, hipDeviceptr_t src, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyDtoDAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyDtoDAsync.dst = dst;
    Args.hipMemcpyDtoDAsync.src = src;
    Args.hipMemcpyDtoDAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyDtoDAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyDtoDAsync_fn(Args.hipMemcpyDtoDAsync.dst, Args.hipMemcpyDtoDAsync.src, Args.hipMemcpyDtoDAsync.sizeBytes, Args.hipMemcpyDtoDAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyDtoDAsync_fn(dst, src, sizeBytes, stream);
  }
}

static hipError_t hipMemcpyDtoH_wrapper(void* dst, hipDeviceptr_t src, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyDtoH;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyDtoH.dst = dst;
    Args.hipMemcpyDtoH.src = src;
    Args.hipMemcpyDtoH.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyDtoH_fn(Args.hipMemcpyDtoH.dst, Args.hipMemcpyDtoH.src, Args.hipMemcpyDtoH.sizeBytes);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyDtoH_fn(dst, src, sizeBytes);
  }
}

static hipError_t hipMemcpyDtoHAsync_wrapper(void* dst, hipDeviceptr_t src, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyDtoHAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyDtoHAsync.dst = dst;
    Args.hipMemcpyDtoHAsync.src = src;
    Args.hipMemcpyDtoHAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyDtoHAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyDtoHAsync_fn(Args.hipMemcpyDtoHAsync.dst, Args.hipMemcpyDtoHAsync.src, Args.hipMemcpyDtoHAsync.sizeBytes, Args.hipMemcpyDtoHAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyDtoHAsync_fn(dst, src, sizeBytes, stream);
  }
}

static hipError_t hipMemcpyFromArray_wrapper(void* dst, hipArray_const_t srcArray, size_t wOffset, size_t hOffset, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyFromArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyFromArray.dst = dst;
    Args.hipMemcpyFromArray.srcArray = srcArray;
    Args.hipMemcpyFromArray.wOffset = wOffset;
    Args.hipMemcpyFromArray.hOffset = hOffset;
    Args.hipMemcpyFromArray.count = count;
    Args.hipMemcpyFromArray.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyFromArray_fn(Args.hipMemcpyFromArray.dst, Args.hipMemcpyFromArray.srcArray, Args.hipMemcpyFromArray.wOffset, Args.hipMemcpyFromArray.hOffset, Args.hipMemcpyFromArray.count, Args.hipMemcpyFromArray.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyFromArray_fn(dst, srcArray, wOffset, hOffset, count, kind);
  }
}

static hipError_t hipMemcpyFromSymbol_wrapper(void* dst, const void* symbol, size_t sizeBytes, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyFromSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyFromSymbol.dst = dst;
    Args.hipMemcpyFromSymbol.symbol = symbol;
    Args.hipMemcpyFromSymbol.sizeBytes = sizeBytes;
    Args.hipMemcpyFromSymbol.offset = offset;
    Args.hipMemcpyFromSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyFromSymbol_fn(Args.hipMemcpyFromSymbol.dst, Args.hipMemcpyFromSymbol.symbol, Args.hipMemcpyFromSymbol.sizeBytes, Args.hipMemcpyFromSymbol.offset, Args.hipMemcpyFromSymbol.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyFromSymbol_fn(dst, symbol, sizeBytes, offset, kind);
  }
}

static hipError_t hipMemcpyFromSymbolAsync_wrapper(void* dst, const void* symbol, size_t sizeBytes, size_t offset, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyFromSymbolAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyFromSymbolAsync.dst = dst;
    Args.hipMemcpyFromSymbolAsync.symbol = symbol;
    Args.hipMemcpyFromSymbolAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyFromSymbolAsync.offset = offset;
    Args.hipMemcpyFromSymbolAsync.kind = kind;
    Args.hipMemcpyFromSymbolAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyFromSymbolAsync_fn(Args.hipMemcpyFromSymbolAsync.dst, Args.hipMemcpyFromSymbolAsync.symbol, Args.hipMemcpyFromSymbolAsync.sizeBytes, Args.hipMemcpyFromSymbolAsync.offset, Args.hipMemcpyFromSymbolAsync.kind, Args.hipMemcpyFromSymbolAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyFromSymbolAsync_fn(dst, symbol, sizeBytes, offset, kind, stream);
  }
}

static hipError_t hipMemcpyHtoA_wrapper(hipArray_t dstArray, size_t dstOffset, const void* srcHost, size_t count) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyHtoA;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyHtoA.dstArray = dstArray;
    Args.hipMemcpyHtoA.dstOffset = dstOffset;
    Args.hipMemcpyHtoA.srcHost = srcHost;
    Args.hipMemcpyHtoA.count = count;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyHtoA_fn(Args.hipMemcpyHtoA.dstArray, Args.hipMemcpyHtoA.dstOffset, Args.hipMemcpyHtoA.srcHost, Args.hipMemcpyHtoA.count);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyHtoA_fn(dstArray, dstOffset, srcHost, count);
  }
}

static hipError_t hipMemcpyHtoD_wrapper(hipDeviceptr_t dst, void* src, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyHtoD;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyHtoD.dst = dst;
    Args.hipMemcpyHtoD.src = src;
    Args.hipMemcpyHtoD.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyHtoD_fn(Args.hipMemcpyHtoD.dst, Args.hipMemcpyHtoD.src, Args.hipMemcpyHtoD.sizeBytes);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyHtoD_fn(dst, src, sizeBytes);
  }
}

static hipError_t hipMemcpyHtoDAsync_wrapper(hipDeviceptr_t dst, void* src, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyHtoDAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyHtoDAsync.dst = dst;
    Args.hipMemcpyHtoDAsync.src = src;
    Args.hipMemcpyHtoDAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyHtoDAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyHtoDAsync_fn(Args.hipMemcpyHtoDAsync.dst, Args.hipMemcpyHtoDAsync.src, Args.hipMemcpyHtoDAsync.sizeBytes, Args.hipMemcpyHtoDAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyHtoDAsync_fn(dst, src, sizeBytes, stream);
  }
}

static hipError_t hipMemcpyParam2D_wrapper(const hip_Memcpy2D* pCopy) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyParam2D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyParam2D.pCopy = pCopy;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyParam2D_fn(Args.hipMemcpyParam2D.pCopy);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyParam2D_fn(pCopy);
  }
}

static hipError_t hipMemcpyParam2DAsync_wrapper(const hip_Memcpy2D* pCopy, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyParam2DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyParam2DAsync.pCopy = pCopy;
    Args.hipMemcpyParam2DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyParam2DAsync_fn(Args.hipMemcpyParam2DAsync.pCopy, Args.hipMemcpyParam2DAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyParam2DAsync_fn(pCopy, stream);
  }
}

static hipError_t hipMemcpyPeer_wrapper(void* dst, int dstDeviceId, const void* src, int srcDeviceId, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyPeer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyPeer.dst = dst;
    Args.hipMemcpyPeer.dstDeviceId = dstDeviceId;
    Args.hipMemcpyPeer.src = src;
    Args.hipMemcpyPeer.srcDeviceId = srcDeviceId;
    Args.hipMemcpyPeer.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyPeer_fn(Args.hipMemcpyPeer.dst, Args.hipMemcpyPeer.dstDeviceId, Args.hipMemcpyPeer.src, Args.hipMemcpyPeer.srcDeviceId, Args.hipMemcpyPeer.sizeBytes);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyPeer_fn(dst, dstDeviceId, src, srcDeviceId, sizeBytes);
  }
}

static hipError_t hipMemcpyPeerAsync_wrapper(void* dst, int dstDeviceId, const void* src, int srcDevice, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyPeerAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyPeerAsync.dst = dst;
    Args.hipMemcpyPeerAsync.dstDeviceId = dstDeviceId;
    Args.hipMemcpyPeerAsync.src = src;
    Args.hipMemcpyPeerAsync.srcDevice = srcDevice;
    Args.hipMemcpyPeerAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyPeerAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyPeerAsync_fn(Args.hipMemcpyPeerAsync.dst, Args.hipMemcpyPeerAsync.dstDeviceId, Args.hipMemcpyPeerAsync.src, Args.hipMemcpyPeerAsync.srcDevice, Args.hipMemcpyPeerAsync.sizeBytes, Args.hipMemcpyPeerAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyPeerAsync_fn(dst, dstDeviceId, src, srcDevice, sizeBytes, stream);
  }
}

static hipError_t hipMemcpyToArray_wrapper(hipArray_t dst, size_t wOffset, size_t hOffset, const void* src, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyToArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyToArray.dst = dst;
    Args.hipMemcpyToArray.wOffset = wOffset;
    Args.hipMemcpyToArray.hOffset = hOffset;
    Args.hipMemcpyToArray.src = src;
    Args.hipMemcpyToArray.count = count;
    Args.hipMemcpyToArray.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyToArray_fn(Args.hipMemcpyToArray.dst, Args.hipMemcpyToArray.wOffset, Args.hipMemcpyToArray.hOffset, Args.hipMemcpyToArray.src, Args.hipMemcpyToArray.count, Args.hipMemcpyToArray.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyToArray_fn(dst, wOffset, hOffset, src, count, kind);
  }
}

static hipError_t hipMemcpyToSymbol_wrapper(const void* symbol, const void* src, size_t sizeBytes, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyToSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyToSymbol.symbol = symbol;
    Args.hipMemcpyToSymbol.src = src;
    Args.hipMemcpyToSymbol.sizeBytes = sizeBytes;
    Args.hipMemcpyToSymbol.offset = offset;
    Args.hipMemcpyToSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyToSymbol_fn(Args.hipMemcpyToSymbol.symbol, Args.hipMemcpyToSymbol.src, Args.hipMemcpyToSymbol.sizeBytes, Args.hipMemcpyToSymbol.offset, Args.hipMemcpyToSymbol.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyToSymbol_fn(symbol, src, sizeBytes, offset, kind);
  }
}

static hipError_t hipMemcpyToSymbolAsync_wrapper(const void* symbol, const void* src, size_t sizeBytes, size_t offset, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyToSymbolAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyToSymbolAsync.symbol = symbol;
    Args.hipMemcpyToSymbolAsync.src = src;
    Args.hipMemcpyToSymbolAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyToSymbolAsync.offset = offset;
    Args.hipMemcpyToSymbolAsync.kind = kind;
    Args.hipMemcpyToSymbolAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyToSymbolAsync_fn(Args.hipMemcpyToSymbolAsync.symbol, Args.hipMemcpyToSymbolAsync.src, Args.hipMemcpyToSymbolAsync.sizeBytes, Args.hipMemcpyToSymbolAsync.offset, Args.hipMemcpyToSymbolAsync.kind, Args.hipMemcpyToSymbolAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyToSymbolAsync_fn(symbol, src, sizeBytes, offset, kind, stream);
  }
}

static hipError_t hipMemcpyWithStream_wrapper(void* dst, const void* src, size_t sizeBytes, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyWithStream;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyWithStream.dst = dst;
    Args.hipMemcpyWithStream.src = src;
    Args.hipMemcpyWithStream.sizeBytes = sizeBytes;
    Args.hipMemcpyWithStream.kind = kind;
    Args.hipMemcpyWithStream.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyWithStream_fn(Args.hipMemcpyWithStream.dst, Args.hipMemcpyWithStream.src, Args.hipMemcpyWithStream.sizeBytes, Args.hipMemcpyWithStream.kind, Args.hipMemcpyWithStream.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyWithStream_fn(dst, src, sizeBytes, kind, stream);
  }
}

static hipError_t hipMemset_wrapper(void* dst, int value, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemset;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemset.dst = dst;
    Args.hipMemset.value = value;
    Args.hipMemset.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemset_fn(Args.hipMemset.dst, Args.hipMemset.value, Args.hipMemset.sizeBytes);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemset_fn(dst, value, sizeBytes);
  }
}

static hipError_t hipMemset2D_wrapper(void* dst, size_t pitch, int value, size_t width, size_t height) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemset2D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemset2D.dst = dst;
    Args.hipMemset2D.pitch = pitch;
    Args.hipMemset2D.value = value;
    Args.hipMemset2D.width = width;
    Args.hipMemset2D.height = height;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemset2D_fn(Args.hipMemset2D.dst, Args.hipMemset2D.pitch, Args.hipMemset2D.value, Args.hipMemset2D.width, Args.hipMemset2D.height);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemset2D_fn(dst, pitch, value, width, height);
  }
}

static hipError_t hipMemset2DAsync_wrapper(void* dst, size_t pitch, int value, size_t width, size_t height, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemset2DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemset2DAsync.dst = dst;
    Args.hipMemset2DAsync.pitch = pitch;
    Args.hipMemset2DAsync.value = value;
    Args.hipMemset2DAsync.width = width;
    Args.hipMemset2DAsync.height = height;
    Args.hipMemset2DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemset2DAsync_fn(Args.hipMemset2DAsync.dst, Args.hipMemset2DAsync.pitch, Args.hipMemset2DAsync.value, Args.hipMemset2DAsync.width, Args.hipMemset2DAsync.height, Args.hipMemset2DAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemset2DAsync_fn(dst, pitch, value, width, height, stream);
  }
}

static hipError_t hipMemset3D_wrapper(hipPitchedPtr pitchedDevPtr, int value, hipExtent extent) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemset3D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemset3D.pitchedDevPtr = pitchedDevPtr;
    Args.hipMemset3D.value = value;
    Args.hipMemset3D.extent = extent;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemset3D_fn(Args.hipMemset3D.pitchedDevPtr, Args.hipMemset3D.value, Args.hipMemset3D.extent);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemset3D_fn(pitchedDevPtr, value, extent);
  }
}

static hipError_t hipMemset3DAsync_wrapper(hipPitchedPtr pitchedDevPtr, int value, hipExtent extent, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemset3DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemset3DAsync.pitchedDevPtr = pitchedDevPtr;
    Args.hipMemset3DAsync.value = value;
    Args.hipMemset3DAsync.extent = extent;
    Args.hipMemset3DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemset3DAsync_fn(Args.hipMemset3DAsync.pitchedDevPtr, Args.hipMemset3DAsync.value, Args.hipMemset3DAsync.extent, Args.hipMemset3DAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemset3DAsync_fn(pitchedDevPtr, value, extent, stream);
  }
}

static hipError_t hipMemsetAsync_wrapper(void* dst, int value, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemsetAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemsetAsync.dst = dst;
    Args.hipMemsetAsync.value = value;
    Args.hipMemsetAsync.sizeBytes = sizeBytes;
    Args.hipMemsetAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemsetAsync_fn(Args.hipMemsetAsync.dst, Args.hipMemsetAsync.value, Args.hipMemsetAsync.sizeBytes, Args.hipMemsetAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemsetAsync_fn(dst, value, sizeBytes, stream);
  }
}

static hipError_t hipMemsetD16_wrapper(hipDeviceptr_t dest, unsigned short value, size_t count) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemsetD16;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemsetD16.dest = dest;
    Args.hipMemsetD16.value = value;
    Args.hipMemsetD16.count = count;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemsetD16_fn(Args.hipMemsetD16.dest, Args.hipMemsetD16.value, Args.hipMemsetD16.count);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemsetD16_fn(dest, value, count);
  }
}

static hipError_t hipMemsetD16Async_wrapper(hipDeviceptr_t dest, unsigned short value, size_t count, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemsetD16Async;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemsetD16Async.dest = dest;
    Args.hipMemsetD16Async.value = value;
    Args.hipMemsetD16Async.count = count;
    Args.hipMemsetD16Async.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemsetD16Async_fn(Args.hipMemsetD16Async.dest, Args.hipMemsetD16Async.value, Args.hipMemsetD16Async.count, Args.hipMemsetD16Async.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemsetD16Async_fn(dest, value, count, stream);
  }
}

static hipError_t hipMemsetD32_wrapper(hipDeviceptr_t dest, int value, size_t count) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemsetD32;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemsetD32.dest = dest;
    Args.hipMemsetD32.value = value;
    Args.hipMemsetD32.count = count;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemsetD32_fn(Args.hipMemsetD32.dest, Args.hipMemsetD32.value, Args.hipMemsetD32.count);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemsetD32_fn(dest, value, count);
  }
}

static hipError_t hipMemsetD32Async_wrapper(hipDeviceptr_t dst, int value, size_t count, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemsetD32Async;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemsetD32Async.dst = dst;
    Args.hipMemsetD32Async.value = value;
    Args.hipMemsetD32Async.count = count;
    Args.hipMemsetD32Async.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemsetD32Async_fn(Args.hipMemsetD32Async.dst, Args.hipMemsetD32Async.value, Args.hipMemsetD32Async.count, Args.hipMemsetD32Async.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemsetD32Async_fn(dst, value, count, stream);
  }
}

static hipError_t hipMemsetD8_wrapper(hipDeviceptr_t dest, unsigned char value, size_t count) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemsetD8;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemsetD8.dest = dest;
    Args.hipMemsetD8.value = value;
    Args.hipMemsetD8.count = count;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemsetD8_fn(Args.hipMemsetD8.dest, Args.hipMemsetD8.value, Args.hipMemsetD8.count);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemsetD8_fn(dest, value, count);
  }
}

static hipError_t hipMemsetD8Async_wrapper(hipDeviceptr_t dest, unsigned char value, size_t count, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemsetD8Async;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemsetD8Async.dest = dest;
    Args.hipMemsetD8Async.value = value;
    Args.hipMemsetD8Async.count = count;
    Args.hipMemsetD8Async.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemsetD8Async_fn(Args.hipMemsetD8Async.dest, Args.hipMemsetD8Async.value, Args.hipMemsetD8Async.count, Args.hipMemsetD8Async.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemsetD8Async_fn(dest, value, count, stream);
  }
}

static hipError_t hipMipmappedArrayCreate_wrapper(hipMipmappedArray_t* pHandle, HIP_ARRAY3D_DESCRIPTOR* pMipmappedArrayDesc, unsigned int numMipmapLevels) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMipmappedArrayCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMipmappedArrayCreate.pHandle = pHandle;
    Args.hipMipmappedArrayCreate.pMipmappedArrayDesc = pMipmappedArrayDesc;
    Args.hipMipmappedArrayCreate.numMipmapLevels = numMipmapLevels;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMipmappedArrayCreate_fn(Args.hipMipmappedArrayCreate.pHandle, Args.hipMipmappedArrayCreate.pMipmappedArrayDesc, Args.hipMipmappedArrayCreate.numMipmapLevels);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMipmappedArrayCreate_fn(pHandle, pMipmappedArrayDesc, numMipmapLevels);
  }
}

static hipError_t hipMipmappedArrayDestroy_wrapper(hipMipmappedArray_t hMipmappedArray) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMipmappedArrayDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMipmappedArrayDestroy.hMipmappedArray = hMipmappedArray;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMipmappedArrayDestroy_fn(Args.hipMipmappedArrayDestroy.hMipmappedArray);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMipmappedArrayDestroy_fn(hMipmappedArray);
  }
}

static hipError_t hipMipmappedArrayGetLevel_wrapper(hipArray_t* pLevelArray, hipMipmappedArray_t hMipMappedArray, unsigned int level) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMipmappedArrayGetLevel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMipmappedArrayGetLevel.pLevelArray = pLevelArray;
    Args.hipMipmappedArrayGetLevel.hMipMappedArray = hMipMappedArray;
    Args.hipMipmappedArrayGetLevel.level = level;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMipmappedArrayGetLevel_fn(Args.hipMipmappedArrayGetLevel.pLevelArray, Args.hipMipmappedArrayGetLevel.hMipMappedArray, Args.hipMipmappedArrayGetLevel.level);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMipmappedArrayGetLevel_fn(pLevelArray, hMipMappedArray, level);
  }
}

static hipError_t hipModuleGetFunction_wrapper(hipFunction_t* function, hipModule_t module, const char* kname) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipModuleGetFunction;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipModuleGetFunction.function = function;
    Args.hipModuleGetFunction.module = module;
    Args.hipModuleGetFunction.kname = kname;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipModuleGetFunction_fn(Args.hipModuleGetFunction.function, Args.hipModuleGetFunction.module, Args.hipModuleGetFunction.kname);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipModuleGetFunction_fn(function, module, kname);
  }
}

static hipError_t hipModuleGetGlobal_wrapper(hipDeviceptr_t* dptr, size_t* bytes, hipModule_t hmod, const char* name) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipModuleGetGlobal;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipModuleGetGlobal.dptr = dptr;
    Args.hipModuleGetGlobal.bytes = bytes;
    Args.hipModuleGetGlobal.hmod = hmod;
    Args.hipModuleGetGlobal.name = name;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipModuleGetGlobal_fn(Args.hipModuleGetGlobal.dptr, Args.hipModuleGetGlobal.bytes, Args.hipModuleGetGlobal.hmod, Args.hipModuleGetGlobal.name);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipModuleGetGlobal_fn(dptr, bytes, hmod, name);
  }
}

static hipError_t hipModuleGetTexRef_wrapper(textureReference** texRef, hipModule_t hmod, const char* name) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipModuleGetTexRef;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipModuleGetTexRef.texRef = texRef;
    Args.hipModuleGetTexRef.hmod = hmod;
    Args.hipModuleGetTexRef.name = name;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipModuleGetTexRef_fn(Args.hipModuleGetTexRef.texRef, Args.hipModuleGetTexRef.hmod, Args.hipModuleGetTexRef.name);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipModuleGetTexRef_fn(texRef, hmod, name);
  }
}

static hipError_t hipModuleLaunchCooperativeKernel_wrapper(hipFunction_t f, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, hipStream_t stream, void** kernelParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipModuleLaunchCooperativeKernel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipModuleLaunchCooperativeKernel.f = f;
    Args.hipModuleLaunchCooperativeKernel.gridDimX = gridDimX;
    Args.hipModuleLaunchCooperativeKernel.gridDimY = gridDimY;
    Args.hipModuleLaunchCooperativeKernel.gridDimZ = gridDimZ;
    Args.hipModuleLaunchCooperativeKernel.blockDimX = blockDimX;
    Args.hipModuleLaunchCooperativeKernel.blockDimY = blockDimY;
    Args.hipModuleLaunchCooperativeKernel.blockDimZ = blockDimZ;
    Args.hipModuleLaunchCooperativeKernel.sharedMemBytes = sharedMemBytes;
    Args.hipModuleLaunchCooperativeKernel.stream = stream;
    Args.hipModuleLaunchCooperativeKernel.kernelParams = kernelParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipModuleLaunchCooperativeKernel_fn(Args.hipModuleLaunchCooperativeKernel.f, Args.hipModuleLaunchCooperativeKernel.gridDimX, Args.hipModuleLaunchCooperativeKernel.gridDimY, Args.hipModuleLaunchCooperativeKernel.gridDimZ, Args.hipModuleLaunchCooperativeKernel.blockDimX, Args.hipModuleLaunchCooperativeKernel.blockDimY, Args.hipModuleLaunchCooperativeKernel.blockDimZ, Args.hipModuleLaunchCooperativeKernel.sharedMemBytes, Args.hipModuleLaunchCooperativeKernel.stream, Args.hipModuleLaunchCooperativeKernel.kernelParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipModuleLaunchCooperativeKernel_fn(f, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, stream, kernelParams);
  }
}

static hipError_t hipModuleLaunchCooperativeKernelMultiDevice_wrapper(hipFunctionLaunchParams* launchParamsList, unsigned int numDevices, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipModuleLaunchCooperativeKernelMultiDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipModuleLaunchCooperativeKernelMultiDevice.launchParamsList = launchParamsList;
    Args.hipModuleLaunchCooperativeKernelMultiDevice.numDevices = numDevices;
    Args.hipModuleLaunchCooperativeKernelMultiDevice.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipModuleLaunchCooperativeKernelMultiDevice_fn(Args.hipModuleLaunchCooperativeKernelMultiDevice.launchParamsList, Args.hipModuleLaunchCooperativeKernelMultiDevice.numDevices, Args.hipModuleLaunchCooperativeKernelMultiDevice.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipModuleLaunchCooperativeKernelMultiDevice_fn(launchParamsList, numDevices, flags);
  }
}

static hipError_t hipModuleLaunchKernel_wrapper(hipFunction_t f, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, hipStream_t stream, void** kernelParams, void** extra) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipModuleLaunchKernel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipModuleLaunchKernel.f = f;
    Args.hipModuleLaunchKernel.gridDimX = gridDimX;
    Args.hipModuleLaunchKernel.gridDimY = gridDimY;
    Args.hipModuleLaunchKernel.gridDimZ = gridDimZ;
    Args.hipModuleLaunchKernel.blockDimX = blockDimX;
    Args.hipModuleLaunchKernel.blockDimY = blockDimY;
    Args.hipModuleLaunchKernel.blockDimZ = blockDimZ;
    Args.hipModuleLaunchKernel.sharedMemBytes = sharedMemBytes;
    Args.hipModuleLaunchKernel.stream = stream;
    Args.hipModuleLaunchKernel.kernelParams = kernelParams;
    Args.hipModuleLaunchKernel.extra = extra;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipModuleLaunchKernel_fn(Args.hipModuleLaunchKernel.f, Args.hipModuleLaunchKernel.gridDimX, Args.hipModuleLaunchKernel.gridDimY, Args.hipModuleLaunchKernel.gridDimZ, Args.hipModuleLaunchKernel.blockDimX, Args.hipModuleLaunchKernel.blockDimY, Args.hipModuleLaunchKernel.blockDimZ, Args.hipModuleLaunchKernel.sharedMemBytes, Args.hipModuleLaunchKernel.stream, Args.hipModuleLaunchKernel.kernelParams, Args.hipModuleLaunchKernel.extra);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipModuleLaunchKernel_fn(f, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, stream, kernelParams, extra);
  }
}

static hipError_t hipModuleLoad_wrapper(hipModule_t* module, const char* fname) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipModuleLoad;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipModuleLoad.module = module;
    Args.hipModuleLoad.fname = fname;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipModuleLoad_fn(Args.hipModuleLoad.module, Args.hipModuleLoad.fname);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipModuleLoad_fn(module, fname);
  }
}

static hipError_t hipModuleLoadData_wrapper(hipModule_t* module, const void* image) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipModuleLoadData;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipModuleLoadData.module = module;
    Args.hipModuleLoadData.image = image;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipModuleLoadData_fn(Args.hipModuleLoadData.module, Args.hipModuleLoadData.image);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipModuleLoadData_fn(module, image);
  }
}

static hipError_t hipModuleLoadDataEx_wrapper(hipModule_t* module, const void* image, unsigned int numOptions, hipJitOption* options, void** optionValues) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipModuleLoadDataEx;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipModuleLoadDataEx.module = module;
    Args.hipModuleLoadDataEx.image = image;
    Args.hipModuleLoadDataEx.numOptions = numOptions;
    Args.hipModuleLoadDataEx.options = options;
    Args.hipModuleLoadDataEx.optionValues = optionValues;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipModuleLoadDataEx_fn(Args.hipModuleLoadDataEx.module, Args.hipModuleLoadDataEx.image, Args.hipModuleLoadDataEx.numOptions, Args.hipModuleLoadDataEx.options, Args.hipModuleLoadDataEx.optionValues);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipModuleLoadDataEx_fn(module, image, numOptions, options, optionValues);
  }
}

static hipError_t hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_wrapper(int* numBlocks, hipFunction_t f, int blockSize, size_t dynSharedMemPerBlk) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipModuleOccupancyMaxActiveBlocksPerMultiprocessor;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.numBlocks = numBlocks;
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.f = f;
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.blockSize = blockSize;
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.dynSharedMemPerBlk = dynSharedMemPerBlk;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_fn(Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.numBlocks, Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.f, Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.blockSize, Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.dynSharedMemPerBlk);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_fn(numBlocks, f, blockSize, dynSharedMemPerBlk);
  }
}

static hipError_t hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_wrapper(int* numBlocks, hipFunction_t f, int blockSize, size_t dynSharedMemPerBlk, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.numBlocks = numBlocks;
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.f = f;
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.blockSize = blockSize;
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.dynSharedMemPerBlk = dynSharedMemPerBlk;
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_fn(Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.numBlocks, Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.f, Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.blockSize, Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.dynSharedMemPerBlk, Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_fn(numBlocks, f, blockSize, dynSharedMemPerBlk, flags);
  }
}

static hipError_t hipModuleOccupancyMaxPotentialBlockSize_wrapper(int* gridSize, int* blockSize, hipFunction_t f, size_t dynSharedMemPerBlk, int blockSizeLimit) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipModuleOccupancyMaxPotentialBlockSize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipModuleOccupancyMaxPotentialBlockSize.gridSize = gridSize;
    Args.hipModuleOccupancyMaxPotentialBlockSize.blockSize = blockSize;
    Args.hipModuleOccupancyMaxPotentialBlockSize.f = f;
    Args.hipModuleOccupancyMaxPotentialBlockSize.dynSharedMemPerBlk = dynSharedMemPerBlk;
    Args.hipModuleOccupancyMaxPotentialBlockSize.blockSizeLimit = blockSizeLimit;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipModuleOccupancyMaxPotentialBlockSize_fn(Args.hipModuleOccupancyMaxPotentialBlockSize.gridSize, Args.hipModuleOccupancyMaxPotentialBlockSize.blockSize, Args.hipModuleOccupancyMaxPotentialBlockSize.f, Args.hipModuleOccupancyMaxPotentialBlockSize.dynSharedMemPerBlk, Args.hipModuleOccupancyMaxPotentialBlockSize.blockSizeLimit);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipModuleOccupancyMaxPotentialBlockSize_fn(gridSize, blockSize, f, dynSharedMemPerBlk, blockSizeLimit);
  }
}

static hipError_t hipModuleOccupancyMaxPotentialBlockSizeWithFlags_wrapper(int* gridSize, int* blockSize, hipFunction_t f, size_t dynSharedMemPerBlk, int blockSizeLimit, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipModuleOccupancyMaxPotentialBlockSizeWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.gridSize = gridSize;
    Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.blockSize = blockSize;
    Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.f = f;
    Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.dynSharedMemPerBlk = dynSharedMemPerBlk;
    Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.blockSizeLimit = blockSizeLimit;
    Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipModuleOccupancyMaxPotentialBlockSizeWithFlags_fn(Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.gridSize, Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.blockSize, Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.f, Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.dynSharedMemPerBlk, Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.blockSizeLimit, Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipModuleOccupancyMaxPotentialBlockSizeWithFlags_fn(gridSize, blockSize, f, dynSharedMemPerBlk, blockSizeLimit, flags);
  }
}

static hipError_t hipModuleUnload_wrapper(hipModule_t module) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipModuleUnload;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipModuleUnload.module = module;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipModuleUnload_fn(Args.hipModuleUnload.module);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipModuleUnload_fn(module);
  }
}

static hipError_t hipOccupancyMaxActiveBlocksPerMultiprocessor_wrapper(int* numBlocks, const void* f, int blockSize, size_t dynSharedMemPerBlk) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipOccupancyMaxActiveBlocksPerMultiprocessor;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessor.numBlocks = numBlocks;
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessor.f = f;
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessor.blockSize = blockSize;
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessor.dynSharedMemPerBlk = dynSharedMemPerBlk;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipOccupancyMaxActiveBlocksPerMultiprocessor_fn(Args.hipOccupancyMaxActiveBlocksPerMultiprocessor.numBlocks, Args.hipOccupancyMaxActiveBlocksPerMultiprocessor.f, Args.hipOccupancyMaxActiveBlocksPerMultiprocessor.blockSize, Args.hipOccupancyMaxActiveBlocksPerMultiprocessor.dynSharedMemPerBlk);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipOccupancyMaxActiveBlocksPerMultiprocessor_fn(numBlocks, f, blockSize, dynSharedMemPerBlk);
  }
}

static hipError_t hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_wrapper(int* numBlocks, const void* f, int blockSize, size_t dynSharedMemPerBlk, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.numBlocks = numBlocks;
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.f = f;
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.blockSize = blockSize;
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.dynSharedMemPerBlk = dynSharedMemPerBlk;
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_fn(Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.numBlocks, Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.f, Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.blockSize, Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.dynSharedMemPerBlk, Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_fn(numBlocks, f, blockSize, dynSharedMemPerBlk, flags);
  }
}

static hipError_t hipOccupancyMaxPotentialBlockSize_wrapper(int* gridSize, int* blockSize, const void* f, size_t dynSharedMemPerBlk, int blockSizeLimit) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipOccupancyMaxPotentialBlockSize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipOccupancyMaxPotentialBlockSize.gridSize = gridSize;
    Args.hipOccupancyMaxPotentialBlockSize.blockSize = blockSize;
    Args.hipOccupancyMaxPotentialBlockSize.f = f;
    Args.hipOccupancyMaxPotentialBlockSize.dynSharedMemPerBlk = dynSharedMemPerBlk;
    Args.hipOccupancyMaxPotentialBlockSize.blockSizeLimit = blockSizeLimit;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipOccupancyMaxPotentialBlockSize_fn(Args.hipOccupancyMaxPotentialBlockSize.gridSize, Args.hipOccupancyMaxPotentialBlockSize.blockSize, Args.hipOccupancyMaxPotentialBlockSize.f, Args.hipOccupancyMaxPotentialBlockSize.dynSharedMemPerBlk, Args.hipOccupancyMaxPotentialBlockSize.blockSizeLimit);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipOccupancyMaxPotentialBlockSize_fn(gridSize, blockSize, f, dynSharedMemPerBlk, blockSizeLimit);
  }
}

static hipError_t hipPeekAtLastError_wrapper() {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipPeekAtLastError;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipPeekAtLastError_fn();
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipPeekAtLastError_fn();
  }
}

static hipError_t hipPointerGetAttribute_wrapper(void* data, hipPointer_attribute attribute, hipDeviceptr_t ptr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipPointerGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipPointerGetAttribute.data = data;
    Args.hipPointerGetAttribute.attribute = attribute;
    Args.hipPointerGetAttribute.ptr = ptr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipPointerGetAttribute_fn(Args.hipPointerGetAttribute.data, Args.hipPointerGetAttribute.attribute, Args.hipPointerGetAttribute.ptr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipPointerGetAttribute_fn(data, attribute, ptr);
  }
}

static hipError_t hipPointerGetAttributes_wrapper(hipPointerAttribute_t* attributes, const void* ptr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipPointerGetAttributes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipPointerGetAttributes.attributes = attributes;
    Args.hipPointerGetAttributes.ptr = ptr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipPointerGetAttributes_fn(Args.hipPointerGetAttributes.attributes, Args.hipPointerGetAttributes.ptr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipPointerGetAttributes_fn(attributes, ptr);
  }
}

static hipError_t hipPointerSetAttribute_wrapper(const void* value, hipPointer_attribute attribute, hipDeviceptr_t ptr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipPointerSetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipPointerSetAttribute.value = value;
    Args.hipPointerSetAttribute.attribute = attribute;
    Args.hipPointerSetAttribute.ptr = ptr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipPointerSetAttribute_fn(Args.hipPointerSetAttribute.value, Args.hipPointerSetAttribute.attribute, Args.hipPointerSetAttribute.ptr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipPointerSetAttribute_fn(value, attribute, ptr);
  }
}

static hipError_t hipProfilerStart_wrapper() {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipProfilerStart;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipProfilerStart_fn();
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipProfilerStart_fn();
  }
}

static hipError_t hipProfilerStop_wrapper() {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipProfilerStop;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipProfilerStop_fn();
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipProfilerStop_fn();
  }
}

static hipError_t hipRuntimeGetVersion_wrapper(int* runtimeVersion) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipRuntimeGetVersion;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipRuntimeGetVersion.runtimeVersion = runtimeVersion;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipRuntimeGetVersion_fn(Args.hipRuntimeGetVersion.runtimeVersion);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipRuntimeGetVersion_fn(runtimeVersion);
  }
}

static hipError_t hipSetDevice_wrapper(int deviceId) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipSetDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipSetDevice.deviceId = deviceId;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipSetDevice_fn(Args.hipSetDevice.deviceId);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipSetDevice_fn(deviceId);
  }
}

static hipError_t hipSetDeviceFlags_wrapper(unsigned flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipSetDeviceFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipSetDeviceFlags.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipSetDeviceFlags_fn(Args.hipSetDeviceFlags.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipSetDeviceFlags_fn(flags);
  }
}

static hipError_t hipSetupArgument_wrapper(const void* arg, size_t size, size_t offset) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipSetupArgument;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipSetupArgument.arg = arg;
    Args.hipSetupArgument.size = size;
    Args.hipSetupArgument.offset = offset;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipSetupArgument_fn(Args.hipSetupArgument.arg, Args.hipSetupArgument.size, Args.hipSetupArgument.offset);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipSetupArgument_fn(arg, size, offset);
  }
}

static hipError_t hipSignalExternalSemaphoresAsync_wrapper(const hipExternalSemaphore_t* extSemArray, const hipExternalSemaphoreSignalParams* paramsArray, unsigned int numExtSems, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipSignalExternalSemaphoresAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipSignalExternalSemaphoresAsync.extSemArray = extSemArray;
    Args.hipSignalExternalSemaphoresAsync.paramsArray = paramsArray;
    Args.hipSignalExternalSemaphoresAsync.numExtSems = numExtSems;
    Args.hipSignalExternalSemaphoresAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipSignalExternalSemaphoresAsync_fn(Args.hipSignalExternalSemaphoresAsync.extSemArray, Args.hipSignalExternalSemaphoresAsync.paramsArray, Args.hipSignalExternalSemaphoresAsync.numExtSems, Args.hipSignalExternalSemaphoresAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipSignalExternalSemaphoresAsync_fn(extSemArray, paramsArray, numExtSems, stream);
  }
}

static hipError_t hipStreamAddCallback_wrapper(hipStream_t stream, hipStreamCallback_t callback, void* userData, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamAddCallback;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamAddCallback.stream = stream;
    Args.hipStreamAddCallback.callback = callback;
    Args.hipStreamAddCallback.userData = userData;
    Args.hipStreamAddCallback.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamAddCallback_fn(Args.hipStreamAddCallback.stream, Args.hipStreamAddCallback.callback, Args.hipStreamAddCallback.userData, Args.hipStreamAddCallback.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamAddCallback_fn(stream, callback, userData, flags);
  }
}

static hipError_t hipStreamAttachMemAsync_wrapper(hipStream_t stream, void* dev_ptr, size_t length, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamAttachMemAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamAttachMemAsync.stream = stream;
    Args.hipStreamAttachMemAsync.dev_ptr = dev_ptr;
    Args.hipStreamAttachMemAsync.length = length;
    Args.hipStreamAttachMemAsync.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamAttachMemAsync_fn(Args.hipStreamAttachMemAsync.stream, Args.hipStreamAttachMemAsync.dev_ptr, Args.hipStreamAttachMemAsync.length, Args.hipStreamAttachMemAsync.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamAttachMemAsync_fn(stream, dev_ptr, length, flags);
  }
}

static hipError_t hipStreamBeginCapture_wrapper(hipStream_t stream, hipStreamCaptureMode mode) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamBeginCapture;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamBeginCapture.stream = stream;
    Args.hipStreamBeginCapture.mode = mode;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamBeginCapture_fn(Args.hipStreamBeginCapture.stream, Args.hipStreamBeginCapture.mode);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamBeginCapture_fn(stream, mode);
  }
}

static hipError_t hipStreamCreate_wrapper(hipStream_t* stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamCreate.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamCreate_fn(Args.hipStreamCreate.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamCreate_fn(stream);
  }
}

static hipError_t hipStreamCreateWithFlags_wrapper(hipStream_t* stream, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamCreateWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamCreateWithFlags.stream = stream;
    Args.hipStreamCreateWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamCreateWithFlags_fn(Args.hipStreamCreateWithFlags.stream, Args.hipStreamCreateWithFlags.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamCreateWithFlags_fn(stream, flags);
  }
}

static hipError_t hipStreamCreateWithPriority_wrapper(hipStream_t* stream, unsigned int flags, int priority) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamCreateWithPriority;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamCreateWithPriority.stream = stream;
    Args.hipStreamCreateWithPriority.flags = flags;
    Args.hipStreamCreateWithPriority.priority = priority;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamCreateWithPriority_fn(Args.hipStreamCreateWithPriority.stream, Args.hipStreamCreateWithPriority.flags, Args.hipStreamCreateWithPriority.priority);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamCreateWithPriority_fn(stream, flags, priority);
  }
}

static hipError_t hipStreamDestroy_wrapper(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamDestroy.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamDestroy_fn(Args.hipStreamDestroy.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamDestroy_fn(stream);
  }
}

static hipError_t hipStreamEndCapture_wrapper(hipStream_t stream, hipGraph_t* pGraph) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamEndCapture;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamEndCapture.stream = stream;
    Args.hipStreamEndCapture.pGraph = pGraph;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamEndCapture_fn(Args.hipStreamEndCapture.stream, Args.hipStreamEndCapture.pGraph);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamEndCapture_fn(stream, pGraph);
  }
}

static hipError_t hipStreamGetCaptureInfo_wrapper(hipStream_t stream, hipStreamCaptureStatus* pCaptureStatus, unsigned long long* pId) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamGetCaptureInfo;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamGetCaptureInfo.stream = stream;
    Args.hipStreamGetCaptureInfo.pCaptureStatus = pCaptureStatus;
    Args.hipStreamGetCaptureInfo.pId = pId;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamGetCaptureInfo_fn(Args.hipStreamGetCaptureInfo.stream, Args.hipStreamGetCaptureInfo.pCaptureStatus, Args.hipStreamGetCaptureInfo.pId);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamGetCaptureInfo_fn(stream, pCaptureStatus, pId);
  }
}

static hipError_t hipStreamGetCaptureInfo_v2_wrapper(hipStream_t stream, hipStreamCaptureStatus* captureStatus_out, unsigned long long* id_out, hipGraph_t* graph_out, const hipGraphNode_t** dependencies_out, size_t* numDependencies_out) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamGetCaptureInfo_v2;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamGetCaptureInfo_v2.stream = stream;
    Args.hipStreamGetCaptureInfo_v2.captureStatus_out = captureStatus_out;
    Args.hipStreamGetCaptureInfo_v2.id_out = id_out;
    Args.hipStreamGetCaptureInfo_v2.graph_out = graph_out;
    Args.hipStreamGetCaptureInfo_v2.dependencies_out = dependencies_out;
    Args.hipStreamGetCaptureInfo_v2.numDependencies_out = numDependencies_out;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamGetCaptureInfo_v2_fn(Args.hipStreamGetCaptureInfo_v2.stream, Args.hipStreamGetCaptureInfo_v2.captureStatus_out, Args.hipStreamGetCaptureInfo_v2.id_out, Args.hipStreamGetCaptureInfo_v2.graph_out, Args.hipStreamGetCaptureInfo_v2.dependencies_out, Args.hipStreamGetCaptureInfo_v2.numDependencies_out);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamGetCaptureInfo_v2_fn(stream, captureStatus_out, id_out, graph_out, dependencies_out, numDependencies_out);
  }
}

static hipError_t hipStreamGetDevice_wrapper(hipStream_t stream, hipDevice_t* device) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamGetDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamGetDevice.stream = stream;
    Args.hipStreamGetDevice.device = device;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamGetDevice_fn(Args.hipStreamGetDevice.stream, Args.hipStreamGetDevice.device);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamGetDevice_fn(stream, device);
  }
}

static hipError_t hipStreamGetFlags_wrapper(hipStream_t stream, unsigned int* flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamGetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamGetFlags.stream = stream;
    Args.hipStreamGetFlags.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamGetFlags_fn(Args.hipStreamGetFlags.stream, Args.hipStreamGetFlags.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamGetFlags_fn(stream, flags);
  }
}

static hipError_t hipStreamGetPriority_wrapper(hipStream_t stream, int* priority) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamGetPriority;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamGetPriority.stream = stream;
    Args.hipStreamGetPriority.priority = priority;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamGetPriority_fn(Args.hipStreamGetPriority.stream, Args.hipStreamGetPriority.priority);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamGetPriority_fn(stream, priority);
  }
}

static hipError_t hipStreamIsCapturing_wrapper(hipStream_t stream, hipStreamCaptureStatus* pCaptureStatus) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamIsCapturing;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamIsCapturing.stream = stream;
    Args.hipStreamIsCapturing.pCaptureStatus = pCaptureStatus;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamIsCapturing_fn(Args.hipStreamIsCapturing.stream, Args.hipStreamIsCapturing.pCaptureStatus);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamIsCapturing_fn(stream, pCaptureStatus);
  }
}

static hipError_t hipStreamQuery_wrapper(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamQuery;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamQuery.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamQuery_fn(Args.hipStreamQuery.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamQuery_fn(stream);
  }
}

static hipError_t hipStreamSynchronize_wrapper(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamSynchronize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamSynchronize.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamSynchronize_fn(Args.hipStreamSynchronize.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamSynchronize_fn(stream);
  }
}

static hipError_t hipStreamUpdateCaptureDependencies_wrapper(hipStream_t stream, hipGraphNode_t* dependencies, size_t numDependencies, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamUpdateCaptureDependencies;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamUpdateCaptureDependencies.stream = stream;
    Args.hipStreamUpdateCaptureDependencies.dependencies = dependencies;
    Args.hipStreamUpdateCaptureDependencies.numDependencies = numDependencies;
    Args.hipStreamUpdateCaptureDependencies.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamUpdateCaptureDependencies_fn(Args.hipStreamUpdateCaptureDependencies.stream, Args.hipStreamUpdateCaptureDependencies.dependencies, Args.hipStreamUpdateCaptureDependencies.numDependencies, Args.hipStreamUpdateCaptureDependencies.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamUpdateCaptureDependencies_fn(stream, dependencies, numDependencies, flags);
  }
}

static hipError_t hipStreamWaitEvent_wrapper(hipStream_t stream, hipEvent_t event, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamWaitEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamWaitEvent.stream = stream;
    Args.hipStreamWaitEvent.event = event;
    Args.hipStreamWaitEvent.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamWaitEvent_fn(Args.hipStreamWaitEvent.stream, Args.hipStreamWaitEvent.event, Args.hipStreamWaitEvent.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamWaitEvent_fn(stream, event, flags);
  }
}

static hipError_t hipStreamWaitValue32_wrapper(hipStream_t stream, void* ptr, uint32_t value, unsigned int flags, uint32_t mask) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamWaitValue32;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamWaitValue32.stream = stream;
    Args.hipStreamWaitValue32.ptr = ptr;
    Args.hipStreamWaitValue32.value = value;
    Args.hipStreamWaitValue32.flags = flags;
    Args.hipStreamWaitValue32.mask = mask;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamWaitValue32_fn(Args.hipStreamWaitValue32.stream, Args.hipStreamWaitValue32.ptr, Args.hipStreamWaitValue32.value, Args.hipStreamWaitValue32.flags, Args.hipStreamWaitValue32.mask);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamWaitValue32_fn(stream, ptr, value, flags, mask);
  }
}

static hipError_t hipStreamWaitValue64_wrapper(hipStream_t stream, void* ptr, uint64_t value, unsigned int flags, uint64_t mask) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamWaitValue64;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamWaitValue64.stream = stream;
    Args.hipStreamWaitValue64.ptr = ptr;
    Args.hipStreamWaitValue64.value = value;
    Args.hipStreamWaitValue64.flags = flags;
    Args.hipStreamWaitValue64.mask = mask;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamWaitValue64_fn(Args.hipStreamWaitValue64.stream, Args.hipStreamWaitValue64.ptr, Args.hipStreamWaitValue64.value, Args.hipStreamWaitValue64.flags, Args.hipStreamWaitValue64.mask);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamWaitValue64_fn(stream, ptr, value, flags, mask);
  }
}

static hipError_t hipStreamWriteValue32_wrapper(hipStream_t stream, void* ptr, uint32_t value, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamWriteValue32;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamWriteValue32.stream = stream;
    Args.hipStreamWriteValue32.ptr = ptr;
    Args.hipStreamWriteValue32.value = value;
    Args.hipStreamWriteValue32.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamWriteValue32_fn(Args.hipStreamWriteValue32.stream, Args.hipStreamWriteValue32.ptr, Args.hipStreamWriteValue32.value, Args.hipStreamWriteValue32.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamWriteValue32_fn(stream, ptr, value, flags);
  }
}

static hipError_t hipStreamWriteValue64_wrapper(hipStream_t stream, void* ptr, uint64_t value, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamWriteValue64;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamWriteValue64.stream = stream;
    Args.hipStreamWriteValue64.ptr = ptr;
    Args.hipStreamWriteValue64.value = value;
    Args.hipStreamWriteValue64.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamWriteValue64_fn(Args.hipStreamWriteValue64.stream, Args.hipStreamWriteValue64.ptr, Args.hipStreamWriteValue64.value, Args.hipStreamWriteValue64.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamWriteValue64_fn(stream, ptr, value, flags);
  }
}

static hipError_t hipTexObjectCreate_wrapper(hipTextureObject_t* pTexObject, const HIP_RESOURCE_DESC* pResDesc, const HIP_TEXTURE_DESC* pTexDesc, const HIP_RESOURCE_VIEW_DESC* pResViewDesc) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexObjectCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexObjectCreate.pTexObject = pTexObject;
    Args.hipTexObjectCreate.pResDesc = pResDesc;
    Args.hipTexObjectCreate.pTexDesc = pTexDesc;
    Args.hipTexObjectCreate.pResViewDesc = pResViewDesc;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexObjectCreate_fn(Args.hipTexObjectCreate.pTexObject, Args.hipTexObjectCreate.pResDesc, Args.hipTexObjectCreate.pTexDesc, Args.hipTexObjectCreate.pResViewDesc);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexObjectCreate_fn(pTexObject, pResDesc, pTexDesc, pResViewDesc);
  }
}

static hipError_t hipTexObjectDestroy_wrapper(hipTextureObject_t texObject) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexObjectDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexObjectDestroy.texObject = texObject;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexObjectDestroy_fn(Args.hipTexObjectDestroy.texObject);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexObjectDestroy_fn(texObject);
  }
}

static hipError_t hipTexObjectGetResourceDesc_wrapper(HIP_RESOURCE_DESC* pResDesc, hipTextureObject_t texObject) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexObjectGetResourceDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexObjectGetResourceDesc.pResDesc = pResDesc;
    Args.hipTexObjectGetResourceDesc.texObject = texObject;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexObjectGetResourceDesc_fn(Args.hipTexObjectGetResourceDesc.pResDesc, Args.hipTexObjectGetResourceDesc.texObject);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexObjectGetResourceDesc_fn(pResDesc, texObject);
  }
}

static hipError_t hipTexObjectGetResourceViewDesc_wrapper(HIP_RESOURCE_VIEW_DESC* pResViewDesc, hipTextureObject_t texObject) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexObjectGetResourceViewDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexObjectGetResourceViewDesc.pResViewDesc = pResViewDesc;
    Args.hipTexObjectGetResourceViewDesc.texObject = texObject;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexObjectGetResourceViewDesc_fn(Args.hipTexObjectGetResourceViewDesc.pResViewDesc, Args.hipTexObjectGetResourceViewDesc.texObject);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexObjectGetResourceViewDesc_fn(pResViewDesc, texObject);
  }
}

static hipError_t hipTexObjectGetTextureDesc_wrapper(HIP_TEXTURE_DESC* pTexDesc, hipTextureObject_t texObject) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexObjectGetTextureDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexObjectGetTextureDesc.pTexDesc = pTexDesc;
    Args.hipTexObjectGetTextureDesc.texObject = texObject;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexObjectGetTextureDesc_fn(Args.hipTexObjectGetTextureDesc.pTexDesc, Args.hipTexObjectGetTextureDesc.texObject);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexObjectGetTextureDesc_fn(pTexDesc, texObject);
  }
}

static hipError_t hipTexRefGetAddress_wrapper(hipDeviceptr_t* dev_ptr, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefGetAddress;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefGetAddress.dev_ptr = dev_ptr;
    Args.hipTexRefGetAddress.texRef = texRef;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefGetAddress_fn(Args.hipTexRefGetAddress.dev_ptr, Args.hipTexRefGetAddress.texRef);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefGetAddress_fn(dev_ptr, texRef);
  }
}

static hipError_t hipTexRefGetAddressMode_wrapper(enum hipTextureAddressMode* pam, const textureReference* texRef, int dim) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefGetAddressMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefGetAddressMode.pam = pam;
    Args.hipTexRefGetAddressMode.texRef = texRef;
    Args.hipTexRefGetAddressMode.dim = dim;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefGetAddressMode_fn(Args.hipTexRefGetAddressMode.pam, Args.hipTexRefGetAddressMode.texRef, Args.hipTexRefGetAddressMode.dim);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefGetAddressMode_fn(pam, texRef, dim);
  }
}

static hipError_t hipTexRefGetFilterMode_wrapper(enum hipTextureFilterMode* pfm, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefGetFilterMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefGetFilterMode.pfm = pfm;
    Args.hipTexRefGetFilterMode.texRef = texRef;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefGetFilterMode_fn(Args.hipTexRefGetFilterMode.pfm, Args.hipTexRefGetFilterMode.texRef);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefGetFilterMode_fn(pfm, texRef);
  }
}

static hipError_t hipTexRefGetFlags_wrapper(unsigned int* pFlags, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefGetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefGetFlags.pFlags = pFlags;
    Args.hipTexRefGetFlags.texRef = texRef;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefGetFlags_fn(Args.hipTexRefGetFlags.pFlags, Args.hipTexRefGetFlags.texRef);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefGetFlags_fn(pFlags, texRef);
  }
}

static hipError_t hipTexRefGetFormat_wrapper(hipArray_Format* pFormat, int* pNumChannels, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefGetFormat;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefGetFormat.pFormat = pFormat;
    Args.hipTexRefGetFormat.pNumChannels = pNumChannels;
    Args.hipTexRefGetFormat.texRef = texRef;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefGetFormat_fn(Args.hipTexRefGetFormat.pFormat, Args.hipTexRefGetFormat.pNumChannels, Args.hipTexRefGetFormat.texRef);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefGetFormat_fn(pFormat, pNumChannels, texRef);
  }
}

static hipError_t hipTexRefGetMaxAnisotropy_wrapper(int* pmaxAnsio, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefGetMaxAnisotropy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefGetMaxAnisotropy.pmaxAnsio = pmaxAnsio;
    Args.hipTexRefGetMaxAnisotropy.texRef = texRef;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefGetMaxAnisotropy_fn(Args.hipTexRefGetMaxAnisotropy.pmaxAnsio, Args.hipTexRefGetMaxAnisotropy.texRef);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefGetMaxAnisotropy_fn(pmaxAnsio, texRef);
  }
}

static hipError_t hipTexRefGetMipMappedArray_wrapper(hipMipmappedArray_t* pArray, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefGetMipMappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefGetMipMappedArray.pArray = pArray;
    Args.hipTexRefGetMipMappedArray.texRef = texRef;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefGetMipMappedArray_fn(Args.hipTexRefGetMipMappedArray.pArray, Args.hipTexRefGetMipMappedArray.texRef);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefGetMipMappedArray_fn(pArray, texRef);
  }
}

static hipError_t hipTexRefGetMipmapFilterMode_wrapper(enum hipTextureFilterMode* pfm, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefGetMipmapFilterMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefGetMipmapFilterMode.pfm = pfm;
    Args.hipTexRefGetMipmapFilterMode.texRef = texRef;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefGetMipmapFilterMode_fn(Args.hipTexRefGetMipmapFilterMode.pfm, Args.hipTexRefGetMipmapFilterMode.texRef);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefGetMipmapFilterMode_fn(pfm, texRef);
  }
}

static hipError_t hipTexRefGetMipmapLevelBias_wrapper(float* pbias, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefGetMipmapLevelBias;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefGetMipmapLevelBias.pbias = pbias;
    Args.hipTexRefGetMipmapLevelBias.texRef = texRef;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefGetMipmapLevelBias_fn(Args.hipTexRefGetMipmapLevelBias.pbias, Args.hipTexRefGetMipmapLevelBias.texRef);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefGetMipmapLevelBias_fn(pbias, texRef);
  }
}

static hipError_t hipTexRefGetMipmapLevelClamp_wrapper(float* pminMipmapLevelClamp, float* pmaxMipmapLevelClamp, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefGetMipmapLevelClamp;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefGetMipmapLevelClamp.pminMipmapLevelClamp = pminMipmapLevelClamp;
    Args.hipTexRefGetMipmapLevelClamp.pmaxMipmapLevelClamp = pmaxMipmapLevelClamp;
    Args.hipTexRefGetMipmapLevelClamp.texRef = texRef;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefGetMipmapLevelClamp_fn(Args.hipTexRefGetMipmapLevelClamp.pminMipmapLevelClamp, Args.hipTexRefGetMipmapLevelClamp.pmaxMipmapLevelClamp, Args.hipTexRefGetMipmapLevelClamp.texRef);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefGetMipmapLevelClamp_fn(pminMipmapLevelClamp, pmaxMipmapLevelClamp, texRef);
  }
}

static hipError_t hipTexRefSetAddress_wrapper(size_t* ByteOffset, textureReference* texRef, hipDeviceptr_t dptr, size_t bytes) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefSetAddress;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefSetAddress.ByteOffset = ByteOffset;
    Args.hipTexRefSetAddress.texRef = texRef;
    Args.hipTexRefSetAddress.dptr = dptr;
    Args.hipTexRefSetAddress.bytes = bytes;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefSetAddress_fn(Args.hipTexRefSetAddress.ByteOffset, Args.hipTexRefSetAddress.texRef, Args.hipTexRefSetAddress.dptr, Args.hipTexRefSetAddress.bytes);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefSetAddress_fn(ByteOffset, texRef, dptr, bytes);
  }
}

static hipError_t hipTexRefSetAddress2D_wrapper(textureReference* texRef, const HIP_ARRAY_DESCRIPTOR* desc, hipDeviceptr_t dptr, size_t Pitch) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefSetAddress2D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefSetAddress2D.texRef = texRef;
    Args.hipTexRefSetAddress2D.desc = desc;
    Args.hipTexRefSetAddress2D.dptr = dptr;
    Args.hipTexRefSetAddress2D.Pitch = Pitch;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefSetAddress2D_fn(Args.hipTexRefSetAddress2D.texRef, Args.hipTexRefSetAddress2D.desc, Args.hipTexRefSetAddress2D.dptr, Args.hipTexRefSetAddress2D.Pitch);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefSetAddress2D_fn(texRef, desc, dptr, Pitch);
  }
}

static hipError_t hipTexRefSetAddressMode_wrapper(textureReference* texRef, int dim, enum hipTextureAddressMode am) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefSetAddressMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefSetAddressMode.texRef = texRef;
    Args.hipTexRefSetAddressMode.dim = dim;
    Args.hipTexRefSetAddressMode.am = am;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefSetAddressMode_fn(Args.hipTexRefSetAddressMode.texRef, Args.hipTexRefSetAddressMode.dim, Args.hipTexRefSetAddressMode.am);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefSetAddressMode_fn(texRef, dim, am);
  }
}

static hipError_t hipTexRefSetArray_wrapper(textureReference* tex, hipArray_const_t array, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefSetArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefSetArray.tex = tex;
    Args.hipTexRefSetArray.array = array;
    Args.hipTexRefSetArray.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefSetArray_fn(Args.hipTexRefSetArray.tex, Args.hipTexRefSetArray.array, Args.hipTexRefSetArray.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefSetArray_fn(tex, array, flags);
  }
}

static hipError_t hipTexRefSetBorderColor_wrapper(textureReference* texRef, float* pBorderColor) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefSetBorderColor;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefSetBorderColor.texRef = texRef;
    Args.hipTexRefSetBorderColor.pBorderColor = pBorderColor;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefSetBorderColor_fn(Args.hipTexRefSetBorderColor.texRef, Args.hipTexRefSetBorderColor.pBorderColor);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefSetBorderColor_fn(texRef, pBorderColor);
  }
}

static hipError_t hipTexRefSetFilterMode_wrapper(textureReference* texRef, enum hipTextureFilterMode fm) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefSetFilterMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefSetFilterMode.texRef = texRef;
    Args.hipTexRefSetFilterMode.fm = fm;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefSetFilterMode_fn(Args.hipTexRefSetFilterMode.texRef, Args.hipTexRefSetFilterMode.fm);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefSetFilterMode_fn(texRef, fm);
  }
}

static hipError_t hipTexRefSetFlags_wrapper(textureReference* texRef, unsigned int Flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefSetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefSetFlags.texRef = texRef;
    Args.hipTexRefSetFlags.Flags = Flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefSetFlags_fn(Args.hipTexRefSetFlags.texRef, Args.hipTexRefSetFlags.Flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefSetFlags_fn(texRef, Flags);
  }
}

static hipError_t hipTexRefSetFormat_wrapper(textureReference* texRef, hipArray_Format fmt, int NumPackedComponents) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefSetFormat;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefSetFormat.texRef = texRef;
    Args.hipTexRefSetFormat.fmt = fmt;
    Args.hipTexRefSetFormat.NumPackedComponents = NumPackedComponents;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefSetFormat_fn(Args.hipTexRefSetFormat.texRef, Args.hipTexRefSetFormat.fmt, Args.hipTexRefSetFormat.NumPackedComponents);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefSetFormat_fn(texRef, fmt, NumPackedComponents);
  }
}

static hipError_t hipTexRefSetMaxAnisotropy_wrapper(textureReference* texRef, unsigned int maxAniso) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefSetMaxAnisotropy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefSetMaxAnisotropy.texRef = texRef;
    Args.hipTexRefSetMaxAnisotropy.maxAniso = maxAniso;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefSetMaxAnisotropy_fn(Args.hipTexRefSetMaxAnisotropy.texRef, Args.hipTexRefSetMaxAnisotropy.maxAniso);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefSetMaxAnisotropy_fn(texRef, maxAniso);
  }
}

static hipError_t hipTexRefSetMipmapFilterMode_wrapper(textureReference* texRef, enum hipTextureFilterMode fm) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefSetMipmapFilterMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefSetMipmapFilterMode.texRef = texRef;
    Args.hipTexRefSetMipmapFilterMode.fm = fm;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefSetMipmapFilterMode_fn(Args.hipTexRefSetMipmapFilterMode.texRef, Args.hipTexRefSetMipmapFilterMode.fm);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefSetMipmapFilterMode_fn(texRef, fm);
  }
}

static hipError_t hipTexRefSetMipmapLevelBias_wrapper(textureReference* texRef, float bias) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefSetMipmapLevelBias;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefSetMipmapLevelBias.texRef = texRef;
    Args.hipTexRefSetMipmapLevelBias.bias = bias;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefSetMipmapLevelBias_fn(Args.hipTexRefSetMipmapLevelBias.texRef, Args.hipTexRefSetMipmapLevelBias.bias);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefSetMipmapLevelBias_fn(texRef, bias);
  }
}

static hipError_t hipTexRefSetMipmapLevelClamp_wrapper(textureReference* texRef, float minMipMapLevelClamp, float maxMipMapLevelClamp) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefSetMipmapLevelClamp;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefSetMipmapLevelClamp.texRef = texRef;
    Args.hipTexRefSetMipmapLevelClamp.minMipMapLevelClamp = minMipMapLevelClamp;
    Args.hipTexRefSetMipmapLevelClamp.maxMipMapLevelClamp = maxMipMapLevelClamp;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefSetMipmapLevelClamp_fn(Args.hipTexRefSetMipmapLevelClamp.texRef, Args.hipTexRefSetMipmapLevelClamp.minMipMapLevelClamp, Args.hipTexRefSetMipmapLevelClamp.maxMipMapLevelClamp);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefSetMipmapLevelClamp_fn(texRef, minMipMapLevelClamp, maxMipMapLevelClamp);
  }
}

static hipError_t hipTexRefSetMipmappedArray_wrapper(textureReference* texRef, struct hipMipmappedArray* mipmappedArray, unsigned int Flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefSetMipmappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefSetMipmappedArray.texRef = texRef;
    Args.hipTexRefSetMipmappedArray.mipmappedArray = mipmappedArray;
    Args.hipTexRefSetMipmappedArray.Flags = Flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefSetMipmappedArray_fn(Args.hipTexRefSetMipmappedArray.texRef, Args.hipTexRefSetMipmappedArray.mipmappedArray, Args.hipTexRefSetMipmappedArray.Flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefSetMipmappedArray_fn(texRef, mipmappedArray, Flags);
  }
}

static hipError_t hipThreadExchangeStreamCaptureMode_wrapper(hipStreamCaptureMode* mode) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipThreadExchangeStreamCaptureMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipThreadExchangeStreamCaptureMode.mode = mode;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipThreadExchangeStreamCaptureMode_fn(Args.hipThreadExchangeStreamCaptureMode.mode);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipThreadExchangeStreamCaptureMode_fn(mode);
  }
}

static hipError_t hipUnbindTexture_wrapper(const textureReference* tex) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipUnbindTexture;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipUnbindTexture.tex = tex;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipUnbindTexture_fn(Args.hipUnbindTexture.tex);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipUnbindTexture_fn(tex);
  }
}

static hipError_t hipUserObjectCreate_wrapper(hipUserObject_t* object_out, void* ptr, hipHostFn_t destroy, unsigned int initialRefcount, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipUserObjectCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipUserObjectCreate.object_out = object_out;
    Args.hipUserObjectCreate.ptr = ptr;
    Args.hipUserObjectCreate.destroy = destroy;
    Args.hipUserObjectCreate.initialRefcount = initialRefcount;
    Args.hipUserObjectCreate.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipUserObjectCreate_fn(Args.hipUserObjectCreate.object_out, Args.hipUserObjectCreate.ptr, Args.hipUserObjectCreate.destroy, Args.hipUserObjectCreate.initialRefcount, Args.hipUserObjectCreate.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipUserObjectCreate_fn(object_out, ptr, destroy, initialRefcount, flags);
  }
}

static hipError_t hipUserObjectRelease_wrapper(hipUserObject_t object, unsigned int count) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipUserObjectRelease;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipUserObjectRelease.object = object;
    Args.hipUserObjectRelease.count = count;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipUserObjectRelease_fn(Args.hipUserObjectRelease.object, Args.hipUserObjectRelease.count);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipUserObjectRelease_fn(object, count);
  }
}

static hipError_t hipUserObjectRetain_wrapper(hipUserObject_t object, unsigned int count) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipUserObjectRetain;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipUserObjectRetain.object = object;
    Args.hipUserObjectRetain.count = count;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipUserObjectRetain_fn(Args.hipUserObjectRetain.object, Args.hipUserObjectRetain.count);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipUserObjectRetain_fn(object, count);
  }
}

static hipError_t hipWaitExternalSemaphoresAsync_wrapper(const hipExternalSemaphore_t* extSemArray, const hipExternalSemaphoreWaitParams* paramsArray, unsigned int numExtSems, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipWaitExternalSemaphoresAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipWaitExternalSemaphoresAsync.extSemArray = extSemArray;
    Args.hipWaitExternalSemaphoresAsync.paramsArray = paramsArray;
    Args.hipWaitExternalSemaphoresAsync.numExtSems = numExtSems;
    Args.hipWaitExternalSemaphoresAsync.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipWaitExternalSemaphoresAsync_fn(Args.hipWaitExternalSemaphoresAsync.extSemArray, Args.hipWaitExternalSemaphoresAsync.paramsArray, Args.hipWaitExternalSemaphoresAsync.numExtSems, Args.hipWaitExternalSemaphoresAsync.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipWaitExternalSemaphoresAsync_fn(extSemArray, paramsArray, numExtSems, stream);
  }
}

static hipChannelFormatDesc hipCreateChannelDesc_wrapper(int x, int y, int z, int w, hipChannelFormatKind f) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipCreateChannelDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipChannelFormatDesc Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipCreateChannelDesc.x = x;
    Args.hipCreateChannelDesc.y = y;
    Args.hipCreateChannelDesc.z = z;
    Args.hipCreateChannelDesc.w = w;
    Args.hipCreateChannelDesc.f = f;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipCreateChannelDesc_fn(Args.hipCreateChannelDesc.x, Args.hipCreateChannelDesc.y, Args.hipCreateChannelDesc.z, Args.hipCreateChannelDesc.w, Args.hipCreateChannelDesc.f);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipCreateChannelDesc_fn(x, y, z, w, f);
  }
}

static hipError_t hipExtModuleLaunchKernel_wrapper(hipFunction_t f, uint32_t globalWorkSizeX, uint32_t globalWorkSizeY, uint32_t globalWorkSizeZ, uint32_t localWorkSizeX, uint32_t localWorkSizeY, uint32_t localWorkSizeZ, size_t sharedMemBytes, hipStream_t hStream, void** kernelParams, void** extra, hipEvent_t startEvent, hipEvent_t stopEvent, uint32_t flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipExtModuleLaunchKernel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipExtModuleLaunchKernel.f = f;
    Args.hipExtModuleLaunchKernel.globalWorkSizeX = globalWorkSizeX;
    Args.hipExtModuleLaunchKernel.globalWorkSizeY = globalWorkSizeY;
    Args.hipExtModuleLaunchKernel.globalWorkSizeZ = globalWorkSizeZ;
    Args.hipExtModuleLaunchKernel.localWorkSizeX = localWorkSizeX;
    Args.hipExtModuleLaunchKernel.localWorkSizeY = localWorkSizeY;
    Args.hipExtModuleLaunchKernel.localWorkSizeZ = localWorkSizeZ;
    Args.hipExtModuleLaunchKernel.sharedMemBytes = sharedMemBytes;
    Args.hipExtModuleLaunchKernel.hStream = hStream;
    Args.hipExtModuleLaunchKernel.kernelParams = kernelParams;
    Args.hipExtModuleLaunchKernel.extra = extra;
    Args.hipExtModuleLaunchKernel.startEvent = startEvent;
    Args.hipExtModuleLaunchKernel.stopEvent = stopEvent;
    Args.hipExtModuleLaunchKernel.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipExtModuleLaunchKernel_fn(Args.hipExtModuleLaunchKernel.f, Args.hipExtModuleLaunchKernel.globalWorkSizeX, Args.hipExtModuleLaunchKernel.globalWorkSizeY, Args.hipExtModuleLaunchKernel.globalWorkSizeZ, Args.hipExtModuleLaunchKernel.localWorkSizeX, Args.hipExtModuleLaunchKernel.localWorkSizeY, Args.hipExtModuleLaunchKernel.localWorkSizeZ, Args.hipExtModuleLaunchKernel.sharedMemBytes, Args.hipExtModuleLaunchKernel.hStream, Args.hipExtModuleLaunchKernel.kernelParams, Args.hipExtModuleLaunchKernel.extra, Args.hipExtModuleLaunchKernel.startEvent, Args.hipExtModuleLaunchKernel.stopEvent, Args.hipExtModuleLaunchKernel.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipExtModuleLaunchKernel_fn(f, globalWorkSizeX, globalWorkSizeY, globalWorkSizeZ, localWorkSizeX, localWorkSizeY, localWorkSizeZ, sharedMemBytes, hStream, kernelParams, extra, startEvent, stopEvent, flags);
  }
}

static hipError_t hipHccModuleLaunchKernel_wrapper(hipFunction_t f, uint32_t globalWorkSizeX, uint32_t globalWorkSizeY, uint32_t globalWorkSizeZ, uint32_t localWorkSizeX, uint32_t localWorkSizeY, uint32_t localWorkSizeZ, size_t sharedMemBytes, hipStream_t hStream, void** kernelParams, void** extra, hipEvent_t startEvent, hipEvent_t stopEvent) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipHccModuleLaunchKernel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipHccModuleLaunchKernel.f = f;
    Args.hipHccModuleLaunchKernel.globalWorkSizeX = globalWorkSizeX;
    Args.hipHccModuleLaunchKernel.globalWorkSizeY = globalWorkSizeY;
    Args.hipHccModuleLaunchKernel.globalWorkSizeZ = globalWorkSizeZ;
    Args.hipHccModuleLaunchKernel.localWorkSizeX = localWorkSizeX;
    Args.hipHccModuleLaunchKernel.localWorkSizeY = localWorkSizeY;
    Args.hipHccModuleLaunchKernel.localWorkSizeZ = localWorkSizeZ;
    Args.hipHccModuleLaunchKernel.sharedMemBytes = sharedMemBytes;
    Args.hipHccModuleLaunchKernel.hStream = hStream;
    Args.hipHccModuleLaunchKernel.kernelParams = kernelParams;
    Args.hipHccModuleLaunchKernel.extra = extra;
    Args.hipHccModuleLaunchKernel.startEvent = startEvent;
    Args.hipHccModuleLaunchKernel.stopEvent = stopEvent;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipHccModuleLaunchKernel_fn(Args.hipHccModuleLaunchKernel.f, Args.hipHccModuleLaunchKernel.globalWorkSizeX, Args.hipHccModuleLaunchKernel.globalWorkSizeY, Args.hipHccModuleLaunchKernel.globalWorkSizeZ, Args.hipHccModuleLaunchKernel.localWorkSizeX, Args.hipHccModuleLaunchKernel.localWorkSizeY, Args.hipHccModuleLaunchKernel.localWorkSizeZ, Args.hipHccModuleLaunchKernel.sharedMemBytes, Args.hipHccModuleLaunchKernel.hStream, Args.hipHccModuleLaunchKernel.kernelParams, Args.hipHccModuleLaunchKernel.extra, Args.hipHccModuleLaunchKernel.startEvent, Args.hipHccModuleLaunchKernel.stopEvent);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipHccModuleLaunchKernel_fn(f, globalWorkSizeX, globalWorkSizeY, globalWorkSizeZ, localWorkSizeX, localWorkSizeY, localWorkSizeZ, sharedMemBytes, hStream, kernelParams, extra, startEvent, stopEvent);
  }
}

static hipError_t hipMemcpy_spt_wrapper(void* dst, const void* src, size_t sizeBytes, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy_spt.dst = dst;
    Args.hipMemcpy_spt.src = src;
    Args.hipMemcpy_spt.sizeBytes = sizeBytes;
    Args.hipMemcpy_spt.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy_spt_fn(Args.hipMemcpy_spt.dst, Args.hipMemcpy_spt.src, Args.hipMemcpy_spt.sizeBytes, Args.hipMemcpy_spt.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy_spt_fn(dst, src, sizeBytes, kind);
  }
}

static hipError_t hipMemcpyToSymbol_spt_wrapper(const void* symbol, const void* src, size_t sizeBytes, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyToSymbol_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyToSymbol_spt.symbol = symbol;
    Args.hipMemcpyToSymbol_spt.src = src;
    Args.hipMemcpyToSymbol_spt.sizeBytes = sizeBytes;
    Args.hipMemcpyToSymbol_spt.offset = offset;
    Args.hipMemcpyToSymbol_spt.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyToSymbol_spt_fn(Args.hipMemcpyToSymbol_spt.symbol, Args.hipMemcpyToSymbol_spt.src, Args.hipMemcpyToSymbol_spt.sizeBytes, Args.hipMemcpyToSymbol_spt.offset, Args.hipMemcpyToSymbol_spt.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyToSymbol_spt_fn(symbol, src, sizeBytes, offset, kind);
  }
}

static hipError_t hipMemcpyFromSymbol_spt_wrapper(void* dst, const void* symbol, size_t sizeBytes, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyFromSymbol_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyFromSymbol_spt.dst = dst;
    Args.hipMemcpyFromSymbol_spt.symbol = symbol;
    Args.hipMemcpyFromSymbol_spt.sizeBytes = sizeBytes;
    Args.hipMemcpyFromSymbol_spt.offset = offset;
    Args.hipMemcpyFromSymbol_spt.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyFromSymbol_spt_fn(Args.hipMemcpyFromSymbol_spt.dst, Args.hipMemcpyFromSymbol_spt.symbol, Args.hipMemcpyFromSymbol_spt.sizeBytes, Args.hipMemcpyFromSymbol_spt.offset, Args.hipMemcpyFromSymbol_spt.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyFromSymbol_spt_fn(dst, symbol, sizeBytes, offset, kind);
  }
}

static hipError_t hipMemcpy2D_spt_wrapper(void* dst, size_t dpitch, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy2D_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy2D_spt.dst = dst;
    Args.hipMemcpy2D_spt.dpitch = dpitch;
    Args.hipMemcpy2D_spt.src = src;
    Args.hipMemcpy2D_spt.spitch = spitch;
    Args.hipMemcpy2D_spt.width = width;
    Args.hipMemcpy2D_spt.height = height;
    Args.hipMemcpy2D_spt.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy2D_spt_fn(Args.hipMemcpy2D_spt.dst, Args.hipMemcpy2D_spt.dpitch, Args.hipMemcpy2D_spt.src, Args.hipMemcpy2D_spt.spitch, Args.hipMemcpy2D_spt.width, Args.hipMemcpy2D_spt.height, Args.hipMemcpy2D_spt.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy2D_spt_fn(dst, dpitch, src, spitch, width, height, kind);
  }
}

static hipError_t hipMemcpy2DFromArray_spt_wrapper(void* dst, size_t dpitch, hipArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy2DFromArray_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy2DFromArray_spt.dst = dst;
    Args.hipMemcpy2DFromArray_spt.dpitch = dpitch;
    Args.hipMemcpy2DFromArray_spt.src = src;
    Args.hipMemcpy2DFromArray_spt.wOffset = wOffset;
    Args.hipMemcpy2DFromArray_spt.hOffset = hOffset;
    Args.hipMemcpy2DFromArray_spt.width = width;
    Args.hipMemcpy2DFromArray_spt.height = height;
    Args.hipMemcpy2DFromArray_spt.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy2DFromArray_spt_fn(Args.hipMemcpy2DFromArray_spt.dst, Args.hipMemcpy2DFromArray_spt.dpitch, Args.hipMemcpy2DFromArray_spt.src, Args.hipMemcpy2DFromArray_spt.wOffset, Args.hipMemcpy2DFromArray_spt.hOffset, Args.hipMemcpy2DFromArray_spt.width, Args.hipMemcpy2DFromArray_spt.height, Args.hipMemcpy2DFromArray_spt.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy2DFromArray_spt_fn(dst, dpitch, src, wOffset, hOffset, width, height, kind);
  }
}

static hipError_t hipMemcpy3D_spt_wrapper(const struct hipMemcpy3DParms* p) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy3D_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy3D_spt.p = p;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy3D_spt_fn(Args.hipMemcpy3D_spt.p);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy3D_spt_fn(p);
  }
}

static hipError_t hipMemset_spt_wrapper(void* dst, int value, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemset_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemset_spt.dst = dst;
    Args.hipMemset_spt.value = value;
    Args.hipMemset_spt.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemset_spt_fn(Args.hipMemset_spt.dst, Args.hipMemset_spt.value, Args.hipMemset_spt.sizeBytes);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemset_spt_fn(dst, value, sizeBytes);
  }
}

static hipError_t hipMemsetAsync_spt_wrapper(void* dst, int value, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemsetAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemsetAsync_spt.dst = dst;
    Args.hipMemsetAsync_spt.value = value;
    Args.hipMemsetAsync_spt.sizeBytes = sizeBytes;
    Args.hipMemsetAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemsetAsync_spt_fn(Args.hipMemsetAsync_spt.dst, Args.hipMemsetAsync_spt.value, Args.hipMemsetAsync_spt.sizeBytes, Args.hipMemsetAsync_spt.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemsetAsync_spt_fn(dst, value, sizeBytes, stream);
  }
}

static hipError_t hipMemset2D_spt_wrapper(void* dst, size_t pitch, int value, size_t width, size_t height) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemset2D_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemset2D_spt.dst = dst;
    Args.hipMemset2D_spt.pitch = pitch;
    Args.hipMemset2D_spt.value = value;
    Args.hipMemset2D_spt.width = width;
    Args.hipMemset2D_spt.height = height;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemset2D_spt_fn(Args.hipMemset2D_spt.dst, Args.hipMemset2D_spt.pitch, Args.hipMemset2D_spt.value, Args.hipMemset2D_spt.width, Args.hipMemset2D_spt.height);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemset2D_spt_fn(dst, pitch, value, width, height);
  }
}

static hipError_t hipMemset2DAsync_spt_wrapper(void* dst, size_t pitch, int value, size_t width, size_t height, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemset2DAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemset2DAsync_spt.dst = dst;
    Args.hipMemset2DAsync_spt.pitch = pitch;
    Args.hipMemset2DAsync_spt.value = value;
    Args.hipMemset2DAsync_spt.width = width;
    Args.hipMemset2DAsync_spt.height = height;
    Args.hipMemset2DAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemset2DAsync_spt_fn(Args.hipMemset2DAsync_spt.dst, Args.hipMemset2DAsync_spt.pitch, Args.hipMemset2DAsync_spt.value, Args.hipMemset2DAsync_spt.width, Args.hipMemset2DAsync_spt.height, Args.hipMemset2DAsync_spt.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemset2DAsync_spt_fn(dst, pitch, value, width, height, stream);
  }
}

static hipError_t hipMemset3DAsync_spt_wrapper(hipPitchedPtr pitchedDevPtr, int value, hipExtent extent, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemset3DAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemset3DAsync_spt.pitchedDevPtr = pitchedDevPtr;
    Args.hipMemset3DAsync_spt.value = value;
    Args.hipMemset3DAsync_spt.extent = extent;
    Args.hipMemset3DAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemset3DAsync_spt_fn(Args.hipMemset3DAsync_spt.pitchedDevPtr, Args.hipMemset3DAsync_spt.value, Args.hipMemset3DAsync_spt.extent, Args.hipMemset3DAsync_spt.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemset3DAsync_spt_fn(pitchedDevPtr, value, extent, stream);
  }
}

static hipError_t hipMemset3D_spt_wrapper(hipPitchedPtr pitchedDevPtr, int value, hipExtent extent) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemset3D_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemset3D_spt.pitchedDevPtr = pitchedDevPtr;
    Args.hipMemset3D_spt.value = value;
    Args.hipMemset3D_spt.extent = extent;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemset3D_spt_fn(Args.hipMemset3D_spt.pitchedDevPtr, Args.hipMemset3D_spt.value, Args.hipMemset3D_spt.extent);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemset3D_spt_fn(pitchedDevPtr, value, extent);
  }
}

static hipError_t hipMemcpyAsync_spt_wrapper(void* dst, const void* src, size_t sizeBytes, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyAsync_spt.dst = dst;
    Args.hipMemcpyAsync_spt.src = src;
    Args.hipMemcpyAsync_spt.sizeBytes = sizeBytes;
    Args.hipMemcpyAsync_spt.kind = kind;
    Args.hipMemcpyAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyAsync_spt_fn(Args.hipMemcpyAsync_spt.dst, Args.hipMemcpyAsync_spt.src, Args.hipMemcpyAsync_spt.sizeBytes, Args.hipMemcpyAsync_spt.kind, Args.hipMemcpyAsync_spt.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyAsync_spt_fn(dst, src, sizeBytes, kind, stream);
  }
}

static hipError_t hipMemcpy3DAsync_spt_wrapper(const hipMemcpy3DParms* p, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy3DAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy3DAsync_spt.p = p;
    Args.hipMemcpy3DAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy3DAsync_spt_fn(Args.hipMemcpy3DAsync_spt.p, Args.hipMemcpy3DAsync_spt.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy3DAsync_spt_fn(p, stream);
  }
}

static hipError_t hipMemcpy2DAsync_spt_wrapper(void* dst, size_t dpitch, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy2DAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy2DAsync_spt.dst = dst;
    Args.hipMemcpy2DAsync_spt.dpitch = dpitch;
    Args.hipMemcpy2DAsync_spt.src = src;
    Args.hipMemcpy2DAsync_spt.spitch = spitch;
    Args.hipMemcpy2DAsync_spt.width = width;
    Args.hipMemcpy2DAsync_spt.height = height;
    Args.hipMemcpy2DAsync_spt.kind = kind;
    Args.hipMemcpy2DAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy2DAsync_spt_fn(Args.hipMemcpy2DAsync_spt.dst, Args.hipMemcpy2DAsync_spt.dpitch, Args.hipMemcpy2DAsync_spt.src, Args.hipMemcpy2DAsync_spt.spitch, Args.hipMemcpy2DAsync_spt.width, Args.hipMemcpy2DAsync_spt.height, Args.hipMemcpy2DAsync_spt.kind, Args.hipMemcpy2DAsync_spt.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy2DAsync_spt_fn(dst, dpitch, src, spitch, width, height, kind, stream);
  }
}

static hipError_t hipMemcpyFromSymbolAsync_spt_wrapper(void* dst, const void* symbol, size_t sizeBytes, size_t offset, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyFromSymbolAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyFromSymbolAsync_spt.dst = dst;
    Args.hipMemcpyFromSymbolAsync_spt.symbol = symbol;
    Args.hipMemcpyFromSymbolAsync_spt.sizeBytes = sizeBytes;
    Args.hipMemcpyFromSymbolAsync_spt.offset = offset;
    Args.hipMemcpyFromSymbolAsync_spt.kind = kind;
    Args.hipMemcpyFromSymbolAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyFromSymbolAsync_spt_fn(Args.hipMemcpyFromSymbolAsync_spt.dst, Args.hipMemcpyFromSymbolAsync_spt.symbol, Args.hipMemcpyFromSymbolAsync_spt.sizeBytes, Args.hipMemcpyFromSymbolAsync_spt.offset, Args.hipMemcpyFromSymbolAsync_spt.kind, Args.hipMemcpyFromSymbolAsync_spt.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyFromSymbolAsync_spt_fn(dst, symbol, sizeBytes, offset, kind, stream);
  }
}

static hipError_t hipMemcpyToSymbolAsync_spt_wrapper(const void* symbol, const void* src, size_t sizeBytes, size_t offset, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyToSymbolAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyToSymbolAsync_spt.symbol = symbol;
    Args.hipMemcpyToSymbolAsync_spt.src = src;
    Args.hipMemcpyToSymbolAsync_spt.sizeBytes = sizeBytes;
    Args.hipMemcpyToSymbolAsync_spt.offset = offset;
    Args.hipMemcpyToSymbolAsync_spt.kind = kind;
    Args.hipMemcpyToSymbolAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyToSymbolAsync_spt_fn(Args.hipMemcpyToSymbolAsync_spt.symbol, Args.hipMemcpyToSymbolAsync_spt.src, Args.hipMemcpyToSymbolAsync_spt.sizeBytes, Args.hipMemcpyToSymbolAsync_spt.offset, Args.hipMemcpyToSymbolAsync_spt.kind, Args.hipMemcpyToSymbolAsync_spt.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyToSymbolAsync_spt_fn(symbol, src, sizeBytes, offset, kind, stream);
  }
}

static hipError_t hipMemcpyFromArray_spt_wrapper(void* dst, hipArray_const_t src, size_t wOffsetSrc, size_t hOffset, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpyFromArray_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpyFromArray_spt.dst = dst;
    Args.hipMemcpyFromArray_spt.src = src;
    Args.hipMemcpyFromArray_spt.wOffsetSrc = wOffsetSrc;
    Args.hipMemcpyFromArray_spt.hOffset = hOffset;
    Args.hipMemcpyFromArray_spt.count = count;
    Args.hipMemcpyFromArray_spt.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpyFromArray_spt_fn(Args.hipMemcpyFromArray_spt.dst, Args.hipMemcpyFromArray_spt.src, Args.hipMemcpyFromArray_spt.wOffsetSrc, Args.hipMemcpyFromArray_spt.hOffset, Args.hipMemcpyFromArray_spt.count, Args.hipMemcpyFromArray_spt.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpyFromArray_spt_fn(dst, src, wOffsetSrc, hOffset, count, kind);
  }
}

static hipError_t hipMemcpy2DToArray_spt_wrapper(hipArray_t dst, size_t wOffset, size_t hOffset, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy2DToArray_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy2DToArray_spt.dst = dst;
    Args.hipMemcpy2DToArray_spt.wOffset = wOffset;
    Args.hipMemcpy2DToArray_spt.hOffset = hOffset;
    Args.hipMemcpy2DToArray_spt.src = src;
    Args.hipMemcpy2DToArray_spt.spitch = spitch;
    Args.hipMemcpy2DToArray_spt.width = width;
    Args.hipMemcpy2DToArray_spt.height = height;
    Args.hipMemcpy2DToArray_spt.kind = kind;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy2DToArray_spt_fn(Args.hipMemcpy2DToArray_spt.dst, Args.hipMemcpy2DToArray_spt.wOffset, Args.hipMemcpy2DToArray_spt.hOffset, Args.hipMemcpy2DToArray_spt.src, Args.hipMemcpy2DToArray_spt.spitch, Args.hipMemcpy2DToArray_spt.width, Args.hipMemcpy2DToArray_spt.height, Args.hipMemcpy2DToArray_spt.kind);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy2DToArray_spt_fn(dst, wOffset, hOffset, src, spitch, width, height, kind);
  }
}

static hipError_t hipMemcpy2DFromArrayAsync_spt_wrapper(void* dst, size_t dpitch, hipArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy2DFromArrayAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy2DFromArrayAsync_spt.dst = dst;
    Args.hipMemcpy2DFromArrayAsync_spt.dpitch = dpitch;
    Args.hipMemcpy2DFromArrayAsync_spt.src = src;
    Args.hipMemcpy2DFromArrayAsync_spt.wOffsetSrc = wOffsetSrc;
    Args.hipMemcpy2DFromArrayAsync_spt.hOffsetSrc = hOffsetSrc;
    Args.hipMemcpy2DFromArrayAsync_spt.width = width;
    Args.hipMemcpy2DFromArrayAsync_spt.height = height;
    Args.hipMemcpy2DFromArrayAsync_spt.kind = kind;
    Args.hipMemcpy2DFromArrayAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy2DFromArrayAsync_spt_fn(Args.hipMemcpy2DFromArrayAsync_spt.dst, Args.hipMemcpy2DFromArrayAsync_spt.dpitch, Args.hipMemcpy2DFromArrayAsync_spt.src, Args.hipMemcpy2DFromArrayAsync_spt.wOffsetSrc, Args.hipMemcpy2DFromArrayAsync_spt.hOffsetSrc, Args.hipMemcpy2DFromArrayAsync_spt.width, Args.hipMemcpy2DFromArrayAsync_spt.height, Args.hipMemcpy2DFromArrayAsync_spt.kind, Args.hipMemcpy2DFromArrayAsync_spt.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy2DFromArrayAsync_spt_fn(dst, dpitch, src, wOffsetSrc, hOffsetSrc, width, height, kind, stream);
  }
}

static hipError_t hipMemcpy2DToArrayAsync_spt_wrapper(hipArray_t dst, size_t wOffset, size_t hOffset, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipMemcpy2DToArrayAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipMemcpy2DToArrayAsync_spt.dst = dst;
    Args.hipMemcpy2DToArrayAsync_spt.wOffset = wOffset;
    Args.hipMemcpy2DToArrayAsync_spt.hOffset = hOffset;
    Args.hipMemcpy2DToArrayAsync_spt.src = src;
    Args.hipMemcpy2DToArrayAsync_spt.spitch = spitch;
    Args.hipMemcpy2DToArrayAsync_spt.width = width;
    Args.hipMemcpy2DToArrayAsync_spt.height = height;
    Args.hipMemcpy2DToArrayAsync_spt.kind = kind;
    Args.hipMemcpy2DToArrayAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipMemcpy2DToArrayAsync_spt_fn(Args.hipMemcpy2DToArrayAsync_spt.dst, Args.hipMemcpy2DToArrayAsync_spt.wOffset, Args.hipMemcpy2DToArrayAsync_spt.hOffset, Args.hipMemcpy2DToArrayAsync_spt.src, Args.hipMemcpy2DToArrayAsync_spt.spitch, Args.hipMemcpy2DToArrayAsync_spt.width, Args.hipMemcpy2DToArrayAsync_spt.height, Args.hipMemcpy2DToArrayAsync_spt.kind, Args.hipMemcpy2DToArrayAsync_spt.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipMemcpy2DToArrayAsync_spt_fn(dst, wOffset, hOffset, src, spitch, width, height, kind, stream);
  }
}

static hipError_t hipStreamQuery_spt_wrapper(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamQuery_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamQuery_spt.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamQuery_spt_fn(Args.hipStreamQuery_spt.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamQuery_spt_fn(stream);
  }
}

static hipError_t hipStreamSynchronize_spt_wrapper(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamSynchronize_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamSynchronize_spt.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamSynchronize_spt_fn(Args.hipStreamSynchronize_spt.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamSynchronize_spt_fn(stream);
  }
}

static hipError_t hipStreamGetPriority_spt_wrapper(hipStream_t stream, int* priority) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamGetPriority_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamGetPriority_spt.stream = stream;
    Args.hipStreamGetPriority_spt.priority = priority;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamGetPriority_spt_fn(Args.hipStreamGetPriority_spt.stream, Args.hipStreamGetPriority_spt.priority);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamGetPriority_spt_fn(stream, priority);
  }
}

static hipError_t hipStreamWaitEvent_spt_wrapper(hipStream_t stream, hipEvent_t event, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamWaitEvent_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamWaitEvent_spt.stream = stream;
    Args.hipStreamWaitEvent_spt.event = event;
    Args.hipStreamWaitEvent_spt.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamWaitEvent_spt_fn(Args.hipStreamWaitEvent_spt.stream, Args.hipStreamWaitEvent_spt.event, Args.hipStreamWaitEvent_spt.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamWaitEvent_spt_fn(stream, event, flags);
  }
}

static hipError_t hipStreamGetFlags_spt_wrapper(hipStream_t stream, unsigned int* flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamGetFlags_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamGetFlags_spt.stream = stream;
    Args.hipStreamGetFlags_spt.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamGetFlags_spt_fn(Args.hipStreamGetFlags_spt.stream, Args.hipStreamGetFlags_spt.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamGetFlags_spt_fn(stream, flags);
  }
}

static hipError_t hipStreamAddCallback_spt_wrapper(hipStream_t stream, hipStreamCallback_t callback, void* userData, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamAddCallback_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamAddCallback_spt.stream = stream;
    Args.hipStreamAddCallback_spt.callback = callback;
    Args.hipStreamAddCallback_spt.userData = userData;
    Args.hipStreamAddCallback_spt.flags = flags;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamAddCallback_spt_fn(Args.hipStreamAddCallback_spt.stream, Args.hipStreamAddCallback_spt.callback, Args.hipStreamAddCallback_spt.userData, Args.hipStreamAddCallback_spt.flags);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamAddCallback_spt_fn(stream, callback, userData, flags);
  }
}

static hipError_t hipEventRecord_spt_wrapper(hipEvent_t event, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipEventRecord_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipEventRecord_spt.event = event;
    Args.hipEventRecord_spt.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipEventRecord_spt_fn(Args.hipEventRecord_spt.event, Args.hipEventRecord_spt.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipEventRecord_spt_fn(event, stream);
  }
}

static hipError_t hipLaunchCooperativeKernel_spt_wrapper(const void* f, dim3 gridDim, dim3 blockDim, void** kernelParams, uint32_t sharedMemBytes, hipStream_t hStream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipLaunchCooperativeKernel_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipLaunchCooperativeKernel_spt.f = f;
    Args.hipLaunchCooperativeKernel_spt.gridDim.x = gridDim.x;
    Args.hipLaunchCooperativeKernel_spt.gridDim.y = gridDim.y;
    Args.hipLaunchCooperativeKernel_spt.gridDim.z = gridDim.z;                    
    Args.hipLaunchCooperativeKernel_spt.blockDim.x = blockDim.x;
    Args.hipLaunchCooperativeKernel_spt.blockDim.y = blockDim.y;
    Args.hipLaunchCooperativeKernel_spt.blockDim.z = blockDim.z;                    
    Args.hipLaunchCooperativeKernel_spt.kernelParams = kernelParams;
    Args.hipLaunchCooperativeKernel_spt.sharedMemBytes = sharedMemBytes;
    Args.hipLaunchCooperativeKernel_spt.hStream = hStream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipLaunchCooperativeKernel_spt_fn(Args.hipLaunchCooperativeKernel_spt.f, *reinterpret_cast<dim3*>(&Args.hipLaunchCooperativeKernel_spt.gridDim), *reinterpret_cast<dim3*>(&Args.hipLaunchCooperativeKernel_spt.blockDim), Args.hipLaunchCooperativeKernel_spt.kernelParams, Args.hipLaunchCooperativeKernel_spt.sharedMemBytes, Args.hipLaunchCooperativeKernel_spt.hStream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipLaunchCooperativeKernel_spt_fn(f, gridDim, blockDim, kernelParams, sharedMemBytes, hStream);
  }
}

static hipError_t hipLaunchKernel_spt_wrapper(const void* function_address, dim3 numBlocks, dim3 dimBlocks, void** args, size_t sharedMemBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipLaunchKernel_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipLaunchKernel_spt.function_address = function_address;
    Args.hipLaunchKernel_spt.numBlocks.x = numBlocks.x;
    Args.hipLaunchKernel_spt.numBlocks.y = numBlocks.y;
    Args.hipLaunchKernel_spt.numBlocks.z = numBlocks.z;                    
    Args.hipLaunchKernel_spt.dimBlocks.x = dimBlocks.x;
    Args.hipLaunchKernel_spt.dimBlocks.y = dimBlocks.y;
    Args.hipLaunchKernel_spt.dimBlocks.z = dimBlocks.z;                    
    Args.hipLaunchKernel_spt.args = args;
    Args.hipLaunchKernel_spt.sharedMemBytes = sharedMemBytes;
    Args.hipLaunchKernel_spt.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipLaunchKernel_spt_fn(Args.hipLaunchKernel_spt.function_address, *reinterpret_cast<dim3*>(&Args.hipLaunchKernel_spt.numBlocks), *reinterpret_cast<dim3*>(&Args.hipLaunchKernel_spt.dimBlocks), Args.hipLaunchKernel_spt.args, Args.hipLaunchKernel_spt.sharedMemBytes, Args.hipLaunchKernel_spt.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipLaunchKernel_spt_fn(function_address, numBlocks, dimBlocks, args, sharedMemBytes, stream);
  }
}

static hipError_t hipGraphLaunch_spt_wrapper(hipGraphExec_t graphExec, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphLaunch_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphLaunch_spt.graphExec = graphExec;
    Args.hipGraphLaunch_spt.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphLaunch_spt_fn(Args.hipGraphLaunch_spt.graphExec, Args.hipGraphLaunch_spt.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphLaunch_spt_fn(graphExec, stream);
  }
}

static hipError_t hipStreamBeginCapture_spt_wrapper(hipStream_t stream, hipStreamCaptureMode mode) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamBeginCapture_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamBeginCapture_spt.stream = stream;
    Args.hipStreamBeginCapture_spt.mode = mode;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamBeginCapture_spt_fn(Args.hipStreamBeginCapture_spt.stream, Args.hipStreamBeginCapture_spt.mode);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamBeginCapture_spt_fn(stream, mode);
  }
}

static hipError_t hipStreamEndCapture_spt_wrapper(hipStream_t stream, hipGraph_t* pGraph) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamEndCapture_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamEndCapture_spt.stream = stream;
    Args.hipStreamEndCapture_spt.pGraph = pGraph;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamEndCapture_spt_fn(Args.hipStreamEndCapture_spt.stream, Args.hipStreamEndCapture_spt.pGraph);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamEndCapture_spt_fn(stream, pGraph);
  }
}

static hipError_t hipStreamIsCapturing_spt_wrapper(hipStream_t stream, hipStreamCaptureStatus* pCaptureStatus) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamIsCapturing_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamIsCapturing_spt.stream = stream;
    Args.hipStreamIsCapturing_spt.pCaptureStatus = pCaptureStatus;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamIsCapturing_spt_fn(Args.hipStreamIsCapturing_spt.stream, Args.hipStreamIsCapturing_spt.pCaptureStatus);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamIsCapturing_spt_fn(stream, pCaptureStatus);
  }
}

static hipError_t hipStreamGetCaptureInfo_spt_wrapper(hipStream_t stream, hipStreamCaptureStatus* pCaptureStatus, unsigned long long* pId) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamGetCaptureInfo_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamGetCaptureInfo_spt.stream = stream;
    Args.hipStreamGetCaptureInfo_spt.pCaptureStatus = pCaptureStatus;
    Args.hipStreamGetCaptureInfo_spt.pId = pId;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamGetCaptureInfo_spt_fn(Args.hipStreamGetCaptureInfo_spt.stream, Args.hipStreamGetCaptureInfo_spt.pCaptureStatus, Args.hipStreamGetCaptureInfo_spt.pId);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamGetCaptureInfo_spt_fn(stream, pCaptureStatus, pId);
  }
}

static hipError_t hipStreamGetCaptureInfo_v2_spt_wrapper(hipStream_t stream, hipStreamCaptureStatus* captureStatus_out, unsigned long long* id_out, hipGraph_t* graph_out, const hipGraphNode_t** dependencies_out, size_t* numDependencies_out) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamGetCaptureInfo_v2_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamGetCaptureInfo_v2_spt.stream = stream;
    Args.hipStreamGetCaptureInfo_v2_spt.captureStatus_out = captureStatus_out;
    Args.hipStreamGetCaptureInfo_v2_spt.id_out = id_out;
    Args.hipStreamGetCaptureInfo_v2_spt.graph_out = graph_out;
    Args.hipStreamGetCaptureInfo_v2_spt.dependencies_out = dependencies_out;
    Args.hipStreamGetCaptureInfo_v2_spt.numDependencies_out = numDependencies_out;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamGetCaptureInfo_v2_spt_fn(Args.hipStreamGetCaptureInfo_v2_spt.stream, Args.hipStreamGetCaptureInfo_v2_spt.captureStatus_out, Args.hipStreamGetCaptureInfo_v2_spt.id_out, Args.hipStreamGetCaptureInfo_v2_spt.graph_out, Args.hipStreamGetCaptureInfo_v2_spt.dependencies_out, Args.hipStreamGetCaptureInfo_v2_spt.numDependencies_out);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamGetCaptureInfo_v2_spt_fn(stream, captureStatus_out, id_out, graph_out, dependencies_out, numDependencies_out);
  }
}

static hipError_t hipLaunchHostFunc_spt_wrapper(hipStream_t stream, hipHostFn_t fn, void* userData) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipLaunchHostFunc_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipLaunchHostFunc_spt.stream = stream;
    Args.hipLaunchHostFunc_spt.fn = fn;
    Args.hipLaunchHostFunc_spt.userData = userData;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipLaunchHostFunc_spt_fn(Args.hipLaunchHostFunc_spt.stream, Args.hipLaunchHostFunc_spt.fn, Args.hipLaunchHostFunc_spt.userData);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipLaunchHostFunc_spt_fn(stream, fn, userData);
  }
}

static int hipGetStreamDeviceId_wrapper(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetStreamDeviceId;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    int Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetStreamDeviceId.stream = stream;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetStreamDeviceId_fn(Args.hipGetStreamDeviceId.stream);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetStreamDeviceId_fn(stream);
  }
}

static hipError_t hipDrvGraphAddMemsetNode_wrapper(hipGraphNode_t* phGraphNode, hipGraph_t hGraph, const hipGraphNode_t* dependencies, size_t numDependencies, const HIP_MEMSET_NODE_PARAMS* memsetParams, hipCtx_t ctx) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipDrvGraphAddMemsetNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipDrvGraphAddMemsetNode.phGraphNode = phGraphNode;
    Args.hipDrvGraphAddMemsetNode.hGraph = hGraph;
    Args.hipDrvGraphAddMemsetNode.dependencies = dependencies;
    Args.hipDrvGraphAddMemsetNode.numDependencies = numDependencies;
    Args.hipDrvGraphAddMemsetNode.memsetParams = memsetParams;
    Args.hipDrvGraphAddMemsetNode.ctx = ctx;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipDrvGraphAddMemsetNode_fn(Args.hipDrvGraphAddMemsetNode.phGraphNode, Args.hipDrvGraphAddMemsetNode.hGraph, Args.hipDrvGraphAddMemsetNode.dependencies, Args.hipDrvGraphAddMemsetNode.numDependencies, Args.hipDrvGraphAddMemsetNode.memsetParams, Args.hipDrvGraphAddMemsetNode.ctx);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipDrvGraphAddMemsetNode_fn(phGraphNode, hGraph, dependencies, numDependencies, memsetParams, ctx);
  }
}

static hipError_t hipGraphAddExternalSemaphoresWaitNode_wrapper(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const hipExternalSemaphoreWaitNodeParams* nodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphAddExternalSemaphoresWaitNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphAddExternalSemaphoresWaitNode.pGraphNode = pGraphNode;
    Args.hipGraphAddExternalSemaphoresWaitNode.graph = graph;
    Args.hipGraphAddExternalSemaphoresWaitNode.pDependencies = pDependencies;
    Args.hipGraphAddExternalSemaphoresWaitNode.numDependencies = numDependencies;
    Args.hipGraphAddExternalSemaphoresWaitNode.nodeParams = nodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphAddExternalSemaphoresWaitNode_fn(Args.hipGraphAddExternalSemaphoresWaitNode.pGraphNode, Args.hipGraphAddExternalSemaphoresWaitNode.graph, Args.hipGraphAddExternalSemaphoresWaitNode.pDependencies, Args.hipGraphAddExternalSemaphoresWaitNode.numDependencies, Args.hipGraphAddExternalSemaphoresWaitNode.nodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphAddExternalSemaphoresWaitNode_fn(pGraphNode, graph, pDependencies, numDependencies, nodeParams);
  }
}

static hipError_t hipGraphAddExternalSemaphoresSignalNode_wrapper(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const hipExternalSemaphoreSignalNodeParams* nodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphAddExternalSemaphoresSignalNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphAddExternalSemaphoresSignalNode.pGraphNode = pGraphNode;
    Args.hipGraphAddExternalSemaphoresSignalNode.graph = graph;
    Args.hipGraphAddExternalSemaphoresSignalNode.pDependencies = pDependencies;
    Args.hipGraphAddExternalSemaphoresSignalNode.numDependencies = numDependencies;
    Args.hipGraphAddExternalSemaphoresSignalNode.nodeParams = nodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphAddExternalSemaphoresSignalNode_fn(Args.hipGraphAddExternalSemaphoresSignalNode.pGraphNode, Args.hipGraphAddExternalSemaphoresSignalNode.graph, Args.hipGraphAddExternalSemaphoresSignalNode.pDependencies, Args.hipGraphAddExternalSemaphoresSignalNode.numDependencies, Args.hipGraphAddExternalSemaphoresSignalNode.nodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphAddExternalSemaphoresSignalNode_fn(pGraphNode, graph, pDependencies, numDependencies, nodeParams);
  }
}

static hipError_t hipGraphExternalSemaphoresSignalNodeSetParams_wrapper(hipGraphNode_t hNode, const hipExternalSemaphoreSignalNodeParams* nodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExternalSemaphoresSignalNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExternalSemaphoresSignalNodeSetParams.hNode = hNode;
    Args.hipGraphExternalSemaphoresSignalNodeSetParams.nodeParams = nodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExternalSemaphoresSignalNodeSetParams_fn(Args.hipGraphExternalSemaphoresSignalNodeSetParams.hNode, Args.hipGraphExternalSemaphoresSignalNodeSetParams.nodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExternalSemaphoresSignalNodeSetParams_fn(hNode, nodeParams);
  }
}

static hipError_t hipGraphExternalSemaphoresWaitNodeSetParams_wrapper(hipGraphNode_t hNode, const hipExternalSemaphoreWaitNodeParams* nodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExternalSemaphoresWaitNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExternalSemaphoresWaitNodeSetParams.hNode = hNode;
    Args.hipGraphExternalSemaphoresWaitNodeSetParams.nodeParams = nodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExternalSemaphoresWaitNodeSetParams_fn(Args.hipGraphExternalSemaphoresWaitNodeSetParams.hNode, Args.hipGraphExternalSemaphoresWaitNodeSetParams.nodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExternalSemaphoresWaitNodeSetParams_fn(hNode, nodeParams);
  }
}

static hipError_t hipGraphExternalSemaphoresSignalNodeGetParams_wrapper(hipGraphNode_t hNode, hipExternalSemaphoreSignalNodeParams* params_out) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExternalSemaphoresSignalNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExternalSemaphoresSignalNodeGetParams.hNode = hNode;
    Args.hipGraphExternalSemaphoresSignalNodeGetParams.params_out = params_out;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExternalSemaphoresSignalNodeGetParams_fn(Args.hipGraphExternalSemaphoresSignalNodeGetParams.hNode, Args.hipGraphExternalSemaphoresSignalNodeGetParams.params_out);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExternalSemaphoresSignalNodeGetParams_fn(hNode, params_out);
  }
}

static hipError_t hipGraphExternalSemaphoresWaitNodeGetParams_wrapper(hipGraphNode_t hNode, hipExternalSemaphoreWaitNodeParams* params_out) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExternalSemaphoresWaitNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExternalSemaphoresWaitNodeGetParams.hNode = hNode;
    Args.hipGraphExternalSemaphoresWaitNodeGetParams.params_out = params_out;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExternalSemaphoresWaitNodeGetParams_fn(Args.hipGraphExternalSemaphoresWaitNodeGetParams.hNode, Args.hipGraphExternalSemaphoresWaitNodeGetParams.params_out);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExternalSemaphoresWaitNodeGetParams_fn(hNode, params_out);
  }
}

static hipError_t hipGraphExecExternalSemaphoresSignalNodeSetParams_wrapper(hipGraphExec_t hGraphExec, hipGraphNode_t hNode, const hipExternalSemaphoreSignalNodeParams* nodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExecExternalSemaphoresSignalNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExecExternalSemaphoresSignalNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecExternalSemaphoresSignalNodeSetParams.hNode = hNode;
    Args.hipGraphExecExternalSemaphoresSignalNodeSetParams.nodeParams = nodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExecExternalSemaphoresSignalNodeSetParams_fn(Args.hipGraphExecExternalSemaphoresSignalNodeSetParams.hGraphExec, Args.hipGraphExecExternalSemaphoresSignalNodeSetParams.hNode, Args.hipGraphExecExternalSemaphoresSignalNodeSetParams.nodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExecExternalSemaphoresSignalNodeSetParams_fn(hGraphExec, hNode, nodeParams);
  }
}

static hipError_t hipGraphExecExternalSemaphoresWaitNodeSetParams_wrapper(hipGraphExec_t hGraphExec, hipGraphNode_t hNode, const hipExternalSemaphoreWaitNodeParams* nodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphExecExternalSemaphoresWaitNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphExecExternalSemaphoresWaitNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecExternalSemaphoresWaitNodeSetParams.hNode = hNode;
    Args.hipGraphExecExternalSemaphoresWaitNodeSetParams.nodeParams = nodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphExecExternalSemaphoresWaitNodeSetParams_fn(Args.hipGraphExecExternalSemaphoresWaitNodeSetParams.hGraphExec, Args.hipGraphExecExternalSemaphoresWaitNodeSetParams.hNode, Args.hipGraphExecExternalSemaphoresWaitNodeSetParams.nodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphExecExternalSemaphoresWaitNodeSetParams_fn(hGraphExec, hNode, nodeParams);
  }
}

static hipError_t hipGraphAddNode_wrapper(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, hipGraphNodeParams* nodeParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphAddNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphAddNode.pGraphNode = pGraphNode;
    Args.hipGraphAddNode.graph = graph;
    Args.hipGraphAddNode.pDependencies = pDependencies;
    Args.hipGraphAddNode.numDependencies = numDependencies;
    Args.hipGraphAddNode.nodeParams = nodeParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphAddNode_fn(Args.hipGraphAddNode.pGraphNode, Args.hipGraphAddNode.graph, Args.hipGraphAddNode.pDependencies, Args.hipGraphAddNode.numDependencies, Args.hipGraphAddNode.nodeParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphAddNode_fn(pGraphNode, graph, pDependencies, numDependencies, nodeParams);
  }
}

static hipError_t hipGraphInstantiateWithParams_wrapper(hipGraphExec_t* pGraphExec, hipGraph_t graph, hipGraphInstantiateParams* instantiateParams) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGraphInstantiateWithParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGraphInstantiateWithParams.pGraphExec = pGraphExec;
    Args.hipGraphInstantiateWithParams.graph = graph;
    Args.hipGraphInstantiateWithParams.instantiateParams = instantiateParams;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGraphInstantiateWithParams_fn(Args.hipGraphInstantiateWithParams.pGraphExec, Args.hipGraphInstantiateWithParams.graph, Args.hipGraphInstantiateWithParams.instantiateParams);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGraphInstantiateWithParams_fn(pGraphExec, graph, instantiateParams);
  }
}

static hipError_t hipExtGetLastError_wrapper() {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipExtGetLastError;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipExtGetLastError_fn();
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipExtGetLastError_fn();
  }
}

static hipError_t hipTexRefGetBorderColor_wrapper(float* pBorderColor, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefGetBorderColor;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefGetBorderColor.pBorderColor = pBorderColor;
    Args.hipTexRefGetBorderColor.texRef = texRef;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefGetBorderColor_fn(Args.hipTexRefGetBorderColor.pBorderColor, Args.hipTexRefGetBorderColor.texRef);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefGetBorderColor_fn(pBorderColor, texRef);
  }
}

static hipError_t hipTexRefGetArray_wrapper(hipArray_t* pArray, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipTexRefGetArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipTexRefGetArray.pArray = pArray;
    Args.hipTexRefGetArray.texRef = texRef;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipTexRefGetArray_fn(Args.hipTexRefGetArray.pArray, Args.hipTexRefGetArray.texRef);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipTexRefGetArray_fn(pArray, texRef);
  }
}

static hipError_t hipGetProcAddress_wrapper(const char* symbol, void** pfn, int hipVersion, uint64_t flags, hipDriverProcAddressQueryResult* symbolStatus) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetProcAddress;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetProcAddress.symbol = symbol;
    Args.hipGetProcAddress.pfn = pfn;
    Args.hipGetProcAddress.hipVersion = hipVersion;
    Args.hipGetProcAddress.flags = flags;
    Args.hipGetProcAddress.symbolStatus = symbolStatus;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetProcAddress_fn(Args.hipGetProcAddress.symbol, Args.hipGetProcAddress.pfn, Args.hipGetProcAddress.hipVersion, Args.hipGetProcAddress.flags, Args.hipGetProcAddress.symbolStatus);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetProcAddress_fn(symbol, pfn, hipVersion, flags, symbolStatus);
  }
}

static hipError_t hipStreamBeginCaptureToGraph_wrapper(hipStream_t stream, hipGraph_t graph, const hipGraphNode_t* dependencies, const hipGraphEdgeData* dependencyData, size_t numDependencies, hipStreamCaptureMode mode) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipStreamBeginCaptureToGraph;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipStreamBeginCaptureToGraph.stream = stream;
    Args.hipStreamBeginCaptureToGraph.graph = graph;
    Args.hipStreamBeginCaptureToGraph.dependencies = dependencies;
    Args.hipStreamBeginCaptureToGraph.dependencyData = dependencyData;
    Args.hipStreamBeginCaptureToGraph.numDependencies = numDependencies;
    Args.hipStreamBeginCaptureToGraph.mode = mode;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipStreamBeginCaptureToGraph_fn(Args.hipStreamBeginCaptureToGraph.stream, Args.hipStreamBeginCaptureToGraph.graph, Args.hipStreamBeginCaptureToGraph.dependencies, Args.hipStreamBeginCaptureToGraph.dependencyData, Args.hipStreamBeginCaptureToGraph.numDependencies, Args.hipStreamBeginCaptureToGraph.mode);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipStreamBeginCaptureToGraph_fn(stream, graph, dependencies, dependencyData, numDependencies, mode);
  }
}

static hipError_t hipGetFuncBySymbol_wrapper(hipFunction_t* functionPtr, const void* symbolPtr) {
  auto& HipInterceptor = luthier::hip::HipRuntimeApiInterceptor::instance();
  HipInterceptor.freezeRuntimeApiTable();
  auto ApiId = luthier::hip::HIP_RUNTIME_API_EVT_ID_hipGetFuncBySymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto [HipUserCallback, UserCallbackLock] = HipInterceptor.getUserCallback();
    auto [HipInternalCallback, InternalCallbackLock] = HipInterceptor.getInternalCallback();
    luthier::hip::ApiEvtArgs Args;
    Args.hipGetFuncBySymbol.functionPtr = functionPtr;
    Args.hipGetFuncBySymbol.symbolPtr = symbolPtr;
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
Out = HipInterceptor.getSavedApiTableContainer().hipGetFuncBySymbol_fn(Args.hipGetFuncBySymbol.functionPtr, Args.hipGetFuncBySymbol.symbolPtr);
    if (IsUserCallbackEnabled)
      (*HipUserCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      (*HipInternalCallback)(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    return Out;
  }
  else {
    return HipInterceptor.getSavedApiTableContainer().hipGetFuncBySymbol_fn(functionPtr, symbolPtr);
  }
}

static void switch_hipApiName_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipApiName_fn = hipApiName_wrapper;
  else
    RuntimeApiTable->hipApiName_fn = SavedApiTable.hipApiName_fn;
}

static void switch_hipArray3DCreate_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipArray3DCreate_fn = hipArray3DCreate_wrapper;
  else
    RuntimeApiTable->hipArray3DCreate_fn = SavedApiTable.hipArray3DCreate_fn;
}

static void switch_hipArray3DGetDescriptor_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipArray3DGetDescriptor_fn = hipArray3DGetDescriptor_wrapper;
  else
    RuntimeApiTable->hipArray3DGetDescriptor_fn = SavedApiTable.hipArray3DGetDescriptor_fn;
}

static void switch_hipArrayCreate_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipArrayCreate_fn = hipArrayCreate_wrapper;
  else
    RuntimeApiTable->hipArrayCreate_fn = SavedApiTable.hipArrayCreate_fn;
}

static void switch_hipArrayDestroy_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipArrayDestroy_fn = hipArrayDestroy_wrapper;
  else
    RuntimeApiTable->hipArrayDestroy_fn = SavedApiTable.hipArrayDestroy_fn;
}

static void switch_hipArrayGetDescriptor_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipArrayGetDescriptor_fn = hipArrayGetDescriptor_wrapper;
  else
    RuntimeApiTable->hipArrayGetDescriptor_fn = SavedApiTable.hipArrayGetDescriptor_fn;
}

static void switch_hipArrayGetInfo_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipArrayGetInfo_fn = hipArrayGetInfo_wrapper;
  else
    RuntimeApiTable->hipArrayGetInfo_fn = SavedApiTable.hipArrayGetInfo_fn;
}

static void switch_hipBindTexture_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipBindTexture_fn = hipBindTexture_wrapper;
  else
    RuntimeApiTable->hipBindTexture_fn = SavedApiTable.hipBindTexture_fn;
}

static void switch_hipBindTexture2D_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipBindTexture2D_fn = hipBindTexture2D_wrapper;
  else
    RuntimeApiTable->hipBindTexture2D_fn = SavedApiTable.hipBindTexture2D_fn;
}

static void switch_hipBindTextureToArray_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipBindTextureToArray_fn = hipBindTextureToArray_wrapper;
  else
    RuntimeApiTable->hipBindTextureToArray_fn = SavedApiTable.hipBindTextureToArray_fn;
}

static void switch_hipBindTextureToMipmappedArray_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipBindTextureToMipmappedArray_fn = hipBindTextureToMipmappedArray_wrapper;
  else
    RuntimeApiTable->hipBindTextureToMipmappedArray_fn = SavedApiTable.hipBindTextureToMipmappedArray_fn;
}

static void switch_hipChooseDevice_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipChooseDevice_fn = hipChooseDevice_wrapper;
  else
    RuntimeApiTable->hipChooseDevice_fn = SavedApiTable.hipChooseDevice_fn;
}

static void switch_hipChooseDeviceR0000_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipChooseDeviceR0000_fn = hipChooseDeviceR0000_wrapper;
  else
    RuntimeApiTable->hipChooseDeviceR0000_fn = SavedApiTable.hipChooseDeviceR0000_fn;
}

static void switch_hipConfigureCall_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipConfigureCall_fn = hipConfigureCall_wrapper;
  else
    RuntimeApiTable->hipConfigureCall_fn = SavedApiTable.hipConfigureCall_fn;
}

static void switch_hipCreateSurfaceObject_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCreateSurfaceObject_fn = hipCreateSurfaceObject_wrapper;
  else
    RuntimeApiTable->hipCreateSurfaceObject_fn = SavedApiTable.hipCreateSurfaceObject_fn;
}

static void switch_hipCreateTextureObject_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCreateTextureObject_fn = hipCreateTextureObject_wrapper;
  else
    RuntimeApiTable->hipCreateTextureObject_fn = SavedApiTable.hipCreateTextureObject_fn;
}

static void switch_hipCtxCreate_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCtxCreate_fn = hipCtxCreate_wrapper;
  else
    RuntimeApiTable->hipCtxCreate_fn = SavedApiTable.hipCtxCreate_fn;
}

static void switch_hipCtxDestroy_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCtxDestroy_fn = hipCtxDestroy_wrapper;
  else
    RuntimeApiTable->hipCtxDestroy_fn = SavedApiTable.hipCtxDestroy_fn;
}

static void switch_hipCtxDisablePeerAccess_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCtxDisablePeerAccess_fn = hipCtxDisablePeerAccess_wrapper;
  else
    RuntimeApiTable->hipCtxDisablePeerAccess_fn = SavedApiTable.hipCtxDisablePeerAccess_fn;
}

static void switch_hipCtxEnablePeerAccess_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCtxEnablePeerAccess_fn = hipCtxEnablePeerAccess_wrapper;
  else
    RuntimeApiTable->hipCtxEnablePeerAccess_fn = SavedApiTable.hipCtxEnablePeerAccess_fn;
}

static void switch_hipCtxGetApiVersion_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCtxGetApiVersion_fn = hipCtxGetApiVersion_wrapper;
  else
    RuntimeApiTable->hipCtxGetApiVersion_fn = SavedApiTable.hipCtxGetApiVersion_fn;
}

static void switch_hipCtxGetCacheConfig_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCtxGetCacheConfig_fn = hipCtxGetCacheConfig_wrapper;
  else
    RuntimeApiTable->hipCtxGetCacheConfig_fn = SavedApiTable.hipCtxGetCacheConfig_fn;
}

static void switch_hipCtxGetCurrent_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCtxGetCurrent_fn = hipCtxGetCurrent_wrapper;
  else
    RuntimeApiTable->hipCtxGetCurrent_fn = SavedApiTable.hipCtxGetCurrent_fn;
}

static void switch_hipCtxGetDevice_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCtxGetDevice_fn = hipCtxGetDevice_wrapper;
  else
    RuntimeApiTable->hipCtxGetDevice_fn = SavedApiTable.hipCtxGetDevice_fn;
}

static void switch_hipCtxGetFlags_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCtxGetFlags_fn = hipCtxGetFlags_wrapper;
  else
    RuntimeApiTable->hipCtxGetFlags_fn = SavedApiTable.hipCtxGetFlags_fn;
}

static void switch_hipCtxGetSharedMemConfig_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCtxGetSharedMemConfig_fn = hipCtxGetSharedMemConfig_wrapper;
  else
    RuntimeApiTable->hipCtxGetSharedMemConfig_fn = SavedApiTable.hipCtxGetSharedMemConfig_fn;
}

static void switch_hipCtxPopCurrent_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCtxPopCurrent_fn = hipCtxPopCurrent_wrapper;
  else
    RuntimeApiTable->hipCtxPopCurrent_fn = SavedApiTable.hipCtxPopCurrent_fn;
}

static void switch_hipCtxPushCurrent_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCtxPushCurrent_fn = hipCtxPushCurrent_wrapper;
  else
    RuntimeApiTable->hipCtxPushCurrent_fn = SavedApiTable.hipCtxPushCurrent_fn;
}

static void switch_hipCtxSetCacheConfig_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCtxSetCacheConfig_fn = hipCtxSetCacheConfig_wrapper;
  else
    RuntimeApiTable->hipCtxSetCacheConfig_fn = SavedApiTable.hipCtxSetCacheConfig_fn;
}

static void switch_hipCtxSetCurrent_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCtxSetCurrent_fn = hipCtxSetCurrent_wrapper;
  else
    RuntimeApiTable->hipCtxSetCurrent_fn = SavedApiTable.hipCtxSetCurrent_fn;
}

static void switch_hipCtxSetSharedMemConfig_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCtxSetSharedMemConfig_fn = hipCtxSetSharedMemConfig_wrapper;
  else
    RuntimeApiTable->hipCtxSetSharedMemConfig_fn = SavedApiTable.hipCtxSetSharedMemConfig_fn;
}

static void switch_hipCtxSynchronize_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCtxSynchronize_fn = hipCtxSynchronize_wrapper;
  else
    RuntimeApiTable->hipCtxSynchronize_fn = SavedApiTable.hipCtxSynchronize_fn;
}

static void switch_hipDestroyExternalMemory_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDestroyExternalMemory_fn = hipDestroyExternalMemory_wrapper;
  else
    RuntimeApiTable->hipDestroyExternalMemory_fn = SavedApiTable.hipDestroyExternalMemory_fn;
}

static void switch_hipDestroyExternalSemaphore_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDestroyExternalSemaphore_fn = hipDestroyExternalSemaphore_wrapper;
  else
    RuntimeApiTable->hipDestroyExternalSemaphore_fn = SavedApiTable.hipDestroyExternalSemaphore_fn;
}

static void switch_hipDestroySurfaceObject_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDestroySurfaceObject_fn = hipDestroySurfaceObject_wrapper;
  else
    RuntimeApiTable->hipDestroySurfaceObject_fn = SavedApiTable.hipDestroySurfaceObject_fn;
}

static void switch_hipDestroyTextureObject_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDestroyTextureObject_fn = hipDestroyTextureObject_wrapper;
  else
    RuntimeApiTable->hipDestroyTextureObject_fn = SavedApiTable.hipDestroyTextureObject_fn;
}

static void switch_hipDeviceCanAccessPeer_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceCanAccessPeer_fn = hipDeviceCanAccessPeer_wrapper;
  else
    RuntimeApiTable->hipDeviceCanAccessPeer_fn = SavedApiTable.hipDeviceCanAccessPeer_fn;
}

static void switch_hipDeviceComputeCapability_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceComputeCapability_fn = hipDeviceComputeCapability_wrapper;
  else
    RuntimeApiTable->hipDeviceComputeCapability_fn = SavedApiTable.hipDeviceComputeCapability_fn;
}

static void switch_hipDeviceDisablePeerAccess_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceDisablePeerAccess_fn = hipDeviceDisablePeerAccess_wrapper;
  else
    RuntimeApiTable->hipDeviceDisablePeerAccess_fn = SavedApiTable.hipDeviceDisablePeerAccess_fn;
}

static void switch_hipDeviceEnablePeerAccess_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceEnablePeerAccess_fn = hipDeviceEnablePeerAccess_wrapper;
  else
    RuntimeApiTable->hipDeviceEnablePeerAccess_fn = SavedApiTable.hipDeviceEnablePeerAccess_fn;
}

static void switch_hipDeviceGet_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceGet_fn = hipDeviceGet_wrapper;
  else
    RuntimeApiTable->hipDeviceGet_fn = SavedApiTable.hipDeviceGet_fn;
}

static void switch_hipDeviceGetAttribute_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceGetAttribute_fn = hipDeviceGetAttribute_wrapper;
  else
    RuntimeApiTable->hipDeviceGetAttribute_fn = SavedApiTable.hipDeviceGetAttribute_fn;
}

static void switch_hipDeviceGetByPCIBusId_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceGetByPCIBusId_fn = hipDeviceGetByPCIBusId_wrapper;
  else
    RuntimeApiTable->hipDeviceGetByPCIBusId_fn = SavedApiTable.hipDeviceGetByPCIBusId_fn;
}

static void switch_hipDeviceGetCacheConfig_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceGetCacheConfig_fn = hipDeviceGetCacheConfig_wrapper;
  else
    RuntimeApiTable->hipDeviceGetCacheConfig_fn = SavedApiTable.hipDeviceGetCacheConfig_fn;
}

static void switch_hipDeviceGetDefaultMemPool_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceGetDefaultMemPool_fn = hipDeviceGetDefaultMemPool_wrapper;
  else
    RuntimeApiTable->hipDeviceGetDefaultMemPool_fn = SavedApiTable.hipDeviceGetDefaultMemPool_fn;
}

static void switch_hipDeviceGetGraphMemAttribute_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceGetGraphMemAttribute_fn = hipDeviceGetGraphMemAttribute_wrapper;
  else
    RuntimeApiTable->hipDeviceGetGraphMemAttribute_fn = SavedApiTable.hipDeviceGetGraphMemAttribute_fn;
}

static void switch_hipDeviceGetLimit_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceGetLimit_fn = hipDeviceGetLimit_wrapper;
  else
    RuntimeApiTable->hipDeviceGetLimit_fn = SavedApiTable.hipDeviceGetLimit_fn;
}

static void switch_hipDeviceGetMemPool_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceGetMemPool_fn = hipDeviceGetMemPool_wrapper;
  else
    RuntimeApiTable->hipDeviceGetMemPool_fn = SavedApiTable.hipDeviceGetMemPool_fn;
}

static void switch_hipDeviceGetName_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceGetName_fn = hipDeviceGetName_wrapper;
  else
    RuntimeApiTable->hipDeviceGetName_fn = SavedApiTable.hipDeviceGetName_fn;
}

static void switch_hipDeviceGetP2PAttribute_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceGetP2PAttribute_fn = hipDeviceGetP2PAttribute_wrapper;
  else
    RuntimeApiTable->hipDeviceGetP2PAttribute_fn = SavedApiTable.hipDeviceGetP2PAttribute_fn;
}

static void switch_hipDeviceGetPCIBusId_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceGetPCIBusId_fn = hipDeviceGetPCIBusId_wrapper;
  else
    RuntimeApiTable->hipDeviceGetPCIBusId_fn = SavedApiTable.hipDeviceGetPCIBusId_fn;
}

static void switch_hipDeviceGetSharedMemConfig_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceGetSharedMemConfig_fn = hipDeviceGetSharedMemConfig_wrapper;
  else
    RuntimeApiTable->hipDeviceGetSharedMemConfig_fn = SavedApiTable.hipDeviceGetSharedMemConfig_fn;
}

static void switch_hipDeviceGetStreamPriorityRange_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceGetStreamPriorityRange_fn = hipDeviceGetStreamPriorityRange_wrapper;
  else
    RuntimeApiTable->hipDeviceGetStreamPriorityRange_fn = SavedApiTable.hipDeviceGetStreamPriorityRange_fn;
}

static void switch_hipDeviceGetUuid_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceGetUuid_fn = hipDeviceGetUuid_wrapper;
  else
    RuntimeApiTable->hipDeviceGetUuid_fn = SavedApiTable.hipDeviceGetUuid_fn;
}

static void switch_hipDeviceGraphMemTrim_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceGraphMemTrim_fn = hipDeviceGraphMemTrim_wrapper;
  else
    RuntimeApiTable->hipDeviceGraphMemTrim_fn = SavedApiTable.hipDeviceGraphMemTrim_fn;
}

static void switch_hipDevicePrimaryCtxGetState_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDevicePrimaryCtxGetState_fn = hipDevicePrimaryCtxGetState_wrapper;
  else
    RuntimeApiTable->hipDevicePrimaryCtxGetState_fn = SavedApiTable.hipDevicePrimaryCtxGetState_fn;
}

static void switch_hipDevicePrimaryCtxRelease_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDevicePrimaryCtxRelease_fn = hipDevicePrimaryCtxRelease_wrapper;
  else
    RuntimeApiTable->hipDevicePrimaryCtxRelease_fn = SavedApiTable.hipDevicePrimaryCtxRelease_fn;
}

static void switch_hipDevicePrimaryCtxReset_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDevicePrimaryCtxReset_fn = hipDevicePrimaryCtxReset_wrapper;
  else
    RuntimeApiTable->hipDevicePrimaryCtxReset_fn = SavedApiTable.hipDevicePrimaryCtxReset_fn;
}

static void switch_hipDevicePrimaryCtxRetain_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDevicePrimaryCtxRetain_fn = hipDevicePrimaryCtxRetain_wrapper;
  else
    RuntimeApiTable->hipDevicePrimaryCtxRetain_fn = SavedApiTable.hipDevicePrimaryCtxRetain_fn;
}

static void switch_hipDevicePrimaryCtxSetFlags_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDevicePrimaryCtxSetFlags_fn = hipDevicePrimaryCtxSetFlags_wrapper;
  else
    RuntimeApiTable->hipDevicePrimaryCtxSetFlags_fn = SavedApiTable.hipDevicePrimaryCtxSetFlags_fn;
}

static void switch_hipDeviceReset_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceReset_fn = hipDeviceReset_wrapper;
  else
    RuntimeApiTable->hipDeviceReset_fn = SavedApiTable.hipDeviceReset_fn;
}

static void switch_hipDeviceSetCacheConfig_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceSetCacheConfig_fn = hipDeviceSetCacheConfig_wrapper;
  else
    RuntimeApiTable->hipDeviceSetCacheConfig_fn = SavedApiTable.hipDeviceSetCacheConfig_fn;
}

static void switch_hipDeviceSetGraphMemAttribute_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceSetGraphMemAttribute_fn = hipDeviceSetGraphMemAttribute_wrapper;
  else
    RuntimeApiTable->hipDeviceSetGraphMemAttribute_fn = SavedApiTable.hipDeviceSetGraphMemAttribute_fn;
}

static void switch_hipDeviceSetLimit_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceSetLimit_fn = hipDeviceSetLimit_wrapper;
  else
    RuntimeApiTable->hipDeviceSetLimit_fn = SavedApiTable.hipDeviceSetLimit_fn;
}

static void switch_hipDeviceSetMemPool_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceSetMemPool_fn = hipDeviceSetMemPool_wrapper;
  else
    RuntimeApiTable->hipDeviceSetMemPool_fn = SavedApiTable.hipDeviceSetMemPool_fn;
}

static void switch_hipDeviceSetSharedMemConfig_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceSetSharedMemConfig_fn = hipDeviceSetSharedMemConfig_wrapper;
  else
    RuntimeApiTable->hipDeviceSetSharedMemConfig_fn = SavedApiTable.hipDeviceSetSharedMemConfig_fn;
}

static void switch_hipDeviceSynchronize_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceSynchronize_fn = hipDeviceSynchronize_wrapper;
  else
    RuntimeApiTable->hipDeviceSynchronize_fn = SavedApiTable.hipDeviceSynchronize_fn;
}

static void switch_hipDeviceTotalMem_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDeviceTotalMem_fn = hipDeviceTotalMem_wrapper;
  else
    RuntimeApiTable->hipDeviceTotalMem_fn = SavedApiTable.hipDeviceTotalMem_fn;
}

static void switch_hipDriverGetVersion_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDriverGetVersion_fn = hipDriverGetVersion_wrapper;
  else
    RuntimeApiTable->hipDriverGetVersion_fn = SavedApiTable.hipDriverGetVersion_fn;
}

static void switch_hipDrvGetErrorName_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDrvGetErrorName_fn = hipDrvGetErrorName_wrapper;
  else
    RuntimeApiTable->hipDrvGetErrorName_fn = SavedApiTable.hipDrvGetErrorName_fn;
}

static void switch_hipDrvGetErrorString_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDrvGetErrorString_fn = hipDrvGetErrorString_wrapper;
  else
    RuntimeApiTable->hipDrvGetErrorString_fn = SavedApiTable.hipDrvGetErrorString_fn;
}

static void switch_hipDrvGraphAddMemcpyNode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDrvGraphAddMemcpyNode_fn = hipDrvGraphAddMemcpyNode_wrapper;
  else
    RuntimeApiTable->hipDrvGraphAddMemcpyNode_fn = SavedApiTable.hipDrvGraphAddMemcpyNode_fn;
}

static void switch_hipDrvMemcpy2DUnaligned_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDrvMemcpy2DUnaligned_fn = hipDrvMemcpy2DUnaligned_wrapper;
  else
    RuntimeApiTable->hipDrvMemcpy2DUnaligned_fn = SavedApiTable.hipDrvMemcpy2DUnaligned_fn;
}

static void switch_hipDrvMemcpy3D_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDrvMemcpy3D_fn = hipDrvMemcpy3D_wrapper;
  else
    RuntimeApiTable->hipDrvMemcpy3D_fn = SavedApiTable.hipDrvMemcpy3D_fn;
}

static void switch_hipDrvMemcpy3DAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDrvMemcpy3DAsync_fn = hipDrvMemcpy3DAsync_wrapper;
  else
    RuntimeApiTable->hipDrvMemcpy3DAsync_fn = SavedApiTable.hipDrvMemcpy3DAsync_fn;
}

static void switch_hipDrvPointerGetAttributes_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDrvPointerGetAttributes_fn = hipDrvPointerGetAttributes_wrapper;
  else
    RuntimeApiTable->hipDrvPointerGetAttributes_fn = SavedApiTable.hipDrvPointerGetAttributes_fn;
}

static void switch_hipEventCreate_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipEventCreate_fn = hipEventCreate_wrapper;
  else
    RuntimeApiTable->hipEventCreate_fn = SavedApiTable.hipEventCreate_fn;
}

static void switch_hipEventCreateWithFlags_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipEventCreateWithFlags_fn = hipEventCreateWithFlags_wrapper;
  else
    RuntimeApiTable->hipEventCreateWithFlags_fn = SavedApiTable.hipEventCreateWithFlags_fn;
}

static void switch_hipEventDestroy_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipEventDestroy_fn = hipEventDestroy_wrapper;
  else
    RuntimeApiTable->hipEventDestroy_fn = SavedApiTable.hipEventDestroy_fn;
}

static void switch_hipEventElapsedTime_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipEventElapsedTime_fn = hipEventElapsedTime_wrapper;
  else
    RuntimeApiTable->hipEventElapsedTime_fn = SavedApiTable.hipEventElapsedTime_fn;
}

static void switch_hipEventQuery_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipEventQuery_fn = hipEventQuery_wrapper;
  else
    RuntimeApiTable->hipEventQuery_fn = SavedApiTable.hipEventQuery_fn;
}

static void switch_hipEventRecord_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipEventRecord_fn = hipEventRecord_wrapper;
  else
    RuntimeApiTable->hipEventRecord_fn = SavedApiTable.hipEventRecord_fn;
}

static void switch_hipEventSynchronize_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipEventSynchronize_fn = hipEventSynchronize_wrapper;
  else
    RuntimeApiTable->hipEventSynchronize_fn = SavedApiTable.hipEventSynchronize_fn;
}

static void switch_hipExtGetLinkTypeAndHopCount_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipExtGetLinkTypeAndHopCount_fn = hipExtGetLinkTypeAndHopCount_wrapper;
  else
    RuntimeApiTable->hipExtGetLinkTypeAndHopCount_fn = SavedApiTable.hipExtGetLinkTypeAndHopCount_fn;
}

static void switch_hipExtLaunchKernel_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipExtLaunchKernel_fn = hipExtLaunchKernel_wrapper;
  else
    RuntimeApiTable->hipExtLaunchKernel_fn = SavedApiTable.hipExtLaunchKernel_fn;
}

static void switch_hipExtLaunchMultiKernelMultiDevice_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipExtLaunchMultiKernelMultiDevice_fn = hipExtLaunchMultiKernelMultiDevice_wrapper;
  else
    RuntimeApiTable->hipExtLaunchMultiKernelMultiDevice_fn = SavedApiTable.hipExtLaunchMultiKernelMultiDevice_fn;
}

static void switch_hipExtMallocWithFlags_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipExtMallocWithFlags_fn = hipExtMallocWithFlags_wrapper;
  else
    RuntimeApiTable->hipExtMallocWithFlags_fn = SavedApiTable.hipExtMallocWithFlags_fn;
}

static void switch_hipExtStreamCreateWithCUMask_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipExtStreamCreateWithCUMask_fn = hipExtStreamCreateWithCUMask_wrapper;
  else
    RuntimeApiTable->hipExtStreamCreateWithCUMask_fn = SavedApiTable.hipExtStreamCreateWithCUMask_fn;
}

static void switch_hipExtStreamGetCUMask_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipExtStreamGetCUMask_fn = hipExtStreamGetCUMask_wrapper;
  else
    RuntimeApiTable->hipExtStreamGetCUMask_fn = SavedApiTable.hipExtStreamGetCUMask_fn;
}

static void switch_hipExternalMemoryGetMappedBuffer_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipExternalMemoryGetMappedBuffer_fn = hipExternalMemoryGetMappedBuffer_wrapper;
  else
    RuntimeApiTable->hipExternalMemoryGetMappedBuffer_fn = SavedApiTable.hipExternalMemoryGetMappedBuffer_fn;
}

static void switch_hipFree_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipFree_fn = hipFree_wrapper;
  else
    RuntimeApiTable->hipFree_fn = SavedApiTable.hipFree_fn;
}

static void switch_hipFreeArray_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipFreeArray_fn = hipFreeArray_wrapper;
  else
    RuntimeApiTable->hipFreeArray_fn = SavedApiTable.hipFreeArray_fn;
}

static void switch_hipFreeAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipFreeAsync_fn = hipFreeAsync_wrapper;
  else
    RuntimeApiTable->hipFreeAsync_fn = SavedApiTable.hipFreeAsync_fn;
}

static void switch_hipFreeHost_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipFreeHost_fn = hipFreeHost_wrapper;
  else
    RuntimeApiTable->hipFreeHost_fn = SavedApiTable.hipFreeHost_fn;
}

static void switch_hipFreeMipmappedArray_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipFreeMipmappedArray_fn = hipFreeMipmappedArray_wrapper;
  else
    RuntimeApiTable->hipFreeMipmappedArray_fn = SavedApiTable.hipFreeMipmappedArray_fn;
}

static void switch_hipFuncGetAttribute_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipFuncGetAttribute_fn = hipFuncGetAttribute_wrapper;
  else
    RuntimeApiTable->hipFuncGetAttribute_fn = SavedApiTable.hipFuncGetAttribute_fn;
}

static void switch_hipFuncGetAttributes_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipFuncGetAttributes_fn = hipFuncGetAttributes_wrapper;
  else
    RuntimeApiTable->hipFuncGetAttributes_fn = SavedApiTable.hipFuncGetAttributes_fn;
}

static void switch_hipFuncSetAttribute_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipFuncSetAttribute_fn = hipFuncSetAttribute_wrapper;
  else
    RuntimeApiTable->hipFuncSetAttribute_fn = SavedApiTable.hipFuncSetAttribute_fn;
}

static void switch_hipFuncSetCacheConfig_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipFuncSetCacheConfig_fn = hipFuncSetCacheConfig_wrapper;
  else
    RuntimeApiTable->hipFuncSetCacheConfig_fn = SavedApiTable.hipFuncSetCacheConfig_fn;
}

static void switch_hipFuncSetSharedMemConfig_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipFuncSetSharedMemConfig_fn = hipFuncSetSharedMemConfig_wrapper;
  else
    RuntimeApiTable->hipFuncSetSharedMemConfig_fn = SavedApiTable.hipFuncSetSharedMemConfig_fn;
}

static void switch_hipGLGetDevices_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGLGetDevices_fn = hipGLGetDevices_wrapper;
  else
    RuntimeApiTable->hipGLGetDevices_fn = SavedApiTable.hipGLGetDevices_fn;
}

static void switch_hipGetChannelDesc_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetChannelDesc_fn = hipGetChannelDesc_wrapper;
  else
    RuntimeApiTable->hipGetChannelDesc_fn = SavedApiTable.hipGetChannelDesc_fn;
}

static void switch_hipGetDevice_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetDevice_fn = hipGetDevice_wrapper;
  else
    RuntimeApiTable->hipGetDevice_fn = SavedApiTable.hipGetDevice_fn;
}

static void switch_hipGetDeviceCount_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetDeviceCount_fn = hipGetDeviceCount_wrapper;
  else
    RuntimeApiTable->hipGetDeviceCount_fn = SavedApiTable.hipGetDeviceCount_fn;
}

static void switch_hipGetDeviceFlags_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetDeviceFlags_fn = hipGetDeviceFlags_wrapper;
  else
    RuntimeApiTable->hipGetDeviceFlags_fn = SavedApiTable.hipGetDeviceFlags_fn;
}

static void switch_hipGetDevicePropertiesR0600_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetDevicePropertiesR0600_fn = hipGetDevicePropertiesR0600_wrapper;
  else
    RuntimeApiTable->hipGetDevicePropertiesR0600_fn = SavedApiTable.hipGetDevicePropertiesR0600_fn;
}

static void switch_hipGetDevicePropertiesR0000_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetDevicePropertiesR0000_fn = hipGetDevicePropertiesR0000_wrapper;
  else
    RuntimeApiTable->hipGetDevicePropertiesR0000_fn = SavedApiTable.hipGetDevicePropertiesR0000_fn;
}

static void switch_hipGetErrorName_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetErrorName_fn = hipGetErrorName_wrapper;
  else
    RuntimeApiTable->hipGetErrorName_fn = SavedApiTable.hipGetErrorName_fn;
}

static void switch_hipGetErrorString_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetErrorString_fn = hipGetErrorString_wrapper;
  else
    RuntimeApiTable->hipGetErrorString_fn = SavedApiTable.hipGetErrorString_fn;
}

static void switch_hipGetLastError_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetLastError_fn = hipGetLastError_wrapper;
  else
    RuntimeApiTable->hipGetLastError_fn = SavedApiTable.hipGetLastError_fn;
}

static void switch_hipGetMipmappedArrayLevel_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetMipmappedArrayLevel_fn = hipGetMipmappedArrayLevel_wrapper;
  else
    RuntimeApiTable->hipGetMipmappedArrayLevel_fn = SavedApiTable.hipGetMipmappedArrayLevel_fn;
}

static void switch_hipGetSymbolAddress_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetSymbolAddress_fn = hipGetSymbolAddress_wrapper;
  else
    RuntimeApiTable->hipGetSymbolAddress_fn = SavedApiTable.hipGetSymbolAddress_fn;
}

static void switch_hipGetSymbolSize_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetSymbolSize_fn = hipGetSymbolSize_wrapper;
  else
    RuntimeApiTable->hipGetSymbolSize_fn = SavedApiTable.hipGetSymbolSize_fn;
}

static void switch_hipGetTextureAlignmentOffset_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetTextureAlignmentOffset_fn = hipGetTextureAlignmentOffset_wrapper;
  else
    RuntimeApiTable->hipGetTextureAlignmentOffset_fn = SavedApiTable.hipGetTextureAlignmentOffset_fn;
}

static void switch_hipGetTextureObjectResourceDesc_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetTextureObjectResourceDesc_fn = hipGetTextureObjectResourceDesc_wrapper;
  else
    RuntimeApiTable->hipGetTextureObjectResourceDesc_fn = SavedApiTable.hipGetTextureObjectResourceDesc_fn;
}

static void switch_hipGetTextureObjectResourceViewDesc_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetTextureObjectResourceViewDesc_fn = hipGetTextureObjectResourceViewDesc_wrapper;
  else
    RuntimeApiTable->hipGetTextureObjectResourceViewDesc_fn = SavedApiTable.hipGetTextureObjectResourceViewDesc_fn;
}

static void switch_hipGetTextureObjectTextureDesc_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetTextureObjectTextureDesc_fn = hipGetTextureObjectTextureDesc_wrapper;
  else
    RuntimeApiTable->hipGetTextureObjectTextureDesc_fn = SavedApiTable.hipGetTextureObjectTextureDesc_fn;
}

static void switch_hipGetTextureReference_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetTextureReference_fn = hipGetTextureReference_wrapper;
  else
    RuntimeApiTable->hipGetTextureReference_fn = SavedApiTable.hipGetTextureReference_fn;
}

static void switch_hipGraphAddChildGraphNode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphAddChildGraphNode_fn = hipGraphAddChildGraphNode_wrapper;
  else
    RuntimeApiTable->hipGraphAddChildGraphNode_fn = SavedApiTable.hipGraphAddChildGraphNode_fn;
}

static void switch_hipGraphAddDependencies_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphAddDependencies_fn = hipGraphAddDependencies_wrapper;
  else
    RuntimeApiTable->hipGraphAddDependencies_fn = SavedApiTable.hipGraphAddDependencies_fn;
}

static void switch_hipGraphAddEmptyNode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphAddEmptyNode_fn = hipGraphAddEmptyNode_wrapper;
  else
    RuntimeApiTable->hipGraphAddEmptyNode_fn = SavedApiTable.hipGraphAddEmptyNode_fn;
}

static void switch_hipGraphAddEventRecordNode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphAddEventRecordNode_fn = hipGraphAddEventRecordNode_wrapper;
  else
    RuntimeApiTable->hipGraphAddEventRecordNode_fn = SavedApiTable.hipGraphAddEventRecordNode_fn;
}

static void switch_hipGraphAddEventWaitNode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphAddEventWaitNode_fn = hipGraphAddEventWaitNode_wrapper;
  else
    RuntimeApiTable->hipGraphAddEventWaitNode_fn = SavedApiTable.hipGraphAddEventWaitNode_fn;
}

static void switch_hipGraphAddHostNode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphAddHostNode_fn = hipGraphAddHostNode_wrapper;
  else
    RuntimeApiTable->hipGraphAddHostNode_fn = SavedApiTable.hipGraphAddHostNode_fn;
}

static void switch_hipGraphAddKernelNode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphAddKernelNode_fn = hipGraphAddKernelNode_wrapper;
  else
    RuntimeApiTable->hipGraphAddKernelNode_fn = SavedApiTable.hipGraphAddKernelNode_fn;
}

static void switch_hipGraphAddMemAllocNode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphAddMemAllocNode_fn = hipGraphAddMemAllocNode_wrapper;
  else
    RuntimeApiTable->hipGraphAddMemAllocNode_fn = SavedApiTable.hipGraphAddMemAllocNode_fn;
}

static void switch_hipGraphAddMemFreeNode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphAddMemFreeNode_fn = hipGraphAddMemFreeNode_wrapper;
  else
    RuntimeApiTable->hipGraphAddMemFreeNode_fn = SavedApiTable.hipGraphAddMemFreeNode_fn;
}

static void switch_hipGraphAddMemcpyNode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphAddMemcpyNode_fn = hipGraphAddMemcpyNode_wrapper;
  else
    RuntimeApiTable->hipGraphAddMemcpyNode_fn = SavedApiTable.hipGraphAddMemcpyNode_fn;
}

static void switch_hipGraphAddMemcpyNode1D_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphAddMemcpyNode1D_fn = hipGraphAddMemcpyNode1D_wrapper;
  else
    RuntimeApiTable->hipGraphAddMemcpyNode1D_fn = SavedApiTable.hipGraphAddMemcpyNode1D_fn;
}

static void switch_hipGraphAddMemcpyNodeFromSymbol_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphAddMemcpyNodeFromSymbol_fn = hipGraphAddMemcpyNodeFromSymbol_wrapper;
  else
    RuntimeApiTable->hipGraphAddMemcpyNodeFromSymbol_fn = SavedApiTable.hipGraphAddMemcpyNodeFromSymbol_fn;
}

static void switch_hipGraphAddMemcpyNodeToSymbol_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphAddMemcpyNodeToSymbol_fn = hipGraphAddMemcpyNodeToSymbol_wrapper;
  else
    RuntimeApiTable->hipGraphAddMemcpyNodeToSymbol_fn = SavedApiTable.hipGraphAddMemcpyNodeToSymbol_fn;
}

static void switch_hipGraphAddMemsetNode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphAddMemsetNode_fn = hipGraphAddMemsetNode_wrapper;
  else
    RuntimeApiTable->hipGraphAddMemsetNode_fn = SavedApiTable.hipGraphAddMemsetNode_fn;
}

static void switch_hipGraphChildGraphNodeGetGraph_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphChildGraphNodeGetGraph_fn = hipGraphChildGraphNodeGetGraph_wrapper;
  else
    RuntimeApiTable->hipGraphChildGraphNodeGetGraph_fn = SavedApiTable.hipGraphChildGraphNodeGetGraph_fn;
}

static void switch_hipGraphClone_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphClone_fn = hipGraphClone_wrapper;
  else
    RuntimeApiTable->hipGraphClone_fn = SavedApiTable.hipGraphClone_fn;
}

static void switch_hipGraphCreate_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphCreate_fn = hipGraphCreate_wrapper;
  else
    RuntimeApiTable->hipGraphCreate_fn = SavedApiTable.hipGraphCreate_fn;
}

static void switch_hipGraphDebugDotPrint_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphDebugDotPrint_fn = hipGraphDebugDotPrint_wrapper;
  else
    RuntimeApiTable->hipGraphDebugDotPrint_fn = SavedApiTable.hipGraphDebugDotPrint_fn;
}

static void switch_hipGraphDestroy_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphDestroy_fn = hipGraphDestroy_wrapper;
  else
    RuntimeApiTable->hipGraphDestroy_fn = SavedApiTable.hipGraphDestroy_fn;
}

static void switch_hipGraphDestroyNode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphDestroyNode_fn = hipGraphDestroyNode_wrapper;
  else
    RuntimeApiTable->hipGraphDestroyNode_fn = SavedApiTable.hipGraphDestroyNode_fn;
}

static void switch_hipGraphEventRecordNodeGetEvent_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphEventRecordNodeGetEvent_fn = hipGraphEventRecordNodeGetEvent_wrapper;
  else
    RuntimeApiTable->hipGraphEventRecordNodeGetEvent_fn = SavedApiTable.hipGraphEventRecordNodeGetEvent_fn;
}

static void switch_hipGraphEventRecordNodeSetEvent_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphEventRecordNodeSetEvent_fn = hipGraphEventRecordNodeSetEvent_wrapper;
  else
    RuntimeApiTable->hipGraphEventRecordNodeSetEvent_fn = SavedApiTable.hipGraphEventRecordNodeSetEvent_fn;
}

static void switch_hipGraphEventWaitNodeGetEvent_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphEventWaitNodeGetEvent_fn = hipGraphEventWaitNodeGetEvent_wrapper;
  else
    RuntimeApiTable->hipGraphEventWaitNodeGetEvent_fn = SavedApiTable.hipGraphEventWaitNodeGetEvent_fn;
}

static void switch_hipGraphEventWaitNodeSetEvent_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphEventWaitNodeSetEvent_fn = hipGraphEventWaitNodeSetEvent_wrapper;
  else
    RuntimeApiTable->hipGraphEventWaitNodeSetEvent_fn = SavedApiTable.hipGraphEventWaitNodeSetEvent_fn;
}

static void switch_hipGraphExecChildGraphNodeSetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExecChildGraphNodeSetParams_fn = hipGraphExecChildGraphNodeSetParams_wrapper;
  else
    RuntimeApiTable->hipGraphExecChildGraphNodeSetParams_fn = SavedApiTable.hipGraphExecChildGraphNodeSetParams_fn;
}

static void switch_hipGraphExecDestroy_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExecDestroy_fn = hipGraphExecDestroy_wrapper;
  else
    RuntimeApiTable->hipGraphExecDestroy_fn = SavedApiTable.hipGraphExecDestroy_fn;
}

static void switch_hipGraphExecEventRecordNodeSetEvent_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExecEventRecordNodeSetEvent_fn = hipGraphExecEventRecordNodeSetEvent_wrapper;
  else
    RuntimeApiTable->hipGraphExecEventRecordNodeSetEvent_fn = SavedApiTable.hipGraphExecEventRecordNodeSetEvent_fn;
}

static void switch_hipGraphExecEventWaitNodeSetEvent_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExecEventWaitNodeSetEvent_fn = hipGraphExecEventWaitNodeSetEvent_wrapper;
  else
    RuntimeApiTable->hipGraphExecEventWaitNodeSetEvent_fn = SavedApiTable.hipGraphExecEventWaitNodeSetEvent_fn;
}

static void switch_hipGraphExecHostNodeSetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExecHostNodeSetParams_fn = hipGraphExecHostNodeSetParams_wrapper;
  else
    RuntimeApiTable->hipGraphExecHostNodeSetParams_fn = SavedApiTable.hipGraphExecHostNodeSetParams_fn;
}

static void switch_hipGraphExecKernelNodeSetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExecKernelNodeSetParams_fn = hipGraphExecKernelNodeSetParams_wrapper;
  else
    RuntimeApiTable->hipGraphExecKernelNodeSetParams_fn = SavedApiTable.hipGraphExecKernelNodeSetParams_fn;
}

static void switch_hipGraphExecMemcpyNodeSetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExecMemcpyNodeSetParams_fn = hipGraphExecMemcpyNodeSetParams_wrapper;
  else
    RuntimeApiTable->hipGraphExecMemcpyNodeSetParams_fn = SavedApiTable.hipGraphExecMemcpyNodeSetParams_fn;
}

static void switch_hipGraphExecMemcpyNodeSetParams1D_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExecMemcpyNodeSetParams1D_fn = hipGraphExecMemcpyNodeSetParams1D_wrapper;
  else
    RuntimeApiTable->hipGraphExecMemcpyNodeSetParams1D_fn = SavedApiTable.hipGraphExecMemcpyNodeSetParams1D_fn;
}

static void switch_hipGraphExecMemcpyNodeSetParamsFromSymbol_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExecMemcpyNodeSetParamsFromSymbol_fn = hipGraphExecMemcpyNodeSetParamsFromSymbol_wrapper;
  else
    RuntimeApiTable->hipGraphExecMemcpyNodeSetParamsFromSymbol_fn = SavedApiTable.hipGraphExecMemcpyNodeSetParamsFromSymbol_fn;
}

static void switch_hipGraphExecMemcpyNodeSetParamsToSymbol_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExecMemcpyNodeSetParamsToSymbol_fn = hipGraphExecMemcpyNodeSetParamsToSymbol_wrapper;
  else
    RuntimeApiTable->hipGraphExecMemcpyNodeSetParamsToSymbol_fn = SavedApiTable.hipGraphExecMemcpyNodeSetParamsToSymbol_fn;
}

static void switch_hipGraphExecMemsetNodeSetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExecMemsetNodeSetParams_fn = hipGraphExecMemsetNodeSetParams_wrapper;
  else
    RuntimeApiTable->hipGraphExecMemsetNodeSetParams_fn = SavedApiTable.hipGraphExecMemsetNodeSetParams_fn;
}

static void switch_hipGraphExecUpdate_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExecUpdate_fn = hipGraphExecUpdate_wrapper;
  else
    RuntimeApiTable->hipGraphExecUpdate_fn = SavedApiTable.hipGraphExecUpdate_fn;
}

static void switch_hipGraphGetEdges_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphGetEdges_fn = hipGraphGetEdges_wrapper;
  else
    RuntimeApiTable->hipGraphGetEdges_fn = SavedApiTable.hipGraphGetEdges_fn;
}

static void switch_hipGraphGetNodes_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphGetNodes_fn = hipGraphGetNodes_wrapper;
  else
    RuntimeApiTable->hipGraphGetNodes_fn = SavedApiTable.hipGraphGetNodes_fn;
}

static void switch_hipGraphGetRootNodes_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphGetRootNodes_fn = hipGraphGetRootNodes_wrapper;
  else
    RuntimeApiTable->hipGraphGetRootNodes_fn = SavedApiTable.hipGraphGetRootNodes_fn;
}

static void switch_hipGraphHostNodeGetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphHostNodeGetParams_fn = hipGraphHostNodeGetParams_wrapper;
  else
    RuntimeApiTable->hipGraphHostNodeGetParams_fn = SavedApiTable.hipGraphHostNodeGetParams_fn;
}

static void switch_hipGraphHostNodeSetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphHostNodeSetParams_fn = hipGraphHostNodeSetParams_wrapper;
  else
    RuntimeApiTable->hipGraphHostNodeSetParams_fn = SavedApiTable.hipGraphHostNodeSetParams_fn;
}

static void switch_hipGraphInstantiate_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphInstantiate_fn = hipGraphInstantiate_wrapper;
  else
    RuntimeApiTable->hipGraphInstantiate_fn = SavedApiTable.hipGraphInstantiate_fn;
}

static void switch_hipGraphInstantiateWithFlags_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphInstantiateWithFlags_fn = hipGraphInstantiateWithFlags_wrapper;
  else
    RuntimeApiTable->hipGraphInstantiateWithFlags_fn = SavedApiTable.hipGraphInstantiateWithFlags_fn;
}

static void switch_hipGraphKernelNodeCopyAttributes_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphKernelNodeCopyAttributes_fn = hipGraphKernelNodeCopyAttributes_wrapper;
  else
    RuntimeApiTable->hipGraphKernelNodeCopyAttributes_fn = SavedApiTable.hipGraphKernelNodeCopyAttributes_fn;
}

static void switch_hipGraphKernelNodeGetAttribute_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphKernelNodeGetAttribute_fn = hipGraphKernelNodeGetAttribute_wrapper;
  else
    RuntimeApiTable->hipGraphKernelNodeGetAttribute_fn = SavedApiTable.hipGraphKernelNodeGetAttribute_fn;
}

static void switch_hipGraphKernelNodeGetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphKernelNodeGetParams_fn = hipGraphKernelNodeGetParams_wrapper;
  else
    RuntimeApiTable->hipGraphKernelNodeGetParams_fn = SavedApiTable.hipGraphKernelNodeGetParams_fn;
}

static void switch_hipGraphKernelNodeSetAttribute_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphKernelNodeSetAttribute_fn = hipGraphKernelNodeSetAttribute_wrapper;
  else
    RuntimeApiTable->hipGraphKernelNodeSetAttribute_fn = SavedApiTable.hipGraphKernelNodeSetAttribute_fn;
}

static void switch_hipGraphKernelNodeSetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphKernelNodeSetParams_fn = hipGraphKernelNodeSetParams_wrapper;
  else
    RuntimeApiTable->hipGraphKernelNodeSetParams_fn = SavedApiTable.hipGraphKernelNodeSetParams_fn;
}

static void switch_hipGraphLaunch_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphLaunch_fn = hipGraphLaunch_wrapper;
  else
    RuntimeApiTable->hipGraphLaunch_fn = SavedApiTable.hipGraphLaunch_fn;
}

static void switch_hipGraphMemAllocNodeGetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphMemAllocNodeGetParams_fn = hipGraphMemAllocNodeGetParams_wrapper;
  else
    RuntimeApiTable->hipGraphMemAllocNodeGetParams_fn = SavedApiTable.hipGraphMemAllocNodeGetParams_fn;
}

static void switch_hipGraphMemFreeNodeGetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphMemFreeNodeGetParams_fn = hipGraphMemFreeNodeGetParams_wrapper;
  else
    RuntimeApiTable->hipGraphMemFreeNodeGetParams_fn = SavedApiTable.hipGraphMemFreeNodeGetParams_fn;
}

static void switch_hipGraphMemcpyNodeGetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphMemcpyNodeGetParams_fn = hipGraphMemcpyNodeGetParams_wrapper;
  else
    RuntimeApiTable->hipGraphMemcpyNodeGetParams_fn = SavedApiTable.hipGraphMemcpyNodeGetParams_fn;
}

static void switch_hipGraphMemcpyNodeSetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphMemcpyNodeSetParams_fn = hipGraphMemcpyNodeSetParams_wrapper;
  else
    RuntimeApiTable->hipGraphMemcpyNodeSetParams_fn = SavedApiTable.hipGraphMemcpyNodeSetParams_fn;
}

static void switch_hipGraphMemcpyNodeSetParams1D_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphMemcpyNodeSetParams1D_fn = hipGraphMemcpyNodeSetParams1D_wrapper;
  else
    RuntimeApiTable->hipGraphMemcpyNodeSetParams1D_fn = SavedApiTable.hipGraphMemcpyNodeSetParams1D_fn;
}

static void switch_hipGraphMemcpyNodeSetParamsFromSymbol_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphMemcpyNodeSetParamsFromSymbol_fn = hipGraphMemcpyNodeSetParamsFromSymbol_wrapper;
  else
    RuntimeApiTable->hipGraphMemcpyNodeSetParamsFromSymbol_fn = SavedApiTable.hipGraphMemcpyNodeSetParamsFromSymbol_fn;
}

static void switch_hipGraphMemcpyNodeSetParamsToSymbol_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphMemcpyNodeSetParamsToSymbol_fn = hipGraphMemcpyNodeSetParamsToSymbol_wrapper;
  else
    RuntimeApiTable->hipGraphMemcpyNodeSetParamsToSymbol_fn = SavedApiTable.hipGraphMemcpyNodeSetParamsToSymbol_fn;
}

static void switch_hipGraphMemsetNodeGetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphMemsetNodeGetParams_fn = hipGraphMemsetNodeGetParams_wrapper;
  else
    RuntimeApiTable->hipGraphMemsetNodeGetParams_fn = SavedApiTable.hipGraphMemsetNodeGetParams_fn;
}

static void switch_hipGraphMemsetNodeSetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphMemsetNodeSetParams_fn = hipGraphMemsetNodeSetParams_wrapper;
  else
    RuntimeApiTable->hipGraphMemsetNodeSetParams_fn = SavedApiTable.hipGraphMemsetNodeSetParams_fn;
}

static void switch_hipGraphNodeFindInClone_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphNodeFindInClone_fn = hipGraphNodeFindInClone_wrapper;
  else
    RuntimeApiTable->hipGraphNodeFindInClone_fn = SavedApiTable.hipGraphNodeFindInClone_fn;
}

static void switch_hipGraphNodeGetDependencies_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphNodeGetDependencies_fn = hipGraphNodeGetDependencies_wrapper;
  else
    RuntimeApiTable->hipGraphNodeGetDependencies_fn = SavedApiTable.hipGraphNodeGetDependencies_fn;
}

static void switch_hipGraphNodeGetDependentNodes_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphNodeGetDependentNodes_fn = hipGraphNodeGetDependentNodes_wrapper;
  else
    RuntimeApiTable->hipGraphNodeGetDependentNodes_fn = SavedApiTable.hipGraphNodeGetDependentNodes_fn;
}

static void switch_hipGraphNodeGetEnabled_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphNodeGetEnabled_fn = hipGraphNodeGetEnabled_wrapper;
  else
    RuntimeApiTable->hipGraphNodeGetEnabled_fn = SavedApiTable.hipGraphNodeGetEnabled_fn;
}

static void switch_hipGraphNodeGetType_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphNodeGetType_fn = hipGraphNodeGetType_wrapper;
  else
    RuntimeApiTable->hipGraphNodeGetType_fn = SavedApiTable.hipGraphNodeGetType_fn;
}

static void switch_hipGraphNodeSetEnabled_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphNodeSetEnabled_fn = hipGraphNodeSetEnabled_wrapper;
  else
    RuntimeApiTable->hipGraphNodeSetEnabled_fn = SavedApiTable.hipGraphNodeSetEnabled_fn;
}

static void switch_hipGraphReleaseUserObject_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphReleaseUserObject_fn = hipGraphReleaseUserObject_wrapper;
  else
    RuntimeApiTable->hipGraphReleaseUserObject_fn = SavedApiTable.hipGraphReleaseUserObject_fn;
}

static void switch_hipGraphRemoveDependencies_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphRemoveDependencies_fn = hipGraphRemoveDependencies_wrapper;
  else
    RuntimeApiTable->hipGraphRemoveDependencies_fn = SavedApiTable.hipGraphRemoveDependencies_fn;
}

static void switch_hipGraphRetainUserObject_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphRetainUserObject_fn = hipGraphRetainUserObject_wrapper;
  else
    RuntimeApiTable->hipGraphRetainUserObject_fn = SavedApiTable.hipGraphRetainUserObject_fn;
}

static void switch_hipGraphUpload_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphUpload_fn = hipGraphUpload_wrapper;
  else
    RuntimeApiTable->hipGraphUpload_fn = SavedApiTable.hipGraphUpload_fn;
}

static void switch_hipGraphicsGLRegisterBuffer_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphicsGLRegisterBuffer_fn = hipGraphicsGLRegisterBuffer_wrapper;
  else
    RuntimeApiTable->hipGraphicsGLRegisterBuffer_fn = SavedApiTable.hipGraphicsGLRegisterBuffer_fn;
}

static void switch_hipGraphicsGLRegisterImage_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphicsGLRegisterImage_fn = hipGraphicsGLRegisterImage_wrapper;
  else
    RuntimeApiTable->hipGraphicsGLRegisterImage_fn = SavedApiTable.hipGraphicsGLRegisterImage_fn;
}

static void switch_hipGraphicsMapResources_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphicsMapResources_fn = hipGraphicsMapResources_wrapper;
  else
    RuntimeApiTable->hipGraphicsMapResources_fn = SavedApiTable.hipGraphicsMapResources_fn;
}

static void switch_hipGraphicsResourceGetMappedPointer_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphicsResourceGetMappedPointer_fn = hipGraphicsResourceGetMappedPointer_wrapper;
  else
    RuntimeApiTable->hipGraphicsResourceGetMappedPointer_fn = SavedApiTable.hipGraphicsResourceGetMappedPointer_fn;
}

static void switch_hipGraphicsSubResourceGetMappedArray_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphicsSubResourceGetMappedArray_fn = hipGraphicsSubResourceGetMappedArray_wrapper;
  else
    RuntimeApiTable->hipGraphicsSubResourceGetMappedArray_fn = SavedApiTable.hipGraphicsSubResourceGetMappedArray_fn;
}

static void switch_hipGraphicsUnmapResources_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphicsUnmapResources_fn = hipGraphicsUnmapResources_wrapper;
  else
    RuntimeApiTable->hipGraphicsUnmapResources_fn = SavedApiTable.hipGraphicsUnmapResources_fn;
}

static void switch_hipGraphicsUnregisterResource_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphicsUnregisterResource_fn = hipGraphicsUnregisterResource_wrapper;
  else
    RuntimeApiTable->hipGraphicsUnregisterResource_fn = SavedApiTable.hipGraphicsUnregisterResource_fn;
}

static void switch_hipHostAlloc_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipHostAlloc_fn = hipHostAlloc_wrapper;
  else
    RuntimeApiTable->hipHostAlloc_fn = SavedApiTable.hipHostAlloc_fn;
}

static void switch_hipHostFree_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipHostFree_fn = hipHostFree_wrapper;
  else
    RuntimeApiTable->hipHostFree_fn = SavedApiTable.hipHostFree_fn;
}

static void switch_hipHostGetDevicePointer_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipHostGetDevicePointer_fn = hipHostGetDevicePointer_wrapper;
  else
    RuntimeApiTable->hipHostGetDevicePointer_fn = SavedApiTable.hipHostGetDevicePointer_fn;
}

static void switch_hipHostGetFlags_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipHostGetFlags_fn = hipHostGetFlags_wrapper;
  else
    RuntimeApiTable->hipHostGetFlags_fn = SavedApiTable.hipHostGetFlags_fn;
}

static void switch_hipHostMalloc_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipHostMalloc_fn = hipHostMalloc_wrapper;
  else
    RuntimeApiTable->hipHostMalloc_fn = SavedApiTable.hipHostMalloc_fn;
}

static void switch_hipHostRegister_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipHostRegister_fn = hipHostRegister_wrapper;
  else
    RuntimeApiTable->hipHostRegister_fn = SavedApiTable.hipHostRegister_fn;
}

static void switch_hipHostUnregister_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipHostUnregister_fn = hipHostUnregister_wrapper;
  else
    RuntimeApiTable->hipHostUnregister_fn = SavedApiTable.hipHostUnregister_fn;
}

static void switch_hipImportExternalMemory_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipImportExternalMemory_fn = hipImportExternalMemory_wrapper;
  else
    RuntimeApiTable->hipImportExternalMemory_fn = SavedApiTable.hipImportExternalMemory_fn;
}

static void switch_hipImportExternalSemaphore_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipImportExternalSemaphore_fn = hipImportExternalSemaphore_wrapper;
  else
    RuntimeApiTable->hipImportExternalSemaphore_fn = SavedApiTable.hipImportExternalSemaphore_fn;
}

static void switch_hipInit_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipInit_fn = hipInit_wrapper;
  else
    RuntimeApiTable->hipInit_fn = SavedApiTable.hipInit_fn;
}

static void switch_hipIpcCloseMemHandle_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipIpcCloseMemHandle_fn = hipIpcCloseMemHandle_wrapper;
  else
    RuntimeApiTable->hipIpcCloseMemHandle_fn = SavedApiTable.hipIpcCloseMemHandle_fn;
}

static void switch_hipIpcGetEventHandle_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipIpcGetEventHandle_fn = hipIpcGetEventHandle_wrapper;
  else
    RuntimeApiTable->hipIpcGetEventHandle_fn = SavedApiTable.hipIpcGetEventHandle_fn;
}

static void switch_hipIpcGetMemHandle_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipIpcGetMemHandle_fn = hipIpcGetMemHandle_wrapper;
  else
    RuntimeApiTable->hipIpcGetMemHandle_fn = SavedApiTable.hipIpcGetMemHandle_fn;
}

static void switch_hipIpcOpenEventHandle_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipIpcOpenEventHandle_fn = hipIpcOpenEventHandle_wrapper;
  else
    RuntimeApiTable->hipIpcOpenEventHandle_fn = SavedApiTable.hipIpcOpenEventHandle_fn;
}

static void switch_hipIpcOpenMemHandle_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipIpcOpenMemHandle_fn = hipIpcOpenMemHandle_wrapper;
  else
    RuntimeApiTable->hipIpcOpenMemHandle_fn = SavedApiTable.hipIpcOpenMemHandle_fn;
}

static void switch_hipKernelNameRef_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipKernelNameRef_fn = hipKernelNameRef_wrapper;
  else
    RuntimeApiTable->hipKernelNameRef_fn = SavedApiTable.hipKernelNameRef_fn;
}

static void switch_hipKernelNameRefByPtr_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipKernelNameRefByPtr_fn = hipKernelNameRefByPtr_wrapper;
  else
    RuntimeApiTable->hipKernelNameRefByPtr_fn = SavedApiTable.hipKernelNameRefByPtr_fn;
}

static void switch_hipLaunchByPtr_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipLaunchByPtr_fn = hipLaunchByPtr_wrapper;
  else
    RuntimeApiTable->hipLaunchByPtr_fn = SavedApiTable.hipLaunchByPtr_fn;
}

static void switch_hipLaunchCooperativeKernel_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipLaunchCooperativeKernel_fn = hipLaunchCooperativeKernel_wrapper;
  else
    RuntimeApiTable->hipLaunchCooperativeKernel_fn = SavedApiTable.hipLaunchCooperativeKernel_fn;
}

static void switch_hipLaunchCooperativeKernelMultiDevice_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipLaunchCooperativeKernelMultiDevice_fn = hipLaunchCooperativeKernelMultiDevice_wrapper;
  else
    RuntimeApiTable->hipLaunchCooperativeKernelMultiDevice_fn = SavedApiTable.hipLaunchCooperativeKernelMultiDevice_fn;
}

static void switch_hipLaunchHostFunc_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipLaunchHostFunc_fn = hipLaunchHostFunc_wrapper;
  else
    RuntimeApiTable->hipLaunchHostFunc_fn = SavedApiTable.hipLaunchHostFunc_fn;
}

static void switch_hipLaunchKernel_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipLaunchKernel_fn = hipLaunchKernel_wrapper;
  else
    RuntimeApiTable->hipLaunchKernel_fn = SavedApiTable.hipLaunchKernel_fn;
}

static void switch_hipMalloc_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMalloc_fn = hipMalloc_wrapper;
  else
    RuntimeApiTable->hipMalloc_fn = SavedApiTable.hipMalloc_fn;
}

static void switch_hipMalloc3D_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMalloc3D_fn = hipMalloc3D_wrapper;
  else
    RuntimeApiTable->hipMalloc3D_fn = SavedApiTable.hipMalloc3D_fn;
}

static void switch_hipMalloc3DArray_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMalloc3DArray_fn = hipMalloc3DArray_wrapper;
  else
    RuntimeApiTable->hipMalloc3DArray_fn = SavedApiTable.hipMalloc3DArray_fn;
}

static void switch_hipMallocArray_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMallocArray_fn = hipMallocArray_wrapper;
  else
    RuntimeApiTable->hipMallocArray_fn = SavedApiTable.hipMallocArray_fn;
}

static void switch_hipMallocAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMallocAsync_fn = hipMallocAsync_wrapper;
  else
    RuntimeApiTable->hipMallocAsync_fn = SavedApiTable.hipMallocAsync_fn;
}

static void switch_hipMallocFromPoolAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMallocFromPoolAsync_fn = hipMallocFromPoolAsync_wrapper;
  else
    RuntimeApiTable->hipMallocFromPoolAsync_fn = SavedApiTable.hipMallocFromPoolAsync_fn;
}

static void switch_hipMallocHost_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMallocHost_fn = hipMallocHost_wrapper;
  else
    RuntimeApiTable->hipMallocHost_fn = SavedApiTable.hipMallocHost_fn;
}

static void switch_hipMallocManaged_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMallocManaged_fn = hipMallocManaged_wrapper;
  else
    RuntimeApiTable->hipMallocManaged_fn = SavedApiTable.hipMallocManaged_fn;
}

static void switch_hipMallocMipmappedArray_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMallocMipmappedArray_fn = hipMallocMipmappedArray_wrapper;
  else
    RuntimeApiTable->hipMallocMipmappedArray_fn = SavedApiTable.hipMallocMipmappedArray_fn;
}

static void switch_hipMallocPitch_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMallocPitch_fn = hipMallocPitch_wrapper;
  else
    RuntimeApiTable->hipMallocPitch_fn = SavedApiTable.hipMallocPitch_fn;
}

static void switch_hipMemAddressFree_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemAddressFree_fn = hipMemAddressFree_wrapper;
  else
    RuntimeApiTable->hipMemAddressFree_fn = SavedApiTable.hipMemAddressFree_fn;
}

static void switch_hipMemAddressReserve_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemAddressReserve_fn = hipMemAddressReserve_wrapper;
  else
    RuntimeApiTable->hipMemAddressReserve_fn = SavedApiTable.hipMemAddressReserve_fn;
}

static void switch_hipMemAdvise_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemAdvise_fn = hipMemAdvise_wrapper;
  else
    RuntimeApiTable->hipMemAdvise_fn = SavedApiTable.hipMemAdvise_fn;
}

static void switch_hipMemAllocHost_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemAllocHost_fn = hipMemAllocHost_wrapper;
  else
    RuntimeApiTable->hipMemAllocHost_fn = SavedApiTable.hipMemAllocHost_fn;
}

static void switch_hipMemAllocPitch_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemAllocPitch_fn = hipMemAllocPitch_wrapper;
  else
    RuntimeApiTable->hipMemAllocPitch_fn = SavedApiTable.hipMemAllocPitch_fn;
}

static void switch_hipMemCreate_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemCreate_fn = hipMemCreate_wrapper;
  else
    RuntimeApiTable->hipMemCreate_fn = SavedApiTable.hipMemCreate_fn;
}

static void switch_hipMemExportToShareableHandle_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemExportToShareableHandle_fn = hipMemExportToShareableHandle_wrapper;
  else
    RuntimeApiTable->hipMemExportToShareableHandle_fn = SavedApiTable.hipMemExportToShareableHandle_fn;
}

static void switch_hipMemGetAccess_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemGetAccess_fn = hipMemGetAccess_wrapper;
  else
    RuntimeApiTable->hipMemGetAccess_fn = SavedApiTable.hipMemGetAccess_fn;
}

static void switch_hipMemGetAddressRange_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemGetAddressRange_fn = hipMemGetAddressRange_wrapper;
  else
    RuntimeApiTable->hipMemGetAddressRange_fn = SavedApiTable.hipMemGetAddressRange_fn;
}

static void switch_hipMemGetAllocationGranularity_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemGetAllocationGranularity_fn = hipMemGetAllocationGranularity_wrapper;
  else
    RuntimeApiTable->hipMemGetAllocationGranularity_fn = SavedApiTable.hipMemGetAllocationGranularity_fn;
}

static void switch_hipMemGetAllocationPropertiesFromHandle_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemGetAllocationPropertiesFromHandle_fn = hipMemGetAllocationPropertiesFromHandle_wrapper;
  else
    RuntimeApiTable->hipMemGetAllocationPropertiesFromHandle_fn = SavedApiTable.hipMemGetAllocationPropertiesFromHandle_fn;
}

static void switch_hipMemGetInfo_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemGetInfo_fn = hipMemGetInfo_wrapper;
  else
    RuntimeApiTable->hipMemGetInfo_fn = SavedApiTable.hipMemGetInfo_fn;
}

static void switch_hipMemImportFromShareableHandle_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemImportFromShareableHandle_fn = hipMemImportFromShareableHandle_wrapper;
  else
    RuntimeApiTable->hipMemImportFromShareableHandle_fn = SavedApiTable.hipMemImportFromShareableHandle_fn;
}

static void switch_hipMemMap_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemMap_fn = hipMemMap_wrapper;
  else
    RuntimeApiTable->hipMemMap_fn = SavedApiTable.hipMemMap_fn;
}

static void switch_hipMemMapArrayAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemMapArrayAsync_fn = hipMemMapArrayAsync_wrapper;
  else
    RuntimeApiTable->hipMemMapArrayAsync_fn = SavedApiTable.hipMemMapArrayAsync_fn;
}

static void switch_hipMemPoolCreate_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemPoolCreate_fn = hipMemPoolCreate_wrapper;
  else
    RuntimeApiTable->hipMemPoolCreate_fn = SavedApiTable.hipMemPoolCreate_fn;
}

static void switch_hipMemPoolDestroy_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemPoolDestroy_fn = hipMemPoolDestroy_wrapper;
  else
    RuntimeApiTable->hipMemPoolDestroy_fn = SavedApiTable.hipMemPoolDestroy_fn;
}

static void switch_hipMemPoolExportPointer_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemPoolExportPointer_fn = hipMemPoolExportPointer_wrapper;
  else
    RuntimeApiTable->hipMemPoolExportPointer_fn = SavedApiTable.hipMemPoolExportPointer_fn;
}

static void switch_hipMemPoolExportToShareableHandle_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemPoolExportToShareableHandle_fn = hipMemPoolExportToShareableHandle_wrapper;
  else
    RuntimeApiTable->hipMemPoolExportToShareableHandle_fn = SavedApiTable.hipMemPoolExportToShareableHandle_fn;
}

static void switch_hipMemPoolGetAccess_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemPoolGetAccess_fn = hipMemPoolGetAccess_wrapper;
  else
    RuntimeApiTable->hipMemPoolGetAccess_fn = SavedApiTable.hipMemPoolGetAccess_fn;
}

static void switch_hipMemPoolGetAttribute_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemPoolGetAttribute_fn = hipMemPoolGetAttribute_wrapper;
  else
    RuntimeApiTable->hipMemPoolGetAttribute_fn = SavedApiTable.hipMemPoolGetAttribute_fn;
}

static void switch_hipMemPoolImportFromShareableHandle_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemPoolImportFromShareableHandle_fn = hipMemPoolImportFromShareableHandle_wrapper;
  else
    RuntimeApiTable->hipMemPoolImportFromShareableHandle_fn = SavedApiTable.hipMemPoolImportFromShareableHandle_fn;
}

static void switch_hipMemPoolImportPointer_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemPoolImportPointer_fn = hipMemPoolImportPointer_wrapper;
  else
    RuntimeApiTable->hipMemPoolImportPointer_fn = SavedApiTable.hipMemPoolImportPointer_fn;
}

static void switch_hipMemPoolSetAccess_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemPoolSetAccess_fn = hipMemPoolSetAccess_wrapper;
  else
    RuntimeApiTable->hipMemPoolSetAccess_fn = SavedApiTable.hipMemPoolSetAccess_fn;
}

static void switch_hipMemPoolSetAttribute_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemPoolSetAttribute_fn = hipMemPoolSetAttribute_wrapper;
  else
    RuntimeApiTable->hipMemPoolSetAttribute_fn = SavedApiTable.hipMemPoolSetAttribute_fn;
}

static void switch_hipMemPoolTrimTo_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemPoolTrimTo_fn = hipMemPoolTrimTo_wrapper;
  else
    RuntimeApiTable->hipMemPoolTrimTo_fn = SavedApiTable.hipMemPoolTrimTo_fn;
}

static void switch_hipMemPrefetchAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemPrefetchAsync_fn = hipMemPrefetchAsync_wrapper;
  else
    RuntimeApiTable->hipMemPrefetchAsync_fn = SavedApiTable.hipMemPrefetchAsync_fn;
}

static void switch_hipMemPtrGetInfo_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemPtrGetInfo_fn = hipMemPtrGetInfo_wrapper;
  else
    RuntimeApiTable->hipMemPtrGetInfo_fn = SavedApiTable.hipMemPtrGetInfo_fn;
}

static void switch_hipMemRangeGetAttribute_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemRangeGetAttribute_fn = hipMemRangeGetAttribute_wrapper;
  else
    RuntimeApiTable->hipMemRangeGetAttribute_fn = SavedApiTable.hipMemRangeGetAttribute_fn;
}

static void switch_hipMemRangeGetAttributes_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemRangeGetAttributes_fn = hipMemRangeGetAttributes_wrapper;
  else
    RuntimeApiTable->hipMemRangeGetAttributes_fn = SavedApiTable.hipMemRangeGetAttributes_fn;
}

static void switch_hipMemRelease_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemRelease_fn = hipMemRelease_wrapper;
  else
    RuntimeApiTable->hipMemRelease_fn = SavedApiTable.hipMemRelease_fn;
}

static void switch_hipMemRetainAllocationHandle_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemRetainAllocationHandle_fn = hipMemRetainAllocationHandle_wrapper;
  else
    RuntimeApiTable->hipMemRetainAllocationHandle_fn = SavedApiTable.hipMemRetainAllocationHandle_fn;
}

static void switch_hipMemSetAccess_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemSetAccess_fn = hipMemSetAccess_wrapper;
  else
    RuntimeApiTable->hipMemSetAccess_fn = SavedApiTable.hipMemSetAccess_fn;
}

static void switch_hipMemUnmap_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemUnmap_fn = hipMemUnmap_wrapper;
  else
    RuntimeApiTable->hipMemUnmap_fn = SavedApiTable.hipMemUnmap_fn;
}

static void switch_hipMemcpy_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy_fn = hipMemcpy_wrapper;
  else
    RuntimeApiTable->hipMemcpy_fn = SavedApiTable.hipMemcpy_fn;
}

static void switch_hipMemcpy2D_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy2D_fn = hipMemcpy2D_wrapper;
  else
    RuntimeApiTable->hipMemcpy2D_fn = SavedApiTable.hipMemcpy2D_fn;
}

static void switch_hipMemcpy2DAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy2DAsync_fn = hipMemcpy2DAsync_wrapper;
  else
    RuntimeApiTable->hipMemcpy2DAsync_fn = SavedApiTable.hipMemcpy2DAsync_fn;
}

static void switch_hipMemcpy2DFromArray_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy2DFromArray_fn = hipMemcpy2DFromArray_wrapper;
  else
    RuntimeApiTable->hipMemcpy2DFromArray_fn = SavedApiTable.hipMemcpy2DFromArray_fn;
}

static void switch_hipMemcpy2DFromArrayAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy2DFromArrayAsync_fn = hipMemcpy2DFromArrayAsync_wrapper;
  else
    RuntimeApiTable->hipMemcpy2DFromArrayAsync_fn = SavedApiTable.hipMemcpy2DFromArrayAsync_fn;
}

static void switch_hipMemcpy2DToArray_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy2DToArray_fn = hipMemcpy2DToArray_wrapper;
  else
    RuntimeApiTable->hipMemcpy2DToArray_fn = SavedApiTable.hipMemcpy2DToArray_fn;
}

static void switch_hipMemcpy2DToArrayAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy2DToArrayAsync_fn = hipMemcpy2DToArrayAsync_wrapper;
  else
    RuntimeApiTable->hipMemcpy2DToArrayAsync_fn = SavedApiTable.hipMemcpy2DToArrayAsync_fn;
}

static void switch_hipMemcpy3D_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy3D_fn = hipMemcpy3D_wrapper;
  else
    RuntimeApiTable->hipMemcpy3D_fn = SavedApiTable.hipMemcpy3D_fn;
}

static void switch_hipMemcpy3DAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy3DAsync_fn = hipMemcpy3DAsync_wrapper;
  else
    RuntimeApiTable->hipMemcpy3DAsync_fn = SavedApiTable.hipMemcpy3DAsync_fn;
}

static void switch_hipMemcpyAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyAsync_fn = hipMemcpyAsync_wrapper;
  else
    RuntimeApiTable->hipMemcpyAsync_fn = SavedApiTable.hipMemcpyAsync_fn;
}

static void switch_hipMemcpyAtoH_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyAtoH_fn = hipMemcpyAtoH_wrapper;
  else
    RuntimeApiTable->hipMemcpyAtoH_fn = SavedApiTable.hipMemcpyAtoH_fn;
}

static void switch_hipMemcpyDtoD_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyDtoD_fn = hipMemcpyDtoD_wrapper;
  else
    RuntimeApiTable->hipMemcpyDtoD_fn = SavedApiTable.hipMemcpyDtoD_fn;
}

static void switch_hipMemcpyDtoDAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyDtoDAsync_fn = hipMemcpyDtoDAsync_wrapper;
  else
    RuntimeApiTable->hipMemcpyDtoDAsync_fn = SavedApiTable.hipMemcpyDtoDAsync_fn;
}

static void switch_hipMemcpyDtoH_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyDtoH_fn = hipMemcpyDtoH_wrapper;
  else
    RuntimeApiTable->hipMemcpyDtoH_fn = SavedApiTable.hipMemcpyDtoH_fn;
}

static void switch_hipMemcpyDtoHAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyDtoHAsync_fn = hipMemcpyDtoHAsync_wrapper;
  else
    RuntimeApiTable->hipMemcpyDtoHAsync_fn = SavedApiTable.hipMemcpyDtoHAsync_fn;
}

static void switch_hipMemcpyFromArray_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyFromArray_fn = hipMemcpyFromArray_wrapper;
  else
    RuntimeApiTable->hipMemcpyFromArray_fn = SavedApiTable.hipMemcpyFromArray_fn;
}

static void switch_hipMemcpyFromSymbol_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyFromSymbol_fn = hipMemcpyFromSymbol_wrapper;
  else
    RuntimeApiTable->hipMemcpyFromSymbol_fn = SavedApiTable.hipMemcpyFromSymbol_fn;
}

static void switch_hipMemcpyFromSymbolAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyFromSymbolAsync_fn = hipMemcpyFromSymbolAsync_wrapper;
  else
    RuntimeApiTable->hipMemcpyFromSymbolAsync_fn = SavedApiTable.hipMemcpyFromSymbolAsync_fn;
}

static void switch_hipMemcpyHtoA_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyHtoA_fn = hipMemcpyHtoA_wrapper;
  else
    RuntimeApiTable->hipMemcpyHtoA_fn = SavedApiTable.hipMemcpyHtoA_fn;
}

static void switch_hipMemcpyHtoD_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyHtoD_fn = hipMemcpyHtoD_wrapper;
  else
    RuntimeApiTable->hipMemcpyHtoD_fn = SavedApiTable.hipMemcpyHtoD_fn;
}

static void switch_hipMemcpyHtoDAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyHtoDAsync_fn = hipMemcpyHtoDAsync_wrapper;
  else
    RuntimeApiTable->hipMemcpyHtoDAsync_fn = SavedApiTable.hipMemcpyHtoDAsync_fn;
}

static void switch_hipMemcpyParam2D_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyParam2D_fn = hipMemcpyParam2D_wrapper;
  else
    RuntimeApiTable->hipMemcpyParam2D_fn = SavedApiTable.hipMemcpyParam2D_fn;
}

static void switch_hipMemcpyParam2DAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyParam2DAsync_fn = hipMemcpyParam2DAsync_wrapper;
  else
    RuntimeApiTable->hipMemcpyParam2DAsync_fn = SavedApiTable.hipMemcpyParam2DAsync_fn;
}

static void switch_hipMemcpyPeer_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyPeer_fn = hipMemcpyPeer_wrapper;
  else
    RuntimeApiTable->hipMemcpyPeer_fn = SavedApiTable.hipMemcpyPeer_fn;
}

static void switch_hipMemcpyPeerAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyPeerAsync_fn = hipMemcpyPeerAsync_wrapper;
  else
    RuntimeApiTable->hipMemcpyPeerAsync_fn = SavedApiTable.hipMemcpyPeerAsync_fn;
}

static void switch_hipMemcpyToArray_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyToArray_fn = hipMemcpyToArray_wrapper;
  else
    RuntimeApiTable->hipMemcpyToArray_fn = SavedApiTable.hipMemcpyToArray_fn;
}

static void switch_hipMemcpyToSymbol_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyToSymbol_fn = hipMemcpyToSymbol_wrapper;
  else
    RuntimeApiTable->hipMemcpyToSymbol_fn = SavedApiTable.hipMemcpyToSymbol_fn;
}

static void switch_hipMemcpyToSymbolAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyToSymbolAsync_fn = hipMemcpyToSymbolAsync_wrapper;
  else
    RuntimeApiTable->hipMemcpyToSymbolAsync_fn = SavedApiTable.hipMemcpyToSymbolAsync_fn;
}

static void switch_hipMemcpyWithStream_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyWithStream_fn = hipMemcpyWithStream_wrapper;
  else
    RuntimeApiTable->hipMemcpyWithStream_fn = SavedApiTable.hipMemcpyWithStream_fn;
}

static void switch_hipMemset_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemset_fn = hipMemset_wrapper;
  else
    RuntimeApiTable->hipMemset_fn = SavedApiTable.hipMemset_fn;
}

static void switch_hipMemset2D_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemset2D_fn = hipMemset2D_wrapper;
  else
    RuntimeApiTable->hipMemset2D_fn = SavedApiTable.hipMemset2D_fn;
}

static void switch_hipMemset2DAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemset2DAsync_fn = hipMemset2DAsync_wrapper;
  else
    RuntimeApiTable->hipMemset2DAsync_fn = SavedApiTable.hipMemset2DAsync_fn;
}

static void switch_hipMemset3D_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemset3D_fn = hipMemset3D_wrapper;
  else
    RuntimeApiTable->hipMemset3D_fn = SavedApiTable.hipMemset3D_fn;
}

static void switch_hipMemset3DAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemset3DAsync_fn = hipMemset3DAsync_wrapper;
  else
    RuntimeApiTable->hipMemset3DAsync_fn = SavedApiTable.hipMemset3DAsync_fn;
}

static void switch_hipMemsetAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemsetAsync_fn = hipMemsetAsync_wrapper;
  else
    RuntimeApiTable->hipMemsetAsync_fn = SavedApiTable.hipMemsetAsync_fn;
}

static void switch_hipMemsetD16_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemsetD16_fn = hipMemsetD16_wrapper;
  else
    RuntimeApiTable->hipMemsetD16_fn = SavedApiTable.hipMemsetD16_fn;
}

static void switch_hipMemsetD16Async_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemsetD16Async_fn = hipMemsetD16Async_wrapper;
  else
    RuntimeApiTable->hipMemsetD16Async_fn = SavedApiTable.hipMemsetD16Async_fn;
}

static void switch_hipMemsetD32_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemsetD32_fn = hipMemsetD32_wrapper;
  else
    RuntimeApiTable->hipMemsetD32_fn = SavedApiTable.hipMemsetD32_fn;
}

static void switch_hipMemsetD32Async_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemsetD32Async_fn = hipMemsetD32Async_wrapper;
  else
    RuntimeApiTable->hipMemsetD32Async_fn = SavedApiTable.hipMemsetD32Async_fn;
}

static void switch_hipMemsetD8_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemsetD8_fn = hipMemsetD8_wrapper;
  else
    RuntimeApiTable->hipMemsetD8_fn = SavedApiTable.hipMemsetD8_fn;
}

static void switch_hipMemsetD8Async_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemsetD8Async_fn = hipMemsetD8Async_wrapper;
  else
    RuntimeApiTable->hipMemsetD8Async_fn = SavedApiTable.hipMemsetD8Async_fn;
}

static void switch_hipMipmappedArrayCreate_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMipmappedArrayCreate_fn = hipMipmappedArrayCreate_wrapper;
  else
    RuntimeApiTable->hipMipmappedArrayCreate_fn = SavedApiTable.hipMipmappedArrayCreate_fn;
}

static void switch_hipMipmappedArrayDestroy_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMipmappedArrayDestroy_fn = hipMipmappedArrayDestroy_wrapper;
  else
    RuntimeApiTable->hipMipmappedArrayDestroy_fn = SavedApiTable.hipMipmappedArrayDestroy_fn;
}

static void switch_hipMipmappedArrayGetLevel_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMipmappedArrayGetLevel_fn = hipMipmappedArrayGetLevel_wrapper;
  else
    RuntimeApiTable->hipMipmappedArrayGetLevel_fn = SavedApiTable.hipMipmappedArrayGetLevel_fn;
}

static void switch_hipModuleGetFunction_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipModuleGetFunction_fn = hipModuleGetFunction_wrapper;
  else
    RuntimeApiTable->hipModuleGetFunction_fn = SavedApiTable.hipModuleGetFunction_fn;
}

static void switch_hipModuleGetGlobal_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipModuleGetGlobal_fn = hipModuleGetGlobal_wrapper;
  else
    RuntimeApiTable->hipModuleGetGlobal_fn = SavedApiTable.hipModuleGetGlobal_fn;
}

static void switch_hipModuleGetTexRef_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipModuleGetTexRef_fn = hipModuleGetTexRef_wrapper;
  else
    RuntimeApiTable->hipModuleGetTexRef_fn = SavedApiTable.hipModuleGetTexRef_fn;
}

static void switch_hipModuleLaunchCooperativeKernel_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipModuleLaunchCooperativeKernel_fn = hipModuleLaunchCooperativeKernel_wrapper;
  else
    RuntimeApiTable->hipModuleLaunchCooperativeKernel_fn = SavedApiTable.hipModuleLaunchCooperativeKernel_fn;
}

static void switch_hipModuleLaunchCooperativeKernelMultiDevice_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipModuleLaunchCooperativeKernelMultiDevice_fn = hipModuleLaunchCooperativeKernelMultiDevice_wrapper;
  else
    RuntimeApiTable->hipModuleLaunchCooperativeKernelMultiDevice_fn = SavedApiTable.hipModuleLaunchCooperativeKernelMultiDevice_fn;
}

static void switch_hipModuleLaunchKernel_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipModuleLaunchKernel_fn = hipModuleLaunchKernel_wrapper;
  else
    RuntimeApiTable->hipModuleLaunchKernel_fn = SavedApiTable.hipModuleLaunchKernel_fn;
}

static void switch_hipModuleLoad_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipModuleLoad_fn = hipModuleLoad_wrapper;
  else
    RuntimeApiTable->hipModuleLoad_fn = SavedApiTable.hipModuleLoad_fn;
}

static void switch_hipModuleLoadData_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipModuleLoadData_fn = hipModuleLoadData_wrapper;
  else
    RuntimeApiTable->hipModuleLoadData_fn = SavedApiTable.hipModuleLoadData_fn;
}

static void switch_hipModuleLoadDataEx_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipModuleLoadDataEx_fn = hipModuleLoadDataEx_wrapper;
  else
    RuntimeApiTable->hipModuleLoadDataEx_fn = SavedApiTable.hipModuleLoadDataEx_fn;
}

static void switch_hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_fn = hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_wrapper;
  else
    RuntimeApiTable->hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_fn = SavedApiTable.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_fn;
}

static void switch_hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_fn = hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_wrapper;
  else
    RuntimeApiTable->hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_fn = SavedApiTable.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_fn;
}

static void switch_hipModuleOccupancyMaxPotentialBlockSize_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipModuleOccupancyMaxPotentialBlockSize_fn = hipModuleOccupancyMaxPotentialBlockSize_wrapper;
  else
    RuntimeApiTable->hipModuleOccupancyMaxPotentialBlockSize_fn = SavedApiTable.hipModuleOccupancyMaxPotentialBlockSize_fn;
}

static void switch_hipModuleOccupancyMaxPotentialBlockSizeWithFlags_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipModuleOccupancyMaxPotentialBlockSizeWithFlags_fn = hipModuleOccupancyMaxPotentialBlockSizeWithFlags_wrapper;
  else
    RuntimeApiTable->hipModuleOccupancyMaxPotentialBlockSizeWithFlags_fn = SavedApiTable.hipModuleOccupancyMaxPotentialBlockSizeWithFlags_fn;
}

static void switch_hipModuleUnload_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipModuleUnload_fn = hipModuleUnload_wrapper;
  else
    RuntimeApiTable->hipModuleUnload_fn = SavedApiTable.hipModuleUnload_fn;
}

static void switch_hipOccupancyMaxActiveBlocksPerMultiprocessor_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipOccupancyMaxActiveBlocksPerMultiprocessor_fn = hipOccupancyMaxActiveBlocksPerMultiprocessor_wrapper;
  else
    RuntimeApiTable->hipOccupancyMaxActiveBlocksPerMultiprocessor_fn = SavedApiTable.hipOccupancyMaxActiveBlocksPerMultiprocessor_fn;
}

static void switch_hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_fn = hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_wrapper;
  else
    RuntimeApiTable->hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_fn = SavedApiTable.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_fn;
}

static void switch_hipOccupancyMaxPotentialBlockSize_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipOccupancyMaxPotentialBlockSize_fn = hipOccupancyMaxPotentialBlockSize_wrapper;
  else
    RuntimeApiTable->hipOccupancyMaxPotentialBlockSize_fn = SavedApiTable.hipOccupancyMaxPotentialBlockSize_fn;
}

static void switch_hipPeekAtLastError_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipPeekAtLastError_fn = hipPeekAtLastError_wrapper;
  else
    RuntimeApiTable->hipPeekAtLastError_fn = SavedApiTable.hipPeekAtLastError_fn;
}

static void switch_hipPointerGetAttribute_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipPointerGetAttribute_fn = hipPointerGetAttribute_wrapper;
  else
    RuntimeApiTable->hipPointerGetAttribute_fn = SavedApiTable.hipPointerGetAttribute_fn;
}

static void switch_hipPointerGetAttributes_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipPointerGetAttributes_fn = hipPointerGetAttributes_wrapper;
  else
    RuntimeApiTable->hipPointerGetAttributes_fn = SavedApiTable.hipPointerGetAttributes_fn;
}

static void switch_hipPointerSetAttribute_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipPointerSetAttribute_fn = hipPointerSetAttribute_wrapper;
  else
    RuntimeApiTable->hipPointerSetAttribute_fn = SavedApiTable.hipPointerSetAttribute_fn;
}

static void switch_hipProfilerStart_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipProfilerStart_fn = hipProfilerStart_wrapper;
  else
    RuntimeApiTable->hipProfilerStart_fn = SavedApiTable.hipProfilerStart_fn;
}

static void switch_hipProfilerStop_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipProfilerStop_fn = hipProfilerStop_wrapper;
  else
    RuntimeApiTable->hipProfilerStop_fn = SavedApiTable.hipProfilerStop_fn;
}

static void switch_hipRuntimeGetVersion_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipRuntimeGetVersion_fn = hipRuntimeGetVersion_wrapper;
  else
    RuntimeApiTable->hipRuntimeGetVersion_fn = SavedApiTable.hipRuntimeGetVersion_fn;
}

static void switch_hipSetDevice_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipSetDevice_fn = hipSetDevice_wrapper;
  else
    RuntimeApiTable->hipSetDevice_fn = SavedApiTable.hipSetDevice_fn;
}

static void switch_hipSetDeviceFlags_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipSetDeviceFlags_fn = hipSetDeviceFlags_wrapper;
  else
    RuntimeApiTable->hipSetDeviceFlags_fn = SavedApiTable.hipSetDeviceFlags_fn;
}

static void switch_hipSetupArgument_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipSetupArgument_fn = hipSetupArgument_wrapper;
  else
    RuntimeApiTable->hipSetupArgument_fn = SavedApiTable.hipSetupArgument_fn;
}

static void switch_hipSignalExternalSemaphoresAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipSignalExternalSemaphoresAsync_fn = hipSignalExternalSemaphoresAsync_wrapper;
  else
    RuntimeApiTable->hipSignalExternalSemaphoresAsync_fn = SavedApiTable.hipSignalExternalSemaphoresAsync_fn;
}

static void switch_hipStreamAddCallback_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamAddCallback_fn = hipStreamAddCallback_wrapper;
  else
    RuntimeApiTable->hipStreamAddCallback_fn = SavedApiTable.hipStreamAddCallback_fn;
}

static void switch_hipStreamAttachMemAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamAttachMemAsync_fn = hipStreamAttachMemAsync_wrapper;
  else
    RuntimeApiTable->hipStreamAttachMemAsync_fn = SavedApiTable.hipStreamAttachMemAsync_fn;
}

static void switch_hipStreamBeginCapture_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamBeginCapture_fn = hipStreamBeginCapture_wrapper;
  else
    RuntimeApiTable->hipStreamBeginCapture_fn = SavedApiTable.hipStreamBeginCapture_fn;
}

static void switch_hipStreamCreate_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamCreate_fn = hipStreamCreate_wrapper;
  else
    RuntimeApiTable->hipStreamCreate_fn = SavedApiTable.hipStreamCreate_fn;
}

static void switch_hipStreamCreateWithFlags_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamCreateWithFlags_fn = hipStreamCreateWithFlags_wrapper;
  else
    RuntimeApiTable->hipStreamCreateWithFlags_fn = SavedApiTable.hipStreamCreateWithFlags_fn;
}

static void switch_hipStreamCreateWithPriority_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamCreateWithPriority_fn = hipStreamCreateWithPriority_wrapper;
  else
    RuntimeApiTable->hipStreamCreateWithPriority_fn = SavedApiTable.hipStreamCreateWithPriority_fn;
}

static void switch_hipStreamDestroy_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamDestroy_fn = hipStreamDestroy_wrapper;
  else
    RuntimeApiTable->hipStreamDestroy_fn = SavedApiTable.hipStreamDestroy_fn;
}

static void switch_hipStreamEndCapture_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamEndCapture_fn = hipStreamEndCapture_wrapper;
  else
    RuntimeApiTable->hipStreamEndCapture_fn = SavedApiTable.hipStreamEndCapture_fn;
}

static void switch_hipStreamGetCaptureInfo_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamGetCaptureInfo_fn = hipStreamGetCaptureInfo_wrapper;
  else
    RuntimeApiTable->hipStreamGetCaptureInfo_fn = SavedApiTable.hipStreamGetCaptureInfo_fn;
}

static void switch_hipStreamGetCaptureInfo_v2_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamGetCaptureInfo_v2_fn = hipStreamGetCaptureInfo_v2_wrapper;
  else
    RuntimeApiTable->hipStreamGetCaptureInfo_v2_fn = SavedApiTable.hipStreamGetCaptureInfo_v2_fn;
}

static void switch_hipStreamGetDevice_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamGetDevice_fn = hipStreamGetDevice_wrapper;
  else
    RuntimeApiTable->hipStreamGetDevice_fn = SavedApiTable.hipStreamGetDevice_fn;
}

static void switch_hipStreamGetFlags_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamGetFlags_fn = hipStreamGetFlags_wrapper;
  else
    RuntimeApiTable->hipStreamGetFlags_fn = SavedApiTable.hipStreamGetFlags_fn;
}

static void switch_hipStreamGetPriority_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamGetPriority_fn = hipStreamGetPriority_wrapper;
  else
    RuntimeApiTable->hipStreamGetPriority_fn = SavedApiTable.hipStreamGetPriority_fn;
}

static void switch_hipStreamIsCapturing_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamIsCapturing_fn = hipStreamIsCapturing_wrapper;
  else
    RuntimeApiTable->hipStreamIsCapturing_fn = SavedApiTable.hipStreamIsCapturing_fn;
}

static void switch_hipStreamQuery_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamQuery_fn = hipStreamQuery_wrapper;
  else
    RuntimeApiTable->hipStreamQuery_fn = SavedApiTable.hipStreamQuery_fn;
}

static void switch_hipStreamSynchronize_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamSynchronize_fn = hipStreamSynchronize_wrapper;
  else
    RuntimeApiTable->hipStreamSynchronize_fn = SavedApiTable.hipStreamSynchronize_fn;
}

static void switch_hipStreamUpdateCaptureDependencies_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamUpdateCaptureDependencies_fn = hipStreamUpdateCaptureDependencies_wrapper;
  else
    RuntimeApiTable->hipStreamUpdateCaptureDependencies_fn = SavedApiTable.hipStreamUpdateCaptureDependencies_fn;
}

static void switch_hipStreamWaitEvent_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamWaitEvent_fn = hipStreamWaitEvent_wrapper;
  else
    RuntimeApiTable->hipStreamWaitEvent_fn = SavedApiTable.hipStreamWaitEvent_fn;
}

static void switch_hipStreamWaitValue32_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamWaitValue32_fn = hipStreamWaitValue32_wrapper;
  else
    RuntimeApiTable->hipStreamWaitValue32_fn = SavedApiTable.hipStreamWaitValue32_fn;
}

static void switch_hipStreamWaitValue64_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamWaitValue64_fn = hipStreamWaitValue64_wrapper;
  else
    RuntimeApiTable->hipStreamWaitValue64_fn = SavedApiTable.hipStreamWaitValue64_fn;
}

static void switch_hipStreamWriteValue32_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamWriteValue32_fn = hipStreamWriteValue32_wrapper;
  else
    RuntimeApiTable->hipStreamWriteValue32_fn = SavedApiTable.hipStreamWriteValue32_fn;
}

static void switch_hipStreamWriteValue64_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamWriteValue64_fn = hipStreamWriteValue64_wrapper;
  else
    RuntimeApiTable->hipStreamWriteValue64_fn = SavedApiTable.hipStreamWriteValue64_fn;
}

static void switch_hipTexObjectCreate_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexObjectCreate_fn = hipTexObjectCreate_wrapper;
  else
    RuntimeApiTable->hipTexObjectCreate_fn = SavedApiTable.hipTexObjectCreate_fn;
}

static void switch_hipTexObjectDestroy_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexObjectDestroy_fn = hipTexObjectDestroy_wrapper;
  else
    RuntimeApiTable->hipTexObjectDestroy_fn = SavedApiTable.hipTexObjectDestroy_fn;
}

static void switch_hipTexObjectGetResourceDesc_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexObjectGetResourceDesc_fn = hipTexObjectGetResourceDesc_wrapper;
  else
    RuntimeApiTable->hipTexObjectGetResourceDesc_fn = SavedApiTable.hipTexObjectGetResourceDesc_fn;
}

static void switch_hipTexObjectGetResourceViewDesc_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexObjectGetResourceViewDesc_fn = hipTexObjectGetResourceViewDesc_wrapper;
  else
    RuntimeApiTable->hipTexObjectGetResourceViewDesc_fn = SavedApiTable.hipTexObjectGetResourceViewDesc_fn;
}

static void switch_hipTexObjectGetTextureDesc_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexObjectGetTextureDesc_fn = hipTexObjectGetTextureDesc_wrapper;
  else
    RuntimeApiTable->hipTexObjectGetTextureDesc_fn = SavedApiTable.hipTexObjectGetTextureDesc_fn;
}

static void switch_hipTexRefGetAddress_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefGetAddress_fn = hipTexRefGetAddress_wrapper;
  else
    RuntimeApiTable->hipTexRefGetAddress_fn = SavedApiTable.hipTexRefGetAddress_fn;
}

static void switch_hipTexRefGetAddressMode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefGetAddressMode_fn = hipTexRefGetAddressMode_wrapper;
  else
    RuntimeApiTable->hipTexRefGetAddressMode_fn = SavedApiTable.hipTexRefGetAddressMode_fn;
}

static void switch_hipTexRefGetFilterMode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefGetFilterMode_fn = hipTexRefGetFilterMode_wrapper;
  else
    RuntimeApiTable->hipTexRefGetFilterMode_fn = SavedApiTable.hipTexRefGetFilterMode_fn;
}

static void switch_hipTexRefGetFlags_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefGetFlags_fn = hipTexRefGetFlags_wrapper;
  else
    RuntimeApiTable->hipTexRefGetFlags_fn = SavedApiTable.hipTexRefGetFlags_fn;
}

static void switch_hipTexRefGetFormat_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefGetFormat_fn = hipTexRefGetFormat_wrapper;
  else
    RuntimeApiTable->hipTexRefGetFormat_fn = SavedApiTable.hipTexRefGetFormat_fn;
}

static void switch_hipTexRefGetMaxAnisotropy_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefGetMaxAnisotropy_fn = hipTexRefGetMaxAnisotropy_wrapper;
  else
    RuntimeApiTable->hipTexRefGetMaxAnisotropy_fn = SavedApiTable.hipTexRefGetMaxAnisotropy_fn;
}

static void switch_hipTexRefGetMipMappedArray_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefGetMipMappedArray_fn = hipTexRefGetMipMappedArray_wrapper;
  else
    RuntimeApiTable->hipTexRefGetMipMappedArray_fn = SavedApiTable.hipTexRefGetMipMappedArray_fn;
}

static void switch_hipTexRefGetMipmapFilterMode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefGetMipmapFilterMode_fn = hipTexRefGetMipmapFilterMode_wrapper;
  else
    RuntimeApiTable->hipTexRefGetMipmapFilterMode_fn = SavedApiTable.hipTexRefGetMipmapFilterMode_fn;
}

static void switch_hipTexRefGetMipmapLevelBias_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefGetMipmapLevelBias_fn = hipTexRefGetMipmapLevelBias_wrapper;
  else
    RuntimeApiTable->hipTexRefGetMipmapLevelBias_fn = SavedApiTable.hipTexRefGetMipmapLevelBias_fn;
}

static void switch_hipTexRefGetMipmapLevelClamp_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefGetMipmapLevelClamp_fn = hipTexRefGetMipmapLevelClamp_wrapper;
  else
    RuntimeApiTable->hipTexRefGetMipmapLevelClamp_fn = SavedApiTable.hipTexRefGetMipmapLevelClamp_fn;
}

static void switch_hipTexRefSetAddress_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefSetAddress_fn = hipTexRefSetAddress_wrapper;
  else
    RuntimeApiTable->hipTexRefSetAddress_fn = SavedApiTable.hipTexRefSetAddress_fn;
}

static void switch_hipTexRefSetAddress2D_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefSetAddress2D_fn = hipTexRefSetAddress2D_wrapper;
  else
    RuntimeApiTable->hipTexRefSetAddress2D_fn = SavedApiTable.hipTexRefSetAddress2D_fn;
}

static void switch_hipTexRefSetAddressMode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefSetAddressMode_fn = hipTexRefSetAddressMode_wrapper;
  else
    RuntimeApiTable->hipTexRefSetAddressMode_fn = SavedApiTable.hipTexRefSetAddressMode_fn;
}

static void switch_hipTexRefSetArray_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefSetArray_fn = hipTexRefSetArray_wrapper;
  else
    RuntimeApiTable->hipTexRefSetArray_fn = SavedApiTable.hipTexRefSetArray_fn;
}

static void switch_hipTexRefSetBorderColor_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefSetBorderColor_fn = hipTexRefSetBorderColor_wrapper;
  else
    RuntimeApiTable->hipTexRefSetBorderColor_fn = SavedApiTable.hipTexRefSetBorderColor_fn;
}

static void switch_hipTexRefSetFilterMode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefSetFilterMode_fn = hipTexRefSetFilterMode_wrapper;
  else
    RuntimeApiTable->hipTexRefSetFilterMode_fn = SavedApiTable.hipTexRefSetFilterMode_fn;
}

static void switch_hipTexRefSetFlags_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefSetFlags_fn = hipTexRefSetFlags_wrapper;
  else
    RuntimeApiTable->hipTexRefSetFlags_fn = SavedApiTable.hipTexRefSetFlags_fn;
}

static void switch_hipTexRefSetFormat_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefSetFormat_fn = hipTexRefSetFormat_wrapper;
  else
    RuntimeApiTable->hipTexRefSetFormat_fn = SavedApiTable.hipTexRefSetFormat_fn;
}

static void switch_hipTexRefSetMaxAnisotropy_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefSetMaxAnisotropy_fn = hipTexRefSetMaxAnisotropy_wrapper;
  else
    RuntimeApiTable->hipTexRefSetMaxAnisotropy_fn = SavedApiTable.hipTexRefSetMaxAnisotropy_fn;
}

static void switch_hipTexRefSetMipmapFilterMode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefSetMipmapFilterMode_fn = hipTexRefSetMipmapFilterMode_wrapper;
  else
    RuntimeApiTable->hipTexRefSetMipmapFilterMode_fn = SavedApiTable.hipTexRefSetMipmapFilterMode_fn;
}

static void switch_hipTexRefSetMipmapLevelBias_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefSetMipmapLevelBias_fn = hipTexRefSetMipmapLevelBias_wrapper;
  else
    RuntimeApiTable->hipTexRefSetMipmapLevelBias_fn = SavedApiTable.hipTexRefSetMipmapLevelBias_fn;
}

static void switch_hipTexRefSetMipmapLevelClamp_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefSetMipmapLevelClamp_fn = hipTexRefSetMipmapLevelClamp_wrapper;
  else
    RuntimeApiTable->hipTexRefSetMipmapLevelClamp_fn = SavedApiTable.hipTexRefSetMipmapLevelClamp_fn;
}

static void switch_hipTexRefSetMipmappedArray_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefSetMipmappedArray_fn = hipTexRefSetMipmappedArray_wrapper;
  else
    RuntimeApiTable->hipTexRefSetMipmappedArray_fn = SavedApiTable.hipTexRefSetMipmappedArray_fn;
}

static void switch_hipThreadExchangeStreamCaptureMode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipThreadExchangeStreamCaptureMode_fn = hipThreadExchangeStreamCaptureMode_wrapper;
  else
    RuntimeApiTable->hipThreadExchangeStreamCaptureMode_fn = SavedApiTable.hipThreadExchangeStreamCaptureMode_fn;
}

static void switch_hipUnbindTexture_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipUnbindTexture_fn = hipUnbindTexture_wrapper;
  else
    RuntimeApiTable->hipUnbindTexture_fn = SavedApiTable.hipUnbindTexture_fn;
}

static void switch_hipUserObjectCreate_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipUserObjectCreate_fn = hipUserObjectCreate_wrapper;
  else
    RuntimeApiTable->hipUserObjectCreate_fn = SavedApiTable.hipUserObjectCreate_fn;
}

static void switch_hipUserObjectRelease_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipUserObjectRelease_fn = hipUserObjectRelease_wrapper;
  else
    RuntimeApiTable->hipUserObjectRelease_fn = SavedApiTable.hipUserObjectRelease_fn;
}

static void switch_hipUserObjectRetain_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipUserObjectRetain_fn = hipUserObjectRetain_wrapper;
  else
    RuntimeApiTable->hipUserObjectRetain_fn = SavedApiTable.hipUserObjectRetain_fn;
}

static void switch_hipWaitExternalSemaphoresAsync_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipWaitExternalSemaphoresAsync_fn = hipWaitExternalSemaphoresAsync_wrapper;
  else
    RuntimeApiTable->hipWaitExternalSemaphoresAsync_fn = SavedApiTable.hipWaitExternalSemaphoresAsync_fn;
}

static void switch_hipCreateChannelDesc_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipCreateChannelDesc_fn = hipCreateChannelDesc_wrapper;
  else
    RuntimeApiTable->hipCreateChannelDesc_fn = SavedApiTable.hipCreateChannelDesc_fn;
}

static void switch_hipExtModuleLaunchKernel_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipExtModuleLaunchKernel_fn = hipExtModuleLaunchKernel_wrapper;
  else
    RuntimeApiTable->hipExtModuleLaunchKernel_fn = SavedApiTable.hipExtModuleLaunchKernel_fn;
}

static void switch_hipHccModuleLaunchKernel_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipHccModuleLaunchKernel_fn = hipHccModuleLaunchKernel_wrapper;
  else
    RuntimeApiTable->hipHccModuleLaunchKernel_fn = SavedApiTable.hipHccModuleLaunchKernel_fn;
}

static void switch_hipMemcpy_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy_spt_fn = hipMemcpy_spt_wrapper;
  else
    RuntimeApiTable->hipMemcpy_spt_fn = SavedApiTable.hipMemcpy_spt_fn;
}

static void switch_hipMemcpyToSymbol_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyToSymbol_spt_fn = hipMemcpyToSymbol_spt_wrapper;
  else
    RuntimeApiTable->hipMemcpyToSymbol_spt_fn = SavedApiTable.hipMemcpyToSymbol_spt_fn;
}

static void switch_hipMemcpyFromSymbol_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyFromSymbol_spt_fn = hipMemcpyFromSymbol_spt_wrapper;
  else
    RuntimeApiTable->hipMemcpyFromSymbol_spt_fn = SavedApiTable.hipMemcpyFromSymbol_spt_fn;
}

static void switch_hipMemcpy2D_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy2D_spt_fn = hipMemcpy2D_spt_wrapper;
  else
    RuntimeApiTable->hipMemcpy2D_spt_fn = SavedApiTable.hipMemcpy2D_spt_fn;
}

static void switch_hipMemcpy2DFromArray_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy2DFromArray_spt_fn = hipMemcpy2DFromArray_spt_wrapper;
  else
    RuntimeApiTable->hipMemcpy2DFromArray_spt_fn = SavedApiTable.hipMemcpy2DFromArray_spt_fn;
}

static void switch_hipMemcpy3D_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy3D_spt_fn = hipMemcpy3D_spt_wrapper;
  else
    RuntimeApiTable->hipMemcpy3D_spt_fn = SavedApiTable.hipMemcpy3D_spt_fn;
}

static void switch_hipMemset_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemset_spt_fn = hipMemset_spt_wrapper;
  else
    RuntimeApiTable->hipMemset_spt_fn = SavedApiTable.hipMemset_spt_fn;
}

static void switch_hipMemsetAsync_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemsetAsync_spt_fn = hipMemsetAsync_spt_wrapper;
  else
    RuntimeApiTable->hipMemsetAsync_spt_fn = SavedApiTable.hipMemsetAsync_spt_fn;
}

static void switch_hipMemset2D_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemset2D_spt_fn = hipMemset2D_spt_wrapper;
  else
    RuntimeApiTable->hipMemset2D_spt_fn = SavedApiTable.hipMemset2D_spt_fn;
}

static void switch_hipMemset2DAsync_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemset2DAsync_spt_fn = hipMemset2DAsync_spt_wrapper;
  else
    RuntimeApiTable->hipMemset2DAsync_spt_fn = SavedApiTable.hipMemset2DAsync_spt_fn;
}

static void switch_hipMemset3DAsync_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemset3DAsync_spt_fn = hipMemset3DAsync_spt_wrapper;
  else
    RuntimeApiTable->hipMemset3DAsync_spt_fn = SavedApiTable.hipMemset3DAsync_spt_fn;
}

static void switch_hipMemset3D_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemset3D_spt_fn = hipMemset3D_spt_wrapper;
  else
    RuntimeApiTable->hipMemset3D_spt_fn = SavedApiTable.hipMemset3D_spt_fn;
}

static void switch_hipMemcpyAsync_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyAsync_spt_fn = hipMemcpyAsync_spt_wrapper;
  else
    RuntimeApiTable->hipMemcpyAsync_spt_fn = SavedApiTable.hipMemcpyAsync_spt_fn;
}

static void switch_hipMemcpy3DAsync_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy3DAsync_spt_fn = hipMemcpy3DAsync_spt_wrapper;
  else
    RuntimeApiTable->hipMemcpy3DAsync_spt_fn = SavedApiTable.hipMemcpy3DAsync_spt_fn;
}

static void switch_hipMemcpy2DAsync_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy2DAsync_spt_fn = hipMemcpy2DAsync_spt_wrapper;
  else
    RuntimeApiTable->hipMemcpy2DAsync_spt_fn = SavedApiTable.hipMemcpy2DAsync_spt_fn;
}

static void switch_hipMemcpyFromSymbolAsync_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyFromSymbolAsync_spt_fn = hipMemcpyFromSymbolAsync_spt_wrapper;
  else
    RuntimeApiTable->hipMemcpyFromSymbolAsync_spt_fn = SavedApiTable.hipMemcpyFromSymbolAsync_spt_fn;
}

static void switch_hipMemcpyToSymbolAsync_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyToSymbolAsync_spt_fn = hipMemcpyToSymbolAsync_spt_wrapper;
  else
    RuntimeApiTable->hipMemcpyToSymbolAsync_spt_fn = SavedApiTable.hipMemcpyToSymbolAsync_spt_fn;
}

static void switch_hipMemcpyFromArray_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpyFromArray_spt_fn = hipMemcpyFromArray_spt_wrapper;
  else
    RuntimeApiTable->hipMemcpyFromArray_spt_fn = SavedApiTable.hipMemcpyFromArray_spt_fn;
}

static void switch_hipMemcpy2DToArray_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy2DToArray_spt_fn = hipMemcpy2DToArray_spt_wrapper;
  else
    RuntimeApiTable->hipMemcpy2DToArray_spt_fn = SavedApiTable.hipMemcpy2DToArray_spt_fn;
}

static void switch_hipMemcpy2DFromArrayAsync_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy2DFromArrayAsync_spt_fn = hipMemcpy2DFromArrayAsync_spt_wrapper;
  else
    RuntimeApiTable->hipMemcpy2DFromArrayAsync_spt_fn = SavedApiTable.hipMemcpy2DFromArrayAsync_spt_fn;
}

static void switch_hipMemcpy2DToArrayAsync_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipMemcpy2DToArrayAsync_spt_fn = hipMemcpy2DToArrayAsync_spt_wrapper;
  else
    RuntimeApiTable->hipMemcpy2DToArrayAsync_spt_fn = SavedApiTable.hipMemcpy2DToArrayAsync_spt_fn;
}

static void switch_hipStreamQuery_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamQuery_spt_fn = hipStreamQuery_spt_wrapper;
  else
    RuntimeApiTable->hipStreamQuery_spt_fn = SavedApiTable.hipStreamQuery_spt_fn;
}

static void switch_hipStreamSynchronize_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamSynchronize_spt_fn = hipStreamSynchronize_spt_wrapper;
  else
    RuntimeApiTable->hipStreamSynchronize_spt_fn = SavedApiTable.hipStreamSynchronize_spt_fn;
}

static void switch_hipStreamGetPriority_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamGetPriority_spt_fn = hipStreamGetPriority_spt_wrapper;
  else
    RuntimeApiTable->hipStreamGetPriority_spt_fn = SavedApiTable.hipStreamGetPriority_spt_fn;
}

static void switch_hipStreamWaitEvent_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamWaitEvent_spt_fn = hipStreamWaitEvent_spt_wrapper;
  else
    RuntimeApiTable->hipStreamWaitEvent_spt_fn = SavedApiTable.hipStreamWaitEvent_spt_fn;
}

static void switch_hipStreamGetFlags_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamGetFlags_spt_fn = hipStreamGetFlags_spt_wrapper;
  else
    RuntimeApiTable->hipStreamGetFlags_spt_fn = SavedApiTable.hipStreamGetFlags_spt_fn;
}

static void switch_hipStreamAddCallback_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamAddCallback_spt_fn = hipStreamAddCallback_spt_wrapper;
  else
    RuntimeApiTable->hipStreamAddCallback_spt_fn = SavedApiTable.hipStreamAddCallback_spt_fn;
}

static void switch_hipEventRecord_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipEventRecord_spt_fn = hipEventRecord_spt_wrapper;
  else
    RuntimeApiTable->hipEventRecord_spt_fn = SavedApiTable.hipEventRecord_spt_fn;
}

static void switch_hipLaunchCooperativeKernel_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipLaunchCooperativeKernel_spt_fn = hipLaunchCooperativeKernel_spt_wrapper;
  else
    RuntimeApiTable->hipLaunchCooperativeKernel_spt_fn = SavedApiTable.hipLaunchCooperativeKernel_spt_fn;
}

static void switch_hipLaunchKernel_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipLaunchKernel_spt_fn = hipLaunchKernel_spt_wrapper;
  else
    RuntimeApiTable->hipLaunchKernel_spt_fn = SavedApiTable.hipLaunchKernel_spt_fn;
}

static void switch_hipGraphLaunch_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphLaunch_spt_fn = hipGraphLaunch_spt_wrapper;
  else
    RuntimeApiTable->hipGraphLaunch_spt_fn = SavedApiTable.hipGraphLaunch_spt_fn;
}

static void switch_hipStreamBeginCapture_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamBeginCapture_spt_fn = hipStreamBeginCapture_spt_wrapper;
  else
    RuntimeApiTable->hipStreamBeginCapture_spt_fn = SavedApiTable.hipStreamBeginCapture_spt_fn;
}

static void switch_hipStreamEndCapture_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamEndCapture_spt_fn = hipStreamEndCapture_spt_wrapper;
  else
    RuntimeApiTable->hipStreamEndCapture_spt_fn = SavedApiTable.hipStreamEndCapture_spt_fn;
}

static void switch_hipStreamIsCapturing_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamIsCapturing_spt_fn = hipStreamIsCapturing_spt_wrapper;
  else
    RuntimeApiTable->hipStreamIsCapturing_spt_fn = SavedApiTable.hipStreamIsCapturing_spt_fn;
}

static void switch_hipStreamGetCaptureInfo_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamGetCaptureInfo_spt_fn = hipStreamGetCaptureInfo_spt_wrapper;
  else
    RuntimeApiTable->hipStreamGetCaptureInfo_spt_fn = SavedApiTable.hipStreamGetCaptureInfo_spt_fn;
}

static void switch_hipStreamGetCaptureInfo_v2_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamGetCaptureInfo_v2_spt_fn = hipStreamGetCaptureInfo_v2_spt_wrapper;
  else
    RuntimeApiTable->hipStreamGetCaptureInfo_v2_spt_fn = SavedApiTable.hipStreamGetCaptureInfo_v2_spt_fn;
}

static void switch_hipLaunchHostFunc_spt_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipLaunchHostFunc_spt_fn = hipLaunchHostFunc_spt_wrapper;
  else
    RuntimeApiTable->hipLaunchHostFunc_spt_fn = SavedApiTable.hipLaunchHostFunc_spt_fn;
}

static void switch_hipGetStreamDeviceId_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetStreamDeviceId_fn = hipGetStreamDeviceId_wrapper;
  else
    RuntimeApiTable->hipGetStreamDeviceId_fn = SavedApiTable.hipGetStreamDeviceId_fn;
}

static void switch_hipDrvGraphAddMemsetNode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipDrvGraphAddMemsetNode_fn = hipDrvGraphAddMemsetNode_wrapper;
  else
    RuntimeApiTable->hipDrvGraphAddMemsetNode_fn = SavedApiTable.hipDrvGraphAddMemsetNode_fn;
}

static void switch_hipGraphAddExternalSemaphoresWaitNode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphAddExternalSemaphoresWaitNode_fn = hipGraphAddExternalSemaphoresWaitNode_wrapper;
  else
    RuntimeApiTable->hipGraphAddExternalSemaphoresWaitNode_fn = SavedApiTable.hipGraphAddExternalSemaphoresWaitNode_fn;
}

static void switch_hipGraphAddExternalSemaphoresSignalNode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphAddExternalSemaphoresSignalNode_fn = hipGraphAddExternalSemaphoresSignalNode_wrapper;
  else
    RuntimeApiTable->hipGraphAddExternalSemaphoresSignalNode_fn = SavedApiTable.hipGraphAddExternalSemaphoresSignalNode_fn;
}

static void switch_hipGraphExternalSemaphoresSignalNodeSetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExternalSemaphoresSignalNodeSetParams_fn = hipGraphExternalSemaphoresSignalNodeSetParams_wrapper;
  else
    RuntimeApiTable->hipGraphExternalSemaphoresSignalNodeSetParams_fn = SavedApiTable.hipGraphExternalSemaphoresSignalNodeSetParams_fn;
}

static void switch_hipGraphExternalSemaphoresWaitNodeSetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExternalSemaphoresWaitNodeSetParams_fn = hipGraphExternalSemaphoresWaitNodeSetParams_wrapper;
  else
    RuntimeApiTable->hipGraphExternalSemaphoresWaitNodeSetParams_fn = SavedApiTable.hipGraphExternalSemaphoresWaitNodeSetParams_fn;
}

static void switch_hipGraphExternalSemaphoresSignalNodeGetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExternalSemaphoresSignalNodeGetParams_fn = hipGraphExternalSemaphoresSignalNodeGetParams_wrapper;
  else
    RuntimeApiTable->hipGraphExternalSemaphoresSignalNodeGetParams_fn = SavedApiTable.hipGraphExternalSemaphoresSignalNodeGetParams_fn;
}

static void switch_hipGraphExternalSemaphoresWaitNodeGetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExternalSemaphoresWaitNodeGetParams_fn = hipGraphExternalSemaphoresWaitNodeGetParams_wrapper;
  else
    RuntimeApiTable->hipGraphExternalSemaphoresWaitNodeGetParams_fn = SavedApiTable.hipGraphExternalSemaphoresWaitNodeGetParams_fn;
}

static void switch_hipGraphExecExternalSemaphoresSignalNodeSetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExecExternalSemaphoresSignalNodeSetParams_fn = hipGraphExecExternalSemaphoresSignalNodeSetParams_wrapper;
  else
    RuntimeApiTable->hipGraphExecExternalSemaphoresSignalNodeSetParams_fn = SavedApiTable.hipGraphExecExternalSemaphoresSignalNodeSetParams_fn;
}

static void switch_hipGraphExecExternalSemaphoresWaitNodeSetParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphExecExternalSemaphoresWaitNodeSetParams_fn = hipGraphExecExternalSemaphoresWaitNodeSetParams_wrapper;
  else
    RuntimeApiTable->hipGraphExecExternalSemaphoresWaitNodeSetParams_fn = SavedApiTable.hipGraphExecExternalSemaphoresWaitNodeSetParams_fn;
}

static void switch_hipGraphAddNode_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphAddNode_fn = hipGraphAddNode_wrapper;
  else
    RuntimeApiTable->hipGraphAddNode_fn = SavedApiTable.hipGraphAddNode_fn;
}

static void switch_hipGraphInstantiateWithParams_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGraphInstantiateWithParams_fn = hipGraphInstantiateWithParams_wrapper;
  else
    RuntimeApiTable->hipGraphInstantiateWithParams_fn = SavedApiTable.hipGraphInstantiateWithParams_fn;
}

static void switch_hipExtGetLastError_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipExtGetLastError_fn = hipExtGetLastError_wrapper;
  else
    RuntimeApiTable->hipExtGetLastError_fn = SavedApiTable.hipExtGetLastError_fn;
}

static void switch_hipTexRefGetBorderColor_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefGetBorderColor_fn = hipTexRefGetBorderColor_wrapper;
  else
    RuntimeApiTable->hipTexRefGetBorderColor_fn = SavedApiTable.hipTexRefGetBorderColor_fn;
}

static void switch_hipTexRefGetArray_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipTexRefGetArray_fn = hipTexRefGetArray_wrapper;
  else
    RuntimeApiTable->hipTexRefGetArray_fn = SavedApiTable.hipTexRefGetArray_fn;
}

static void switch_hipGetProcAddress_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetProcAddress_fn = hipGetProcAddress_wrapper;
  else
    RuntimeApiTable->hipGetProcAddress_fn = SavedApiTable.hipGetProcAddress_fn;
}

static void switch_hipStreamBeginCaptureToGraph_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipStreamBeginCaptureToGraph_fn = hipStreamBeginCaptureToGraph_wrapper;
  else
    RuntimeApiTable->hipStreamBeginCaptureToGraph_fn = SavedApiTable.hipStreamBeginCaptureToGraph_fn;
}

static void switch_hipGetFuncBySymbol_wrapper(HipDispatchTable *RuntimeApiTable, 
    const HipDispatchTable &SavedApiTable, bool State) {
  if (State)
    RuntimeApiTable->hipGetFuncBySymbol_fn = hipGetFuncBySymbol_wrapper;
  else
    RuntimeApiTable->hipGetFuncBySymbol_fn = SavedApiTable.hipGetFuncBySymbol_fn;
}

static bool is_hipApiName_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipApiName_fn == hipApiName_wrapper;
}

static bool is_hipArray3DCreate_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipArray3DCreate_fn == hipArray3DCreate_wrapper;
}

static bool is_hipArray3DGetDescriptor_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipArray3DGetDescriptor_fn == hipArray3DGetDescriptor_wrapper;
}

static bool is_hipArrayCreate_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipArrayCreate_fn == hipArrayCreate_wrapper;
}

static bool is_hipArrayDestroy_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipArrayDestroy_fn == hipArrayDestroy_wrapper;
}

static bool is_hipArrayGetDescriptor_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipArrayGetDescriptor_fn == hipArrayGetDescriptor_wrapper;
}

static bool is_hipArrayGetInfo_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipArrayGetInfo_fn == hipArrayGetInfo_wrapper;
}

static bool is_hipBindTexture_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipBindTexture_fn == hipBindTexture_wrapper;
}

static bool is_hipBindTexture2D_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipBindTexture2D_fn == hipBindTexture2D_wrapper;
}

static bool is_hipBindTextureToArray_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipBindTextureToArray_fn == hipBindTextureToArray_wrapper;
}

static bool is_hipBindTextureToMipmappedArray_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipBindTextureToMipmappedArray_fn == hipBindTextureToMipmappedArray_wrapper;
}

static bool is_hipChooseDevice_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipChooseDevice_fn == hipChooseDevice_wrapper;
}

static bool is_hipChooseDeviceR0000_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipChooseDeviceR0000_fn == hipChooseDeviceR0000_wrapper;
}

static bool is_hipConfigureCall_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipConfigureCall_fn == hipConfigureCall_wrapper;
}

static bool is_hipCreateSurfaceObject_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCreateSurfaceObject_fn == hipCreateSurfaceObject_wrapper;
}

static bool is_hipCreateTextureObject_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCreateTextureObject_fn == hipCreateTextureObject_wrapper;
}

static bool is_hipCtxCreate_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCtxCreate_fn == hipCtxCreate_wrapper;
}

static bool is_hipCtxDestroy_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCtxDestroy_fn == hipCtxDestroy_wrapper;
}

static bool is_hipCtxDisablePeerAccess_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCtxDisablePeerAccess_fn == hipCtxDisablePeerAccess_wrapper;
}

static bool is_hipCtxEnablePeerAccess_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCtxEnablePeerAccess_fn == hipCtxEnablePeerAccess_wrapper;
}

static bool is_hipCtxGetApiVersion_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCtxGetApiVersion_fn == hipCtxGetApiVersion_wrapper;
}

static bool is_hipCtxGetCacheConfig_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCtxGetCacheConfig_fn == hipCtxGetCacheConfig_wrapper;
}

static bool is_hipCtxGetCurrent_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCtxGetCurrent_fn == hipCtxGetCurrent_wrapper;
}

static bool is_hipCtxGetDevice_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCtxGetDevice_fn == hipCtxGetDevice_wrapper;
}

static bool is_hipCtxGetFlags_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCtxGetFlags_fn == hipCtxGetFlags_wrapper;
}

static bool is_hipCtxGetSharedMemConfig_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCtxGetSharedMemConfig_fn == hipCtxGetSharedMemConfig_wrapper;
}

static bool is_hipCtxPopCurrent_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCtxPopCurrent_fn == hipCtxPopCurrent_wrapper;
}

static bool is_hipCtxPushCurrent_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCtxPushCurrent_fn == hipCtxPushCurrent_wrapper;
}

static bool is_hipCtxSetCacheConfig_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCtxSetCacheConfig_fn == hipCtxSetCacheConfig_wrapper;
}

static bool is_hipCtxSetCurrent_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCtxSetCurrent_fn == hipCtxSetCurrent_wrapper;
}

static bool is_hipCtxSetSharedMemConfig_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCtxSetSharedMemConfig_fn == hipCtxSetSharedMemConfig_wrapper;
}

static bool is_hipCtxSynchronize_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCtxSynchronize_fn == hipCtxSynchronize_wrapper;
}

static bool is_hipDestroyExternalMemory_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDestroyExternalMemory_fn == hipDestroyExternalMemory_wrapper;
}

static bool is_hipDestroyExternalSemaphore_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDestroyExternalSemaphore_fn == hipDestroyExternalSemaphore_wrapper;
}

static bool is_hipDestroySurfaceObject_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDestroySurfaceObject_fn == hipDestroySurfaceObject_wrapper;
}

static bool is_hipDestroyTextureObject_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDestroyTextureObject_fn == hipDestroyTextureObject_wrapper;
}

static bool is_hipDeviceCanAccessPeer_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceCanAccessPeer_fn == hipDeviceCanAccessPeer_wrapper;
}

static bool is_hipDeviceComputeCapability_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceComputeCapability_fn == hipDeviceComputeCapability_wrapper;
}

static bool is_hipDeviceDisablePeerAccess_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceDisablePeerAccess_fn == hipDeviceDisablePeerAccess_wrapper;
}

static bool is_hipDeviceEnablePeerAccess_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceEnablePeerAccess_fn == hipDeviceEnablePeerAccess_wrapper;
}

static bool is_hipDeviceGet_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceGet_fn == hipDeviceGet_wrapper;
}

static bool is_hipDeviceGetAttribute_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceGetAttribute_fn == hipDeviceGetAttribute_wrapper;
}

static bool is_hipDeviceGetByPCIBusId_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceGetByPCIBusId_fn == hipDeviceGetByPCIBusId_wrapper;
}

static bool is_hipDeviceGetCacheConfig_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceGetCacheConfig_fn == hipDeviceGetCacheConfig_wrapper;
}

static bool is_hipDeviceGetDefaultMemPool_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceGetDefaultMemPool_fn == hipDeviceGetDefaultMemPool_wrapper;
}

static bool is_hipDeviceGetGraphMemAttribute_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceGetGraphMemAttribute_fn == hipDeviceGetGraphMemAttribute_wrapper;
}

static bool is_hipDeviceGetLimit_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceGetLimit_fn == hipDeviceGetLimit_wrapper;
}

static bool is_hipDeviceGetMemPool_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceGetMemPool_fn == hipDeviceGetMemPool_wrapper;
}

static bool is_hipDeviceGetName_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceGetName_fn == hipDeviceGetName_wrapper;
}

static bool is_hipDeviceGetP2PAttribute_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceGetP2PAttribute_fn == hipDeviceGetP2PAttribute_wrapper;
}

static bool is_hipDeviceGetPCIBusId_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceGetPCIBusId_fn == hipDeviceGetPCIBusId_wrapper;
}

static bool is_hipDeviceGetSharedMemConfig_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceGetSharedMemConfig_fn == hipDeviceGetSharedMemConfig_wrapper;
}

static bool is_hipDeviceGetStreamPriorityRange_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceGetStreamPriorityRange_fn == hipDeviceGetStreamPriorityRange_wrapper;
}

static bool is_hipDeviceGetUuid_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceGetUuid_fn == hipDeviceGetUuid_wrapper;
}

static bool is_hipDeviceGraphMemTrim_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceGraphMemTrim_fn == hipDeviceGraphMemTrim_wrapper;
}

static bool is_hipDevicePrimaryCtxGetState_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDevicePrimaryCtxGetState_fn == hipDevicePrimaryCtxGetState_wrapper;
}

static bool is_hipDevicePrimaryCtxRelease_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDevicePrimaryCtxRelease_fn == hipDevicePrimaryCtxRelease_wrapper;
}

static bool is_hipDevicePrimaryCtxReset_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDevicePrimaryCtxReset_fn == hipDevicePrimaryCtxReset_wrapper;
}

static bool is_hipDevicePrimaryCtxRetain_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDevicePrimaryCtxRetain_fn == hipDevicePrimaryCtxRetain_wrapper;
}

static bool is_hipDevicePrimaryCtxSetFlags_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDevicePrimaryCtxSetFlags_fn == hipDevicePrimaryCtxSetFlags_wrapper;
}

static bool is_hipDeviceReset_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceReset_fn == hipDeviceReset_wrapper;
}

static bool is_hipDeviceSetCacheConfig_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceSetCacheConfig_fn == hipDeviceSetCacheConfig_wrapper;
}

static bool is_hipDeviceSetGraphMemAttribute_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceSetGraphMemAttribute_fn == hipDeviceSetGraphMemAttribute_wrapper;
}

static bool is_hipDeviceSetLimit_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceSetLimit_fn == hipDeviceSetLimit_wrapper;
}

static bool is_hipDeviceSetMemPool_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceSetMemPool_fn == hipDeviceSetMemPool_wrapper;
}

static bool is_hipDeviceSetSharedMemConfig_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceSetSharedMemConfig_fn == hipDeviceSetSharedMemConfig_wrapper;
}

static bool is_hipDeviceSynchronize_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceSynchronize_fn == hipDeviceSynchronize_wrapper;
}

static bool is_hipDeviceTotalMem_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDeviceTotalMem_fn == hipDeviceTotalMem_wrapper;
}

static bool is_hipDriverGetVersion_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDriverGetVersion_fn == hipDriverGetVersion_wrapper;
}

static bool is_hipDrvGetErrorName_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDrvGetErrorName_fn == hipDrvGetErrorName_wrapper;
}

static bool is_hipDrvGetErrorString_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDrvGetErrorString_fn == hipDrvGetErrorString_wrapper;
}

static bool is_hipDrvGraphAddMemcpyNode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDrvGraphAddMemcpyNode_fn == hipDrvGraphAddMemcpyNode_wrapper;
}

static bool is_hipDrvMemcpy2DUnaligned_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDrvMemcpy2DUnaligned_fn == hipDrvMemcpy2DUnaligned_wrapper;
}

static bool is_hipDrvMemcpy3D_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDrvMemcpy3D_fn == hipDrvMemcpy3D_wrapper;
}

static bool is_hipDrvMemcpy3DAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDrvMemcpy3DAsync_fn == hipDrvMemcpy3DAsync_wrapper;
}

static bool is_hipDrvPointerGetAttributes_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDrvPointerGetAttributes_fn == hipDrvPointerGetAttributes_wrapper;
}

static bool is_hipEventCreate_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipEventCreate_fn == hipEventCreate_wrapper;
}

static bool is_hipEventCreateWithFlags_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipEventCreateWithFlags_fn == hipEventCreateWithFlags_wrapper;
}

static bool is_hipEventDestroy_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipEventDestroy_fn == hipEventDestroy_wrapper;
}

static bool is_hipEventElapsedTime_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipEventElapsedTime_fn == hipEventElapsedTime_wrapper;
}

static bool is_hipEventQuery_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipEventQuery_fn == hipEventQuery_wrapper;
}

static bool is_hipEventRecord_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipEventRecord_fn == hipEventRecord_wrapper;
}

static bool is_hipEventSynchronize_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipEventSynchronize_fn == hipEventSynchronize_wrapper;
}

static bool is_hipExtGetLinkTypeAndHopCount_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipExtGetLinkTypeAndHopCount_fn == hipExtGetLinkTypeAndHopCount_wrapper;
}

static bool is_hipExtLaunchKernel_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipExtLaunchKernel_fn == hipExtLaunchKernel_wrapper;
}

static bool is_hipExtLaunchMultiKernelMultiDevice_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipExtLaunchMultiKernelMultiDevice_fn == hipExtLaunchMultiKernelMultiDevice_wrapper;
}

static bool is_hipExtMallocWithFlags_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipExtMallocWithFlags_fn == hipExtMallocWithFlags_wrapper;
}

static bool is_hipExtStreamCreateWithCUMask_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipExtStreamCreateWithCUMask_fn == hipExtStreamCreateWithCUMask_wrapper;
}

static bool is_hipExtStreamGetCUMask_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipExtStreamGetCUMask_fn == hipExtStreamGetCUMask_wrapper;
}

static bool is_hipExternalMemoryGetMappedBuffer_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipExternalMemoryGetMappedBuffer_fn == hipExternalMemoryGetMappedBuffer_wrapper;
}

static bool is_hipFree_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipFree_fn == hipFree_wrapper;
}

static bool is_hipFreeArray_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipFreeArray_fn == hipFreeArray_wrapper;
}

static bool is_hipFreeAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipFreeAsync_fn == hipFreeAsync_wrapper;
}

static bool is_hipFreeHost_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipFreeHost_fn == hipFreeHost_wrapper;
}

static bool is_hipFreeMipmappedArray_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipFreeMipmappedArray_fn == hipFreeMipmappedArray_wrapper;
}

static bool is_hipFuncGetAttribute_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipFuncGetAttribute_fn == hipFuncGetAttribute_wrapper;
}

static bool is_hipFuncGetAttributes_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipFuncGetAttributes_fn == hipFuncGetAttributes_wrapper;
}

static bool is_hipFuncSetAttribute_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipFuncSetAttribute_fn == hipFuncSetAttribute_wrapper;
}

static bool is_hipFuncSetCacheConfig_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipFuncSetCacheConfig_fn == hipFuncSetCacheConfig_wrapper;
}

static bool is_hipFuncSetSharedMemConfig_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipFuncSetSharedMemConfig_fn == hipFuncSetSharedMemConfig_wrapper;
}

static bool is_hipGLGetDevices_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGLGetDevices_fn == hipGLGetDevices_wrapper;
}

static bool is_hipGetChannelDesc_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetChannelDesc_fn == hipGetChannelDesc_wrapper;
}

static bool is_hipGetDevice_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetDevice_fn == hipGetDevice_wrapper;
}

static bool is_hipGetDeviceCount_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetDeviceCount_fn == hipGetDeviceCount_wrapper;
}

static bool is_hipGetDeviceFlags_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetDeviceFlags_fn == hipGetDeviceFlags_wrapper;
}

static bool is_hipGetDevicePropertiesR0600_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetDevicePropertiesR0600_fn == hipGetDevicePropertiesR0600_wrapper;
}

static bool is_hipGetDevicePropertiesR0000_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetDevicePropertiesR0000_fn == hipGetDevicePropertiesR0000_wrapper;
}

static bool is_hipGetErrorName_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetErrorName_fn == hipGetErrorName_wrapper;
}

static bool is_hipGetErrorString_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetErrorString_fn == hipGetErrorString_wrapper;
}

static bool is_hipGetLastError_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetLastError_fn == hipGetLastError_wrapper;
}

static bool is_hipGetMipmappedArrayLevel_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetMipmappedArrayLevel_fn == hipGetMipmappedArrayLevel_wrapper;
}

static bool is_hipGetSymbolAddress_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetSymbolAddress_fn == hipGetSymbolAddress_wrapper;
}

static bool is_hipGetSymbolSize_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetSymbolSize_fn == hipGetSymbolSize_wrapper;
}

static bool is_hipGetTextureAlignmentOffset_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetTextureAlignmentOffset_fn == hipGetTextureAlignmentOffset_wrapper;
}

static bool is_hipGetTextureObjectResourceDesc_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetTextureObjectResourceDesc_fn == hipGetTextureObjectResourceDesc_wrapper;
}

static bool is_hipGetTextureObjectResourceViewDesc_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetTextureObjectResourceViewDesc_fn == hipGetTextureObjectResourceViewDesc_wrapper;
}

static bool is_hipGetTextureObjectTextureDesc_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetTextureObjectTextureDesc_fn == hipGetTextureObjectTextureDesc_wrapper;
}

static bool is_hipGetTextureReference_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetTextureReference_fn == hipGetTextureReference_wrapper;
}

static bool is_hipGraphAddChildGraphNode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphAddChildGraphNode_fn == hipGraphAddChildGraphNode_wrapper;
}

static bool is_hipGraphAddDependencies_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphAddDependencies_fn == hipGraphAddDependencies_wrapper;
}

static bool is_hipGraphAddEmptyNode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphAddEmptyNode_fn == hipGraphAddEmptyNode_wrapper;
}

static bool is_hipGraphAddEventRecordNode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphAddEventRecordNode_fn == hipGraphAddEventRecordNode_wrapper;
}

static bool is_hipGraphAddEventWaitNode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphAddEventWaitNode_fn == hipGraphAddEventWaitNode_wrapper;
}

static bool is_hipGraphAddHostNode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphAddHostNode_fn == hipGraphAddHostNode_wrapper;
}

static bool is_hipGraphAddKernelNode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphAddKernelNode_fn == hipGraphAddKernelNode_wrapper;
}

static bool is_hipGraphAddMemAllocNode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphAddMemAllocNode_fn == hipGraphAddMemAllocNode_wrapper;
}

static bool is_hipGraphAddMemFreeNode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphAddMemFreeNode_fn == hipGraphAddMemFreeNode_wrapper;
}

static bool is_hipGraphAddMemcpyNode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphAddMemcpyNode_fn == hipGraphAddMemcpyNode_wrapper;
}

static bool is_hipGraphAddMemcpyNode1D_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphAddMemcpyNode1D_fn == hipGraphAddMemcpyNode1D_wrapper;
}

static bool is_hipGraphAddMemcpyNodeFromSymbol_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphAddMemcpyNodeFromSymbol_fn == hipGraphAddMemcpyNodeFromSymbol_wrapper;
}

static bool is_hipGraphAddMemcpyNodeToSymbol_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphAddMemcpyNodeToSymbol_fn == hipGraphAddMemcpyNodeToSymbol_wrapper;
}

static bool is_hipGraphAddMemsetNode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphAddMemsetNode_fn == hipGraphAddMemsetNode_wrapper;
}

static bool is_hipGraphChildGraphNodeGetGraph_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphChildGraphNodeGetGraph_fn == hipGraphChildGraphNodeGetGraph_wrapper;
}

static bool is_hipGraphClone_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphClone_fn == hipGraphClone_wrapper;
}

static bool is_hipGraphCreate_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphCreate_fn == hipGraphCreate_wrapper;
}

static bool is_hipGraphDebugDotPrint_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphDebugDotPrint_fn == hipGraphDebugDotPrint_wrapper;
}

static bool is_hipGraphDestroy_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphDestroy_fn == hipGraphDestroy_wrapper;
}

static bool is_hipGraphDestroyNode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphDestroyNode_fn == hipGraphDestroyNode_wrapper;
}

static bool is_hipGraphEventRecordNodeGetEvent_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphEventRecordNodeGetEvent_fn == hipGraphEventRecordNodeGetEvent_wrapper;
}

static bool is_hipGraphEventRecordNodeSetEvent_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphEventRecordNodeSetEvent_fn == hipGraphEventRecordNodeSetEvent_wrapper;
}

static bool is_hipGraphEventWaitNodeGetEvent_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphEventWaitNodeGetEvent_fn == hipGraphEventWaitNodeGetEvent_wrapper;
}

static bool is_hipGraphEventWaitNodeSetEvent_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphEventWaitNodeSetEvent_fn == hipGraphEventWaitNodeSetEvent_wrapper;
}

static bool is_hipGraphExecChildGraphNodeSetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExecChildGraphNodeSetParams_fn == hipGraphExecChildGraphNodeSetParams_wrapper;
}

static bool is_hipGraphExecDestroy_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExecDestroy_fn == hipGraphExecDestroy_wrapper;
}

static bool is_hipGraphExecEventRecordNodeSetEvent_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExecEventRecordNodeSetEvent_fn == hipGraphExecEventRecordNodeSetEvent_wrapper;
}

static bool is_hipGraphExecEventWaitNodeSetEvent_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExecEventWaitNodeSetEvent_fn == hipGraphExecEventWaitNodeSetEvent_wrapper;
}

static bool is_hipGraphExecHostNodeSetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExecHostNodeSetParams_fn == hipGraphExecHostNodeSetParams_wrapper;
}

static bool is_hipGraphExecKernelNodeSetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExecKernelNodeSetParams_fn == hipGraphExecKernelNodeSetParams_wrapper;
}

static bool is_hipGraphExecMemcpyNodeSetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExecMemcpyNodeSetParams_fn == hipGraphExecMemcpyNodeSetParams_wrapper;
}

static bool is_hipGraphExecMemcpyNodeSetParams1D_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExecMemcpyNodeSetParams1D_fn == hipGraphExecMemcpyNodeSetParams1D_wrapper;
}

static bool is_hipGraphExecMemcpyNodeSetParamsFromSymbol_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExecMemcpyNodeSetParamsFromSymbol_fn == hipGraphExecMemcpyNodeSetParamsFromSymbol_wrapper;
}

static bool is_hipGraphExecMemcpyNodeSetParamsToSymbol_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExecMemcpyNodeSetParamsToSymbol_fn == hipGraphExecMemcpyNodeSetParamsToSymbol_wrapper;
}

static bool is_hipGraphExecMemsetNodeSetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExecMemsetNodeSetParams_fn == hipGraphExecMemsetNodeSetParams_wrapper;
}

static bool is_hipGraphExecUpdate_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExecUpdate_fn == hipGraphExecUpdate_wrapper;
}

static bool is_hipGraphGetEdges_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphGetEdges_fn == hipGraphGetEdges_wrapper;
}

static bool is_hipGraphGetNodes_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphGetNodes_fn == hipGraphGetNodes_wrapper;
}

static bool is_hipGraphGetRootNodes_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphGetRootNodes_fn == hipGraphGetRootNodes_wrapper;
}

static bool is_hipGraphHostNodeGetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphHostNodeGetParams_fn == hipGraphHostNodeGetParams_wrapper;
}

static bool is_hipGraphHostNodeSetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphHostNodeSetParams_fn == hipGraphHostNodeSetParams_wrapper;
}

static bool is_hipGraphInstantiate_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphInstantiate_fn == hipGraphInstantiate_wrapper;
}

static bool is_hipGraphInstantiateWithFlags_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphInstantiateWithFlags_fn == hipGraphInstantiateWithFlags_wrapper;
}

static bool is_hipGraphKernelNodeCopyAttributes_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphKernelNodeCopyAttributes_fn == hipGraphKernelNodeCopyAttributes_wrapper;
}

static bool is_hipGraphKernelNodeGetAttribute_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphKernelNodeGetAttribute_fn == hipGraphKernelNodeGetAttribute_wrapper;
}

static bool is_hipGraphKernelNodeGetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphKernelNodeGetParams_fn == hipGraphKernelNodeGetParams_wrapper;
}

static bool is_hipGraphKernelNodeSetAttribute_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphKernelNodeSetAttribute_fn == hipGraphKernelNodeSetAttribute_wrapper;
}

static bool is_hipGraphKernelNodeSetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphKernelNodeSetParams_fn == hipGraphKernelNodeSetParams_wrapper;
}

static bool is_hipGraphLaunch_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphLaunch_fn == hipGraphLaunch_wrapper;
}

static bool is_hipGraphMemAllocNodeGetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphMemAllocNodeGetParams_fn == hipGraphMemAllocNodeGetParams_wrapper;
}

static bool is_hipGraphMemFreeNodeGetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphMemFreeNodeGetParams_fn == hipGraphMemFreeNodeGetParams_wrapper;
}

static bool is_hipGraphMemcpyNodeGetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphMemcpyNodeGetParams_fn == hipGraphMemcpyNodeGetParams_wrapper;
}

static bool is_hipGraphMemcpyNodeSetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphMemcpyNodeSetParams_fn == hipGraphMemcpyNodeSetParams_wrapper;
}

static bool is_hipGraphMemcpyNodeSetParams1D_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphMemcpyNodeSetParams1D_fn == hipGraphMemcpyNodeSetParams1D_wrapper;
}

static bool is_hipGraphMemcpyNodeSetParamsFromSymbol_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphMemcpyNodeSetParamsFromSymbol_fn == hipGraphMemcpyNodeSetParamsFromSymbol_wrapper;
}

static bool is_hipGraphMemcpyNodeSetParamsToSymbol_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphMemcpyNodeSetParamsToSymbol_fn == hipGraphMemcpyNodeSetParamsToSymbol_wrapper;
}

static bool is_hipGraphMemsetNodeGetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphMemsetNodeGetParams_fn == hipGraphMemsetNodeGetParams_wrapper;
}

static bool is_hipGraphMemsetNodeSetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphMemsetNodeSetParams_fn == hipGraphMemsetNodeSetParams_wrapper;
}

static bool is_hipGraphNodeFindInClone_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphNodeFindInClone_fn == hipGraphNodeFindInClone_wrapper;
}

static bool is_hipGraphNodeGetDependencies_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphNodeGetDependencies_fn == hipGraphNodeGetDependencies_wrapper;
}

static bool is_hipGraphNodeGetDependentNodes_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphNodeGetDependentNodes_fn == hipGraphNodeGetDependentNodes_wrapper;
}

static bool is_hipGraphNodeGetEnabled_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphNodeGetEnabled_fn == hipGraphNodeGetEnabled_wrapper;
}

static bool is_hipGraphNodeGetType_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphNodeGetType_fn == hipGraphNodeGetType_wrapper;
}

static bool is_hipGraphNodeSetEnabled_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphNodeSetEnabled_fn == hipGraphNodeSetEnabled_wrapper;
}

static bool is_hipGraphReleaseUserObject_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphReleaseUserObject_fn == hipGraphReleaseUserObject_wrapper;
}

static bool is_hipGraphRemoveDependencies_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphRemoveDependencies_fn == hipGraphRemoveDependencies_wrapper;
}

static bool is_hipGraphRetainUserObject_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphRetainUserObject_fn == hipGraphRetainUserObject_wrapper;
}

static bool is_hipGraphUpload_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphUpload_fn == hipGraphUpload_wrapper;
}

static bool is_hipGraphicsGLRegisterBuffer_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphicsGLRegisterBuffer_fn == hipGraphicsGLRegisterBuffer_wrapper;
}

static bool is_hipGraphicsGLRegisterImage_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphicsGLRegisterImage_fn == hipGraphicsGLRegisterImage_wrapper;
}

static bool is_hipGraphicsMapResources_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphicsMapResources_fn == hipGraphicsMapResources_wrapper;
}

static bool is_hipGraphicsResourceGetMappedPointer_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphicsResourceGetMappedPointer_fn == hipGraphicsResourceGetMappedPointer_wrapper;
}

static bool is_hipGraphicsSubResourceGetMappedArray_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphicsSubResourceGetMappedArray_fn == hipGraphicsSubResourceGetMappedArray_wrapper;
}

static bool is_hipGraphicsUnmapResources_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphicsUnmapResources_fn == hipGraphicsUnmapResources_wrapper;
}

static bool is_hipGraphicsUnregisterResource_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphicsUnregisterResource_fn == hipGraphicsUnregisterResource_wrapper;
}

static bool is_hipHostAlloc_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipHostAlloc_fn == hipHostAlloc_wrapper;
}

static bool is_hipHostFree_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipHostFree_fn == hipHostFree_wrapper;
}

static bool is_hipHostGetDevicePointer_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipHostGetDevicePointer_fn == hipHostGetDevicePointer_wrapper;
}

static bool is_hipHostGetFlags_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipHostGetFlags_fn == hipHostGetFlags_wrapper;
}

static bool is_hipHostMalloc_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipHostMalloc_fn == hipHostMalloc_wrapper;
}

static bool is_hipHostRegister_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipHostRegister_fn == hipHostRegister_wrapper;
}

static bool is_hipHostUnregister_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipHostUnregister_fn == hipHostUnregister_wrapper;
}

static bool is_hipImportExternalMemory_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipImportExternalMemory_fn == hipImportExternalMemory_wrapper;
}

static bool is_hipImportExternalSemaphore_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipImportExternalSemaphore_fn == hipImportExternalSemaphore_wrapper;
}

static bool is_hipInit_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipInit_fn == hipInit_wrapper;
}

static bool is_hipIpcCloseMemHandle_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipIpcCloseMemHandle_fn == hipIpcCloseMemHandle_wrapper;
}

static bool is_hipIpcGetEventHandle_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipIpcGetEventHandle_fn == hipIpcGetEventHandle_wrapper;
}

static bool is_hipIpcGetMemHandle_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipIpcGetMemHandle_fn == hipIpcGetMemHandle_wrapper;
}

static bool is_hipIpcOpenEventHandle_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipIpcOpenEventHandle_fn == hipIpcOpenEventHandle_wrapper;
}

static bool is_hipIpcOpenMemHandle_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipIpcOpenMemHandle_fn == hipIpcOpenMemHandle_wrapper;
}

static bool is_hipKernelNameRef_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipKernelNameRef_fn == hipKernelNameRef_wrapper;
}

static bool is_hipKernelNameRefByPtr_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipKernelNameRefByPtr_fn == hipKernelNameRefByPtr_wrapper;
}

static bool is_hipLaunchByPtr_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipLaunchByPtr_fn == hipLaunchByPtr_wrapper;
}

static bool is_hipLaunchCooperativeKernel_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipLaunchCooperativeKernel_fn == hipLaunchCooperativeKernel_wrapper;
}

static bool is_hipLaunchCooperativeKernelMultiDevice_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipLaunchCooperativeKernelMultiDevice_fn == hipLaunchCooperativeKernelMultiDevice_wrapper;
}

static bool is_hipLaunchHostFunc_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipLaunchHostFunc_fn == hipLaunchHostFunc_wrapper;
}

static bool is_hipLaunchKernel_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipLaunchKernel_fn == hipLaunchKernel_wrapper;
}

static bool is_hipMalloc_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMalloc_fn == hipMalloc_wrapper;
}

static bool is_hipMalloc3D_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMalloc3D_fn == hipMalloc3D_wrapper;
}

static bool is_hipMalloc3DArray_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMalloc3DArray_fn == hipMalloc3DArray_wrapper;
}

static bool is_hipMallocArray_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMallocArray_fn == hipMallocArray_wrapper;
}

static bool is_hipMallocAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMallocAsync_fn == hipMallocAsync_wrapper;
}

static bool is_hipMallocFromPoolAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMallocFromPoolAsync_fn == hipMallocFromPoolAsync_wrapper;
}

static bool is_hipMallocHost_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMallocHost_fn == hipMallocHost_wrapper;
}

static bool is_hipMallocManaged_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMallocManaged_fn == hipMallocManaged_wrapper;
}

static bool is_hipMallocMipmappedArray_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMallocMipmappedArray_fn == hipMallocMipmappedArray_wrapper;
}

static bool is_hipMallocPitch_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMallocPitch_fn == hipMallocPitch_wrapper;
}

static bool is_hipMemAddressFree_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemAddressFree_fn == hipMemAddressFree_wrapper;
}

static bool is_hipMemAddressReserve_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemAddressReserve_fn == hipMemAddressReserve_wrapper;
}

static bool is_hipMemAdvise_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemAdvise_fn == hipMemAdvise_wrapper;
}

static bool is_hipMemAllocHost_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemAllocHost_fn == hipMemAllocHost_wrapper;
}

static bool is_hipMemAllocPitch_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemAllocPitch_fn == hipMemAllocPitch_wrapper;
}

static bool is_hipMemCreate_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemCreate_fn == hipMemCreate_wrapper;
}

static bool is_hipMemExportToShareableHandle_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemExportToShareableHandle_fn == hipMemExportToShareableHandle_wrapper;
}

static bool is_hipMemGetAccess_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemGetAccess_fn == hipMemGetAccess_wrapper;
}

static bool is_hipMemGetAddressRange_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemGetAddressRange_fn == hipMemGetAddressRange_wrapper;
}

static bool is_hipMemGetAllocationGranularity_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemGetAllocationGranularity_fn == hipMemGetAllocationGranularity_wrapper;
}

static bool is_hipMemGetAllocationPropertiesFromHandle_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemGetAllocationPropertiesFromHandle_fn == hipMemGetAllocationPropertiesFromHandle_wrapper;
}

static bool is_hipMemGetInfo_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemGetInfo_fn == hipMemGetInfo_wrapper;
}

static bool is_hipMemImportFromShareableHandle_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemImportFromShareableHandle_fn == hipMemImportFromShareableHandle_wrapper;
}

static bool is_hipMemMap_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemMap_fn == hipMemMap_wrapper;
}

static bool is_hipMemMapArrayAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemMapArrayAsync_fn == hipMemMapArrayAsync_wrapper;
}

static bool is_hipMemPoolCreate_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemPoolCreate_fn == hipMemPoolCreate_wrapper;
}

static bool is_hipMemPoolDestroy_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemPoolDestroy_fn == hipMemPoolDestroy_wrapper;
}

static bool is_hipMemPoolExportPointer_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemPoolExportPointer_fn == hipMemPoolExportPointer_wrapper;
}

static bool is_hipMemPoolExportToShareableHandle_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemPoolExportToShareableHandle_fn == hipMemPoolExportToShareableHandle_wrapper;
}

static bool is_hipMemPoolGetAccess_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemPoolGetAccess_fn == hipMemPoolGetAccess_wrapper;
}

static bool is_hipMemPoolGetAttribute_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemPoolGetAttribute_fn == hipMemPoolGetAttribute_wrapper;
}

static bool is_hipMemPoolImportFromShareableHandle_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemPoolImportFromShareableHandle_fn == hipMemPoolImportFromShareableHandle_wrapper;
}

static bool is_hipMemPoolImportPointer_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemPoolImportPointer_fn == hipMemPoolImportPointer_wrapper;
}

static bool is_hipMemPoolSetAccess_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemPoolSetAccess_fn == hipMemPoolSetAccess_wrapper;
}

static bool is_hipMemPoolSetAttribute_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemPoolSetAttribute_fn == hipMemPoolSetAttribute_wrapper;
}

static bool is_hipMemPoolTrimTo_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemPoolTrimTo_fn == hipMemPoolTrimTo_wrapper;
}

static bool is_hipMemPrefetchAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemPrefetchAsync_fn == hipMemPrefetchAsync_wrapper;
}

static bool is_hipMemPtrGetInfo_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemPtrGetInfo_fn == hipMemPtrGetInfo_wrapper;
}

static bool is_hipMemRangeGetAttribute_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemRangeGetAttribute_fn == hipMemRangeGetAttribute_wrapper;
}

static bool is_hipMemRangeGetAttributes_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemRangeGetAttributes_fn == hipMemRangeGetAttributes_wrapper;
}

static bool is_hipMemRelease_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemRelease_fn == hipMemRelease_wrapper;
}

static bool is_hipMemRetainAllocationHandle_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemRetainAllocationHandle_fn == hipMemRetainAllocationHandle_wrapper;
}

static bool is_hipMemSetAccess_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemSetAccess_fn == hipMemSetAccess_wrapper;
}

static bool is_hipMemUnmap_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemUnmap_fn == hipMemUnmap_wrapper;
}

static bool is_hipMemcpy_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy_fn == hipMemcpy_wrapper;
}

static bool is_hipMemcpy2D_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy2D_fn == hipMemcpy2D_wrapper;
}

static bool is_hipMemcpy2DAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy2DAsync_fn == hipMemcpy2DAsync_wrapper;
}

static bool is_hipMemcpy2DFromArray_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy2DFromArray_fn == hipMemcpy2DFromArray_wrapper;
}

static bool is_hipMemcpy2DFromArrayAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy2DFromArrayAsync_fn == hipMemcpy2DFromArrayAsync_wrapper;
}

static bool is_hipMemcpy2DToArray_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy2DToArray_fn == hipMemcpy2DToArray_wrapper;
}

static bool is_hipMemcpy2DToArrayAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy2DToArrayAsync_fn == hipMemcpy2DToArrayAsync_wrapper;
}

static bool is_hipMemcpy3D_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy3D_fn == hipMemcpy3D_wrapper;
}

static bool is_hipMemcpy3DAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy3DAsync_fn == hipMemcpy3DAsync_wrapper;
}

static bool is_hipMemcpyAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyAsync_fn == hipMemcpyAsync_wrapper;
}

static bool is_hipMemcpyAtoH_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyAtoH_fn == hipMemcpyAtoH_wrapper;
}

static bool is_hipMemcpyDtoD_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyDtoD_fn == hipMemcpyDtoD_wrapper;
}

static bool is_hipMemcpyDtoDAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyDtoDAsync_fn == hipMemcpyDtoDAsync_wrapper;
}

static bool is_hipMemcpyDtoH_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyDtoH_fn == hipMemcpyDtoH_wrapper;
}

static bool is_hipMemcpyDtoHAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyDtoHAsync_fn == hipMemcpyDtoHAsync_wrapper;
}

static bool is_hipMemcpyFromArray_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyFromArray_fn == hipMemcpyFromArray_wrapper;
}

static bool is_hipMemcpyFromSymbol_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyFromSymbol_fn == hipMemcpyFromSymbol_wrapper;
}

static bool is_hipMemcpyFromSymbolAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyFromSymbolAsync_fn == hipMemcpyFromSymbolAsync_wrapper;
}

static bool is_hipMemcpyHtoA_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyHtoA_fn == hipMemcpyHtoA_wrapper;
}

static bool is_hipMemcpyHtoD_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyHtoD_fn == hipMemcpyHtoD_wrapper;
}

static bool is_hipMemcpyHtoDAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyHtoDAsync_fn == hipMemcpyHtoDAsync_wrapper;
}

static bool is_hipMemcpyParam2D_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyParam2D_fn == hipMemcpyParam2D_wrapper;
}

static bool is_hipMemcpyParam2DAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyParam2DAsync_fn == hipMemcpyParam2DAsync_wrapper;
}

static bool is_hipMemcpyPeer_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyPeer_fn == hipMemcpyPeer_wrapper;
}

static bool is_hipMemcpyPeerAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyPeerAsync_fn == hipMemcpyPeerAsync_wrapper;
}

static bool is_hipMemcpyToArray_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyToArray_fn == hipMemcpyToArray_wrapper;
}

static bool is_hipMemcpyToSymbol_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyToSymbol_fn == hipMemcpyToSymbol_wrapper;
}

static bool is_hipMemcpyToSymbolAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyToSymbolAsync_fn == hipMemcpyToSymbolAsync_wrapper;
}

static bool is_hipMemcpyWithStream_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyWithStream_fn == hipMemcpyWithStream_wrapper;
}

static bool is_hipMemset_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemset_fn == hipMemset_wrapper;
}

static bool is_hipMemset2D_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemset2D_fn == hipMemset2D_wrapper;
}

static bool is_hipMemset2DAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemset2DAsync_fn == hipMemset2DAsync_wrapper;
}

static bool is_hipMemset3D_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemset3D_fn == hipMemset3D_wrapper;
}

static bool is_hipMemset3DAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemset3DAsync_fn == hipMemset3DAsync_wrapper;
}

static bool is_hipMemsetAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemsetAsync_fn == hipMemsetAsync_wrapper;
}

static bool is_hipMemsetD16_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemsetD16_fn == hipMemsetD16_wrapper;
}

static bool is_hipMemsetD16Async_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemsetD16Async_fn == hipMemsetD16Async_wrapper;
}

static bool is_hipMemsetD32_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemsetD32_fn == hipMemsetD32_wrapper;
}

static bool is_hipMemsetD32Async_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemsetD32Async_fn == hipMemsetD32Async_wrapper;
}

static bool is_hipMemsetD8_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemsetD8_fn == hipMemsetD8_wrapper;
}

static bool is_hipMemsetD8Async_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemsetD8Async_fn == hipMemsetD8Async_wrapper;
}

static bool is_hipMipmappedArrayCreate_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMipmappedArrayCreate_fn == hipMipmappedArrayCreate_wrapper;
}

static bool is_hipMipmappedArrayDestroy_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMipmappedArrayDestroy_fn == hipMipmappedArrayDestroy_wrapper;
}

static bool is_hipMipmappedArrayGetLevel_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMipmappedArrayGetLevel_fn == hipMipmappedArrayGetLevel_wrapper;
}

static bool is_hipModuleGetFunction_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipModuleGetFunction_fn == hipModuleGetFunction_wrapper;
}

static bool is_hipModuleGetGlobal_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipModuleGetGlobal_fn == hipModuleGetGlobal_wrapper;
}

static bool is_hipModuleGetTexRef_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipModuleGetTexRef_fn == hipModuleGetTexRef_wrapper;
}

static bool is_hipModuleLaunchCooperativeKernel_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipModuleLaunchCooperativeKernel_fn == hipModuleLaunchCooperativeKernel_wrapper;
}

static bool is_hipModuleLaunchCooperativeKernelMultiDevice_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipModuleLaunchCooperativeKernelMultiDevice_fn == hipModuleLaunchCooperativeKernelMultiDevice_wrapper;
}

static bool is_hipModuleLaunchKernel_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipModuleLaunchKernel_fn == hipModuleLaunchKernel_wrapper;
}

static bool is_hipModuleLoad_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipModuleLoad_fn == hipModuleLoad_wrapper;
}

static bool is_hipModuleLoadData_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipModuleLoadData_fn == hipModuleLoadData_wrapper;
}

static bool is_hipModuleLoadDataEx_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipModuleLoadDataEx_fn == hipModuleLoadDataEx_wrapper;
}

static bool is_hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_fn == hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_wrapper;
}

static bool is_hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_fn == hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_wrapper;
}

static bool is_hipModuleOccupancyMaxPotentialBlockSize_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipModuleOccupancyMaxPotentialBlockSize_fn == hipModuleOccupancyMaxPotentialBlockSize_wrapper;
}

static bool is_hipModuleOccupancyMaxPotentialBlockSizeWithFlags_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipModuleOccupancyMaxPotentialBlockSizeWithFlags_fn == hipModuleOccupancyMaxPotentialBlockSizeWithFlags_wrapper;
}

static bool is_hipModuleUnload_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipModuleUnload_fn == hipModuleUnload_wrapper;
}

static bool is_hipOccupancyMaxActiveBlocksPerMultiprocessor_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipOccupancyMaxActiveBlocksPerMultiprocessor_fn == hipOccupancyMaxActiveBlocksPerMultiprocessor_wrapper;
}

static bool is_hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_fn == hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_wrapper;
}

static bool is_hipOccupancyMaxPotentialBlockSize_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipOccupancyMaxPotentialBlockSize_fn == hipOccupancyMaxPotentialBlockSize_wrapper;
}

static bool is_hipPeekAtLastError_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipPeekAtLastError_fn == hipPeekAtLastError_wrapper;
}

static bool is_hipPointerGetAttribute_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipPointerGetAttribute_fn == hipPointerGetAttribute_wrapper;
}

static bool is_hipPointerGetAttributes_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipPointerGetAttributes_fn == hipPointerGetAttributes_wrapper;
}

static bool is_hipPointerSetAttribute_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipPointerSetAttribute_fn == hipPointerSetAttribute_wrapper;
}

static bool is_hipProfilerStart_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipProfilerStart_fn == hipProfilerStart_wrapper;
}

static bool is_hipProfilerStop_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipProfilerStop_fn == hipProfilerStop_wrapper;
}

static bool is_hipRuntimeGetVersion_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipRuntimeGetVersion_fn == hipRuntimeGetVersion_wrapper;
}

static bool is_hipSetDevice_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipSetDevice_fn == hipSetDevice_wrapper;
}

static bool is_hipSetDeviceFlags_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipSetDeviceFlags_fn == hipSetDeviceFlags_wrapper;
}

static bool is_hipSetupArgument_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipSetupArgument_fn == hipSetupArgument_wrapper;
}

static bool is_hipSignalExternalSemaphoresAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipSignalExternalSemaphoresAsync_fn == hipSignalExternalSemaphoresAsync_wrapper;
}

static bool is_hipStreamAddCallback_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamAddCallback_fn == hipStreamAddCallback_wrapper;
}

static bool is_hipStreamAttachMemAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamAttachMemAsync_fn == hipStreamAttachMemAsync_wrapper;
}

static bool is_hipStreamBeginCapture_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamBeginCapture_fn == hipStreamBeginCapture_wrapper;
}

static bool is_hipStreamCreate_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamCreate_fn == hipStreamCreate_wrapper;
}

static bool is_hipStreamCreateWithFlags_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamCreateWithFlags_fn == hipStreamCreateWithFlags_wrapper;
}

static bool is_hipStreamCreateWithPriority_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamCreateWithPriority_fn == hipStreamCreateWithPriority_wrapper;
}

static bool is_hipStreamDestroy_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamDestroy_fn == hipStreamDestroy_wrapper;
}

static bool is_hipStreamEndCapture_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamEndCapture_fn == hipStreamEndCapture_wrapper;
}

static bool is_hipStreamGetCaptureInfo_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamGetCaptureInfo_fn == hipStreamGetCaptureInfo_wrapper;
}

static bool is_hipStreamGetCaptureInfo_v2_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamGetCaptureInfo_v2_fn == hipStreamGetCaptureInfo_v2_wrapper;
}

static bool is_hipStreamGetDevice_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamGetDevice_fn == hipStreamGetDevice_wrapper;
}

static bool is_hipStreamGetFlags_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamGetFlags_fn == hipStreamGetFlags_wrapper;
}

static bool is_hipStreamGetPriority_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamGetPriority_fn == hipStreamGetPriority_wrapper;
}

static bool is_hipStreamIsCapturing_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamIsCapturing_fn == hipStreamIsCapturing_wrapper;
}

static bool is_hipStreamQuery_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamQuery_fn == hipStreamQuery_wrapper;
}

static bool is_hipStreamSynchronize_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamSynchronize_fn == hipStreamSynchronize_wrapper;
}

static bool is_hipStreamUpdateCaptureDependencies_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamUpdateCaptureDependencies_fn == hipStreamUpdateCaptureDependencies_wrapper;
}

static bool is_hipStreamWaitEvent_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamWaitEvent_fn == hipStreamWaitEvent_wrapper;
}

static bool is_hipStreamWaitValue32_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamWaitValue32_fn == hipStreamWaitValue32_wrapper;
}

static bool is_hipStreamWaitValue64_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamWaitValue64_fn == hipStreamWaitValue64_wrapper;
}

static bool is_hipStreamWriteValue32_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamWriteValue32_fn == hipStreamWriteValue32_wrapper;
}

static bool is_hipStreamWriteValue64_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamWriteValue64_fn == hipStreamWriteValue64_wrapper;
}

static bool is_hipTexObjectCreate_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexObjectCreate_fn == hipTexObjectCreate_wrapper;
}

static bool is_hipTexObjectDestroy_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexObjectDestroy_fn == hipTexObjectDestroy_wrapper;
}

static bool is_hipTexObjectGetResourceDesc_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexObjectGetResourceDesc_fn == hipTexObjectGetResourceDesc_wrapper;
}

static bool is_hipTexObjectGetResourceViewDesc_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexObjectGetResourceViewDesc_fn == hipTexObjectGetResourceViewDesc_wrapper;
}

static bool is_hipTexObjectGetTextureDesc_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexObjectGetTextureDesc_fn == hipTexObjectGetTextureDesc_wrapper;
}

static bool is_hipTexRefGetAddress_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefGetAddress_fn == hipTexRefGetAddress_wrapper;
}

static bool is_hipTexRefGetAddressMode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefGetAddressMode_fn == hipTexRefGetAddressMode_wrapper;
}

static bool is_hipTexRefGetFilterMode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefGetFilterMode_fn == hipTexRefGetFilterMode_wrapper;
}

static bool is_hipTexRefGetFlags_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefGetFlags_fn == hipTexRefGetFlags_wrapper;
}

static bool is_hipTexRefGetFormat_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefGetFormat_fn == hipTexRefGetFormat_wrapper;
}

static bool is_hipTexRefGetMaxAnisotropy_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefGetMaxAnisotropy_fn == hipTexRefGetMaxAnisotropy_wrapper;
}

static bool is_hipTexRefGetMipMappedArray_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefGetMipMappedArray_fn == hipTexRefGetMipMappedArray_wrapper;
}

static bool is_hipTexRefGetMipmapFilterMode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefGetMipmapFilterMode_fn == hipTexRefGetMipmapFilterMode_wrapper;
}

static bool is_hipTexRefGetMipmapLevelBias_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefGetMipmapLevelBias_fn == hipTexRefGetMipmapLevelBias_wrapper;
}

static bool is_hipTexRefGetMipmapLevelClamp_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefGetMipmapLevelClamp_fn == hipTexRefGetMipmapLevelClamp_wrapper;
}

static bool is_hipTexRefSetAddress_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefSetAddress_fn == hipTexRefSetAddress_wrapper;
}

static bool is_hipTexRefSetAddress2D_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefSetAddress2D_fn == hipTexRefSetAddress2D_wrapper;
}

static bool is_hipTexRefSetAddressMode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefSetAddressMode_fn == hipTexRefSetAddressMode_wrapper;
}

static bool is_hipTexRefSetArray_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefSetArray_fn == hipTexRefSetArray_wrapper;
}

static bool is_hipTexRefSetBorderColor_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefSetBorderColor_fn == hipTexRefSetBorderColor_wrapper;
}

static bool is_hipTexRefSetFilterMode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefSetFilterMode_fn == hipTexRefSetFilterMode_wrapper;
}

static bool is_hipTexRefSetFlags_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefSetFlags_fn == hipTexRefSetFlags_wrapper;
}

static bool is_hipTexRefSetFormat_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefSetFormat_fn == hipTexRefSetFormat_wrapper;
}

static bool is_hipTexRefSetMaxAnisotropy_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefSetMaxAnisotropy_fn == hipTexRefSetMaxAnisotropy_wrapper;
}

static bool is_hipTexRefSetMipmapFilterMode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefSetMipmapFilterMode_fn == hipTexRefSetMipmapFilterMode_wrapper;
}

static bool is_hipTexRefSetMipmapLevelBias_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefSetMipmapLevelBias_fn == hipTexRefSetMipmapLevelBias_wrapper;
}

static bool is_hipTexRefSetMipmapLevelClamp_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefSetMipmapLevelClamp_fn == hipTexRefSetMipmapLevelClamp_wrapper;
}

static bool is_hipTexRefSetMipmappedArray_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefSetMipmappedArray_fn == hipTexRefSetMipmappedArray_wrapper;
}

static bool is_hipThreadExchangeStreamCaptureMode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipThreadExchangeStreamCaptureMode_fn == hipThreadExchangeStreamCaptureMode_wrapper;
}

static bool is_hipUnbindTexture_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipUnbindTexture_fn == hipUnbindTexture_wrapper;
}

static bool is_hipUserObjectCreate_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipUserObjectCreate_fn == hipUserObjectCreate_wrapper;
}

static bool is_hipUserObjectRelease_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipUserObjectRelease_fn == hipUserObjectRelease_wrapper;
}

static bool is_hipUserObjectRetain_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipUserObjectRetain_fn == hipUserObjectRetain_wrapper;
}

static bool is_hipWaitExternalSemaphoresAsync_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipWaitExternalSemaphoresAsync_fn == hipWaitExternalSemaphoresAsync_wrapper;
}

static bool is_hipCreateChannelDesc_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipCreateChannelDesc_fn == hipCreateChannelDesc_wrapper;
}

static bool is_hipExtModuleLaunchKernel_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipExtModuleLaunchKernel_fn == hipExtModuleLaunchKernel_wrapper;
}

static bool is_hipHccModuleLaunchKernel_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipHccModuleLaunchKernel_fn == hipHccModuleLaunchKernel_wrapper;
}

static bool is_hipMemcpy_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy_spt_fn == hipMemcpy_spt_wrapper;
}

static bool is_hipMemcpyToSymbol_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyToSymbol_spt_fn == hipMemcpyToSymbol_spt_wrapper;
}

static bool is_hipMemcpyFromSymbol_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyFromSymbol_spt_fn == hipMemcpyFromSymbol_spt_wrapper;
}

static bool is_hipMemcpy2D_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy2D_spt_fn == hipMemcpy2D_spt_wrapper;
}

static bool is_hipMemcpy2DFromArray_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy2DFromArray_spt_fn == hipMemcpy2DFromArray_spt_wrapper;
}

static bool is_hipMemcpy3D_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy3D_spt_fn == hipMemcpy3D_spt_wrapper;
}

static bool is_hipMemset_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemset_spt_fn == hipMemset_spt_wrapper;
}

static bool is_hipMemsetAsync_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemsetAsync_spt_fn == hipMemsetAsync_spt_wrapper;
}

static bool is_hipMemset2D_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemset2D_spt_fn == hipMemset2D_spt_wrapper;
}

static bool is_hipMemset2DAsync_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemset2DAsync_spt_fn == hipMemset2DAsync_spt_wrapper;
}

static bool is_hipMemset3DAsync_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemset3DAsync_spt_fn == hipMemset3DAsync_spt_wrapper;
}

static bool is_hipMemset3D_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemset3D_spt_fn == hipMemset3D_spt_wrapper;
}

static bool is_hipMemcpyAsync_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyAsync_spt_fn == hipMemcpyAsync_spt_wrapper;
}

static bool is_hipMemcpy3DAsync_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy3DAsync_spt_fn == hipMemcpy3DAsync_spt_wrapper;
}

static bool is_hipMemcpy2DAsync_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy2DAsync_spt_fn == hipMemcpy2DAsync_spt_wrapper;
}

static bool is_hipMemcpyFromSymbolAsync_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyFromSymbolAsync_spt_fn == hipMemcpyFromSymbolAsync_spt_wrapper;
}

static bool is_hipMemcpyToSymbolAsync_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyToSymbolAsync_spt_fn == hipMemcpyToSymbolAsync_spt_wrapper;
}

static bool is_hipMemcpyFromArray_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpyFromArray_spt_fn == hipMemcpyFromArray_spt_wrapper;
}

static bool is_hipMemcpy2DToArray_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy2DToArray_spt_fn == hipMemcpy2DToArray_spt_wrapper;
}

static bool is_hipMemcpy2DFromArrayAsync_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy2DFromArrayAsync_spt_fn == hipMemcpy2DFromArrayAsync_spt_wrapper;
}

static bool is_hipMemcpy2DToArrayAsync_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipMemcpy2DToArrayAsync_spt_fn == hipMemcpy2DToArrayAsync_spt_wrapper;
}

static bool is_hipStreamQuery_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamQuery_spt_fn == hipStreamQuery_spt_wrapper;
}

static bool is_hipStreamSynchronize_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamSynchronize_spt_fn == hipStreamSynchronize_spt_wrapper;
}

static bool is_hipStreamGetPriority_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamGetPriority_spt_fn == hipStreamGetPriority_spt_wrapper;
}

static bool is_hipStreamWaitEvent_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamWaitEvent_spt_fn == hipStreamWaitEvent_spt_wrapper;
}

static bool is_hipStreamGetFlags_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamGetFlags_spt_fn == hipStreamGetFlags_spt_wrapper;
}

static bool is_hipStreamAddCallback_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamAddCallback_spt_fn == hipStreamAddCallback_spt_wrapper;
}

static bool is_hipEventRecord_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipEventRecord_spt_fn == hipEventRecord_spt_wrapper;
}

static bool is_hipLaunchCooperativeKernel_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipLaunchCooperativeKernel_spt_fn == hipLaunchCooperativeKernel_spt_wrapper;
}

static bool is_hipLaunchKernel_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipLaunchKernel_spt_fn == hipLaunchKernel_spt_wrapper;
}

static bool is_hipGraphLaunch_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphLaunch_spt_fn == hipGraphLaunch_spt_wrapper;
}

static bool is_hipStreamBeginCapture_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamBeginCapture_spt_fn == hipStreamBeginCapture_spt_wrapper;
}

static bool is_hipStreamEndCapture_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamEndCapture_spt_fn == hipStreamEndCapture_spt_wrapper;
}

static bool is_hipStreamIsCapturing_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamIsCapturing_spt_fn == hipStreamIsCapturing_spt_wrapper;
}

static bool is_hipStreamGetCaptureInfo_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamGetCaptureInfo_spt_fn == hipStreamGetCaptureInfo_spt_wrapper;
}

static bool is_hipStreamGetCaptureInfo_v2_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamGetCaptureInfo_v2_spt_fn == hipStreamGetCaptureInfo_v2_spt_wrapper;
}

static bool is_hipLaunchHostFunc_spt_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipLaunchHostFunc_spt_fn == hipLaunchHostFunc_spt_wrapper;
}

static bool is_hipGetStreamDeviceId_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetStreamDeviceId_fn == hipGetStreamDeviceId_wrapper;
}

static bool is_hipDrvGraphAddMemsetNode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipDrvGraphAddMemsetNode_fn == hipDrvGraphAddMemsetNode_wrapper;
}

static bool is_hipGraphAddExternalSemaphoresWaitNode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphAddExternalSemaphoresWaitNode_fn == hipGraphAddExternalSemaphoresWaitNode_wrapper;
}

static bool is_hipGraphAddExternalSemaphoresSignalNode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphAddExternalSemaphoresSignalNode_fn == hipGraphAddExternalSemaphoresSignalNode_wrapper;
}

static bool is_hipGraphExternalSemaphoresSignalNodeSetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExternalSemaphoresSignalNodeSetParams_fn == hipGraphExternalSemaphoresSignalNodeSetParams_wrapper;
}

static bool is_hipGraphExternalSemaphoresWaitNodeSetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExternalSemaphoresWaitNodeSetParams_fn == hipGraphExternalSemaphoresWaitNodeSetParams_wrapper;
}

static bool is_hipGraphExternalSemaphoresSignalNodeGetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExternalSemaphoresSignalNodeGetParams_fn == hipGraphExternalSemaphoresSignalNodeGetParams_wrapper;
}

static bool is_hipGraphExternalSemaphoresWaitNodeGetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExternalSemaphoresWaitNodeGetParams_fn == hipGraphExternalSemaphoresWaitNodeGetParams_wrapper;
}

static bool is_hipGraphExecExternalSemaphoresSignalNodeSetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExecExternalSemaphoresSignalNodeSetParams_fn == hipGraphExecExternalSemaphoresSignalNodeSetParams_wrapper;
}

static bool is_hipGraphExecExternalSemaphoresWaitNodeSetParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphExecExternalSemaphoresWaitNodeSetParams_fn == hipGraphExecExternalSemaphoresWaitNodeSetParams_wrapper;
}

static bool is_hipGraphAddNode_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphAddNode_fn == hipGraphAddNode_wrapper;
}

static bool is_hipGraphInstantiateWithParams_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGraphInstantiateWithParams_fn == hipGraphInstantiateWithParams_wrapper;
}

static bool is_hipExtGetLastError_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipExtGetLastError_fn == hipExtGetLastError_wrapper;
}

static bool is_hipTexRefGetBorderColor_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefGetBorderColor_fn == hipTexRefGetBorderColor_wrapper;
}

static bool is_hipTexRefGetArray_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipTexRefGetArray_fn == hipTexRefGetArray_wrapper;
}

static bool is_hipGetProcAddress_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetProcAddress_fn == hipGetProcAddress_wrapper;
}

static bool is_hipStreamBeginCaptureToGraph_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipStreamBeginCaptureToGraph_fn == hipStreamBeginCaptureToGraph_wrapper;
}

static bool is_hipGetFuncBySymbol_wrapper_installed(HipDispatchTable *RuntimeApiTable) {
  return RuntimeApiTable->hipGetFuncBySymbol_fn == hipGetFuncBySymbol_wrapper;
}

static constexpr void (*HipRuntimeWrapperSwitchFunctionsMap[])(HipDispatchTable *, const HipDispatchTable &, bool) {
  switch_hipApiName_wrapper,
  switch_hipArray3DCreate_wrapper,
  switch_hipArray3DGetDescriptor_wrapper,
  switch_hipArrayCreate_wrapper,
  switch_hipArrayDestroy_wrapper,
  switch_hipArrayGetDescriptor_wrapper,
  switch_hipArrayGetInfo_wrapper,
  switch_hipBindTexture_wrapper,
  switch_hipBindTexture2D_wrapper,
  switch_hipBindTextureToArray_wrapper,
  switch_hipBindTextureToMipmappedArray_wrapper,
  switch_hipChooseDevice_wrapper,
  switch_hipChooseDeviceR0000_wrapper,
  switch_hipConfigureCall_wrapper,
  switch_hipCreateSurfaceObject_wrapper,
  switch_hipCreateTextureObject_wrapper,
  switch_hipCtxCreate_wrapper,
  switch_hipCtxDestroy_wrapper,
  switch_hipCtxDisablePeerAccess_wrapper,
  switch_hipCtxEnablePeerAccess_wrapper,
  switch_hipCtxGetApiVersion_wrapper,
  switch_hipCtxGetCacheConfig_wrapper,
  switch_hipCtxGetCurrent_wrapper,
  switch_hipCtxGetDevice_wrapper,
  switch_hipCtxGetFlags_wrapper,
  switch_hipCtxGetSharedMemConfig_wrapper,
  switch_hipCtxPopCurrent_wrapper,
  switch_hipCtxPushCurrent_wrapper,
  switch_hipCtxSetCacheConfig_wrapper,
  switch_hipCtxSetCurrent_wrapper,
  switch_hipCtxSetSharedMemConfig_wrapper,
  switch_hipCtxSynchronize_wrapper,
  switch_hipDestroyExternalMemory_wrapper,
  switch_hipDestroyExternalSemaphore_wrapper,
  switch_hipDestroySurfaceObject_wrapper,
  switch_hipDestroyTextureObject_wrapper,
  switch_hipDeviceCanAccessPeer_wrapper,
  switch_hipDeviceComputeCapability_wrapper,
  switch_hipDeviceDisablePeerAccess_wrapper,
  switch_hipDeviceEnablePeerAccess_wrapper,
  switch_hipDeviceGet_wrapper,
  switch_hipDeviceGetAttribute_wrapper,
  switch_hipDeviceGetByPCIBusId_wrapper,
  switch_hipDeviceGetCacheConfig_wrapper,
  switch_hipDeviceGetDefaultMemPool_wrapper,
  switch_hipDeviceGetGraphMemAttribute_wrapper,
  switch_hipDeviceGetLimit_wrapper,
  switch_hipDeviceGetMemPool_wrapper,
  switch_hipDeviceGetName_wrapper,
  switch_hipDeviceGetP2PAttribute_wrapper,
  switch_hipDeviceGetPCIBusId_wrapper,
  switch_hipDeviceGetSharedMemConfig_wrapper,
  switch_hipDeviceGetStreamPriorityRange_wrapper,
  switch_hipDeviceGetUuid_wrapper,
  switch_hipDeviceGraphMemTrim_wrapper,
  switch_hipDevicePrimaryCtxGetState_wrapper,
  switch_hipDevicePrimaryCtxRelease_wrapper,
  switch_hipDevicePrimaryCtxReset_wrapper,
  switch_hipDevicePrimaryCtxRetain_wrapper,
  switch_hipDevicePrimaryCtxSetFlags_wrapper,
  switch_hipDeviceReset_wrapper,
  switch_hipDeviceSetCacheConfig_wrapper,
  switch_hipDeviceSetGraphMemAttribute_wrapper,
  switch_hipDeviceSetLimit_wrapper,
  switch_hipDeviceSetMemPool_wrapper,
  switch_hipDeviceSetSharedMemConfig_wrapper,
  switch_hipDeviceSynchronize_wrapper,
  switch_hipDeviceTotalMem_wrapper,
  switch_hipDriverGetVersion_wrapper,
  switch_hipDrvGetErrorName_wrapper,
  switch_hipDrvGetErrorString_wrapper,
  switch_hipDrvGraphAddMemcpyNode_wrapper,
  switch_hipDrvMemcpy2DUnaligned_wrapper,
  switch_hipDrvMemcpy3D_wrapper,
  switch_hipDrvMemcpy3DAsync_wrapper,
  switch_hipDrvPointerGetAttributes_wrapper,
  switch_hipEventCreate_wrapper,
  switch_hipEventCreateWithFlags_wrapper,
  switch_hipEventDestroy_wrapper,
  switch_hipEventElapsedTime_wrapper,
  switch_hipEventQuery_wrapper,
  switch_hipEventRecord_wrapper,
  switch_hipEventSynchronize_wrapper,
  switch_hipExtGetLinkTypeAndHopCount_wrapper,
  switch_hipExtLaunchKernel_wrapper,
  switch_hipExtLaunchMultiKernelMultiDevice_wrapper,
  switch_hipExtMallocWithFlags_wrapper,
  switch_hipExtStreamCreateWithCUMask_wrapper,
  switch_hipExtStreamGetCUMask_wrapper,
  switch_hipExternalMemoryGetMappedBuffer_wrapper,
  switch_hipFree_wrapper,
  switch_hipFreeArray_wrapper,
  switch_hipFreeAsync_wrapper,
  switch_hipFreeHost_wrapper,
  switch_hipFreeMipmappedArray_wrapper,
  switch_hipFuncGetAttribute_wrapper,
  switch_hipFuncGetAttributes_wrapper,
  switch_hipFuncSetAttribute_wrapper,
  switch_hipFuncSetCacheConfig_wrapper,
  switch_hipFuncSetSharedMemConfig_wrapper,
  switch_hipGLGetDevices_wrapper,
  switch_hipGetChannelDesc_wrapper,
  switch_hipGetDevice_wrapper,
  switch_hipGetDeviceCount_wrapper,
  switch_hipGetDeviceFlags_wrapper,
  switch_hipGetDevicePropertiesR0600_wrapper,
  switch_hipGetDevicePropertiesR0000_wrapper,
  switch_hipGetErrorName_wrapper,
  switch_hipGetErrorString_wrapper,
  switch_hipGetLastError_wrapper,
  switch_hipGetMipmappedArrayLevel_wrapper,
  switch_hipGetSymbolAddress_wrapper,
  switch_hipGetSymbolSize_wrapper,
  switch_hipGetTextureAlignmentOffset_wrapper,
  switch_hipGetTextureObjectResourceDesc_wrapper,
  switch_hipGetTextureObjectResourceViewDesc_wrapper,
  switch_hipGetTextureObjectTextureDesc_wrapper,
  switch_hipGetTextureReference_wrapper,
  switch_hipGraphAddChildGraphNode_wrapper,
  switch_hipGraphAddDependencies_wrapper,
  switch_hipGraphAddEmptyNode_wrapper,
  switch_hipGraphAddEventRecordNode_wrapper,
  switch_hipGraphAddEventWaitNode_wrapper,
  switch_hipGraphAddHostNode_wrapper,
  switch_hipGraphAddKernelNode_wrapper,
  switch_hipGraphAddMemAllocNode_wrapper,
  switch_hipGraphAddMemFreeNode_wrapper,
  switch_hipGraphAddMemcpyNode_wrapper,
  switch_hipGraphAddMemcpyNode1D_wrapper,
  switch_hipGraphAddMemcpyNodeFromSymbol_wrapper,
  switch_hipGraphAddMemcpyNodeToSymbol_wrapper,
  switch_hipGraphAddMemsetNode_wrapper,
  switch_hipGraphChildGraphNodeGetGraph_wrapper,
  switch_hipGraphClone_wrapper,
  switch_hipGraphCreate_wrapper,
  switch_hipGraphDebugDotPrint_wrapper,
  switch_hipGraphDestroy_wrapper,
  switch_hipGraphDestroyNode_wrapper,
  switch_hipGraphEventRecordNodeGetEvent_wrapper,
  switch_hipGraphEventRecordNodeSetEvent_wrapper,
  switch_hipGraphEventWaitNodeGetEvent_wrapper,
  switch_hipGraphEventWaitNodeSetEvent_wrapper,
  switch_hipGraphExecChildGraphNodeSetParams_wrapper,
  switch_hipGraphExecDestroy_wrapper,
  switch_hipGraphExecEventRecordNodeSetEvent_wrapper,
  switch_hipGraphExecEventWaitNodeSetEvent_wrapper,
  switch_hipGraphExecHostNodeSetParams_wrapper,
  switch_hipGraphExecKernelNodeSetParams_wrapper,
  switch_hipGraphExecMemcpyNodeSetParams_wrapper,
  switch_hipGraphExecMemcpyNodeSetParams1D_wrapper,
  switch_hipGraphExecMemcpyNodeSetParamsFromSymbol_wrapper,
  switch_hipGraphExecMemcpyNodeSetParamsToSymbol_wrapper,
  switch_hipGraphExecMemsetNodeSetParams_wrapper,
  switch_hipGraphExecUpdate_wrapper,
  switch_hipGraphGetEdges_wrapper,
  switch_hipGraphGetNodes_wrapper,
  switch_hipGraphGetRootNodes_wrapper,
  switch_hipGraphHostNodeGetParams_wrapper,
  switch_hipGraphHostNodeSetParams_wrapper,
  switch_hipGraphInstantiate_wrapper,
  switch_hipGraphInstantiateWithFlags_wrapper,
  switch_hipGraphKernelNodeCopyAttributes_wrapper,
  switch_hipGraphKernelNodeGetAttribute_wrapper,
  switch_hipGraphKernelNodeGetParams_wrapper,
  switch_hipGraphKernelNodeSetAttribute_wrapper,
  switch_hipGraphKernelNodeSetParams_wrapper,
  switch_hipGraphLaunch_wrapper,
  switch_hipGraphMemAllocNodeGetParams_wrapper,
  switch_hipGraphMemFreeNodeGetParams_wrapper,
  switch_hipGraphMemcpyNodeGetParams_wrapper,
  switch_hipGraphMemcpyNodeSetParams_wrapper,
  switch_hipGraphMemcpyNodeSetParams1D_wrapper,
  switch_hipGraphMemcpyNodeSetParamsFromSymbol_wrapper,
  switch_hipGraphMemcpyNodeSetParamsToSymbol_wrapper,
  switch_hipGraphMemsetNodeGetParams_wrapper,
  switch_hipGraphMemsetNodeSetParams_wrapper,
  switch_hipGraphNodeFindInClone_wrapper,
  switch_hipGraphNodeGetDependencies_wrapper,
  switch_hipGraphNodeGetDependentNodes_wrapper,
  switch_hipGraphNodeGetEnabled_wrapper,
  switch_hipGraphNodeGetType_wrapper,
  switch_hipGraphNodeSetEnabled_wrapper,
  switch_hipGraphReleaseUserObject_wrapper,
  switch_hipGraphRemoveDependencies_wrapper,
  switch_hipGraphRetainUserObject_wrapper,
  switch_hipGraphUpload_wrapper,
  switch_hipGraphicsGLRegisterBuffer_wrapper,
  switch_hipGraphicsGLRegisterImage_wrapper,
  switch_hipGraphicsMapResources_wrapper,
  switch_hipGraphicsResourceGetMappedPointer_wrapper,
  switch_hipGraphicsSubResourceGetMappedArray_wrapper,
  switch_hipGraphicsUnmapResources_wrapper,
  switch_hipGraphicsUnregisterResource_wrapper,
  switch_hipHostAlloc_wrapper,
  switch_hipHostFree_wrapper,
  switch_hipHostGetDevicePointer_wrapper,
  switch_hipHostGetFlags_wrapper,
  switch_hipHostMalloc_wrapper,
  switch_hipHostRegister_wrapper,
  switch_hipHostUnregister_wrapper,
  switch_hipImportExternalMemory_wrapper,
  switch_hipImportExternalSemaphore_wrapper,
  switch_hipInit_wrapper,
  switch_hipIpcCloseMemHandle_wrapper,
  switch_hipIpcGetEventHandle_wrapper,
  switch_hipIpcGetMemHandle_wrapper,
  switch_hipIpcOpenEventHandle_wrapper,
  switch_hipIpcOpenMemHandle_wrapper,
  switch_hipKernelNameRef_wrapper,
  switch_hipKernelNameRefByPtr_wrapper,
  switch_hipLaunchByPtr_wrapper,
  switch_hipLaunchCooperativeKernel_wrapper,
  switch_hipLaunchCooperativeKernelMultiDevice_wrapper,
  switch_hipLaunchHostFunc_wrapper,
  switch_hipLaunchKernel_wrapper,
  switch_hipMalloc_wrapper,
  switch_hipMalloc3D_wrapper,
  switch_hipMalloc3DArray_wrapper,
  switch_hipMallocArray_wrapper,
  switch_hipMallocAsync_wrapper,
  switch_hipMallocFromPoolAsync_wrapper,
  switch_hipMallocHost_wrapper,
  switch_hipMallocManaged_wrapper,
  switch_hipMallocMipmappedArray_wrapper,
  switch_hipMallocPitch_wrapper,
  switch_hipMemAddressFree_wrapper,
  switch_hipMemAddressReserve_wrapper,
  switch_hipMemAdvise_wrapper,
  switch_hipMemAllocHost_wrapper,
  switch_hipMemAllocPitch_wrapper,
  switch_hipMemCreate_wrapper,
  switch_hipMemExportToShareableHandle_wrapper,
  switch_hipMemGetAccess_wrapper,
  switch_hipMemGetAddressRange_wrapper,
  switch_hipMemGetAllocationGranularity_wrapper,
  switch_hipMemGetAllocationPropertiesFromHandle_wrapper,
  switch_hipMemGetInfo_wrapper,
  switch_hipMemImportFromShareableHandle_wrapper,
  switch_hipMemMap_wrapper,
  switch_hipMemMapArrayAsync_wrapper,
  switch_hipMemPoolCreate_wrapper,
  switch_hipMemPoolDestroy_wrapper,
  switch_hipMemPoolExportPointer_wrapper,
  switch_hipMemPoolExportToShareableHandle_wrapper,
  switch_hipMemPoolGetAccess_wrapper,
  switch_hipMemPoolGetAttribute_wrapper,
  switch_hipMemPoolImportFromShareableHandle_wrapper,
  switch_hipMemPoolImportPointer_wrapper,
  switch_hipMemPoolSetAccess_wrapper,
  switch_hipMemPoolSetAttribute_wrapper,
  switch_hipMemPoolTrimTo_wrapper,
  switch_hipMemPrefetchAsync_wrapper,
  switch_hipMemPtrGetInfo_wrapper,
  switch_hipMemRangeGetAttribute_wrapper,
  switch_hipMemRangeGetAttributes_wrapper,
  switch_hipMemRelease_wrapper,
  switch_hipMemRetainAllocationHandle_wrapper,
  switch_hipMemSetAccess_wrapper,
  switch_hipMemUnmap_wrapper,
  switch_hipMemcpy_wrapper,
  switch_hipMemcpy2D_wrapper,
  switch_hipMemcpy2DAsync_wrapper,
  switch_hipMemcpy2DFromArray_wrapper,
  switch_hipMemcpy2DFromArrayAsync_wrapper,
  switch_hipMemcpy2DToArray_wrapper,
  switch_hipMemcpy2DToArrayAsync_wrapper,
  switch_hipMemcpy3D_wrapper,
  switch_hipMemcpy3DAsync_wrapper,
  switch_hipMemcpyAsync_wrapper,
  switch_hipMemcpyAtoH_wrapper,
  switch_hipMemcpyDtoD_wrapper,
  switch_hipMemcpyDtoDAsync_wrapper,
  switch_hipMemcpyDtoH_wrapper,
  switch_hipMemcpyDtoHAsync_wrapper,
  switch_hipMemcpyFromArray_wrapper,
  switch_hipMemcpyFromSymbol_wrapper,
  switch_hipMemcpyFromSymbolAsync_wrapper,
  switch_hipMemcpyHtoA_wrapper,
  switch_hipMemcpyHtoD_wrapper,
  switch_hipMemcpyHtoDAsync_wrapper,
  switch_hipMemcpyParam2D_wrapper,
  switch_hipMemcpyParam2DAsync_wrapper,
  switch_hipMemcpyPeer_wrapper,
  switch_hipMemcpyPeerAsync_wrapper,
  switch_hipMemcpyToArray_wrapper,
  switch_hipMemcpyToSymbol_wrapper,
  switch_hipMemcpyToSymbolAsync_wrapper,
  switch_hipMemcpyWithStream_wrapper,
  switch_hipMemset_wrapper,
  switch_hipMemset2D_wrapper,
  switch_hipMemset2DAsync_wrapper,
  switch_hipMemset3D_wrapper,
  switch_hipMemset3DAsync_wrapper,
  switch_hipMemsetAsync_wrapper,
  switch_hipMemsetD16_wrapper,
  switch_hipMemsetD16Async_wrapper,
  switch_hipMemsetD32_wrapper,
  switch_hipMemsetD32Async_wrapper,
  switch_hipMemsetD8_wrapper,
  switch_hipMemsetD8Async_wrapper,
  switch_hipMipmappedArrayCreate_wrapper,
  switch_hipMipmappedArrayDestroy_wrapper,
  switch_hipMipmappedArrayGetLevel_wrapper,
  switch_hipModuleGetFunction_wrapper,
  switch_hipModuleGetGlobal_wrapper,
  switch_hipModuleGetTexRef_wrapper,
  switch_hipModuleLaunchCooperativeKernel_wrapper,
  switch_hipModuleLaunchCooperativeKernelMultiDevice_wrapper,
  switch_hipModuleLaunchKernel_wrapper,
  switch_hipModuleLoad_wrapper,
  switch_hipModuleLoadData_wrapper,
  switch_hipModuleLoadDataEx_wrapper,
  switch_hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_wrapper,
  switch_hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_wrapper,
  switch_hipModuleOccupancyMaxPotentialBlockSize_wrapper,
  switch_hipModuleOccupancyMaxPotentialBlockSizeWithFlags_wrapper,
  switch_hipModuleUnload_wrapper,
  switch_hipOccupancyMaxActiveBlocksPerMultiprocessor_wrapper,
  switch_hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_wrapper,
  switch_hipOccupancyMaxPotentialBlockSize_wrapper,
  switch_hipPeekAtLastError_wrapper,
  switch_hipPointerGetAttribute_wrapper,
  switch_hipPointerGetAttributes_wrapper,
  switch_hipPointerSetAttribute_wrapper,
  switch_hipProfilerStart_wrapper,
  switch_hipProfilerStop_wrapper,
  switch_hipRuntimeGetVersion_wrapper,
  switch_hipSetDevice_wrapper,
  switch_hipSetDeviceFlags_wrapper,
  switch_hipSetupArgument_wrapper,
  switch_hipSignalExternalSemaphoresAsync_wrapper,
  switch_hipStreamAddCallback_wrapper,
  switch_hipStreamAttachMemAsync_wrapper,
  switch_hipStreamBeginCapture_wrapper,
  switch_hipStreamCreate_wrapper,
  switch_hipStreamCreateWithFlags_wrapper,
  switch_hipStreamCreateWithPriority_wrapper,
  switch_hipStreamDestroy_wrapper,
  switch_hipStreamEndCapture_wrapper,
  switch_hipStreamGetCaptureInfo_wrapper,
  switch_hipStreamGetCaptureInfo_v2_wrapper,
  switch_hipStreamGetDevice_wrapper,
  switch_hipStreamGetFlags_wrapper,
  switch_hipStreamGetPriority_wrapper,
  switch_hipStreamIsCapturing_wrapper,
  switch_hipStreamQuery_wrapper,
  switch_hipStreamSynchronize_wrapper,
  switch_hipStreamUpdateCaptureDependencies_wrapper,
  switch_hipStreamWaitEvent_wrapper,
  switch_hipStreamWaitValue32_wrapper,
  switch_hipStreamWaitValue64_wrapper,
  switch_hipStreamWriteValue32_wrapper,
  switch_hipStreamWriteValue64_wrapper,
  switch_hipTexObjectCreate_wrapper,
  switch_hipTexObjectDestroy_wrapper,
  switch_hipTexObjectGetResourceDesc_wrapper,
  switch_hipTexObjectGetResourceViewDesc_wrapper,
  switch_hipTexObjectGetTextureDesc_wrapper,
  switch_hipTexRefGetAddress_wrapper,
  switch_hipTexRefGetAddressMode_wrapper,
  switch_hipTexRefGetFilterMode_wrapper,
  switch_hipTexRefGetFlags_wrapper,
  switch_hipTexRefGetFormat_wrapper,
  switch_hipTexRefGetMaxAnisotropy_wrapper,
  switch_hipTexRefGetMipMappedArray_wrapper,
  switch_hipTexRefGetMipmapFilterMode_wrapper,
  switch_hipTexRefGetMipmapLevelBias_wrapper,
  switch_hipTexRefGetMipmapLevelClamp_wrapper,
  switch_hipTexRefSetAddress_wrapper,
  switch_hipTexRefSetAddress2D_wrapper,
  switch_hipTexRefSetAddressMode_wrapper,
  switch_hipTexRefSetArray_wrapper,
  switch_hipTexRefSetBorderColor_wrapper,
  switch_hipTexRefSetFilterMode_wrapper,
  switch_hipTexRefSetFlags_wrapper,
  switch_hipTexRefSetFormat_wrapper,
  switch_hipTexRefSetMaxAnisotropy_wrapper,
  switch_hipTexRefSetMipmapFilterMode_wrapper,
  switch_hipTexRefSetMipmapLevelBias_wrapper,
  switch_hipTexRefSetMipmapLevelClamp_wrapper,
  switch_hipTexRefSetMipmappedArray_wrapper,
  switch_hipThreadExchangeStreamCaptureMode_wrapper,
  switch_hipUnbindTexture_wrapper,
  switch_hipUserObjectCreate_wrapper,
  switch_hipUserObjectRelease_wrapper,
  switch_hipUserObjectRetain_wrapper,
  switch_hipWaitExternalSemaphoresAsync_wrapper,
  switch_hipCreateChannelDesc_wrapper,
  switch_hipExtModuleLaunchKernel_wrapper,
  switch_hipHccModuleLaunchKernel_wrapper,
  switch_hipMemcpy_spt_wrapper,
  switch_hipMemcpyToSymbol_spt_wrapper,
  switch_hipMemcpyFromSymbol_spt_wrapper,
  switch_hipMemcpy2D_spt_wrapper,
  switch_hipMemcpy2DFromArray_spt_wrapper,
  switch_hipMemcpy3D_spt_wrapper,
  switch_hipMemset_spt_wrapper,
  switch_hipMemsetAsync_spt_wrapper,
  switch_hipMemset2D_spt_wrapper,
  switch_hipMemset2DAsync_spt_wrapper,
  switch_hipMemset3DAsync_spt_wrapper,
  switch_hipMemset3D_spt_wrapper,
  switch_hipMemcpyAsync_spt_wrapper,
  switch_hipMemcpy3DAsync_spt_wrapper,
  switch_hipMemcpy2DAsync_spt_wrapper,
  switch_hipMemcpyFromSymbolAsync_spt_wrapper,
  switch_hipMemcpyToSymbolAsync_spt_wrapper,
  switch_hipMemcpyFromArray_spt_wrapper,
  switch_hipMemcpy2DToArray_spt_wrapper,
  switch_hipMemcpy2DFromArrayAsync_spt_wrapper,
  switch_hipMemcpy2DToArrayAsync_spt_wrapper,
  switch_hipStreamQuery_spt_wrapper,
  switch_hipStreamSynchronize_spt_wrapper,
  switch_hipStreamGetPriority_spt_wrapper,
  switch_hipStreamWaitEvent_spt_wrapper,
  switch_hipStreamGetFlags_spt_wrapper,
  switch_hipStreamAddCallback_spt_wrapper,
  switch_hipEventRecord_spt_wrapper,
  switch_hipLaunchCooperativeKernel_spt_wrapper,
  switch_hipLaunchKernel_spt_wrapper,
  switch_hipGraphLaunch_spt_wrapper,
  switch_hipStreamBeginCapture_spt_wrapper,
  switch_hipStreamEndCapture_spt_wrapper,
  switch_hipStreamIsCapturing_spt_wrapper,
  switch_hipStreamGetCaptureInfo_spt_wrapper,
  switch_hipStreamGetCaptureInfo_v2_spt_wrapper,
  switch_hipLaunchHostFunc_spt_wrapper,
  switch_hipGetStreamDeviceId_wrapper,
  switch_hipDrvGraphAddMemsetNode_wrapper,
  switch_hipGraphAddExternalSemaphoresWaitNode_wrapper,
  switch_hipGraphAddExternalSemaphoresSignalNode_wrapper,
  switch_hipGraphExternalSemaphoresSignalNodeSetParams_wrapper,
  switch_hipGraphExternalSemaphoresWaitNodeSetParams_wrapper,
  switch_hipGraphExternalSemaphoresSignalNodeGetParams_wrapper,
  switch_hipGraphExternalSemaphoresWaitNodeGetParams_wrapper,
  switch_hipGraphExecExternalSemaphoresSignalNodeSetParams_wrapper,
  switch_hipGraphExecExternalSemaphoresWaitNodeSetParams_wrapper,
  switch_hipGraphAddNode_wrapper,
  switch_hipGraphInstantiateWithParams_wrapper,
  switch_hipExtGetLastError_wrapper,
  switch_hipTexRefGetBorderColor_wrapper,
  switch_hipTexRefGetArray_wrapper,
  switch_hipGetProcAddress_wrapper,
  switch_hipStreamBeginCaptureToGraph_wrapper,
  switch_hipGetFuncBySymbol_wrapper,
};static constexpr bool (*HipRuntimeWrapperInstallationCheckFunctionsMap[]) (HipDispatchTable *) {
  is_hipApiName_wrapper_installed,
  is_hipArray3DCreate_wrapper_installed,
  is_hipArray3DGetDescriptor_wrapper_installed,
  is_hipArrayCreate_wrapper_installed,
  is_hipArrayDestroy_wrapper_installed,
  is_hipArrayGetDescriptor_wrapper_installed,
  is_hipArrayGetInfo_wrapper_installed,
  is_hipBindTexture_wrapper_installed,
  is_hipBindTexture2D_wrapper_installed,
  is_hipBindTextureToArray_wrapper_installed,
  is_hipBindTextureToMipmappedArray_wrapper_installed,
  is_hipChooseDevice_wrapper_installed,
  is_hipChooseDeviceR0000_wrapper_installed,
  is_hipConfigureCall_wrapper_installed,
  is_hipCreateSurfaceObject_wrapper_installed,
  is_hipCreateTextureObject_wrapper_installed,
  is_hipCtxCreate_wrapper_installed,
  is_hipCtxDestroy_wrapper_installed,
  is_hipCtxDisablePeerAccess_wrapper_installed,
  is_hipCtxEnablePeerAccess_wrapper_installed,
  is_hipCtxGetApiVersion_wrapper_installed,
  is_hipCtxGetCacheConfig_wrapper_installed,
  is_hipCtxGetCurrent_wrapper_installed,
  is_hipCtxGetDevice_wrapper_installed,
  is_hipCtxGetFlags_wrapper_installed,
  is_hipCtxGetSharedMemConfig_wrapper_installed,
  is_hipCtxPopCurrent_wrapper_installed,
  is_hipCtxPushCurrent_wrapper_installed,
  is_hipCtxSetCacheConfig_wrapper_installed,
  is_hipCtxSetCurrent_wrapper_installed,
  is_hipCtxSetSharedMemConfig_wrapper_installed,
  is_hipCtxSynchronize_wrapper_installed,
  is_hipDestroyExternalMemory_wrapper_installed,
  is_hipDestroyExternalSemaphore_wrapper_installed,
  is_hipDestroySurfaceObject_wrapper_installed,
  is_hipDestroyTextureObject_wrapper_installed,
  is_hipDeviceCanAccessPeer_wrapper_installed,
  is_hipDeviceComputeCapability_wrapper_installed,
  is_hipDeviceDisablePeerAccess_wrapper_installed,
  is_hipDeviceEnablePeerAccess_wrapper_installed,
  is_hipDeviceGet_wrapper_installed,
  is_hipDeviceGetAttribute_wrapper_installed,
  is_hipDeviceGetByPCIBusId_wrapper_installed,
  is_hipDeviceGetCacheConfig_wrapper_installed,
  is_hipDeviceGetDefaultMemPool_wrapper_installed,
  is_hipDeviceGetGraphMemAttribute_wrapper_installed,
  is_hipDeviceGetLimit_wrapper_installed,
  is_hipDeviceGetMemPool_wrapper_installed,
  is_hipDeviceGetName_wrapper_installed,
  is_hipDeviceGetP2PAttribute_wrapper_installed,
  is_hipDeviceGetPCIBusId_wrapper_installed,
  is_hipDeviceGetSharedMemConfig_wrapper_installed,
  is_hipDeviceGetStreamPriorityRange_wrapper_installed,
  is_hipDeviceGetUuid_wrapper_installed,
  is_hipDeviceGraphMemTrim_wrapper_installed,
  is_hipDevicePrimaryCtxGetState_wrapper_installed,
  is_hipDevicePrimaryCtxRelease_wrapper_installed,
  is_hipDevicePrimaryCtxReset_wrapper_installed,
  is_hipDevicePrimaryCtxRetain_wrapper_installed,
  is_hipDevicePrimaryCtxSetFlags_wrapper_installed,
  is_hipDeviceReset_wrapper_installed,
  is_hipDeviceSetCacheConfig_wrapper_installed,
  is_hipDeviceSetGraphMemAttribute_wrapper_installed,
  is_hipDeviceSetLimit_wrapper_installed,
  is_hipDeviceSetMemPool_wrapper_installed,
  is_hipDeviceSetSharedMemConfig_wrapper_installed,
  is_hipDeviceSynchronize_wrapper_installed,
  is_hipDeviceTotalMem_wrapper_installed,
  is_hipDriverGetVersion_wrapper_installed,
  is_hipDrvGetErrorName_wrapper_installed,
  is_hipDrvGetErrorString_wrapper_installed,
  is_hipDrvGraphAddMemcpyNode_wrapper_installed,
  is_hipDrvMemcpy2DUnaligned_wrapper_installed,
  is_hipDrvMemcpy3D_wrapper_installed,
  is_hipDrvMemcpy3DAsync_wrapper_installed,
  is_hipDrvPointerGetAttributes_wrapper_installed,
  is_hipEventCreate_wrapper_installed,
  is_hipEventCreateWithFlags_wrapper_installed,
  is_hipEventDestroy_wrapper_installed,
  is_hipEventElapsedTime_wrapper_installed,
  is_hipEventQuery_wrapper_installed,
  is_hipEventRecord_wrapper_installed,
  is_hipEventSynchronize_wrapper_installed,
  is_hipExtGetLinkTypeAndHopCount_wrapper_installed,
  is_hipExtLaunchKernel_wrapper_installed,
  is_hipExtLaunchMultiKernelMultiDevice_wrapper_installed,
  is_hipExtMallocWithFlags_wrapper_installed,
  is_hipExtStreamCreateWithCUMask_wrapper_installed,
  is_hipExtStreamGetCUMask_wrapper_installed,
  is_hipExternalMemoryGetMappedBuffer_wrapper_installed,
  is_hipFree_wrapper_installed,
  is_hipFreeArray_wrapper_installed,
  is_hipFreeAsync_wrapper_installed,
  is_hipFreeHost_wrapper_installed,
  is_hipFreeMipmappedArray_wrapper_installed,
  is_hipFuncGetAttribute_wrapper_installed,
  is_hipFuncGetAttributes_wrapper_installed,
  is_hipFuncSetAttribute_wrapper_installed,
  is_hipFuncSetCacheConfig_wrapper_installed,
  is_hipFuncSetSharedMemConfig_wrapper_installed,
  is_hipGLGetDevices_wrapper_installed,
  is_hipGetChannelDesc_wrapper_installed,
  is_hipGetDevice_wrapper_installed,
  is_hipGetDeviceCount_wrapper_installed,
  is_hipGetDeviceFlags_wrapper_installed,
  is_hipGetDevicePropertiesR0600_wrapper_installed,
  is_hipGetDevicePropertiesR0000_wrapper_installed,
  is_hipGetErrorName_wrapper_installed,
  is_hipGetErrorString_wrapper_installed,
  is_hipGetLastError_wrapper_installed,
  is_hipGetMipmappedArrayLevel_wrapper_installed,
  is_hipGetSymbolAddress_wrapper_installed,
  is_hipGetSymbolSize_wrapper_installed,
  is_hipGetTextureAlignmentOffset_wrapper_installed,
  is_hipGetTextureObjectResourceDesc_wrapper_installed,
  is_hipGetTextureObjectResourceViewDesc_wrapper_installed,
  is_hipGetTextureObjectTextureDesc_wrapper_installed,
  is_hipGetTextureReference_wrapper_installed,
  is_hipGraphAddChildGraphNode_wrapper_installed,
  is_hipGraphAddDependencies_wrapper_installed,
  is_hipGraphAddEmptyNode_wrapper_installed,
  is_hipGraphAddEventRecordNode_wrapper_installed,
  is_hipGraphAddEventWaitNode_wrapper_installed,
  is_hipGraphAddHostNode_wrapper_installed,
  is_hipGraphAddKernelNode_wrapper_installed,
  is_hipGraphAddMemAllocNode_wrapper_installed,
  is_hipGraphAddMemFreeNode_wrapper_installed,
  is_hipGraphAddMemcpyNode_wrapper_installed,
  is_hipGraphAddMemcpyNode1D_wrapper_installed,
  is_hipGraphAddMemcpyNodeFromSymbol_wrapper_installed,
  is_hipGraphAddMemcpyNodeToSymbol_wrapper_installed,
  is_hipGraphAddMemsetNode_wrapper_installed,
  is_hipGraphChildGraphNodeGetGraph_wrapper_installed,
  is_hipGraphClone_wrapper_installed,
  is_hipGraphCreate_wrapper_installed,
  is_hipGraphDebugDotPrint_wrapper_installed,
  is_hipGraphDestroy_wrapper_installed,
  is_hipGraphDestroyNode_wrapper_installed,
  is_hipGraphEventRecordNodeGetEvent_wrapper_installed,
  is_hipGraphEventRecordNodeSetEvent_wrapper_installed,
  is_hipGraphEventWaitNodeGetEvent_wrapper_installed,
  is_hipGraphEventWaitNodeSetEvent_wrapper_installed,
  is_hipGraphExecChildGraphNodeSetParams_wrapper_installed,
  is_hipGraphExecDestroy_wrapper_installed,
  is_hipGraphExecEventRecordNodeSetEvent_wrapper_installed,
  is_hipGraphExecEventWaitNodeSetEvent_wrapper_installed,
  is_hipGraphExecHostNodeSetParams_wrapper_installed,
  is_hipGraphExecKernelNodeSetParams_wrapper_installed,
  is_hipGraphExecMemcpyNodeSetParams_wrapper_installed,
  is_hipGraphExecMemcpyNodeSetParams1D_wrapper_installed,
  is_hipGraphExecMemcpyNodeSetParamsFromSymbol_wrapper_installed,
  is_hipGraphExecMemcpyNodeSetParamsToSymbol_wrapper_installed,
  is_hipGraphExecMemsetNodeSetParams_wrapper_installed,
  is_hipGraphExecUpdate_wrapper_installed,
  is_hipGraphGetEdges_wrapper_installed,
  is_hipGraphGetNodes_wrapper_installed,
  is_hipGraphGetRootNodes_wrapper_installed,
  is_hipGraphHostNodeGetParams_wrapper_installed,
  is_hipGraphHostNodeSetParams_wrapper_installed,
  is_hipGraphInstantiate_wrapper_installed,
  is_hipGraphInstantiateWithFlags_wrapper_installed,
  is_hipGraphKernelNodeCopyAttributes_wrapper_installed,
  is_hipGraphKernelNodeGetAttribute_wrapper_installed,
  is_hipGraphKernelNodeGetParams_wrapper_installed,
  is_hipGraphKernelNodeSetAttribute_wrapper_installed,
  is_hipGraphKernelNodeSetParams_wrapper_installed,
  is_hipGraphLaunch_wrapper_installed,
  is_hipGraphMemAllocNodeGetParams_wrapper_installed,
  is_hipGraphMemFreeNodeGetParams_wrapper_installed,
  is_hipGraphMemcpyNodeGetParams_wrapper_installed,
  is_hipGraphMemcpyNodeSetParams_wrapper_installed,
  is_hipGraphMemcpyNodeSetParams1D_wrapper_installed,
  is_hipGraphMemcpyNodeSetParamsFromSymbol_wrapper_installed,
  is_hipGraphMemcpyNodeSetParamsToSymbol_wrapper_installed,
  is_hipGraphMemsetNodeGetParams_wrapper_installed,
  is_hipGraphMemsetNodeSetParams_wrapper_installed,
  is_hipGraphNodeFindInClone_wrapper_installed,
  is_hipGraphNodeGetDependencies_wrapper_installed,
  is_hipGraphNodeGetDependentNodes_wrapper_installed,
  is_hipGraphNodeGetEnabled_wrapper_installed,
  is_hipGraphNodeGetType_wrapper_installed,
  is_hipGraphNodeSetEnabled_wrapper_installed,
  is_hipGraphReleaseUserObject_wrapper_installed,
  is_hipGraphRemoveDependencies_wrapper_installed,
  is_hipGraphRetainUserObject_wrapper_installed,
  is_hipGraphUpload_wrapper_installed,
  is_hipGraphicsGLRegisterBuffer_wrapper_installed,
  is_hipGraphicsGLRegisterImage_wrapper_installed,
  is_hipGraphicsMapResources_wrapper_installed,
  is_hipGraphicsResourceGetMappedPointer_wrapper_installed,
  is_hipGraphicsSubResourceGetMappedArray_wrapper_installed,
  is_hipGraphicsUnmapResources_wrapper_installed,
  is_hipGraphicsUnregisterResource_wrapper_installed,
  is_hipHostAlloc_wrapper_installed,
  is_hipHostFree_wrapper_installed,
  is_hipHostGetDevicePointer_wrapper_installed,
  is_hipHostGetFlags_wrapper_installed,
  is_hipHostMalloc_wrapper_installed,
  is_hipHostRegister_wrapper_installed,
  is_hipHostUnregister_wrapper_installed,
  is_hipImportExternalMemory_wrapper_installed,
  is_hipImportExternalSemaphore_wrapper_installed,
  is_hipInit_wrapper_installed,
  is_hipIpcCloseMemHandle_wrapper_installed,
  is_hipIpcGetEventHandle_wrapper_installed,
  is_hipIpcGetMemHandle_wrapper_installed,
  is_hipIpcOpenEventHandle_wrapper_installed,
  is_hipIpcOpenMemHandle_wrapper_installed,
  is_hipKernelNameRef_wrapper_installed,
  is_hipKernelNameRefByPtr_wrapper_installed,
  is_hipLaunchByPtr_wrapper_installed,
  is_hipLaunchCooperativeKernel_wrapper_installed,
  is_hipLaunchCooperativeKernelMultiDevice_wrapper_installed,
  is_hipLaunchHostFunc_wrapper_installed,
  is_hipLaunchKernel_wrapper_installed,
  is_hipMalloc_wrapper_installed,
  is_hipMalloc3D_wrapper_installed,
  is_hipMalloc3DArray_wrapper_installed,
  is_hipMallocArray_wrapper_installed,
  is_hipMallocAsync_wrapper_installed,
  is_hipMallocFromPoolAsync_wrapper_installed,
  is_hipMallocHost_wrapper_installed,
  is_hipMallocManaged_wrapper_installed,
  is_hipMallocMipmappedArray_wrapper_installed,
  is_hipMallocPitch_wrapper_installed,
  is_hipMemAddressFree_wrapper_installed,
  is_hipMemAddressReserve_wrapper_installed,
  is_hipMemAdvise_wrapper_installed,
  is_hipMemAllocHost_wrapper_installed,
  is_hipMemAllocPitch_wrapper_installed,
  is_hipMemCreate_wrapper_installed,
  is_hipMemExportToShareableHandle_wrapper_installed,
  is_hipMemGetAccess_wrapper_installed,
  is_hipMemGetAddressRange_wrapper_installed,
  is_hipMemGetAllocationGranularity_wrapper_installed,
  is_hipMemGetAllocationPropertiesFromHandle_wrapper_installed,
  is_hipMemGetInfo_wrapper_installed,
  is_hipMemImportFromShareableHandle_wrapper_installed,
  is_hipMemMap_wrapper_installed,
  is_hipMemMapArrayAsync_wrapper_installed,
  is_hipMemPoolCreate_wrapper_installed,
  is_hipMemPoolDestroy_wrapper_installed,
  is_hipMemPoolExportPointer_wrapper_installed,
  is_hipMemPoolExportToShareableHandle_wrapper_installed,
  is_hipMemPoolGetAccess_wrapper_installed,
  is_hipMemPoolGetAttribute_wrapper_installed,
  is_hipMemPoolImportFromShareableHandle_wrapper_installed,
  is_hipMemPoolImportPointer_wrapper_installed,
  is_hipMemPoolSetAccess_wrapper_installed,
  is_hipMemPoolSetAttribute_wrapper_installed,
  is_hipMemPoolTrimTo_wrapper_installed,
  is_hipMemPrefetchAsync_wrapper_installed,
  is_hipMemPtrGetInfo_wrapper_installed,
  is_hipMemRangeGetAttribute_wrapper_installed,
  is_hipMemRangeGetAttributes_wrapper_installed,
  is_hipMemRelease_wrapper_installed,
  is_hipMemRetainAllocationHandle_wrapper_installed,
  is_hipMemSetAccess_wrapper_installed,
  is_hipMemUnmap_wrapper_installed,
  is_hipMemcpy_wrapper_installed,
  is_hipMemcpy2D_wrapper_installed,
  is_hipMemcpy2DAsync_wrapper_installed,
  is_hipMemcpy2DFromArray_wrapper_installed,
  is_hipMemcpy2DFromArrayAsync_wrapper_installed,
  is_hipMemcpy2DToArray_wrapper_installed,
  is_hipMemcpy2DToArrayAsync_wrapper_installed,
  is_hipMemcpy3D_wrapper_installed,
  is_hipMemcpy3DAsync_wrapper_installed,
  is_hipMemcpyAsync_wrapper_installed,
  is_hipMemcpyAtoH_wrapper_installed,
  is_hipMemcpyDtoD_wrapper_installed,
  is_hipMemcpyDtoDAsync_wrapper_installed,
  is_hipMemcpyDtoH_wrapper_installed,
  is_hipMemcpyDtoHAsync_wrapper_installed,
  is_hipMemcpyFromArray_wrapper_installed,
  is_hipMemcpyFromSymbol_wrapper_installed,
  is_hipMemcpyFromSymbolAsync_wrapper_installed,
  is_hipMemcpyHtoA_wrapper_installed,
  is_hipMemcpyHtoD_wrapper_installed,
  is_hipMemcpyHtoDAsync_wrapper_installed,
  is_hipMemcpyParam2D_wrapper_installed,
  is_hipMemcpyParam2DAsync_wrapper_installed,
  is_hipMemcpyPeer_wrapper_installed,
  is_hipMemcpyPeerAsync_wrapper_installed,
  is_hipMemcpyToArray_wrapper_installed,
  is_hipMemcpyToSymbol_wrapper_installed,
  is_hipMemcpyToSymbolAsync_wrapper_installed,
  is_hipMemcpyWithStream_wrapper_installed,
  is_hipMemset_wrapper_installed,
  is_hipMemset2D_wrapper_installed,
  is_hipMemset2DAsync_wrapper_installed,
  is_hipMemset3D_wrapper_installed,
  is_hipMemset3DAsync_wrapper_installed,
  is_hipMemsetAsync_wrapper_installed,
  is_hipMemsetD16_wrapper_installed,
  is_hipMemsetD16Async_wrapper_installed,
  is_hipMemsetD32_wrapper_installed,
  is_hipMemsetD32Async_wrapper_installed,
  is_hipMemsetD8_wrapper_installed,
  is_hipMemsetD8Async_wrapper_installed,
  is_hipMipmappedArrayCreate_wrapper_installed,
  is_hipMipmappedArrayDestroy_wrapper_installed,
  is_hipMipmappedArrayGetLevel_wrapper_installed,
  is_hipModuleGetFunction_wrapper_installed,
  is_hipModuleGetGlobal_wrapper_installed,
  is_hipModuleGetTexRef_wrapper_installed,
  is_hipModuleLaunchCooperativeKernel_wrapper_installed,
  is_hipModuleLaunchCooperativeKernelMultiDevice_wrapper_installed,
  is_hipModuleLaunchKernel_wrapper_installed,
  is_hipModuleLoad_wrapper_installed,
  is_hipModuleLoadData_wrapper_installed,
  is_hipModuleLoadDataEx_wrapper_installed,
  is_hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_wrapper_installed,
  is_hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_wrapper_installed,
  is_hipModuleOccupancyMaxPotentialBlockSize_wrapper_installed,
  is_hipModuleOccupancyMaxPotentialBlockSizeWithFlags_wrapper_installed,
  is_hipModuleUnload_wrapper_installed,
  is_hipOccupancyMaxActiveBlocksPerMultiprocessor_wrapper_installed,
  is_hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_wrapper_installed,
  is_hipOccupancyMaxPotentialBlockSize_wrapper_installed,
  is_hipPeekAtLastError_wrapper_installed,
  is_hipPointerGetAttribute_wrapper_installed,
  is_hipPointerGetAttributes_wrapper_installed,
  is_hipPointerSetAttribute_wrapper_installed,
  is_hipProfilerStart_wrapper_installed,
  is_hipProfilerStop_wrapper_installed,
  is_hipRuntimeGetVersion_wrapper_installed,
  is_hipSetDevice_wrapper_installed,
  is_hipSetDeviceFlags_wrapper_installed,
  is_hipSetupArgument_wrapper_installed,
  is_hipSignalExternalSemaphoresAsync_wrapper_installed,
  is_hipStreamAddCallback_wrapper_installed,
  is_hipStreamAttachMemAsync_wrapper_installed,
  is_hipStreamBeginCapture_wrapper_installed,
  is_hipStreamCreate_wrapper_installed,
  is_hipStreamCreateWithFlags_wrapper_installed,
  is_hipStreamCreateWithPriority_wrapper_installed,
  is_hipStreamDestroy_wrapper_installed,
  is_hipStreamEndCapture_wrapper_installed,
  is_hipStreamGetCaptureInfo_wrapper_installed,
  is_hipStreamGetCaptureInfo_v2_wrapper_installed,
  is_hipStreamGetDevice_wrapper_installed,
  is_hipStreamGetFlags_wrapper_installed,
  is_hipStreamGetPriority_wrapper_installed,
  is_hipStreamIsCapturing_wrapper_installed,
  is_hipStreamQuery_wrapper_installed,
  is_hipStreamSynchronize_wrapper_installed,
  is_hipStreamUpdateCaptureDependencies_wrapper_installed,
  is_hipStreamWaitEvent_wrapper_installed,
  is_hipStreamWaitValue32_wrapper_installed,
  is_hipStreamWaitValue64_wrapper_installed,
  is_hipStreamWriteValue32_wrapper_installed,
  is_hipStreamWriteValue64_wrapper_installed,
  is_hipTexObjectCreate_wrapper_installed,
  is_hipTexObjectDestroy_wrapper_installed,
  is_hipTexObjectGetResourceDesc_wrapper_installed,
  is_hipTexObjectGetResourceViewDesc_wrapper_installed,
  is_hipTexObjectGetTextureDesc_wrapper_installed,
  is_hipTexRefGetAddress_wrapper_installed,
  is_hipTexRefGetAddressMode_wrapper_installed,
  is_hipTexRefGetFilterMode_wrapper_installed,
  is_hipTexRefGetFlags_wrapper_installed,
  is_hipTexRefGetFormat_wrapper_installed,
  is_hipTexRefGetMaxAnisotropy_wrapper_installed,
  is_hipTexRefGetMipMappedArray_wrapper_installed,
  is_hipTexRefGetMipmapFilterMode_wrapper_installed,
  is_hipTexRefGetMipmapLevelBias_wrapper_installed,
  is_hipTexRefGetMipmapLevelClamp_wrapper_installed,
  is_hipTexRefSetAddress_wrapper_installed,
  is_hipTexRefSetAddress2D_wrapper_installed,
  is_hipTexRefSetAddressMode_wrapper_installed,
  is_hipTexRefSetArray_wrapper_installed,
  is_hipTexRefSetBorderColor_wrapper_installed,
  is_hipTexRefSetFilterMode_wrapper_installed,
  is_hipTexRefSetFlags_wrapper_installed,
  is_hipTexRefSetFormat_wrapper_installed,
  is_hipTexRefSetMaxAnisotropy_wrapper_installed,
  is_hipTexRefSetMipmapFilterMode_wrapper_installed,
  is_hipTexRefSetMipmapLevelBias_wrapper_installed,
  is_hipTexRefSetMipmapLevelClamp_wrapper_installed,
  is_hipTexRefSetMipmappedArray_wrapper_installed,
  is_hipThreadExchangeStreamCaptureMode_wrapper_installed,
  is_hipUnbindTexture_wrapper_installed,
  is_hipUserObjectCreate_wrapper_installed,
  is_hipUserObjectRelease_wrapper_installed,
  is_hipUserObjectRetain_wrapper_installed,
  is_hipWaitExternalSemaphoresAsync_wrapper_installed,
  is_hipCreateChannelDesc_wrapper_installed,
  is_hipExtModuleLaunchKernel_wrapper_installed,
  is_hipHccModuleLaunchKernel_wrapper_installed,
  is_hipMemcpy_spt_wrapper_installed,
  is_hipMemcpyToSymbol_spt_wrapper_installed,
  is_hipMemcpyFromSymbol_spt_wrapper_installed,
  is_hipMemcpy2D_spt_wrapper_installed,
  is_hipMemcpy2DFromArray_spt_wrapper_installed,
  is_hipMemcpy3D_spt_wrapper_installed,
  is_hipMemset_spt_wrapper_installed,
  is_hipMemsetAsync_spt_wrapper_installed,
  is_hipMemset2D_spt_wrapper_installed,
  is_hipMemset2DAsync_spt_wrapper_installed,
  is_hipMemset3DAsync_spt_wrapper_installed,
  is_hipMemset3D_spt_wrapper_installed,
  is_hipMemcpyAsync_spt_wrapper_installed,
  is_hipMemcpy3DAsync_spt_wrapper_installed,
  is_hipMemcpy2DAsync_spt_wrapper_installed,
  is_hipMemcpyFromSymbolAsync_spt_wrapper_installed,
  is_hipMemcpyToSymbolAsync_spt_wrapper_installed,
  is_hipMemcpyFromArray_spt_wrapper_installed,
  is_hipMemcpy2DToArray_spt_wrapper_installed,
  is_hipMemcpy2DFromArrayAsync_spt_wrapper_installed,
  is_hipMemcpy2DToArrayAsync_spt_wrapper_installed,
  is_hipStreamQuery_spt_wrapper_installed,
  is_hipStreamSynchronize_spt_wrapper_installed,
  is_hipStreamGetPriority_spt_wrapper_installed,
  is_hipStreamWaitEvent_spt_wrapper_installed,
  is_hipStreamGetFlags_spt_wrapper_installed,
  is_hipStreamAddCallback_spt_wrapper_installed,
  is_hipEventRecord_spt_wrapper_installed,
  is_hipLaunchCooperativeKernel_spt_wrapper_installed,
  is_hipLaunchKernel_spt_wrapper_installed,
  is_hipGraphLaunch_spt_wrapper_installed,
  is_hipStreamBeginCapture_spt_wrapper_installed,
  is_hipStreamEndCapture_spt_wrapper_installed,
  is_hipStreamIsCapturing_spt_wrapper_installed,
  is_hipStreamGetCaptureInfo_spt_wrapper_installed,
  is_hipStreamGetCaptureInfo_v2_spt_wrapper_installed,
  is_hipLaunchHostFunc_spt_wrapper_installed,
  is_hipGetStreamDeviceId_wrapper_installed,
  is_hipDrvGraphAddMemsetNode_wrapper_installed,
  is_hipGraphAddExternalSemaphoresWaitNode_wrapper_installed,
  is_hipGraphAddExternalSemaphoresSignalNode_wrapper_installed,
  is_hipGraphExternalSemaphoresSignalNodeSetParams_wrapper_installed,
  is_hipGraphExternalSemaphoresWaitNodeSetParams_wrapper_installed,
  is_hipGraphExternalSemaphoresSignalNodeGetParams_wrapper_installed,
  is_hipGraphExternalSemaphoresWaitNodeGetParams_wrapper_installed,
  is_hipGraphExecExternalSemaphoresSignalNodeSetParams_wrapper_installed,
  is_hipGraphExecExternalSemaphoresWaitNodeSetParams_wrapper_installed,
  is_hipGraphAddNode_wrapper_installed,
  is_hipGraphInstantiateWithParams_wrapper_installed,
  is_hipExtGetLastError_wrapper_installed,
  is_hipTexRefGetBorderColor_wrapper_installed,
  is_hipTexRefGetArray_wrapper_installed,
  is_hipGetProcAddress_wrapper_installed,
  is_hipStreamBeginCaptureToGraph_wrapper_installed,
  is_hipGetFuncBySymbol_wrapper_installed,
};
llvm::Error luthier::hip::HipRuntimeApiInterceptor::enableUserCallback(ApiEvtID Op) {
  LUTHIER_RETURN_ON_ERROR(LUTHIER_ASSERTION(Status != WAITING_FOR_API_TABLE));
  LUTHIER_RETURN_ON_ERROR(
     LUTHIER_ARGUMENT_ERROR_CHECK(
        static_cast<unsigned int>(HIP_RUNTIME_API_EVT_ID_FIRST) <= static_cast<unsigned int>(Op))); 
  LUTHIER_RETURN_ON_ERROR(
     LUTHIER_ARGUMENT_ERROR_CHECK(
        static_cast<unsigned int>(HIP_RUNTIME_API_EVT_ID_LAST) >= static_cast<unsigned int>(Op)));
  unsigned int OpIdx = static_cast<unsigned int>(Op) - 
                       static_cast<unsigned int>(HIP_RUNTIME_API_EVT_ID_FIRST);
  if (Status != FROZEN)
    HipRuntimeWrapperSwitchFunctionsMap[OpIdx](RuntimeApiTable, SavedRuntimeApiTable, true);
  else {
    LUTHIER_RETURN_ON_ERROR(LUTHIER_ASSERTION(!HipRuntimeWrapperInstallationCheckFunctionsMap[OpIdx](RuntimeApiTable)));
  };
  EnabledUserOps.insert(Op);
  return llvm::Error::success();
}

llvm::Error luthier::hip::HipRuntimeApiInterceptor::disableUserCallback(ApiEvtID Op) {
  LUTHIER_RETURN_ON_ERROR(LUTHIER_ASSERTION(Status != WAITING_FOR_API_TABLE));
  LUTHIER_RETURN_ON_ERROR(
     LUTHIER_ARGUMENT_ERROR_CHECK(
        static_cast<unsigned int>(HIP_RUNTIME_API_EVT_ID_FIRST) <= static_cast<unsigned int>(Op))); 
  LUTHIER_RETURN_ON_ERROR(
     LUTHIER_ARGUMENT_ERROR_CHECK(
        static_cast<unsigned int>(HIP_RUNTIME_API_EVT_ID_LAST) >= static_cast<unsigned int>(Op)));
  EnabledUserOps.erase(Op);
  if (Status != FROZEN && !EnabledInternalOps.contains(Op)) {
    unsigned int OpIdx = static_cast<unsigned int>(Op) - 
                   static_cast<unsigned int>(HIP_RUNTIME_API_EVT_ID_FIRST);
    HipRuntimeWrapperSwitchFunctionsMap[OpIdx](RuntimeApiTable, SavedRuntimeApiTable, false);
  }
    
  return llvm::Error::success();
}

llvm::Error luthier::hip::HipRuntimeApiInterceptor::enableInternalCallback(ApiEvtID Op) {
  LUTHIER_RETURN_ON_ERROR(LUTHIER_ASSERTION(Status != WAITING_FOR_API_TABLE));
  LUTHIER_RETURN_ON_ERROR(
     LUTHIER_ARGUMENT_ERROR_CHECK(
        static_cast<unsigned int>(HIP_RUNTIME_API_EVT_ID_FIRST) <= static_cast<unsigned int>(Op))); 
  LUTHIER_RETURN_ON_ERROR(
     LUTHIER_ARGUMENT_ERROR_CHECK(
        static_cast<unsigned int>(HIP_RUNTIME_API_EVT_ID_LAST) >= static_cast<unsigned int>(Op)));
  unsigned int OpIdx = static_cast<unsigned int>(Op) - 
                       static_cast<unsigned int>(HIP_RUNTIME_API_EVT_ID_FIRST);
  if (Status != FROZEN)
    HipRuntimeWrapperSwitchFunctionsMap[OpIdx](RuntimeApiTable, SavedRuntimeApiTable, true);
  else {
    LUTHIER_RETURN_ON_ERROR(LUTHIER_ASSERTION(!HipRuntimeWrapperInstallationCheckFunctionsMap[OpIdx](RuntimeApiTable)));
  };
  EnabledInternalOps.insert(Op);
  return llvm::Error::success();
}

llvm::Error luthier::hip::HipRuntimeApiInterceptor::disableInternalCallback(ApiEvtID Op) {
  LUTHIER_RETURN_ON_ERROR(LUTHIER_ASSERTION(Status != WAITING_FOR_API_TABLE));
  LUTHIER_RETURN_ON_ERROR(
     LUTHIER_ARGUMENT_ERROR_CHECK(
        static_cast<unsigned int>(HIP_RUNTIME_API_EVT_ID_FIRST) <= static_cast<unsigned int>(Op))); 
  LUTHIER_RETURN_ON_ERROR(
     LUTHIER_ARGUMENT_ERROR_CHECK(
        static_cast<unsigned int>(HIP_RUNTIME_API_EVT_ID_LAST) >= static_cast<unsigned int>(Op)));
  EnabledInternalOps.erase(Op);
  if (Status != FROZEN && !EnabledInternalOps.contains(Op)) {
    unsigned int OpIdx = static_cast<unsigned int>(Op) - 
                   static_cast<unsigned int>(HIP_RUNTIME_API_EVT_ID_FIRST);
    HipRuntimeWrapperSwitchFunctionsMap[OpIdx](RuntimeApiTable, SavedRuntimeApiTable, false);
  }
  return llvm::Error::success();
}
// NOLINTEND
