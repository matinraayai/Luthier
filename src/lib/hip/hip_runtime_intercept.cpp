// NOLINTBEGIN
/* Generated by hip_intercept_gen.py. DO NOT EDIT! */
#include "hip/hip_runtime_intercept.hpp"
#include "luthier/luthier.h"
#include "luthier/types.h"
#include <rocprofiler-sdk/hip/api_args.h>
#include <rocprofiler-sdk/hip/api_id.h>


static const char* hipApiName_callback(uint32_t id) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipApiName;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    const char* Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipApiName.id = id;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipApiName_fn(Args.hipApiName.id);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipApiName_fn(id);
  }
}

static hipError_t hipArray3DCreate_callback(hipArray_t* array, const HIP_ARRAY3D_DESCRIPTOR* pAllocateArray) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipArray3DCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipArray3DCreate.array = array;
    Args.hipArray3DCreate.pAllocateArray = pAllocateArray;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipArray3DCreate_fn(Args.hipArray3DCreate.array, Args.hipArray3DCreate.pAllocateArray);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipArray3DCreate_fn(array, pAllocateArray);
  }
}

static hipError_t hipArray3DGetDescriptor_callback(HIP_ARRAY3D_DESCRIPTOR* pArrayDescriptor, hipArray_t array) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipArray3DGetDescriptor;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipArray3DGetDescriptor.pArrayDescriptor = pArrayDescriptor;
    Args.hipArray3DGetDescriptor.array = array;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipArray3DGetDescriptor_fn(Args.hipArray3DGetDescriptor.pArrayDescriptor, Args.hipArray3DGetDescriptor.array);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipArray3DGetDescriptor_fn(pArrayDescriptor, array);
  }
}

static hipError_t hipArrayCreate_callback(hipArray_t* pHandle, const HIP_ARRAY_DESCRIPTOR* pAllocateArray) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipArrayCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipArrayCreate.pHandle = pHandle;
    Args.hipArrayCreate.pAllocateArray = pAllocateArray;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipArrayCreate_fn(Args.hipArrayCreate.pHandle, Args.hipArrayCreate.pAllocateArray);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipArrayCreate_fn(pHandle, pAllocateArray);
  }
}

static hipError_t hipArrayDestroy_callback(hipArray_t array) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipArrayDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipArrayDestroy.array = array;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipArrayDestroy_fn(Args.hipArrayDestroy.array);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipArrayDestroy_fn(array);
  }
}

static hipError_t hipArrayGetDescriptor_callback(HIP_ARRAY_DESCRIPTOR* pArrayDescriptor, hipArray_t array) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipArrayGetDescriptor;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipArrayGetDescriptor.pArrayDescriptor = pArrayDescriptor;
    Args.hipArrayGetDescriptor.array = array;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipArrayGetDescriptor_fn(Args.hipArrayGetDescriptor.pArrayDescriptor, Args.hipArrayGetDescriptor.array);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipArrayGetDescriptor_fn(pArrayDescriptor, array);
  }
}

static hipError_t hipArrayGetInfo_callback(hipChannelFormatDesc* desc, hipExtent* extent, unsigned int* flags, hipArray_t array) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipArrayGetInfo;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipArrayGetInfo.desc = desc;
    Args.hipArrayGetInfo.extent = extent;
    Args.hipArrayGetInfo.flags = flags;
    Args.hipArrayGetInfo.array = array;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipArrayGetInfo_fn(Args.hipArrayGetInfo.desc, Args.hipArrayGetInfo.extent, Args.hipArrayGetInfo.flags, Args.hipArrayGetInfo.array);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipArrayGetInfo_fn(desc, extent, flags, array);
  }
}

static hipError_t hipBindTexture_callback(size_t* offset, const textureReference* tex, const void* devPtr, const hipChannelFormatDesc* desc, size_t size) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipBindTexture;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipBindTexture.offset = offset;
    Args.hipBindTexture.tex = tex;
    Args.hipBindTexture.devPtr = devPtr;
    Args.hipBindTexture.desc = desc;
    Args.hipBindTexture.size = size;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipBindTexture_fn(Args.hipBindTexture.offset, Args.hipBindTexture.tex, Args.hipBindTexture.devPtr, Args.hipBindTexture.desc, Args.hipBindTexture.size);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipBindTexture_fn(offset, tex, devPtr, desc, size);
  }
}

static hipError_t hipBindTexture2D_callback(size_t* offset, const textureReference* tex, const void* devPtr, const hipChannelFormatDesc* desc, size_t width, size_t height, size_t pitch) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipBindTexture2D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipBindTexture2D.offset = offset;
    Args.hipBindTexture2D.tex = tex;
    Args.hipBindTexture2D.devPtr = devPtr;
    Args.hipBindTexture2D.desc = desc;
    Args.hipBindTexture2D.width = width;
    Args.hipBindTexture2D.height = height;
    Args.hipBindTexture2D.pitch = pitch;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipBindTexture2D_fn(Args.hipBindTexture2D.offset, Args.hipBindTexture2D.tex, Args.hipBindTexture2D.devPtr, Args.hipBindTexture2D.desc, Args.hipBindTexture2D.width, Args.hipBindTexture2D.height, Args.hipBindTexture2D.pitch);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipBindTexture2D_fn(offset, tex, devPtr, desc, width, height, pitch);
  }
}

static hipError_t hipBindTextureToArray_callback(const textureReference* tex, hipArray_const_t array, const hipChannelFormatDesc* desc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipBindTextureToArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipBindTextureToArray.tex = tex;
    Args.hipBindTextureToArray.array = array;
    Args.hipBindTextureToArray.desc = desc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipBindTextureToArray_fn(Args.hipBindTextureToArray.tex, Args.hipBindTextureToArray.array, Args.hipBindTextureToArray.desc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipBindTextureToArray_fn(tex, array, desc);
  }
}

static hipError_t hipBindTextureToMipmappedArray_callback(const textureReference* tex, hipMipmappedArray_const_t mipmappedArray, const hipChannelFormatDesc* desc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipBindTextureToMipmappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipBindTextureToMipmappedArray.tex = tex;
    Args.hipBindTextureToMipmappedArray.mipmappedArray = mipmappedArray;
    Args.hipBindTextureToMipmappedArray.desc = desc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipBindTextureToMipmappedArray_fn(Args.hipBindTextureToMipmappedArray.tex, Args.hipBindTextureToMipmappedArray.mipmappedArray, Args.hipBindTextureToMipmappedArray.desc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipBindTextureToMipmappedArray_fn(tex, mipmappedArray, desc);
  }
}

static hipError_t hipChooseDevice_callback(int* device, const hipDeviceProp_t* prop) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipChooseDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipChooseDevice.device = device;
    Args.hipChooseDevice.prop = prop;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipChooseDevice_fn(Args.hipChooseDevice.device, Args.hipChooseDevice.prop);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipChooseDevice_fn(device, prop);
  }
}

static hipError_t hipConfigureCall_callback(dim3 gridDim, dim3 blockDim, size_t sharedMem, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipConfigureCall;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipConfigureCall.gridDim = luthier::convertToRocprofilerDim3(gridDim);
    Args.hipConfigureCall.blockDim = luthier::convertToRocprofilerDim3(blockDim);
    Args.hipConfigureCall.sharedMem = sharedMem;
    Args.hipConfigureCall.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipConfigureCall_fn(gridDim, blockDim, Args.hipConfigureCall.sharedMem, Args.hipConfigureCall.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipConfigureCall_fn(gridDim, blockDim, sharedMem, stream);
  }
}

static hipError_t hipCreateSurfaceObject_callback(hipSurfaceObject_t* pSurfObject, const hipResourceDesc* pResDesc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCreateSurfaceObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCreateSurfaceObject.pSurfObject = pSurfObject;
    Args.hipCreateSurfaceObject.pResDesc = pResDesc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCreateSurfaceObject_fn(Args.hipCreateSurfaceObject.pSurfObject, Args.hipCreateSurfaceObject.pResDesc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCreateSurfaceObject_fn(pSurfObject, pResDesc);
  }
}

static hipError_t hipCreateTextureObject_callback(hipTextureObject_t* pTexObject, const hipResourceDesc* pResDesc, const hipTextureDesc* pTexDesc, const struct hipResourceViewDesc* pResViewDesc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCreateTextureObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCreateTextureObject.pTexObject = pTexObject;
    Args.hipCreateTextureObject.pResDesc = pResDesc;
    Args.hipCreateTextureObject.pTexDesc = pTexDesc;
    Args.hipCreateTextureObject.pResViewDesc = pResViewDesc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCreateTextureObject_fn(Args.hipCreateTextureObject.pTexObject, Args.hipCreateTextureObject.pResDesc, Args.hipCreateTextureObject.pTexDesc, Args.hipCreateTextureObject.pResViewDesc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCreateTextureObject_fn(pTexObject, pResDesc, pTexDesc, pResViewDesc);
  }
}

static hipError_t hipCtxCreate_callback(hipCtx_t* ctx, unsigned int flags, hipDevice_t device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxCreate.ctx = ctx;
    Args.hipCtxCreate.flags = flags;
    Args.hipCtxCreate.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxCreate_fn(Args.hipCtxCreate.ctx, Args.hipCtxCreate.flags, Args.hipCtxCreate.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxCreate_fn(ctx, flags, device);
  }
}

static hipError_t hipCtxDestroy_callback(hipCtx_t ctx) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxDestroy.ctx = ctx;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxDestroy_fn(Args.hipCtxDestroy.ctx);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxDestroy_fn(ctx);
  }
}

static hipError_t hipCtxDisablePeerAccess_callback(hipCtx_t peerCtx) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxDisablePeerAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxDisablePeerAccess.peerCtx = peerCtx;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxDisablePeerAccess_fn(Args.hipCtxDisablePeerAccess.peerCtx);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxDisablePeerAccess_fn(peerCtx);
  }
}

static hipError_t hipCtxEnablePeerAccess_callback(hipCtx_t peerCtx, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxEnablePeerAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxEnablePeerAccess.peerCtx = peerCtx;
    Args.hipCtxEnablePeerAccess.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxEnablePeerAccess_fn(Args.hipCtxEnablePeerAccess.peerCtx, Args.hipCtxEnablePeerAccess.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxEnablePeerAccess_fn(peerCtx, flags);
  }
}

static hipError_t hipCtxGetApiVersion_callback(hipCtx_t ctx, int* apiVersion) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetApiVersion;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxGetApiVersion.ctx = ctx;
    Args.hipCtxGetApiVersion.apiVersion = apiVersion;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxGetApiVersion_fn(Args.hipCtxGetApiVersion.ctx, Args.hipCtxGetApiVersion.apiVersion);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxGetApiVersion_fn(ctx, apiVersion);
  }
}

static hipError_t hipCtxGetCacheConfig_callback(hipFuncCache_t* cacheConfig) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetCacheConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxGetCacheConfig.cacheConfig = cacheConfig;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxGetCacheConfig_fn(Args.hipCtxGetCacheConfig.cacheConfig);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxGetCacheConfig_fn(cacheConfig);
  }
}

static hipError_t hipCtxGetCurrent_callback(hipCtx_t* ctx) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetCurrent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxGetCurrent.ctx = ctx;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxGetCurrent_fn(Args.hipCtxGetCurrent.ctx);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxGetCurrent_fn(ctx);
  }
}

static hipError_t hipCtxGetDevice_callback(hipDevice_t* device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxGetDevice.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxGetDevice_fn(Args.hipCtxGetDevice.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxGetDevice_fn(device);
  }
}

static hipError_t hipCtxGetFlags_callback(unsigned int* flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxGetFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxGetFlags_fn(Args.hipCtxGetFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxGetFlags_fn(flags);
  }
}

static hipError_t hipCtxGetSharedMemConfig_callback(hipSharedMemConfig* pConfig) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetSharedMemConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxGetSharedMemConfig.pConfig = pConfig;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxGetSharedMemConfig_fn(Args.hipCtxGetSharedMemConfig.pConfig);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxGetSharedMemConfig_fn(pConfig);
  }
}

static hipError_t hipCtxPopCurrent_callback(hipCtx_t* ctx) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxPopCurrent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxPopCurrent.ctx = ctx;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxPopCurrent_fn(Args.hipCtxPopCurrent.ctx);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxPopCurrent_fn(ctx);
  }
}

static hipError_t hipCtxPushCurrent_callback(hipCtx_t ctx) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxPushCurrent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxPushCurrent.ctx = ctx;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxPushCurrent_fn(Args.hipCtxPushCurrent.ctx);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxPushCurrent_fn(ctx);
  }
}

static hipError_t hipCtxSetCacheConfig_callback(hipFuncCache_t cacheConfig) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxSetCacheConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxSetCacheConfig.cacheConfig = cacheConfig;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxSetCacheConfig_fn(Args.hipCtxSetCacheConfig.cacheConfig);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxSetCacheConfig_fn(cacheConfig);
  }
}

static hipError_t hipCtxSetCurrent_callback(hipCtx_t ctx) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxSetCurrent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxSetCurrent.ctx = ctx;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxSetCurrent_fn(Args.hipCtxSetCurrent.ctx);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxSetCurrent_fn(ctx);
  }
}

static hipError_t hipCtxSetSharedMemConfig_callback(hipSharedMemConfig config) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxSetSharedMemConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxSetSharedMemConfig.config = config;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxSetSharedMemConfig_fn(Args.hipCtxSetSharedMemConfig.config);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxSetSharedMemConfig_fn(config);
  }
}

static hipError_t hipCtxSynchronize_callback() {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxSynchronize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxSynchronize_fn();
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxSynchronize_fn();
  }
}

static hipError_t hipDestroyExternalMemory_callback(hipExternalMemory_t extMem) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDestroyExternalMemory;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDestroyExternalMemory.extMem = extMem;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDestroyExternalMemory_fn(Args.hipDestroyExternalMemory.extMem);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDestroyExternalMemory_fn(extMem);
  }
}

static hipError_t hipDestroyExternalSemaphore_callback(hipExternalSemaphore_t extSem) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDestroyExternalSemaphore;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDestroyExternalSemaphore.extSem = extSem;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDestroyExternalSemaphore_fn(Args.hipDestroyExternalSemaphore.extSem);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDestroyExternalSemaphore_fn(extSem);
  }
}

static hipError_t hipDestroySurfaceObject_callback(hipSurfaceObject_t surfaceObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDestroySurfaceObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDestroySurfaceObject.surfaceObject = surfaceObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDestroySurfaceObject_fn(Args.hipDestroySurfaceObject.surfaceObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDestroySurfaceObject_fn(surfaceObject);
  }
}

static hipError_t hipDestroyTextureObject_callback(hipTextureObject_t textureObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDestroyTextureObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDestroyTextureObject.textureObject = textureObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDestroyTextureObject_fn(Args.hipDestroyTextureObject.textureObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDestroyTextureObject_fn(textureObject);
  }
}

static hipError_t hipDeviceCanAccessPeer_callback(int* canAccessPeer, int deviceId, int peerDeviceId) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceCanAccessPeer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceCanAccessPeer.canAccessPeer = canAccessPeer;
    Args.hipDeviceCanAccessPeer.deviceId = deviceId;
    Args.hipDeviceCanAccessPeer.peerDeviceId = peerDeviceId;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceCanAccessPeer_fn(Args.hipDeviceCanAccessPeer.canAccessPeer, Args.hipDeviceCanAccessPeer.deviceId, Args.hipDeviceCanAccessPeer.peerDeviceId);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceCanAccessPeer_fn(canAccessPeer, deviceId, peerDeviceId);
  }
}

static hipError_t hipDeviceComputeCapability_callback(int* major, int* minor, hipDevice_t device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceComputeCapability;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceComputeCapability.major = major;
    Args.hipDeviceComputeCapability.minor = minor;
    Args.hipDeviceComputeCapability.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceComputeCapability_fn(Args.hipDeviceComputeCapability.major, Args.hipDeviceComputeCapability.minor, Args.hipDeviceComputeCapability.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceComputeCapability_fn(major, minor, device);
  }
}

static hipError_t hipDeviceDisablePeerAccess_callback(int peerDeviceId) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceDisablePeerAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceDisablePeerAccess.peerDeviceId = peerDeviceId;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceDisablePeerAccess_fn(Args.hipDeviceDisablePeerAccess.peerDeviceId);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceDisablePeerAccess_fn(peerDeviceId);
  }
}

static hipError_t hipDeviceEnablePeerAccess_callback(int peerDeviceId, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceEnablePeerAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceEnablePeerAccess.peerDeviceId = peerDeviceId;
    Args.hipDeviceEnablePeerAccess.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceEnablePeerAccess_fn(Args.hipDeviceEnablePeerAccess.peerDeviceId, Args.hipDeviceEnablePeerAccess.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceEnablePeerAccess_fn(peerDeviceId, flags);
  }
}

static hipError_t hipDeviceGet_callback(hipDevice_t* device, int ordinal) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGet;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGet.device = device;
    Args.hipDeviceGet.ordinal = ordinal;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGet_fn(Args.hipDeviceGet.device, Args.hipDeviceGet.ordinal);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGet_fn(device, ordinal);
  }
}

static hipError_t hipDeviceGetAttribute_callback(int* pi, hipDeviceAttribute_t attr, int deviceId) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetAttribute.pi = pi;
    Args.hipDeviceGetAttribute.attr = attr;
    Args.hipDeviceGetAttribute.deviceId = deviceId;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetAttribute_fn(Args.hipDeviceGetAttribute.pi, Args.hipDeviceGetAttribute.attr, Args.hipDeviceGetAttribute.deviceId);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetAttribute_fn(pi, attr, deviceId);
  }
}

static hipError_t hipDeviceGetByPCIBusId_callback(int* device, const char* pciBusId) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetByPCIBusId;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetByPCIBusId.device = device;
    Args.hipDeviceGetByPCIBusId.pciBusId = pciBusId;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetByPCIBusId_fn(Args.hipDeviceGetByPCIBusId.device, Args.hipDeviceGetByPCIBusId.pciBusId);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetByPCIBusId_fn(device, pciBusId);
  }
}

static hipError_t hipDeviceGetCacheConfig_callback(hipFuncCache_t* cacheConfig) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetCacheConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetCacheConfig.cacheConfig = cacheConfig;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetCacheConfig_fn(Args.hipDeviceGetCacheConfig.cacheConfig);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetCacheConfig_fn(cacheConfig);
  }
}

static hipError_t hipDeviceGetDefaultMemPool_callback(hipMemPool_t* mem_pool, int device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetDefaultMemPool;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetDefaultMemPool.mem_pool = mem_pool;
    Args.hipDeviceGetDefaultMemPool.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetDefaultMemPool_fn(Args.hipDeviceGetDefaultMemPool.mem_pool, Args.hipDeviceGetDefaultMemPool.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetDefaultMemPool_fn(mem_pool, device);
  }
}

static hipError_t hipDeviceGetGraphMemAttribute_callback(int device, hipGraphMemAttributeType attr, void* value) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetGraphMemAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetGraphMemAttribute.device = device;
    Args.hipDeviceGetGraphMemAttribute.attr = attr;
    Args.hipDeviceGetGraphMemAttribute.value = value;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetGraphMemAttribute_fn(Args.hipDeviceGetGraphMemAttribute.device, Args.hipDeviceGetGraphMemAttribute.attr, Args.hipDeviceGetGraphMemAttribute.value);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetGraphMemAttribute_fn(device, attr, value);
  }
}

static hipError_t hipDeviceGetLimit_callback(size_t* pValue, enum hipLimit_t limit) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetLimit;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetLimit.pValue = pValue;
    Args.hipDeviceGetLimit.limit = limit;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetLimit_fn(Args.hipDeviceGetLimit.pValue, Args.hipDeviceGetLimit.limit);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetLimit_fn(pValue, limit);
  }
}

static hipError_t hipDeviceGetMemPool_callback(hipMemPool_t* mem_pool, int device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetMemPool;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetMemPool.mem_pool = mem_pool;
    Args.hipDeviceGetMemPool.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetMemPool_fn(Args.hipDeviceGetMemPool.mem_pool, Args.hipDeviceGetMemPool.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetMemPool_fn(mem_pool, device);
  }
}

static hipError_t hipDeviceGetName_callback(char* name, int len, hipDevice_t device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetName;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetName.name = name;
    Args.hipDeviceGetName.len = len;
    Args.hipDeviceGetName.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetName_fn(Args.hipDeviceGetName.name, Args.hipDeviceGetName.len, Args.hipDeviceGetName.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetName_fn(name, len, device);
  }
}

static hipError_t hipDeviceGetP2PAttribute_callback(int* value, hipDeviceP2PAttr attr, int srcDevice, int dstDevice) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetP2PAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetP2PAttribute.value = value;
    Args.hipDeviceGetP2PAttribute.attr = attr;
    Args.hipDeviceGetP2PAttribute.srcDevice = srcDevice;
    Args.hipDeviceGetP2PAttribute.dstDevice = dstDevice;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetP2PAttribute_fn(Args.hipDeviceGetP2PAttribute.value, Args.hipDeviceGetP2PAttribute.attr, Args.hipDeviceGetP2PAttribute.srcDevice, Args.hipDeviceGetP2PAttribute.dstDevice);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetP2PAttribute_fn(value, attr, srcDevice, dstDevice);
  }
}

static hipError_t hipDeviceGetPCIBusId_callback(char* pciBusId, int len, int device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetPCIBusId;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetPCIBusId.pciBusId = pciBusId;
    Args.hipDeviceGetPCIBusId.len = len;
    Args.hipDeviceGetPCIBusId.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetPCIBusId_fn(Args.hipDeviceGetPCIBusId.pciBusId, Args.hipDeviceGetPCIBusId.len, Args.hipDeviceGetPCIBusId.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetPCIBusId_fn(pciBusId, len, device);
  }
}

static hipError_t hipDeviceGetSharedMemConfig_callback(hipSharedMemConfig* pConfig) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetSharedMemConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetSharedMemConfig.pConfig = pConfig;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetSharedMemConfig_fn(Args.hipDeviceGetSharedMemConfig.pConfig);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetSharedMemConfig_fn(pConfig);
  }
}

static hipError_t hipDeviceGetStreamPriorityRange_callback(int* leastPriority, int* greatestPriority) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetStreamPriorityRange;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetStreamPriorityRange.leastPriority = leastPriority;
    Args.hipDeviceGetStreamPriorityRange.greatestPriority = greatestPriority;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetStreamPriorityRange_fn(Args.hipDeviceGetStreamPriorityRange.leastPriority, Args.hipDeviceGetStreamPriorityRange.greatestPriority);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetStreamPriorityRange_fn(leastPriority, greatestPriority);
  }
}

static hipError_t hipDeviceGetUuid_callback(hipUUID* uuid, hipDevice_t device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetUuid;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetUuid.uuid = uuid;
    Args.hipDeviceGetUuid.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetUuid_fn(Args.hipDeviceGetUuid.uuid, Args.hipDeviceGetUuid.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetUuid_fn(uuid, device);
  }
}

static hipError_t hipDeviceGraphMemTrim_callback(int device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGraphMemTrim;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGraphMemTrim.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGraphMemTrim_fn(Args.hipDeviceGraphMemTrim.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGraphMemTrim_fn(device);
  }
}

static hipError_t hipDevicePrimaryCtxGetState_callback(hipDevice_t dev, unsigned int* flags, int* active) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDevicePrimaryCtxGetState;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDevicePrimaryCtxGetState.dev = dev;
    Args.hipDevicePrimaryCtxGetState.flags = flags;
    Args.hipDevicePrimaryCtxGetState.active = active;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxGetState_fn(Args.hipDevicePrimaryCtxGetState.dev, Args.hipDevicePrimaryCtxGetState.flags, Args.hipDevicePrimaryCtxGetState.active);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxGetState_fn(dev, flags, active);
  }
}

static hipError_t hipDevicePrimaryCtxRelease_callback(hipDevice_t dev) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDevicePrimaryCtxRelease;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDevicePrimaryCtxRelease.dev = dev;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxRelease_fn(Args.hipDevicePrimaryCtxRelease.dev);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxRelease_fn(dev);
  }
}

static hipError_t hipDevicePrimaryCtxReset_callback(hipDevice_t dev) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDevicePrimaryCtxReset;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDevicePrimaryCtxReset.dev = dev;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxReset_fn(Args.hipDevicePrimaryCtxReset.dev);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxReset_fn(dev);
  }
}

static hipError_t hipDevicePrimaryCtxRetain_callback(hipCtx_t* pctx, hipDevice_t dev) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDevicePrimaryCtxRetain;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDevicePrimaryCtxRetain.pctx = pctx;
    Args.hipDevicePrimaryCtxRetain.dev = dev;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxRetain_fn(Args.hipDevicePrimaryCtxRetain.pctx, Args.hipDevicePrimaryCtxRetain.dev);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxRetain_fn(pctx, dev);
  }
}

static hipError_t hipDevicePrimaryCtxSetFlags_callback(hipDevice_t dev, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDevicePrimaryCtxSetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDevicePrimaryCtxSetFlags.dev = dev;
    Args.hipDevicePrimaryCtxSetFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxSetFlags_fn(Args.hipDevicePrimaryCtxSetFlags.dev, Args.hipDevicePrimaryCtxSetFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxSetFlags_fn(dev, flags);
  }
}

static hipError_t hipDeviceReset_callback() {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceReset;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceReset_fn();
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceReset_fn();
  }
}

static hipError_t hipDeviceSetCacheConfig_callback(hipFuncCache_t cacheConfig) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSetCacheConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceSetCacheConfig.cacheConfig = cacheConfig;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceSetCacheConfig_fn(Args.hipDeviceSetCacheConfig.cacheConfig);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceSetCacheConfig_fn(cacheConfig);
  }
}

static hipError_t hipDeviceSetGraphMemAttribute_callback(int device, hipGraphMemAttributeType attr, void* value) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSetGraphMemAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceSetGraphMemAttribute.device = device;
    Args.hipDeviceSetGraphMemAttribute.attr = attr;
    Args.hipDeviceSetGraphMemAttribute.value = value;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceSetGraphMemAttribute_fn(Args.hipDeviceSetGraphMemAttribute.device, Args.hipDeviceSetGraphMemAttribute.attr, Args.hipDeviceSetGraphMemAttribute.value);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceSetGraphMemAttribute_fn(device, attr, value);
  }
}

static hipError_t hipDeviceSetLimit_callback(enum hipLimit_t limit, size_t value) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSetLimit;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceSetLimit.limit = limit;
    Args.hipDeviceSetLimit.value = value;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceSetLimit_fn(Args.hipDeviceSetLimit.limit, Args.hipDeviceSetLimit.value);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceSetLimit_fn(limit, value);
  }
}

static hipError_t hipDeviceSetMemPool_callback(int device, hipMemPool_t mem_pool) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSetMemPool;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceSetMemPool.device = device;
    Args.hipDeviceSetMemPool.mem_pool = mem_pool;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceSetMemPool_fn(Args.hipDeviceSetMemPool.device, Args.hipDeviceSetMemPool.mem_pool);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceSetMemPool_fn(device, mem_pool);
  }
}

static hipError_t hipDeviceSetSharedMemConfig_callback(hipSharedMemConfig config) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSetSharedMemConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceSetSharedMemConfig.config = config;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceSetSharedMemConfig_fn(Args.hipDeviceSetSharedMemConfig.config);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceSetSharedMemConfig_fn(config);
  }
}

static hipError_t hipDeviceSynchronize_callback() {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSynchronize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceSynchronize_fn();
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceSynchronize_fn();
  }
}

static hipError_t hipDeviceTotalMem_callback(size_t* bytes, hipDevice_t device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceTotalMem;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceTotalMem.bytes = bytes;
    Args.hipDeviceTotalMem.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceTotalMem_fn(Args.hipDeviceTotalMem.bytes, Args.hipDeviceTotalMem.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceTotalMem_fn(bytes, device);
  }
}

static hipError_t hipDriverGetVersion_callback(int* driverVersion) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDriverGetVersion;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDriverGetVersion.driverVersion = driverVersion;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDriverGetVersion_fn(Args.hipDriverGetVersion.driverVersion);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDriverGetVersion_fn(driverVersion);
  }
}

static hipError_t hipDrvGetErrorName_callback(hipError_t hipError, const char** errorString) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvGetErrorName;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDrvGetErrorName.hipError = hipError;
    Args.hipDrvGetErrorName.errorString = errorString;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDrvGetErrorName_fn(Args.hipDrvGetErrorName.hipError, Args.hipDrvGetErrorName.errorString);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDrvGetErrorName_fn(hipError, errorString);
  }
}

static hipError_t hipDrvGetErrorString_callback(hipError_t hipError, const char** errorString) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvGetErrorString;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDrvGetErrorString.hipError = hipError;
    Args.hipDrvGetErrorString.errorString = errorString;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDrvGetErrorString_fn(Args.hipDrvGetErrorString.hipError, Args.hipDrvGetErrorString.errorString);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDrvGetErrorString_fn(hipError, errorString);
  }
}

static hipError_t hipDrvGraphAddMemcpyNode_callback(hipGraphNode_t* phGraphNode, hipGraph_t hGraph, const hipGraphNode_t* dependencies, size_t numDependencies, const HIP_MEMCPY3D* copyParams, hipCtx_t ctx) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvGraphAddMemcpyNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDrvGraphAddMemcpyNode.phGraphNode = phGraphNode;
    Args.hipDrvGraphAddMemcpyNode.hGraph = hGraph;
    Args.hipDrvGraphAddMemcpyNode.dependencies = dependencies;
    Args.hipDrvGraphAddMemcpyNode.numDependencies = numDependencies;
    Args.hipDrvGraphAddMemcpyNode.copyParams = copyParams;
    Args.hipDrvGraphAddMemcpyNode.ctx = ctx;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDrvGraphAddMemcpyNode_fn(Args.hipDrvGraphAddMemcpyNode.phGraphNode, Args.hipDrvGraphAddMemcpyNode.hGraph, Args.hipDrvGraphAddMemcpyNode.dependencies, Args.hipDrvGraphAddMemcpyNode.numDependencies, Args.hipDrvGraphAddMemcpyNode.copyParams, Args.hipDrvGraphAddMemcpyNode.ctx);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDrvGraphAddMemcpyNode_fn(phGraphNode, hGraph, dependencies, numDependencies, copyParams, ctx);
  }
}

static hipError_t hipDrvMemcpy2DUnaligned_callback(const hip_Memcpy2D* pCopy) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvMemcpy2DUnaligned;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDrvMemcpy2DUnaligned.pCopy = pCopy;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDrvMemcpy2DUnaligned_fn(Args.hipDrvMemcpy2DUnaligned.pCopy);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDrvMemcpy2DUnaligned_fn(pCopy);
  }
}

static hipError_t hipDrvMemcpy3D_callback(const HIP_MEMCPY3D* pCopy) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvMemcpy3D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDrvMemcpy3D.pCopy = pCopy;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDrvMemcpy3D_fn(Args.hipDrvMemcpy3D.pCopy);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDrvMemcpy3D_fn(pCopy);
  }
}

static hipError_t hipDrvMemcpy3DAsync_callback(const HIP_MEMCPY3D* pCopy, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvMemcpy3DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDrvMemcpy3DAsync.pCopy = pCopy;
    Args.hipDrvMemcpy3DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDrvMemcpy3DAsync_fn(Args.hipDrvMemcpy3DAsync.pCopy, Args.hipDrvMemcpy3DAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDrvMemcpy3DAsync_fn(pCopy, stream);
  }
}

static hipError_t hipDrvPointerGetAttributes_callback(unsigned int numAttributes, hipPointer_attribute* attributes, void** data, hipDeviceptr_t ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvPointerGetAttributes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDrvPointerGetAttributes.numAttributes = numAttributes;
    Args.hipDrvPointerGetAttributes.attributes = attributes;
    Args.hipDrvPointerGetAttributes.data = data;
    Args.hipDrvPointerGetAttributes.ptr = ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDrvPointerGetAttributes_fn(Args.hipDrvPointerGetAttributes.numAttributes, Args.hipDrvPointerGetAttributes.attributes, Args.hipDrvPointerGetAttributes.data, Args.hipDrvPointerGetAttributes.ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDrvPointerGetAttributes_fn(numAttributes, attributes, data, ptr);
  }
}

static hipError_t hipEventCreate_callback(hipEvent_t* event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipEventCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipEventCreate.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipEventCreate_fn(Args.hipEventCreate.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipEventCreate_fn(event);
  }
}

static hipError_t hipEventCreateWithFlags_callback(hipEvent_t* event, unsigned flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipEventCreateWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipEventCreateWithFlags.event = event;
    Args.hipEventCreateWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipEventCreateWithFlags_fn(Args.hipEventCreateWithFlags.event, Args.hipEventCreateWithFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipEventCreateWithFlags_fn(event, flags);
  }
}

static hipError_t hipEventDestroy_callback(hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipEventDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipEventDestroy.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipEventDestroy_fn(Args.hipEventDestroy.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipEventDestroy_fn(event);
  }
}

static hipError_t hipEventElapsedTime_callback(float* ms, hipEvent_t start, hipEvent_t stop) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipEventElapsedTime;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipEventElapsedTime.ms = ms;
    Args.hipEventElapsedTime.start = start;
    Args.hipEventElapsedTime.stop = stop;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipEventElapsedTime_fn(Args.hipEventElapsedTime.ms, Args.hipEventElapsedTime.start, Args.hipEventElapsedTime.stop);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipEventElapsedTime_fn(ms, start, stop);
  }
}

static hipError_t hipEventQuery_callback(hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipEventQuery;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipEventQuery.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipEventQuery_fn(Args.hipEventQuery.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipEventQuery_fn(event);
  }
}

static hipError_t hipEventRecord_callback(hipEvent_t event, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipEventRecord;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipEventRecord.event = event;
    Args.hipEventRecord.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipEventRecord_fn(Args.hipEventRecord.event, Args.hipEventRecord.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipEventRecord_fn(event, stream);
  }
}

static hipError_t hipEventSynchronize_callback(hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipEventSynchronize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipEventSynchronize.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipEventSynchronize_fn(Args.hipEventSynchronize.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipEventSynchronize_fn(event);
  }
}

static hipError_t hipExtGetLinkTypeAndHopCount_callback(int device1, int device2, uint32_t* linktype, uint32_t* hopcount) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipExtGetLinkTypeAndHopCount;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipExtGetLinkTypeAndHopCount.device1 = device1;
    Args.hipExtGetLinkTypeAndHopCount.device2 = device2;
    Args.hipExtGetLinkTypeAndHopCount.linktype = linktype;
    Args.hipExtGetLinkTypeAndHopCount.hopcount = hopcount;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipExtGetLinkTypeAndHopCount_fn(Args.hipExtGetLinkTypeAndHopCount.device1, Args.hipExtGetLinkTypeAndHopCount.device2, Args.hipExtGetLinkTypeAndHopCount.linktype, Args.hipExtGetLinkTypeAndHopCount.hopcount);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipExtGetLinkTypeAndHopCount_fn(device1, device2, linktype, hopcount);
  }
}

static hipError_t hipExtLaunchKernel_callback(const void* function_address, dim3 numBlocks, dim3 dimBlocks, void** args, size_t sharedMemBytes, hipStream_t stream, hipEvent_t startEvent, hipEvent_t stopEvent, int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipExtLaunchKernel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipExtLaunchKernel.function_address = function_address;
    Args.hipExtLaunchKernel.numBlocks = luthier::convertToRocprofilerDim3(numBlocks);
    Args.hipExtLaunchKernel.dimBlocks = luthier::convertToRocprofilerDim3(dimBlocks);
    Args.hipExtLaunchKernel.args = args;
    Args.hipExtLaunchKernel.sharedMemBytes = sharedMemBytes;
    Args.hipExtLaunchKernel.stream = stream;
    Args.hipExtLaunchKernel.startEvent = startEvent;
    Args.hipExtLaunchKernel.stopEvent = stopEvent;
    Args.hipExtLaunchKernel.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipExtLaunchKernel_fn(Args.hipExtLaunchKernel.function_address, numBlocks, dimBlocks, Args.hipExtLaunchKernel.args, Args.hipExtLaunchKernel.sharedMemBytes, Args.hipExtLaunchKernel.stream, Args.hipExtLaunchKernel.startEvent, Args.hipExtLaunchKernel.stopEvent, Args.hipExtLaunchKernel.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipExtLaunchKernel_fn(function_address, numBlocks, dimBlocks, args, sharedMemBytes, stream, startEvent, stopEvent, flags);
  }
}

static hipError_t hipExtLaunchMultiKernelMultiDevice_callback(hipLaunchParams* launchParamsList, int numDevices, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipExtLaunchMultiKernelMultiDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipExtLaunchMultiKernelMultiDevice.launchParamsList = launchParamsList;
    Args.hipExtLaunchMultiKernelMultiDevice.numDevices = numDevices;
    Args.hipExtLaunchMultiKernelMultiDevice.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipExtLaunchMultiKernelMultiDevice_fn(Args.hipExtLaunchMultiKernelMultiDevice.launchParamsList, Args.hipExtLaunchMultiKernelMultiDevice.numDevices, Args.hipExtLaunchMultiKernelMultiDevice.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipExtLaunchMultiKernelMultiDevice_fn(launchParamsList, numDevices, flags);
  }
}

static hipError_t hipExtMallocWithFlags_callback(void** ptr, size_t sizeBytes, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipExtMallocWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipExtMallocWithFlags.ptr = ptr;
    Args.hipExtMallocWithFlags.sizeBytes = sizeBytes;
    Args.hipExtMallocWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipExtMallocWithFlags_fn(Args.hipExtMallocWithFlags.ptr, Args.hipExtMallocWithFlags.sizeBytes, Args.hipExtMallocWithFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipExtMallocWithFlags_fn(ptr, sizeBytes, flags);
  }
}

static hipError_t hipExtStreamCreateWithCUMask_callback(hipStream_t* stream, uint32_t cuMaskSize, const uint32_t* cuMask) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipExtStreamCreateWithCUMask;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipExtStreamCreateWithCUMask.stream = stream;
    Args.hipExtStreamCreateWithCUMask.cuMaskSize = cuMaskSize;
    Args.hipExtStreamCreateWithCUMask.cuMask = cuMask;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipExtStreamCreateWithCUMask_fn(Args.hipExtStreamCreateWithCUMask.stream, Args.hipExtStreamCreateWithCUMask.cuMaskSize, Args.hipExtStreamCreateWithCUMask.cuMask);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipExtStreamCreateWithCUMask_fn(stream, cuMaskSize, cuMask);
  }
}

static hipError_t hipExtStreamGetCUMask_callback(hipStream_t stream, uint32_t cuMaskSize, uint32_t* cuMask) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipExtStreamGetCUMask;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipExtStreamGetCUMask.stream = stream;
    Args.hipExtStreamGetCUMask.cuMaskSize = cuMaskSize;
    Args.hipExtStreamGetCUMask.cuMask = cuMask;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipExtStreamGetCUMask_fn(Args.hipExtStreamGetCUMask.stream, Args.hipExtStreamGetCUMask.cuMaskSize, Args.hipExtStreamGetCUMask.cuMask);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipExtStreamGetCUMask_fn(stream, cuMaskSize, cuMask);
  }
}

static hipError_t hipExternalMemoryGetMappedBuffer_callback(void** devPtr, hipExternalMemory_t extMem, const hipExternalMemoryBufferDesc* bufferDesc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipExternalMemoryGetMappedBuffer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipExternalMemoryGetMappedBuffer.devPtr = devPtr;
    Args.hipExternalMemoryGetMappedBuffer.extMem = extMem;
    Args.hipExternalMemoryGetMappedBuffer.bufferDesc = bufferDesc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipExternalMemoryGetMappedBuffer_fn(Args.hipExternalMemoryGetMappedBuffer.devPtr, Args.hipExternalMemoryGetMappedBuffer.extMem, Args.hipExternalMemoryGetMappedBuffer.bufferDesc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipExternalMemoryGetMappedBuffer_fn(devPtr, extMem, bufferDesc);
  }
}

static hipError_t hipFree_callback(void* ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFree;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFree.ptr = ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFree_fn(Args.hipFree.ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFree_fn(ptr);
  }
}

static hipError_t hipFreeArray_callback(hipArray_t array) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFreeArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFreeArray.array = array;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFreeArray_fn(Args.hipFreeArray.array);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFreeArray_fn(array);
  }
}

static hipError_t hipFreeAsync_callback(void* dev_ptr, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFreeAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFreeAsync.dev_ptr = dev_ptr;
    Args.hipFreeAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFreeAsync_fn(Args.hipFreeAsync.dev_ptr, Args.hipFreeAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFreeAsync_fn(dev_ptr, stream);
  }
}

static hipError_t hipFreeHost_callback(void* ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFreeHost;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFreeHost.ptr = ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFreeHost_fn(Args.hipFreeHost.ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFreeHost_fn(ptr);
  }
}

static hipError_t hipFreeMipmappedArray_callback(hipMipmappedArray_t mipmappedArray) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFreeMipmappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFreeMipmappedArray.mipmappedArray = mipmappedArray;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFreeMipmappedArray_fn(Args.hipFreeMipmappedArray.mipmappedArray);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFreeMipmappedArray_fn(mipmappedArray);
  }
}

static hipError_t hipFuncGetAttribute_callback(int* value, hipFunction_attribute attrib, hipFunction_t hfunc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFuncGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFuncGetAttribute.value = value;
    Args.hipFuncGetAttribute.attrib = attrib;
    Args.hipFuncGetAttribute.hfunc = hfunc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFuncGetAttribute_fn(Args.hipFuncGetAttribute.value, Args.hipFuncGetAttribute.attrib, Args.hipFuncGetAttribute.hfunc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFuncGetAttribute_fn(value, attrib, hfunc);
  }
}

static hipError_t hipFuncGetAttributes_callback(struct hipFuncAttributes* attr, const void* func) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFuncGetAttributes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFuncGetAttributes.attr = attr;
    Args.hipFuncGetAttributes.func = func;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFuncGetAttributes_fn(Args.hipFuncGetAttributes.attr, Args.hipFuncGetAttributes.func);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFuncGetAttributes_fn(attr, func);
  }
}

static hipError_t hipFuncSetAttribute_callback(const void* func, hipFuncAttribute attr, int value) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFuncSetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFuncSetAttribute.func = func;
    Args.hipFuncSetAttribute.attr = attr;
    Args.hipFuncSetAttribute.value = value;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFuncSetAttribute_fn(Args.hipFuncSetAttribute.func, Args.hipFuncSetAttribute.attr, Args.hipFuncSetAttribute.value);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFuncSetAttribute_fn(func, attr, value);
  }
}

static hipError_t hipFuncSetCacheConfig_callback(const void* func, hipFuncCache_t config) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFuncSetCacheConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFuncSetCacheConfig.func = func;
    Args.hipFuncSetCacheConfig.config = config;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFuncSetCacheConfig_fn(Args.hipFuncSetCacheConfig.func, Args.hipFuncSetCacheConfig.config);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFuncSetCacheConfig_fn(func, config);
  }
}

static hipError_t hipFuncSetSharedMemConfig_callback(const void* func, hipSharedMemConfig config) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFuncSetSharedMemConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFuncSetSharedMemConfig.func = func;
    Args.hipFuncSetSharedMemConfig.config = config;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFuncSetSharedMemConfig_fn(Args.hipFuncSetSharedMemConfig.func, Args.hipFuncSetSharedMemConfig.config);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFuncSetSharedMemConfig_fn(func, config);
  }
}

static hipError_t hipGLGetDevices_callback(unsigned int* pHipDeviceCount, int* pHipDevices, unsigned int hipDeviceCount, hipGLDeviceList deviceList) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGLGetDevices;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGLGetDevices.pHipDeviceCount = pHipDeviceCount;
    Args.hipGLGetDevices.pHipDevices = pHipDevices;
    Args.hipGLGetDevices.hipDeviceCount = hipDeviceCount;
    Args.hipGLGetDevices.deviceList = deviceList;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGLGetDevices_fn(Args.hipGLGetDevices.pHipDeviceCount, Args.hipGLGetDevices.pHipDevices, Args.hipGLGetDevices.hipDeviceCount, Args.hipGLGetDevices.deviceList);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGLGetDevices_fn(pHipDeviceCount, pHipDevices, hipDeviceCount, deviceList);
  }
}

static hipError_t hipGetChannelDesc_callback(hipChannelFormatDesc* desc, hipArray_const_t array) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetChannelDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetChannelDesc.desc = desc;
    Args.hipGetChannelDesc.array = array;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetChannelDesc_fn(Args.hipGetChannelDesc.desc, Args.hipGetChannelDesc.array);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetChannelDesc_fn(desc, array);
  }
}

static hipError_t hipGetDevice_callback(int* deviceId) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetDevice.deviceId = deviceId;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetDevice_fn(Args.hipGetDevice.deviceId);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetDevice_fn(deviceId);
  }
}

static hipError_t hipGetDeviceCount_callback(int* count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetDeviceCount;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetDeviceCount.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetDeviceCount_fn(Args.hipGetDeviceCount.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetDeviceCount_fn(count);
  }
}

static hipError_t hipGetDeviceFlags_callback(unsigned int* flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetDeviceFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetDeviceFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetDeviceFlags_fn(Args.hipGetDeviceFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetDeviceFlags_fn(flags);
  }
}

static const char* hipGetErrorName_callback(hipError_t hip_error) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetErrorName;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    const char* Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetErrorName.hip_error = hip_error;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetErrorName_fn(Args.hipGetErrorName.hip_error);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetErrorName_fn(hip_error);
  }
}

static const char* hipGetErrorString_callback(hipError_t hipError) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetErrorString;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    const char* Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetErrorString.hipError = hipError;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetErrorString_fn(Args.hipGetErrorString.hipError);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetErrorString_fn(hipError);
  }
}

static hipError_t hipGetLastError_callback() {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetLastError;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetLastError_fn();
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetLastError_fn();
  }
}

static hipError_t hipGetMipmappedArrayLevel_callback(hipArray_t* levelArray, hipMipmappedArray_const_t mipmappedArray, unsigned int level) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetMipmappedArrayLevel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetMipmappedArrayLevel.levelArray = levelArray;
    Args.hipGetMipmappedArrayLevel.mipmappedArray = mipmappedArray;
    Args.hipGetMipmappedArrayLevel.level = level;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetMipmappedArrayLevel_fn(Args.hipGetMipmappedArrayLevel.levelArray, Args.hipGetMipmappedArrayLevel.mipmappedArray, Args.hipGetMipmappedArrayLevel.level);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetMipmappedArrayLevel_fn(levelArray, mipmappedArray, level);
  }
}

static hipError_t hipGetSymbolAddress_callback(void** devPtr, const void* symbol) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetSymbolAddress;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetSymbolAddress.devPtr = devPtr;
    Args.hipGetSymbolAddress.symbol = symbol;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetSymbolAddress_fn(Args.hipGetSymbolAddress.devPtr, Args.hipGetSymbolAddress.symbol);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetSymbolAddress_fn(devPtr, symbol);
  }
}

static hipError_t hipGetSymbolSize_callback(size_t* size, const void* symbol) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetSymbolSize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetSymbolSize.size = size;
    Args.hipGetSymbolSize.symbol = symbol;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetSymbolSize_fn(Args.hipGetSymbolSize.size, Args.hipGetSymbolSize.symbol);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetSymbolSize_fn(size, symbol);
  }
}

static hipError_t hipGetTextureAlignmentOffset_callback(size_t* offset, const textureReference* texref) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetTextureAlignmentOffset;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetTextureAlignmentOffset.offset = offset;
    Args.hipGetTextureAlignmentOffset.texref = texref;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetTextureAlignmentOffset_fn(Args.hipGetTextureAlignmentOffset.offset, Args.hipGetTextureAlignmentOffset.texref);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetTextureAlignmentOffset_fn(offset, texref);
  }
}

static hipError_t hipGetTextureObjectResourceDesc_callback(hipResourceDesc* pResDesc, hipTextureObject_t textureObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetTextureObjectResourceDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetTextureObjectResourceDesc.pResDesc = pResDesc;
    Args.hipGetTextureObjectResourceDesc.textureObject = textureObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetTextureObjectResourceDesc_fn(Args.hipGetTextureObjectResourceDesc.pResDesc, Args.hipGetTextureObjectResourceDesc.textureObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetTextureObjectResourceDesc_fn(pResDesc, textureObject);
  }
}

static hipError_t hipGetTextureObjectResourceViewDesc_callback(struct hipResourceViewDesc* pResViewDesc, hipTextureObject_t textureObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetTextureObjectResourceViewDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetTextureObjectResourceViewDesc.pResViewDesc = pResViewDesc;
    Args.hipGetTextureObjectResourceViewDesc.textureObject = textureObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetTextureObjectResourceViewDesc_fn(Args.hipGetTextureObjectResourceViewDesc.pResViewDesc, Args.hipGetTextureObjectResourceViewDesc.textureObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetTextureObjectResourceViewDesc_fn(pResViewDesc, textureObject);
  }
}

static hipError_t hipGetTextureObjectTextureDesc_callback(hipTextureDesc* pTexDesc, hipTextureObject_t textureObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetTextureObjectTextureDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetTextureObjectTextureDesc.pTexDesc = pTexDesc;
    Args.hipGetTextureObjectTextureDesc.textureObject = textureObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetTextureObjectTextureDesc_fn(Args.hipGetTextureObjectTextureDesc.pTexDesc, Args.hipGetTextureObjectTextureDesc.textureObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetTextureObjectTextureDesc_fn(pTexDesc, textureObject);
  }
}

static hipError_t hipGetTextureReference_callback(const textureReference** texref, const void* symbol) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetTextureReference;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetTextureReference.texref = texref;
    Args.hipGetTextureReference.symbol = symbol;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetTextureReference_fn(Args.hipGetTextureReference.texref, Args.hipGetTextureReference.symbol);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetTextureReference_fn(texref, symbol);
  }
}

static hipError_t hipGraphAddChildGraphNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, hipGraph_t childGraph) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddChildGraphNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddChildGraphNode.pGraphNode = pGraphNode;
    Args.hipGraphAddChildGraphNode.graph = graph;
    Args.hipGraphAddChildGraphNode.pDependencies = pDependencies;
    Args.hipGraphAddChildGraphNode.numDependencies = numDependencies;
    Args.hipGraphAddChildGraphNode.childGraph = childGraph;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddChildGraphNode_fn(Args.hipGraphAddChildGraphNode.pGraphNode, Args.hipGraphAddChildGraphNode.graph, Args.hipGraphAddChildGraphNode.pDependencies, Args.hipGraphAddChildGraphNode.numDependencies, Args.hipGraphAddChildGraphNode.childGraph);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddChildGraphNode_fn(pGraphNode, graph, pDependencies, numDependencies, childGraph);
  }
}

static hipError_t hipGraphAddDependencies_callback(hipGraph_t graph, const hipGraphNode_t* from, const hipGraphNode_t* to, size_t numDependencies) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddDependencies;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddDependencies.graph = graph;
    Args.hipGraphAddDependencies.from = from;
    Args.hipGraphAddDependencies.to = to;
    Args.hipGraphAddDependencies.numDependencies = numDependencies;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddDependencies_fn(Args.hipGraphAddDependencies.graph, Args.hipGraphAddDependencies.from, Args.hipGraphAddDependencies.to, Args.hipGraphAddDependencies.numDependencies);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddDependencies_fn(graph, from, to, numDependencies);
  }
}

static hipError_t hipGraphAddEmptyNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddEmptyNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddEmptyNode.pGraphNode = pGraphNode;
    Args.hipGraphAddEmptyNode.graph = graph;
    Args.hipGraphAddEmptyNode.pDependencies = pDependencies;
    Args.hipGraphAddEmptyNode.numDependencies = numDependencies;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddEmptyNode_fn(Args.hipGraphAddEmptyNode.pGraphNode, Args.hipGraphAddEmptyNode.graph, Args.hipGraphAddEmptyNode.pDependencies, Args.hipGraphAddEmptyNode.numDependencies);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddEmptyNode_fn(pGraphNode, graph, pDependencies, numDependencies);
  }
}

static hipError_t hipGraphAddEventRecordNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddEventRecordNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddEventRecordNode.pGraphNode = pGraphNode;
    Args.hipGraphAddEventRecordNode.graph = graph;
    Args.hipGraphAddEventRecordNode.pDependencies = pDependencies;
    Args.hipGraphAddEventRecordNode.numDependencies = numDependencies;
    Args.hipGraphAddEventRecordNode.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddEventRecordNode_fn(Args.hipGraphAddEventRecordNode.pGraphNode, Args.hipGraphAddEventRecordNode.graph, Args.hipGraphAddEventRecordNode.pDependencies, Args.hipGraphAddEventRecordNode.numDependencies, Args.hipGraphAddEventRecordNode.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddEventRecordNode_fn(pGraphNode, graph, pDependencies, numDependencies, event);
  }
}

static hipError_t hipGraphAddEventWaitNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddEventWaitNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddEventWaitNode.pGraphNode = pGraphNode;
    Args.hipGraphAddEventWaitNode.graph = graph;
    Args.hipGraphAddEventWaitNode.pDependencies = pDependencies;
    Args.hipGraphAddEventWaitNode.numDependencies = numDependencies;
    Args.hipGraphAddEventWaitNode.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddEventWaitNode_fn(Args.hipGraphAddEventWaitNode.pGraphNode, Args.hipGraphAddEventWaitNode.graph, Args.hipGraphAddEventWaitNode.pDependencies, Args.hipGraphAddEventWaitNode.numDependencies, Args.hipGraphAddEventWaitNode.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddEventWaitNode_fn(pGraphNode, graph, pDependencies, numDependencies, event);
  }
}

static hipError_t hipGraphAddHostNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const hipHostNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddHostNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddHostNode.pGraphNode = pGraphNode;
    Args.hipGraphAddHostNode.graph = graph;
    Args.hipGraphAddHostNode.pDependencies = pDependencies;
    Args.hipGraphAddHostNode.numDependencies = numDependencies;
    Args.hipGraphAddHostNode.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddHostNode_fn(Args.hipGraphAddHostNode.pGraphNode, Args.hipGraphAddHostNode.graph, Args.hipGraphAddHostNode.pDependencies, Args.hipGraphAddHostNode.numDependencies, Args.hipGraphAddHostNode.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddHostNode_fn(pGraphNode, graph, pDependencies, numDependencies, pNodeParams);
  }
}

static hipError_t hipGraphAddKernelNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const hipKernelNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddKernelNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddKernelNode.pGraphNode = pGraphNode;
    Args.hipGraphAddKernelNode.graph = graph;
    Args.hipGraphAddKernelNode.pDependencies = pDependencies;
    Args.hipGraphAddKernelNode.numDependencies = numDependencies;
    Args.hipGraphAddKernelNode.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddKernelNode_fn(Args.hipGraphAddKernelNode.pGraphNode, Args.hipGraphAddKernelNode.graph, Args.hipGraphAddKernelNode.pDependencies, Args.hipGraphAddKernelNode.numDependencies, Args.hipGraphAddKernelNode.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddKernelNode_fn(pGraphNode, graph, pDependencies, numDependencies, pNodeParams);
  }
}

static hipError_t hipGraphAddMemAllocNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, hipMemAllocNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemAllocNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddMemAllocNode.pGraphNode = pGraphNode;
    Args.hipGraphAddMemAllocNode.graph = graph;
    Args.hipGraphAddMemAllocNode.pDependencies = pDependencies;
    Args.hipGraphAddMemAllocNode.numDependencies = numDependencies;
    Args.hipGraphAddMemAllocNode.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddMemAllocNode_fn(Args.hipGraphAddMemAllocNode.pGraphNode, Args.hipGraphAddMemAllocNode.graph, Args.hipGraphAddMemAllocNode.pDependencies, Args.hipGraphAddMemAllocNode.numDependencies, Args.hipGraphAddMemAllocNode.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddMemAllocNode_fn(pGraphNode, graph, pDependencies, numDependencies, pNodeParams);
  }
}

static hipError_t hipGraphAddMemFreeNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, void* dev_ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemFreeNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddMemFreeNode.pGraphNode = pGraphNode;
    Args.hipGraphAddMemFreeNode.graph = graph;
    Args.hipGraphAddMemFreeNode.pDependencies = pDependencies;
    Args.hipGraphAddMemFreeNode.numDependencies = numDependencies;
    Args.hipGraphAddMemFreeNode.dev_ptr = dev_ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddMemFreeNode_fn(Args.hipGraphAddMemFreeNode.pGraphNode, Args.hipGraphAddMemFreeNode.graph, Args.hipGraphAddMemFreeNode.pDependencies, Args.hipGraphAddMemFreeNode.numDependencies, Args.hipGraphAddMemFreeNode.dev_ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddMemFreeNode_fn(pGraphNode, graph, pDependencies, numDependencies, dev_ptr);
  }
}

static hipError_t hipGraphAddMemcpyNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const hipMemcpy3DParms* pCopyParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemcpyNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddMemcpyNode.pGraphNode = pGraphNode;
    Args.hipGraphAddMemcpyNode.graph = graph;
    Args.hipGraphAddMemcpyNode.pDependencies = pDependencies;
    Args.hipGraphAddMemcpyNode.numDependencies = numDependencies;
    Args.hipGraphAddMemcpyNode.pCopyParams = pCopyParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddMemcpyNode_fn(Args.hipGraphAddMemcpyNode.pGraphNode, Args.hipGraphAddMemcpyNode.graph, Args.hipGraphAddMemcpyNode.pDependencies, Args.hipGraphAddMemcpyNode.numDependencies, Args.hipGraphAddMemcpyNode.pCopyParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddMemcpyNode_fn(pGraphNode, graph, pDependencies, numDependencies, pCopyParams);
  }
}

static hipError_t hipGraphAddMemcpyNode1D_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, void* dst, const void* src, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemcpyNode1D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddMemcpyNode1D.pGraphNode = pGraphNode;
    Args.hipGraphAddMemcpyNode1D.graph = graph;
    Args.hipGraphAddMemcpyNode1D.pDependencies = pDependencies;
    Args.hipGraphAddMemcpyNode1D.numDependencies = numDependencies;
    Args.hipGraphAddMemcpyNode1D.dst = dst;
    Args.hipGraphAddMemcpyNode1D.src = src;
    Args.hipGraphAddMemcpyNode1D.count = count;
    Args.hipGraphAddMemcpyNode1D.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddMemcpyNode1D_fn(Args.hipGraphAddMemcpyNode1D.pGraphNode, Args.hipGraphAddMemcpyNode1D.graph, Args.hipGraphAddMemcpyNode1D.pDependencies, Args.hipGraphAddMemcpyNode1D.numDependencies, Args.hipGraphAddMemcpyNode1D.dst, Args.hipGraphAddMemcpyNode1D.src, Args.hipGraphAddMemcpyNode1D.count, Args.hipGraphAddMemcpyNode1D.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddMemcpyNode1D_fn(pGraphNode, graph, pDependencies, numDependencies, dst, src, count, kind);
  }
}

static hipError_t hipGraphAddMemcpyNodeFromSymbol_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, void* dst, const void* symbol, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemcpyNodeFromSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddMemcpyNodeFromSymbol.pGraphNode = pGraphNode;
    Args.hipGraphAddMemcpyNodeFromSymbol.graph = graph;
    Args.hipGraphAddMemcpyNodeFromSymbol.pDependencies = pDependencies;
    Args.hipGraphAddMemcpyNodeFromSymbol.numDependencies = numDependencies;
    Args.hipGraphAddMemcpyNodeFromSymbol.dst = dst;
    Args.hipGraphAddMemcpyNodeFromSymbol.symbol = symbol;
    Args.hipGraphAddMemcpyNodeFromSymbol.count = count;
    Args.hipGraphAddMemcpyNodeFromSymbol.offset = offset;
    Args.hipGraphAddMemcpyNodeFromSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddMemcpyNodeFromSymbol_fn(Args.hipGraphAddMemcpyNodeFromSymbol.pGraphNode, Args.hipGraphAddMemcpyNodeFromSymbol.graph, Args.hipGraphAddMemcpyNodeFromSymbol.pDependencies, Args.hipGraphAddMemcpyNodeFromSymbol.numDependencies, Args.hipGraphAddMemcpyNodeFromSymbol.dst, Args.hipGraphAddMemcpyNodeFromSymbol.symbol, Args.hipGraphAddMemcpyNodeFromSymbol.count, Args.hipGraphAddMemcpyNodeFromSymbol.offset, Args.hipGraphAddMemcpyNodeFromSymbol.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddMemcpyNodeFromSymbol_fn(pGraphNode, graph, pDependencies, numDependencies, dst, symbol, count, offset, kind);
  }
}

static hipError_t hipGraphAddMemcpyNodeToSymbol_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const void* symbol, const void* src, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemcpyNodeToSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddMemcpyNodeToSymbol.pGraphNode = pGraphNode;
    Args.hipGraphAddMemcpyNodeToSymbol.graph = graph;
    Args.hipGraphAddMemcpyNodeToSymbol.pDependencies = pDependencies;
    Args.hipGraphAddMemcpyNodeToSymbol.numDependencies = numDependencies;
    Args.hipGraphAddMemcpyNodeToSymbol.symbol = symbol;
    Args.hipGraphAddMemcpyNodeToSymbol.src = src;
    Args.hipGraphAddMemcpyNodeToSymbol.count = count;
    Args.hipGraphAddMemcpyNodeToSymbol.offset = offset;
    Args.hipGraphAddMemcpyNodeToSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddMemcpyNodeToSymbol_fn(Args.hipGraphAddMemcpyNodeToSymbol.pGraphNode, Args.hipGraphAddMemcpyNodeToSymbol.graph, Args.hipGraphAddMemcpyNodeToSymbol.pDependencies, Args.hipGraphAddMemcpyNodeToSymbol.numDependencies, Args.hipGraphAddMemcpyNodeToSymbol.symbol, Args.hipGraphAddMemcpyNodeToSymbol.src, Args.hipGraphAddMemcpyNodeToSymbol.count, Args.hipGraphAddMemcpyNodeToSymbol.offset, Args.hipGraphAddMemcpyNodeToSymbol.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddMemcpyNodeToSymbol_fn(pGraphNode, graph, pDependencies, numDependencies, symbol, src, count, offset, kind);
  }
}

static hipError_t hipGraphAddMemsetNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const hipMemsetParams* pMemsetParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemsetNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddMemsetNode.pGraphNode = pGraphNode;
    Args.hipGraphAddMemsetNode.graph = graph;
    Args.hipGraphAddMemsetNode.pDependencies = pDependencies;
    Args.hipGraphAddMemsetNode.numDependencies = numDependencies;
    Args.hipGraphAddMemsetNode.pMemsetParams = pMemsetParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddMemsetNode_fn(Args.hipGraphAddMemsetNode.pGraphNode, Args.hipGraphAddMemsetNode.graph, Args.hipGraphAddMemsetNode.pDependencies, Args.hipGraphAddMemsetNode.numDependencies, Args.hipGraphAddMemsetNode.pMemsetParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddMemsetNode_fn(pGraphNode, graph, pDependencies, numDependencies, pMemsetParams);
  }
}

static hipError_t hipGraphChildGraphNodeGetGraph_callback(hipGraphNode_t node, hipGraph_t* pGraph) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphChildGraphNodeGetGraph;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphChildGraphNodeGetGraph.node = node;
    Args.hipGraphChildGraphNodeGetGraph.pGraph = pGraph;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphChildGraphNodeGetGraph_fn(Args.hipGraphChildGraphNodeGetGraph.node, Args.hipGraphChildGraphNodeGetGraph.pGraph);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphChildGraphNodeGetGraph_fn(node, pGraph);
  }
}

static hipError_t hipGraphClone_callback(hipGraph_t* pGraphClone, hipGraph_t originalGraph) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphClone;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphClone.pGraphClone = pGraphClone;
    Args.hipGraphClone.originalGraph = originalGraph;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphClone_fn(Args.hipGraphClone.pGraphClone, Args.hipGraphClone.originalGraph);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphClone_fn(pGraphClone, originalGraph);
  }
}

static hipError_t hipGraphCreate_callback(hipGraph_t* pGraph, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphCreate.pGraph = pGraph;
    Args.hipGraphCreate.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphCreate_fn(Args.hipGraphCreate.pGraph, Args.hipGraphCreate.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphCreate_fn(pGraph, flags);
  }
}

static hipError_t hipGraphDebugDotPrint_callback(hipGraph_t graph, const char* path, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphDebugDotPrint;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphDebugDotPrint.graph = graph;
    Args.hipGraphDebugDotPrint.path = path;
    Args.hipGraphDebugDotPrint.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphDebugDotPrint_fn(Args.hipGraphDebugDotPrint.graph, Args.hipGraphDebugDotPrint.path, Args.hipGraphDebugDotPrint.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphDebugDotPrint_fn(graph, path, flags);
  }
}

static hipError_t hipGraphDestroy_callback(hipGraph_t graph) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphDestroy.graph = graph;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphDestroy_fn(Args.hipGraphDestroy.graph);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphDestroy_fn(graph);
  }
}

static hipError_t hipGraphDestroyNode_callback(hipGraphNode_t node) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphDestroyNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphDestroyNode.node = node;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphDestroyNode_fn(Args.hipGraphDestroyNode.node);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphDestroyNode_fn(node);
  }
}

static hipError_t hipGraphEventRecordNodeGetEvent_callback(hipGraphNode_t node, hipEvent_t* event_out) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphEventRecordNodeGetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphEventRecordNodeGetEvent.node = node;
    Args.hipGraphEventRecordNodeGetEvent.event_out = event_out;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphEventRecordNodeGetEvent_fn(Args.hipGraphEventRecordNodeGetEvent.node, Args.hipGraphEventRecordNodeGetEvent.event_out);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphEventRecordNodeGetEvent_fn(node, event_out);
  }
}

static hipError_t hipGraphEventRecordNodeSetEvent_callback(hipGraphNode_t node, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphEventRecordNodeSetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphEventRecordNodeSetEvent.node = node;
    Args.hipGraphEventRecordNodeSetEvent.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphEventRecordNodeSetEvent_fn(Args.hipGraphEventRecordNodeSetEvent.node, Args.hipGraphEventRecordNodeSetEvent.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphEventRecordNodeSetEvent_fn(node, event);
  }
}

static hipError_t hipGraphEventWaitNodeGetEvent_callback(hipGraphNode_t node, hipEvent_t* event_out) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphEventWaitNodeGetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphEventWaitNodeGetEvent.node = node;
    Args.hipGraphEventWaitNodeGetEvent.event_out = event_out;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphEventWaitNodeGetEvent_fn(Args.hipGraphEventWaitNodeGetEvent.node, Args.hipGraphEventWaitNodeGetEvent.event_out);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphEventWaitNodeGetEvent_fn(node, event_out);
  }
}

static hipError_t hipGraphEventWaitNodeSetEvent_callback(hipGraphNode_t node, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphEventWaitNodeSetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphEventWaitNodeSetEvent.node = node;
    Args.hipGraphEventWaitNodeSetEvent.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphEventWaitNodeSetEvent_fn(Args.hipGraphEventWaitNodeSetEvent.node, Args.hipGraphEventWaitNodeSetEvent.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphEventWaitNodeSetEvent_fn(node, event);
  }
}

static hipError_t hipGraphExecChildGraphNodeSetParams_callback(hipGraphExec_t hGraphExec, hipGraphNode_t node, hipGraph_t childGraph) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecChildGraphNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecChildGraphNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecChildGraphNodeSetParams.node = node;
    Args.hipGraphExecChildGraphNodeSetParams.childGraph = childGraph;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecChildGraphNodeSetParams_fn(Args.hipGraphExecChildGraphNodeSetParams.hGraphExec, Args.hipGraphExecChildGraphNodeSetParams.node, Args.hipGraphExecChildGraphNodeSetParams.childGraph);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecChildGraphNodeSetParams_fn(hGraphExec, node, childGraph);
  }
}

static hipError_t hipGraphExecDestroy_callback(hipGraphExec_t graphExec) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecDestroy.graphExec = graphExec;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecDestroy_fn(Args.hipGraphExecDestroy.graphExec);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecDestroy_fn(graphExec);
  }
}

static hipError_t hipGraphExecEventRecordNodeSetEvent_callback(hipGraphExec_t hGraphExec, hipGraphNode_t hNode, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecEventRecordNodeSetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecEventRecordNodeSetEvent.hGraphExec = hGraphExec;
    Args.hipGraphExecEventRecordNodeSetEvent.hNode = hNode;
    Args.hipGraphExecEventRecordNodeSetEvent.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecEventRecordNodeSetEvent_fn(Args.hipGraphExecEventRecordNodeSetEvent.hGraphExec, Args.hipGraphExecEventRecordNodeSetEvent.hNode, Args.hipGraphExecEventRecordNodeSetEvent.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecEventRecordNodeSetEvent_fn(hGraphExec, hNode, event);
  }
}

static hipError_t hipGraphExecEventWaitNodeSetEvent_callback(hipGraphExec_t hGraphExec, hipGraphNode_t hNode, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecEventWaitNodeSetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecEventWaitNodeSetEvent.hGraphExec = hGraphExec;
    Args.hipGraphExecEventWaitNodeSetEvent.hNode = hNode;
    Args.hipGraphExecEventWaitNodeSetEvent.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecEventWaitNodeSetEvent_fn(Args.hipGraphExecEventWaitNodeSetEvent.hGraphExec, Args.hipGraphExecEventWaitNodeSetEvent.hNode, Args.hipGraphExecEventWaitNodeSetEvent.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecEventWaitNodeSetEvent_fn(hGraphExec, hNode, event);
  }
}

static hipError_t hipGraphExecHostNodeSetParams_callback(hipGraphExec_t hGraphExec, hipGraphNode_t node, const hipHostNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecHostNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecHostNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecHostNodeSetParams.node = node;
    Args.hipGraphExecHostNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecHostNodeSetParams_fn(Args.hipGraphExecHostNodeSetParams.hGraphExec, Args.hipGraphExecHostNodeSetParams.node, Args.hipGraphExecHostNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecHostNodeSetParams_fn(hGraphExec, node, pNodeParams);
  }
}

static hipError_t hipGraphExecKernelNodeSetParams_callback(hipGraphExec_t hGraphExec, hipGraphNode_t node, const hipKernelNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecKernelNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecKernelNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecKernelNodeSetParams.node = node;
    Args.hipGraphExecKernelNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecKernelNodeSetParams_fn(Args.hipGraphExecKernelNodeSetParams.hGraphExec, Args.hipGraphExecKernelNodeSetParams.node, Args.hipGraphExecKernelNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecKernelNodeSetParams_fn(hGraphExec, node, pNodeParams);
  }
}

static hipError_t hipGraphExecMemcpyNodeSetParams_callback(hipGraphExec_t hGraphExec, hipGraphNode_t node, hipMemcpy3DParms* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecMemcpyNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecMemcpyNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecMemcpyNodeSetParams.node = node;
    Args.hipGraphExecMemcpyNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecMemcpyNodeSetParams_fn(Args.hipGraphExecMemcpyNodeSetParams.hGraphExec, Args.hipGraphExecMemcpyNodeSetParams.node, Args.hipGraphExecMemcpyNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecMemcpyNodeSetParams_fn(hGraphExec, node, pNodeParams);
  }
}

static hipError_t hipGraphExecMemcpyNodeSetParams1D_callback(hipGraphExec_t hGraphExec, hipGraphNode_t node, void* dst, const void* src, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecMemcpyNodeSetParams1D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecMemcpyNodeSetParams1D.hGraphExec = hGraphExec;
    Args.hipGraphExecMemcpyNodeSetParams1D.node = node;
    Args.hipGraphExecMemcpyNodeSetParams1D.dst = dst;
    Args.hipGraphExecMemcpyNodeSetParams1D.src = src;
    Args.hipGraphExecMemcpyNodeSetParams1D.count = count;
    Args.hipGraphExecMemcpyNodeSetParams1D.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecMemcpyNodeSetParams1D_fn(Args.hipGraphExecMemcpyNodeSetParams1D.hGraphExec, Args.hipGraphExecMemcpyNodeSetParams1D.node, Args.hipGraphExecMemcpyNodeSetParams1D.dst, Args.hipGraphExecMemcpyNodeSetParams1D.src, Args.hipGraphExecMemcpyNodeSetParams1D.count, Args.hipGraphExecMemcpyNodeSetParams1D.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecMemcpyNodeSetParams1D_fn(hGraphExec, node, dst, src, count, kind);
  }
}

static hipError_t hipGraphExecMemcpyNodeSetParamsFromSymbol_callback(hipGraphExec_t hGraphExec, hipGraphNode_t node, void* dst, const void* symbol, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecMemcpyNodeSetParamsFromSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.hGraphExec = hGraphExec;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.node = node;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.dst = dst;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.symbol = symbol;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.count = count;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.offset = offset;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecMemcpyNodeSetParamsFromSymbol_fn(Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.hGraphExec, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.node, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.dst, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.symbol, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.count, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.offset, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecMemcpyNodeSetParamsFromSymbol_fn(hGraphExec, node, dst, symbol, count, offset, kind);
  }
}

static hipError_t hipGraphExecMemcpyNodeSetParamsToSymbol_callback(hipGraphExec_t hGraphExec, hipGraphNode_t node, const void* symbol, const void* src, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecMemcpyNodeSetParamsToSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.hGraphExec = hGraphExec;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.node = node;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.symbol = symbol;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.src = src;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.count = count;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.offset = offset;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecMemcpyNodeSetParamsToSymbol_fn(Args.hipGraphExecMemcpyNodeSetParamsToSymbol.hGraphExec, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.node, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.symbol, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.src, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.count, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.offset, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecMemcpyNodeSetParamsToSymbol_fn(hGraphExec, node, symbol, src, count, offset, kind);
  }
}

static hipError_t hipGraphExecMemsetNodeSetParams_callback(hipGraphExec_t hGraphExec, hipGraphNode_t node, const hipMemsetParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecMemsetNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecMemsetNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecMemsetNodeSetParams.node = node;
    Args.hipGraphExecMemsetNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecMemsetNodeSetParams_fn(Args.hipGraphExecMemsetNodeSetParams.hGraphExec, Args.hipGraphExecMemsetNodeSetParams.node, Args.hipGraphExecMemsetNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecMemsetNodeSetParams_fn(hGraphExec, node, pNodeParams);
  }
}

static hipError_t hipGraphExecUpdate_callback(hipGraphExec_t hGraphExec, hipGraph_t hGraph, hipGraphNode_t* hErrorNode_out, hipGraphExecUpdateResult* updateResult_out) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecUpdate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecUpdate.hGraphExec = hGraphExec;
    Args.hipGraphExecUpdate.hGraph = hGraph;
    Args.hipGraphExecUpdate.hErrorNode_out = hErrorNode_out;
    Args.hipGraphExecUpdate.updateResult_out = updateResult_out;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecUpdate_fn(Args.hipGraphExecUpdate.hGraphExec, Args.hipGraphExecUpdate.hGraph, Args.hipGraphExecUpdate.hErrorNode_out, Args.hipGraphExecUpdate.updateResult_out);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecUpdate_fn(hGraphExec, hGraph, hErrorNode_out, updateResult_out);
  }
}

static hipError_t hipGraphGetEdges_callback(hipGraph_t graph, hipGraphNode_t* from, hipGraphNode_t* to, size_t* numEdges) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphGetEdges;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphGetEdges.graph = graph;
    Args.hipGraphGetEdges.from = from;
    Args.hipGraphGetEdges.to = to;
    Args.hipGraphGetEdges.numEdges = numEdges;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphGetEdges_fn(Args.hipGraphGetEdges.graph, Args.hipGraphGetEdges.from, Args.hipGraphGetEdges.to, Args.hipGraphGetEdges.numEdges);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphGetEdges_fn(graph, from, to, numEdges);
  }
}

static hipError_t hipGraphGetNodes_callback(hipGraph_t graph, hipGraphNode_t* nodes, size_t* numNodes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphGetNodes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphGetNodes.graph = graph;
    Args.hipGraphGetNodes.nodes = nodes;
    Args.hipGraphGetNodes.numNodes = numNodes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphGetNodes_fn(Args.hipGraphGetNodes.graph, Args.hipGraphGetNodes.nodes, Args.hipGraphGetNodes.numNodes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphGetNodes_fn(graph, nodes, numNodes);
  }
}

static hipError_t hipGraphGetRootNodes_callback(hipGraph_t graph, hipGraphNode_t* pRootNodes, size_t* pNumRootNodes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphGetRootNodes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphGetRootNodes.graph = graph;
    Args.hipGraphGetRootNodes.pRootNodes = pRootNodes;
    Args.hipGraphGetRootNodes.pNumRootNodes = pNumRootNodes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphGetRootNodes_fn(Args.hipGraphGetRootNodes.graph, Args.hipGraphGetRootNodes.pRootNodes, Args.hipGraphGetRootNodes.pNumRootNodes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphGetRootNodes_fn(graph, pRootNodes, pNumRootNodes);
  }
}

static hipError_t hipGraphHostNodeGetParams_callback(hipGraphNode_t node, hipHostNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphHostNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphHostNodeGetParams.node = node;
    Args.hipGraphHostNodeGetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphHostNodeGetParams_fn(Args.hipGraphHostNodeGetParams.node, Args.hipGraphHostNodeGetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphHostNodeGetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphHostNodeSetParams_callback(hipGraphNode_t node, const hipHostNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphHostNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphHostNodeSetParams.node = node;
    Args.hipGraphHostNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphHostNodeSetParams_fn(Args.hipGraphHostNodeSetParams.node, Args.hipGraphHostNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphHostNodeSetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphInstantiate_callback(hipGraphExec_t* pGraphExec, hipGraph_t graph, hipGraphNode_t* pErrorNode, char* pLogBuffer, size_t bufferSize) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphInstantiate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphInstantiate.pGraphExec = pGraphExec;
    Args.hipGraphInstantiate.graph = graph;
    Args.hipGraphInstantiate.pErrorNode = pErrorNode;
    Args.hipGraphInstantiate.pLogBuffer = pLogBuffer;
    Args.hipGraphInstantiate.bufferSize = bufferSize;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphInstantiate_fn(Args.hipGraphInstantiate.pGraphExec, Args.hipGraphInstantiate.graph, Args.hipGraphInstantiate.pErrorNode, Args.hipGraphInstantiate.pLogBuffer, Args.hipGraphInstantiate.bufferSize);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphInstantiate_fn(pGraphExec, graph, pErrorNode, pLogBuffer, bufferSize);
  }
}

static hipError_t hipGraphInstantiateWithFlags_callback(hipGraphExec_t* pGraphExec, hipGraph_t graph, unsigned long long flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphInstantiateWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphInstantiateWithFlags.pGraphExec = pGraphExec;
    Args.hipGraphInstantiateWithFlags.graph = graph;
    Args.hipGraphInstantiateWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphInstantiateWithFlags_fn(Args.hipGraphInstantiateWithFlags.pGraphExec, Args.hipGraphInstantiateWithFlags.graph, Args.hipGraphInstantiateWithFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphInstantiateWithFlags_fn(pGraphExec, graph, flags);
  }
}

static hipError_t hipGraphKernelNodeCopyAttributes_callback(hipGraphNode_t hSrc, hipGraphNode_t hDst) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphKernelNodeCopyAttributes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphKernelNodeCopyAttributes.hSrc = hSrc;
    Args.hipGraphKernelNodeCopyAttributes.hDst = hDst;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeCopyAttributes_fn(Args.hipGraphKernelNodeCopyAttributes.hSrc, Args.hipGraphKernelNodeCopyAttributes.hDst);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeCopyAttributes_fn(hSrc, hDst);
  }
}

static hipError_t hipGraphKernelNodeGetAttribute_callback(hipGraphNode_t hNode, hipKernelNodeAttrID attr, hipKernelNodeAttrValue* value) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphKernelNodeGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphKernelNodeGetAttribute.hNode = hNode;
    Args.hipGraphKernelNodeGetAttribute.attr = attr;
    Args.hipGraphKernelNodeGetAttribute.value = value;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeGetAttribute_fn(Args.hipGraphKernelNodeGetAttribute.hNode, Args.hipGraphKernelNodeGetAttribute.attr, Args.hipGraphKernelNodeGetAttribute.value);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeGetAttribute_fn(hNode, attr, value);
  }
}

static hipError_t hipGraphKernelNodeGetParams_callback(hipGraphNode_t node, hipKernelNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphKernelNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphKernelNodeGetParams.node = node;
    Args.hipGraphKernelNodeGetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeGetParams_fn(Args.hipGraphKernelNodeGetParams.node, Args.hipGraphKernelNodeGetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeGetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphKernelNodeSetAttribute_callback(hipGraphNode_t hNode, hipKernelNodeAttrID attr, const hipKernelNodeAttrValue* value) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphKernelNodeSetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphKernelNodeSetAttribute.hNode = hNode;
    Args.hipGraphKernelNodeSetAttribute.attr = attr;
    Args.hipGraphKernelNodeSetAttribute.value = value;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeSetAttribute_fn(Args.hipGraphKernelNodeSetAttribute.hNode, Args.hipGraphKernelNodeSetAttribute.attr, Args.hipGraphKernelNodeSetAttribute.value);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeSetAttribute_fn(hNode, attr, value);
  }
}

static hipError_t hipGraphKernelNodeSetParams_callback(hipGraphNode_t node, const hipKernelNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphKernelNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphKernelNodeSetParams.node = node;
    Args.hipGraphKernelNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeSetParams_fn(Args.hipGraphKernelNodeSetParams.node, Args.hipGraphKernelNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeSetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphLaunch_callback(hipGraphExec_t graphExec, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphLaunch;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphLaunch.graphExec = graphExec;
    Args.hipGraphLaunch.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphLaunch_fn(Args.hipGraphLaunch.graphExec, Args.hipGraphLaunch.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphLaunch_fn(graphExec, stream);
  }
}

static hipError_t hipGraphMemAllocNodeGetParams_callback(hipGraphNode_t node, hipMemAllocNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemAllocNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemAllocNodeGetParams.node = node;
    Args.hipGraphMemAllocNodeGetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemAllocNodeGetParams_fn(Args.hipGraphMemAllocNodeGetParams.node, Args.hipGraphMemAllocNodeGetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemAllocNodeGetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphMemFreeNodeGetParams_callback(hipGraphNode_t node, void* dev_ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemFreeNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemFreeNodeGetParams.node = node;
    Args.hipGraphMemFreeNodeGetParams.dev_ptr = dev_ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemFreeNodeGetParams_fn(Args.hipGraphMemFreeNodeGetParams.node, Args.hipGraphMemFreeNodeGetParams.dev_ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemFreeNodeGetParams_fn(node, dev_ptr);
  }
}

static hipError_t hipGraphMemcpyNodeGetParams_callback(hipGraphNode_t node, hipMemcpy3DParms* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemcpyNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemcpyNodeGetParams.node = node;
    Args.hipGraphMemcpyNodeGetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeGetParams_fn(Args.hipGraphMemcpyNodeGetParams.node, Args.hipGraphMemcpyNodeGetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeGetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphMemcpyNodeSetParams_callback(hipGraphNode_t node, const hipMemcpy3DParms* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemcpyNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemcpyNodeSetParams.node = node;
    Args.hipGraphMemcpyNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeSetParams_fn(Args.hipGraphMemcpyNodeSetParams.node, Args.hipGraphMemcpyNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeSetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphMemcpyNodeSetParams1D_callback(hipGraphNode_t node, void* dst, const void* src, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemcpyNodeSetParams1D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemcpyNodeSetParams1D.node = node;
    Args.hipGraphMemcpyNodeSetParams1D.dst = dst;
    Args.hipGraphMemcpyNodeSetParams1D.src = src;
    Args.hipGraphMemcpyNodeSetParams1D.count = count;
    Args.hipGraphMemcpyNodeSetParams1D.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeSetParams1D_fn(Args.hipGraphMemcpyNodeSetParams1D.node, Args.hipGraphMemcpyNodeSetParams1D.dst, Args.hipGraphMemcpyNodeSetParams1D.src, Args.hipGraphMemcpyNodeSetParams1D.count, Args.hipGraphMemcpyNodeSetParams1D.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeSetParams1D_fn(node, dst, src, count, kind);
  }
}

static hipError_t hipGraphMemcpyNodeSetParamsFromSymbol_callback(hipGraphNode_t node, void* dst, const void* symbol, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemcpyNodeSetParamsFromSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.node = node;
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.dst = dst;
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.symbol = symbol;
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.count = count;
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.offset = offset;
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeSetParamsFromSymbol_fn(Args.hipGraphMemcpyNodeSetParamsFromSymbol.node, Args.hipGraphMemcpyNodeSetParamsFromSymbol.dst, Args.hipGraphMemcpyNodeSetParamsFromSymbol.symbol, Args.hipGraphMemcpyNodeSetParamsFromSymbol.count, Args.hipGraphMemcpyNodeSetParamsFromSymbol.offset, Args.hipGraphMemcpyNodeSetParamsFromSymbol.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeSetParamsFromSymbol_fn(node, dst, symbol, count, offset, kind);
  }
}

static hipError_t hipGraphMemcpyNodeSetParamsToSymbol_callback(hipGraphNode_t node, const void* symbol, const void* src, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemcpyNodeSetParamsToSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemcpyNodeSetParamsToSymbol.node = node;
    Args.hipGraphMemcpyNodeSetParamsToSymbol.symbol = symbol;
    Args.hipGraphMemcpyNodeSetParamsToSymbol.src = src;
    Args.hipGraphMemcpyNodeSetParamsToSymbol.count = count;
    Args.hipGraphMemcpyNodeSetParamsToSymbol.offset = offset;
    Args.hipGraphMemcpyNodeSetParamsToSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeSetParamsToSymbol_fn(Args.hipGraphMemcpyNodeSetParamsToSymbol.node, Args.hipGraphMemcpyNodeSetParamsToSymbol.symbol, Args.hipGraphMemcpyNodeSetParamsToSymbol.src, Args.hipGraphMemcpyNodeSetParamsToSymbol.count, Args.hipGraphMemcpyNodeSetParamsToSymbol.offset, Args.hipGraphMemcpyNodeSetParamsToSymbol.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeSetParamsToSymbol_fn(node, symbol, src, count, offset, kind);
  }
}

static hipError_t hipGraphMemsetNodeGetParams_callback(hipGraphNode_t node, hipMemsetParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemsetNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemsetNodeGetParams.node = node;
    Args.hipGraphMemsetNodeGetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemsetNodeGetParams_fn(Args.hipGraphMemsetNodeGetParams.node, Args.hipGraphMemsetNodeGetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemsetNodeGetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphMemsetNodeSetParams_callback(hipGraphNode_t node, const hipMemsetParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemsetNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemsetNodeSetParams.node = node;
    Args.hipGraphMemsetNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemsetNodeSetParams_fn(Args.hipGraphMemsetNodeSetParams.node, Args.hipGraphMemsetNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemsetNodeSetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphNodeFindInClone_callback(hipGraphNode_t* pNode, hipGraphNode_t originalNode, hipGraph_t clonedGraph) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeFindInClone;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphNodeFindInClone.pNode = pNode;
    Args.hipGraphNodeFindInClone.originalNode = originalNode;
    Args.hipGraphNodeFindInClone.clonedGraph = clonedGraph;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphNodeFindInClone_fn(Args.hipGraphNodeFindInClone.pNode, Args.hipGraphNodeFindInClone.originalNode, Args.hipGraphNodeFindInClone.clonedGraph);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphNodeFindInClone_fn(pNode, originalNode, clonedGraph);
  }
}

static hipError_t hipGraphNodeGetDependencies_callback(hipGraphNode_t node, hipGraphNode_t* pDependencies, size_t* pNumDependencies) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeGetDependencies;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphNodeGetDependencies.node = node;
    Args.hipGraphNodeGetDependencies.pDependencies = pDependencies;
    Args.hipGraphNodeGetDependencies.pNumDependencies = pNumDependencies;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphNodeGetDependencies_fn(Args.hipGraphNodeGetDependencies.node, Args.hipGraphNodeGetDependencies.pDependencies, Args.hipGraphNodeGetDependencies.pNumDependencies);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphNodeGetDependencies_fn(node, pDependencies, pNumDependencies);
  }
}

static hipError_t hipGraphNodeGetDependentNodes_callback(hipGraphNode_t node, hipGraphNode_t* pDependentNodes, size_t* pNumDependentNodes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeGetDependentNodes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphNodeGetDependentNodes.node = node;
    Args.hipGraphNodeGetDependentNodes.pDependentNodes = pDependentNodes;
    Args.hipGraphNodeGetDependentNodes.pNumDependentNodes = pNumDependentNodes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphNodeGetDependentNodes_fn(Args.hipGraphNodeGetDependentNodes.node, Args.hipGraphNodeGetDependentNodes.pDependentNodes, Args.hipGraphNodeGetDependentNodes.pNumDependentNodes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphNodeGetDependentNodes_fn(node, pDependentNodes, pNumDependentNodes);
  }
}

static hipError_t hipGraphNodeGetEnabled_callback(hipGraphExec_t hGraphExec, hipGraphNode_t hNode, unsigned int* isEnabled) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeGetEnabled;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphNodeGetEnabled.hGraphExec = hGraphExec;
    Args.hipGraphNodeGetEnabled.hNode = hNode;
    Args.hipGraphNodeGetEnabled.isEnabled = isEnabled;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphNodeGetEnabled_fn(Args.hipGraphNodeGetEnabled.hGraphExec, Args.hipGraphNodeGetEnabled.hNode, Args.hipGraphNodeGetEnabled.isEnabled);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphNodeGetEnabled_fn(hGraphExec, hNode, isEnabled);
  }
}

static hipError_t hipGraphNodeGetType_callback(hipGraphNode_t node, hipGraphNodeType* pType) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeGetType;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphNodeGetType.node = node;
    Args.hipGraphNodeGetType.pType = pType;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphNodeGetType_fn(Args.hipGraphNodeGetType.node, Args.hipGraphNodeGetType.pType);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphNodeGetType_fn(node, pType);
  }
}

static hipError_t hipGraphNodeSetEnabled_callback(hipGraphExec_t hGraphExec, hipGraphNode_t hNode, unsigned int isEnabled) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeSetEnabled;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphNodeSetEnabled.hGraphExec = hGraphExec;
    Args.hipGraphNodeSetEnabled.hNode = hNode;
    Args.hipGraphNodeSetEnabled.isEnabled = isEnabled;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphNodeSetEnabled_fn(Args.hipGraphNodeSetEnabled.hGraphExec, Args.hipGraphNodeSetEnabled.hNode, Args.hipGraphNodeSetEnabled.isEnabled);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphNodeSetEnabled_fn(hGraphExec, hNode, isEnabled);
  }
}

static hipError_t hipGraphReleaseUserObject_callback(hipGraph_t graph, hipUserObject_t object, unsigned int count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphReleaseUserObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphReleaseUserObject.graph = graph;
    Args.hipGraphReleaseUserObject.object = object;
    Args.hipGraphReleaseUserObject.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphReleaseUserObject_fn(Args.hipGraphReleaseUserObject.graph, Args.hipGraphReleaseUserObject.object, Args.hipGraphReleaseUserObject.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphReleaseUserObject_fn(graph, object, count);
  }
}

static hipError_t hipGraphRemoveDependencies_callback(hipGraph_t graph, const hipGraphNode_t* from, const hipGraphNode_t* to, size_t numDependencies) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphRemoveDependencies;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphRemoveDependencies.graph = graph;
    Args.hipGraphRemoveDependencies.from = from;
    Args.hipGraphRemoveDependencies.to = to;
    Args.hipGraphRemoveDependencies.numDependencies = numDependencies;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphRemoveDependencies_fn(Args.hipGraphRemoveDependencies.graph, Args.hipGraphRemoveDependencies.from, Args.hipGraphRemoveDependencies.to, Args.hipGraphRemoveDependencies.numDependencies);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphRemoveDependencies_fn(graph, from, to, numDependencies);
  }
}

static hipError_t hipGraphRetainUserObject_callback(hipGraph_t graph, hipUserObject_t object, unsigned int count, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphRetainUserObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphRetainUserObject.graph = graph;
    Args.hipGraphRetainUserObject.object = object;
    Args.hipGraphRetainUserObject.count = count;
    Args.hipGraphRetainUserObject.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphRetainUserObject_fn(Args.hipGraphRetainUserObject.graph, Args.hipGraphRetainUserObject.object, Args.hipGraphRetainUserObject.count, Args.hipGraphRetainUserObject.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphRetainUserObject_fn(graph, object, count, flags);
  }
}

static hipError_t hipGraphUpload_callback(hipGraphExec_t graphExec, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphUpload;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphUpload.graphExec = graphExec;
    Args.hipGraphUpload.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphUpload_fn(Args.hipGraphUpload.graphExec, Args.hipGraphUpload.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphUpload_fn(graphExec, stream);
  }
}

static hipError_t hipGraphicsGLRegisterBuffer_callback(hipGraphicsResource** resource, GLuint buffer, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsGLRegisterBuffer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphicsGLRegisterBuffer.resource = resource;
    Args.hipGraphicsGLRegisterBuffer.buffer = buffer;
    Args.hipGraphicsGLRegisterBuffer.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphicsGLRegisterBuffer_fn(Args.hipGraphicsGLRegisterBuffer.resource, Args.hipGraphicsGLRegisterBuffer.buffer, Args.hipGraphicsGLRegisterBuffer.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphicsGLRegisterBuffer_fn(resource, buffer, flags);
  }
}

static hipError_t hipGraphicsGLRegisterImage_callback(hipGraphicsResource** resource, GLuint image, GLenum target, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsGLRegisterImage;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphicsGLRegisterImage.resource = resource;
    Args.hipGraphicsGLRegisterImage.image = image;
    Args.hipGraphicsGLRegisterImage.target = target;
    Args.hipGraphicsGLRegisterImage.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphicsGLRegisterImage_fn(Args.hipGraphicsGLRegisterImage.resource, Args.hipGraphicsGLRegisterImage.image, Args.hipGraphicsGLRegisterImage.target, Args.hipGraphicsGLRegisterImage.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphicsGLRegisterImage_fn(resource, image, target, flags);
  }
}

static hipError_t hipGraphicsMapResources_callback(int count, hipGraphicsResource_t* resources, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsMapResources;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphicsMapResources.count = count;
    Args.hipGraphicsMapResources.resources = resources;
    Args.hipGraphicsMapResources.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphicsMapResources_fn(Args.hipGraphicsMapResources.count, Args.hipGraphicsMapResources.resources, Args.hipGraphicsMapResources.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphicsMapResources_fn(count, resources, stream);
  }
}

static hipError_t hipGraphicsResourceGetMappedPointer_callback(void** devPtr, size_t* size, hipGraphicsResource_t resource) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsResourceGetMappedPointer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphicsResourceGetMappedPointer.devPtr = devPtr;
    Args.hipGraphicsResourceGetMappedPointer.size = size;
    Args.hipGraphicsResourceGetMappedPointer.resource = resource;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphicsResourceGetMappedPointer_fn(Args.hipGraphicsResourceGetMappedPointer.devPtr, Args.hipGraphicsResourceGetMappedPointer.size, Args.hipGraphicsResourceGetMappedPointer.resource);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphicsResourceGetMappedPointer_fn(devPtr, size, resource);
  }
}

static hipError_t hipGraphicsSubResourceGetMappedArray_callback(hipArray_t* array, hipGraphicsResource_t resource, unsigned int arrayIndex, unsigned int mipLevel) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsSubResourceGetMappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphicsSubResourceGetMappedArray.array = array;
    Args.hipGraphicsSubResourceGetMappedArray.resource = resource;
    Args.hipGraphicsSubResourceGetMappedArray.arrayIndex = arrayIndex;
    Args.hipGraphicsSubResourceGetMappedArray.mipLevel = mipLevel;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphicsSubResourceGetMappedArray_fn(Args.hipGraphicsSubResourceGetMappedArray.array, Args.hipGraphicsSubResourceGetMappedArray.resource, Args.hipGraphicsSubResourceGetMappedArray.arrayIndex, Args.hipGraphicsSubResourceGetMappedArray.mipLevel);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphicsSubResourceGetMappedArray_fn(array, resource, arrayIndex, mipLevel);
  }
}

static hipError_t hipGraphicsUnmapResources_callback(int count, hipGraphicsResource_t* resources, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsUnmapResources;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphicsUnmapResources.count = count;
    Args.hipGraphicsUnmapResources.resources = resources;
    Args.hipGraphicsUnmapResources.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphicsUnmapResources_fn(Args.hipGraphicsUnmapResources.count, Args.hipGraphicsUnmapResources.resources, Args.hipGraphicsUnmapResources.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphicsUnmapResources_fn(count, resources, stream);
  }
}

static hipError_t hipGraphicsUnregisterResource_callback(hipGraphicsResource_t resource) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsUnregisterResource;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphicsUnregisterResource.resource = resource;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphicsUnregisterResource_fn(Args.hipGraphicsUnregisterResource.resource);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphicsUnregisterResource_fn(resource);
  }
}

static hipError_t hipHostAlloc_callback(void** ptr, size_t size, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipHostAlloc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipHostAlloc.ptr = ptr;
    Args.hipHostAlloc.size = size;
    Args.hipHostAlloc.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipHostAlloc_fn(Args.hipHostAlloc.ptr, Args.hipHostAlloc.size, Args.hipHostAlloc.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipHostAlloc_fn(ptr, size, flags);
  }
}

static hipError_t hipHostFree_callback(void* ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipHostFree;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipHostFree.ptr = ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipHostFree_fn(Args.hipHostFree.ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipHostFree_fn(ptr);
  }
}

static hipError_t hipHostGetDevicePointer_callback(void** devPtr, void* hstPtr, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipHostGetDevicePointer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipHostGetDevicePointer.devPtr = devPtr;
    Args.hipHostGetDevicePointer.hstPtr = hstPtr;
    Args.hipHostGetDevicePointer.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipHostGetDevicePointer_fn(Args.hipHostGetDevicePointer.devPtr, Args.hipHostGetDevicePointer.hstPtr, Args.hipHostGetDevicePointer.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipHostGetDevicePointer_fn(devPtr, hstPtr, flags);
  }
}

static hipError_t hipHostGetFlags_callback(unsigned int* flagsPtr, void* hostPtr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipHostGetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipHostGetFlags.flagsPtr = flagsPtr;
    Args.hipHostGetFlags.hostPtr = hostPtr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipHostGetFlags_fn(Args.hipHostGetFlags.flagsPtr, Args.hipHostGetFlags.hostPtr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipHostGetFlags_fn(flagsPtr, hostPtr);
  }
}

static hipError_t hipHostMalloc_callback(void** ptr, size_t size, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipHostMalloc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipHostMalloc.ptr = ptr;
    Args.hipHostMalloc.size = size;
    Args.hipHostMalloc.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipHostMalloc_fn(Args.hipHostMalloc.ptr, Args.hipHostMalloc.size, Args.hipHostMalloc.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipHostMalloc_fn(ptr, size, flags);
  }
}

static hipError_t hipHostRegister_callback(void* hostPtr, size_t sizeBytes, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipHostRegister;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipHostRegister.hostPtr = hostPtr;
    Args.hipHostRegister.sizeBytes = sizeBytes;
    Args.hipHostRegister.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipHostRegister_fn(Args.hipHostRegister.hostPtr, Args.hipHostRegister.sizeBytes, Args.hipHostRegister.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipHostRegister_fn(hostPtr, sizeBytes, flags);
  }
}

static hipError_t hipHostUnregister_callback(void* hostPtr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipHostUnregister;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipHostUnregister.hostPtr = hostPtr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipHostUnregister_fn(Args.hipHostUnregister.hostPtr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipHostUnregister_fn(hostPtr);
  }
}

static hipError_t hipImportExternalMemory_callback(hipExternalMemory_t* extMem_out, const hipExternalMemoryHandleDesc* memHandleDesc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipImportExternalMemory;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipImportExternalMemory.extMem_out = extMem_out;
    Args.hipImportExternalMemory.memHandleDesc = memHandleDesc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipImportExternalMemory_fn(Args.hipImportExternalMemory.extMem_out, Args.hipImportExternalMemory.memHandleDesc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipImportExternalMemory_fn(extMem_out, memHandleDesc);
  }
}

static hipError_t hipImportExternalSemaphore_callback(hipExternalSemaphore_t* extSem_out, const hipExternalSemaphoreHandleDesc* semHandleDesc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipImportExternalSemaphore;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipImportExternalSemaphore.extSem_out = extSem_out;
    Args.hipImportExternalSemaphore.semHandleDesc = semHandleDesc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipImportExternalSemaphore_fn(Args.hipImportExternalSemaphore.extSem_out, Args.hipImportExternalSemaphore.semHandleDesc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipImportExternalSemaphore_fn(extSem_out, semHandleDesc);
  }
}

static hipError_t hipInit_callback(unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipInit;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipInit.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipInit_fn(Args.hipInit.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipInit_fn(flags);
  }
}

static hipError_t hipIpcCloseMemHandle_callback(void* devPtr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipIpcCloseMemHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipIpcCloseMemHandle.devPtr = devPtr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipIpcCloseMemHandle_fn(Args.hipIpcCloseMemHandle.devPtr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipIpcCloseMemHandle_fn(devPtr);
  }
}

static hipError_t hipIpcGetEventHandle_callback(hipIpcEventHandle_t* handle, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipIpcGetEventHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipIpcGetEventHandle.handle = handle;
    Args.hipIpcGetEventHandle.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipIpcGetEventHandle_fn(Args.hipIpcGetEventHandle.handle, Args.hipIpcGetEventHandle.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipIpcGetEventHandle_fn(handle, event);
  }
}

static hipError_t hipIpcGetMemHandle_callback(hipIpcMemHandle_t* handle, void* devPtr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipIpcGetMemHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipIpcGetMemHandle.handle = handle;
    Args.hipIpcGetMemHandle.devPtr = devPtr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipIpcGetMemHandle_fn(Args.hipIpcGetMemHandle.handle, Args.hipIpcGetMemHandle.devPtr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipIpcGetMemHandle_fn(handle, devPtr);
  }
}

static hipError_t hipIpcOpenEventHandle_callback(hipEvent_t* event, hipIpcEventHandle_t handle) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipIpcOpenEventHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipIpcOpenEventHandle.event = event;
    Args.hipIpcOpenEventHandle.handle = handle;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipIpcOpenEventHandle_fn(Args.hipIpcOpenEventHandle.event, Args.hipIpcOpenEventHandle.handle);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipIpcOpenEventHandle_fn(event, handle);
  }
}

static hipError_t hipIpcOpenMemHandle_callback(void** devPtr, hipIpcMemHandle_t handle, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipIpcOpenMemHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipIpcOpenMemHandle.devPtr = devPtr;
    Args.hipIpcOpenMemHandle.handle = handle;
    Args.hipIpcOpenMemHandle.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipIpcOpenMemHandle_fn(Args.hipIpcOpenMemHandle.devPtr, Args.hipIpcOpenMemHandle.handle, Args.hipIpcOpenMemHandle.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipIpcOpenMemHandle_fn(devPtr, handle, flags);
  }
}

static const char* hipKernelNameRefByPtr_callback(const void* hostFunction, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipKernelNameRefByPtr;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    const char* Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipKernelNameRefByPtr.hostFunction = hostFunction;
    Args.hipKernelNameRefByPtr.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipKernelNameRefByPtr_fn(Args.hipKernelNameRefByPtr.hostFunction, Args.hipKernelNameRefByPtr.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipKernelNameRefByPtr_fn(hostFunction, stream);
  }
}

static hipError_t hipLaunchByPtr_callback(const void* func) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchByPtr;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipLaunchByPtr.func = func;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipLaunchByPtr_fn(Args.hipLaunchByPtr.func);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipLaunchByPtr_fn(func);
  }
}

static hipError_t hipLaunchCooperativeKernelMultiDevice_callback(hipLaunchParams* launchParamsList, int numDevices, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchCooperativeKernelMultiDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipLaunchCooperativeKernelMultiDevice.launchParamsList = launchParamsList;
    Args.hipLaunchCooperativeKernelMultiDevice.numDevices = numDevices;
    Args.hipLaunchCooperativeKernelMultiDevice.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipLaunchCooperativeKernelMultiDevice_fn(Args.hipLaunchCooperativeKernelMultiDevice.launchParamsList, Args.hipLaunchCooperativeKernelMultiDevice.numDevices, Args.hipLaunchCooperativeKernelMultiDevice.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipLaunchCooperativeKernelMultiDevice_fn(launchParamsList, numDevices, flags);
  }
}

static hipError_t hipLaunchHostFunc_callback(hipStream_t stream, hipHostFn_t fn, void* userData) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchHostFunc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipLaunchHostFunc.stream = stream;
    Args.hipLaunchHostFunc.fn = fn;
    Args.hipLaunchHostFunc.userData = userData;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipLaunchHostFunc_fn(Args.hipLaunchHostFunc.stream, Args.hipLaunchHostFunc.fn, Args.hipLaunchHostFunc.userData);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipLaunchHostFunc_fn(stream, fn, userData);
  }
}

static hipError_t hipLaunchKernel_callback(const void* function_address, dim3 numBlocks, dim3 dimBlocks, void** args, size_t sharedMemBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchKernel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipLaunchKernel.function_address = function_address;
    Args.hipLaunchKernel.numBlocks = luthier::convertToRocprofilerDim3(numBlocks);
    Args.hipLaunchKernel.dimBlocks = luthier::convertToRocprofilerDim3(dimBlocks);
    Args.hipLaunchKernel.args = args;
    Args.hipLaunchKernel.sharedMemBytes = sharedMemBytes;
    Args.hipLaunchKernel.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipLaunchKernel_fn(Args.hipLaunchKernel.function_address, numBlocks, dimBlocks, Args.hipLaunchKernel.args, Args.hipLaunchKernel.sharedMemBytes, Args.hipLaunchKernel.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipLaunchKernel_fn(function_address, numBlocks, dimBlocks, args, sharedMemBytes, stream);
  }
}

static hipError_t hipMalloc_callback(void** ptr, size_t size) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMalloc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMalloc.ptr = ptr;
    Args.hipMalloc.size = size;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMalloc_fn(Args.hipMalloc.ptr, Args.hipMalloc.size);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMalloc_fn(ptr, size);
  }
}

static hipError_t hipMalloc3D_callback(hipPitchedPtr* pitchedDevPtr, hipExtent extent) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMalloc3D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMalloc3D.pitchedDevPtr = pitchedDevPtr;
    Args.hipMalloc3D.extent = extent;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMalloc3D_fn(Args.hipMalloc3D.pitchedDevPtr, Args.hipMalloc3D.extent);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMalloc3D_fn(pitchedDevPtr, extent);
  }
}

static hipError_t hipMalloc3DArray_callback(hipArray_t* array, const struct hipChannelFormatDesc* desc, struct hipExtent extent, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMalloc3DArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMalloc3DArray.array = array;
    Args.hipMalloc3DArray.desc = desc;
    Args.hipMalloc3DArray.extent = extent;
    Args.hipMalloc3DArray.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMalloc3DArray_fn(Args.hipMalloc3DArray.array, Args.hipMalloc3DArray.desc, Args.hipMalloc3DArray.extent, Args.hipMalloc3DArray.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMalloc3DArray_fn(array, desc, extent, flags);
  }
}

static hipError_t hipMallocArray_callback(hipArray_t* array, const hipChannelFormatDesc* desc, size_t width, size_t height, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMallocArray.array = array;
    Args.hipMallocArray.desc = desc;
    Args.hipMallocArray.width = width;
    Args.hipMallocArray.height = height;
    Args.hipMallocArray.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMallocArray_fn(Args.hipMallocArray.array, Args.hipMallocArray.desc, Args.hipMallocArray.width, Args.hipMallocArray.height, Args.hipMallocArray.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMallocArray_fn(array, desc, width, height, flags);
  }
}

static hipError_t hipMallocAsync_callback(void** dev_ptr, size_t size, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMallocAsync.dev_ptr = dev_ptr;
    Args.hipMallocAsync.size = size;
    Args.hipMallocAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMallocAsync_fn(Args.hipMallocAsync.dev_ptr, Args.hipMallocAsync.size, Args.hipMallocAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMallocAsync_fn(dev_ptr, size, stream);
  }
}

static hipError_t hipMallocFromPoolAsync_callback(void** dev_ptr, size_t size, hipMemPool_t mem_pool, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocFromPoolAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMallocFromPoolAsync.dev_ptr = dev_ptr;
    Args.hipMallocFromPoolAsync.size = size;
    Args.hipMallocFromPoolAsync.mem_pool = mem_pool;
    Args.hipMallocFromPoolAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMallocFromPoolAsync_fn(Args.hipMallocFromPoolAsync.dev_ptr, Args.hipMallocFromPoolAsync.size, Args.hipMallocFromPoolAsync.mem_pool, Args.hipMallocFromPoolAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMallocFromPoolAsync_fn(dev_ptr, size, mem_pool, stream);
  }
}

static hipError_t hipMallocHost_callback(void** ptr, size_t size) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocHost;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMallocHost.ptr = ptr;
    Args.hipMallocHost.size = size;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMallocHost_fn(Args.hipMallocHost.ptr, Args.hipMallocHost.size);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMallocHost_fn(ptr, size);
  }
}

static hipError_t hipMallocManaged_callback(void** dev_ptr, size_t size, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocManaged;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMallocManaged.dev_ptr = dev_ptr;
    Args.hipMallocManaged.size = size;
    Args.hipMallocManaged.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMallocManaged_fn(Args.hipMallocManaged.dev_ptr, Args.hipMallocManaged.size, Args.hipMallocManaged.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMallocManaged_fn(dev_ptr, size, flags);
  }
}

static hipError_t hipMallocMipmappedArray_callback(hipMipmappedArray_t* mipmappedArray, const struct hipChannelFormatDesc* desc, struct hipExtent extent, unsigned int numLevels, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocMipmappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMallocMipmappedArray.mipmappedArray = mipmappedArray;
    Args.hipMallocMipmappedArray.desc = desc;
    Args.hipMallocMipmappedArray.extent = extent;
    Args.hipMallocMipmappedArray.numLevels = numLevels;
    Args.hipMallocMipmappedArray.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMallocMipmappedArray_fn(Args.hipMallocMipmappedArray.mipmappedArray, Args.hipMallocMipmappedArray.desc, Args.hipMallocMipmappedArray.extent, Args.hipMallocMipmappedArray.numLevels, Args.hipMallocMipmappedArray.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMallocMipmappedArray_fn(mipmappedArray, desc, extent, numLevels, flags);
  }
}

static hipError_t hipMallocPitch_callback(void** ptr, size_t* pitch, size_t width, size_t height) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocPitch;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMallocPitch.ptr = ptr;
    Args.hipMallocPitch.pitch = pitch;
    Args.hipMallocPitch.width = width;
    Args.hipMallocPitch.height = height;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMallocPitch_fn(Args.hipMallocPitch.ptr, Args.hipMallocPitch.pitch, Args.hipMallocPitch.width, Args.hipMallocPitch.height);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMallocPitch_fn(ptr, pitch, width, height);
  }
}

static hipError_t hipMemAddressFree_callback(void* devPtr, size_t size) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemAddressFree;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemAddressFree.devPtr = devPtr;
    Args.hipMemAddressFree.size = size;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemAddressFree_fn(Args.hipMemAddressFree.devPtr, Args.hipMemAddressFree.size);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemAddressFree_fn(devPtr, size);
  }
}

static hipError_t hipMemAddressReserve_callback(void** ptr, size_t size, size_t alignment, void* addr, unsigned long long flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemAddressReserve;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemAddressReserve.ptr = ptr;
    Args.hipMemAddressReserve.size = size;
    Args.hipMemAddressReserve.alignment = alignment;
    Args.hipMemAddressReserve.addr = addr;
    Args.hipMemAddressReserve.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemAddressReserve_fn(Args.hipMemAddressReserve.ptr, Args.hipMemAddressReserve.size, Args.hipMemAddressReserve.alignment, Args.hipMemAddressReserve.addr, Args.hipMemAddressReserve.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemAddressReserve_fn(ptr, size, alignment, addr, flags);
  }
}

static hipError_t hipMemAdvise_callback(const void* dev_ptr, size_t count, hipMemoryAdvise advice, int device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemAdvise;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemAdvise.dev_ptr = dev_ptr;
    Args.hipMemAdvise.count = count;
    Args.hipMemAdvise.advice = advice;
    Args.hipMemAdvise.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemAdvise_fn(Args.hipMemAdvise.dev_ptr, Args.hipMemAdvise.count, Args.hipMemAdvise.advice, Args.hipMemAdvise.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemAdvise_fn(dev_ptr, count, advice, device);
  }
}

static hipError_t hipMemAllocHost_callback(void** ptr, size_t size) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemAllocHost;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemAllocHost.ptr = ptr;
    Args.hipMemAllocHost.size = size;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemAllocHost_fn(Args.hipMemAllocHost.ptr, Args.hipMemAllocHost.size);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemAllocHost_fn(ptr, size);
  }
}

static hipError_t hipMemAllocPitch_callback(hipDeviceptr_t* dptr, size_t* pitch, size_t widthInBytes, size_t height, unsigned int elementSizeBytes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemAllocPitch;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemAllocPitch.dptr = dptr;
    Args.hipMemAllocPitch.pitch = pitch;
    Args.hipMemAllocPitch.widthInBytes = widthInBytes;
    Args.hipMemAllocPitch.height = height;
    Args.hipMemAllocPitch.elementSizeBytes = elementSizeBytes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemAllocPitch_fn(Args.hipMemAllocPitch.dptr, Args.hipMemAllocPitch.pitch, Args.hipMemAllocPitch.widthInBytes, Args.hipMemAllocPitch.height, Args.hipMemAllocPitch.elementSizeBytes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemAllocPitch_fn(dptr, pitch, widthInBytes, height, elementSizeBytes);
  }
}

static hipError_t hipMemCreate_callback(hipMemGenericAllocationHandle_t* handle, size_t size, const hipMemAllocationProp* prop, unsigned long long flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemCreate.handle = handle;
    Args.hipMemCreate.size = size;
    Args.hipMemCreate.prop = prop;
    Args.hipMemCreate.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemCreate_fn(Args.hipMemCreate.handle, Args.hipMemCreate.size, Args.hipMemCreate.prop, Args.hipMemCreate.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemCreate_fn(handle, size, prop, flags);
  }
}

static hipError_t hipMemExportToShareableHandle_callback(void* shareableHandle, hipMemGenericAllocationHandle_t handle, hipMemAllocationHandleType handleType, unsigned long long flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemExportToShareableHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemExportToShareableHandle.shareableHandle = shareableHandle;
    Args.hipMemExportToShareableHandle.handle = handle;
    Args.hipMemExportToShareableHandle.handleType = handleType;
    Args.hipMemExportToShareableHandle.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemExportToShareableHandle_fn(Args.hipMemExportToShareableHandle.shareableHandle, Args.hipMemExportToShareableHandle.handle, Args.hipMemExportToShareableHandle.handleType, Args.hipMemExportToShareableHandle.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemExportToShareableHandle_fn(shareableHandle, handle, handleType, flags);
  }
}

static hipError_t hipMemGetAccess_callback(unsigned long long* flags, const hipMemLocation* location, void* ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemGetAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemGetAccess.flags = flags;
    Args.hipMemGetAccess.location = location;
    Args.hipMemGetAccess.ptr = ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemGetAccess_fn(Args.hipMemGetAccess.flags, Args.hipMemGetAccess.location, Args.hipMemGetAccess.ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemGetAccess_fn(flags, location, ptr);
  }
}

static hipError_t hipMemGetAddressRange_callback(hipDeviceptr_t* pbase, size_t* psize, hipDeviceptr_t dptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemGetAddressRange;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemGetAddressRange.pbase = pbase;
    Args.hipMemGetAddressRange.psize = psize;
    Args.hipMemGetAddressRange.dptr = dptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemGetAddressRange_fn(Args.hipMemGetAddressRange.pbase, Args.hipMemGetAddressRange.psize, Args.hipMemGetAddressRange.dptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemGetAddressRange_fn(pbase, psize, dptr);
  }
}

static hipError_t hipMemGetAllocationGranularity_callback(size_t* granularity, const hipMemAllocationProp* prop, hipMemAllocationGranularity_flags option) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemGetAllocationGranularity;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemGetAllocationGranularity.granularity = granularity;
    Args.hipMemGetAllocationGranularity.prop = prop;
    Args.hipMemGetAllocationGranularity.option = option;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemGetAllocationGranularity_fn(Args.hipMemGetAllocationGranularity.granularity, Args.hipMemGetAllocationGranularity.prop, Args.hipMemGetAllocationGranularity.option);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemGetAllocationGranularity_fn(granularity, prop, option);
  }
}

static hipError_t hipMemGetAllocationPropertiesFromHandle_callback(hipMemAllocationProp* prop, hipMemGenericAllocationHandle_t handle) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemGetAllocationPropertiesFromHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemGetAllocationPropertiesFromHandle.prop = prop;
    Args.hipMemGetAllocationPropertiesFromHandle.handle = handle;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemGetAllocationPropertiesFromHandle_fn(Args.hipMemGetAllocationPropertiesFromHandle.prop, Args.hipMemGetAllocationPropertiesFromHandle.handle);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemGetAllocationPropertiesFromHandle_fn(prop, handle);
  }
}

static hipError_t hipMemGetInfo_callback(size_t* free, size_t* total) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemGetInfo;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemGetInfo.free = free;
    Args.hipMemGetInfo.total = total;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemGetInfo_fn(Args.hipMemGetInfo.free, Args.hipMemGetInfo.total);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemGetInfo_fn(free, total);
  }
}

static hipError_t hipMemImportFromShareableHandle_callback(hipMemGenericAllocationHandle_t* handle, void* osHandle, hipMemAllocationHandleType shHandleType) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemImportFromShareableHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemImportFromShareableHandle.handle = handle;
    Args.hipMemImportFromShareableHandle.osHandle = osHandle;
    Args.hipMemImportFromShareableHandle.shHandleType = shHandleType;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemImportFromShareableHandle_fn(Args.hipMemImportFromShareableHandle.handle, Args.hipMemImportFromShareableHandle.osHandle, Args.hipMemImportFromShareableHandle.shHandleType);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemImportFromShareableHandle_fn(handle, osHandle, shHandleType);
  }
}

static hipError_t hipMemMap_callback(void* ptr, size_t size, size_t offset, hipMemGenericAllocationHandle_t handle, unsigned long long flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemMap;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemMap.ptr = ptr;
    Args.hipMemMap.size = size;
    Args.hipMemMap.offset = offset;
    Args.hipMemMap.handle = handle;
    Args.hipMemMap.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemMap_fn(Args.hipMemMap.ptr, Args.hipMemMap.size, Args.hipMemMap.offset, Args.hipMemMap.handle, Args.hipMemMap.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemMap_fn(ptr, size, offset, handle, flags);
  }
}

static hipError_t hipMemMapArrayAsync_callback(hipArrayMapInfo* mapInfoList, unsigned int count, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemMapArrayAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemMapArrayAsync.mapInfoList = mapInfoList;
    Args.hipMemMapArrayAsync.count = count;
    Args.hipMemMapArrayAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemMapArrayAsync_fn(Args.hipMemMapArrayAsync.mapInfoList, Args.hipMemMapArrayAsync.count, Args.hipMemMapArrayAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemMapArrayAsync_fn(mapInfoList, count, stream);
  }
}

static hipError_t hipMemPoolCreate_callback(hipMemPool_t* mem_pool, const hipMemPoolProps* pool_props) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolCreate.mem_pool = mem_pool;
    Args.hipMemPoolCreate.pool_props = pool_props;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolCreate_fn(Args.hipMemPoolCreate.mem_pool, Args.hipMemPoolCreate.pool_props);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolCreate_fn(mem_pool, pool_props);
  }
}

static hipError_t hipMemPoolDestroy_callback(hipMemPool_t mem_pool) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolDestroy.mem_pool = mem_pool;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolDestroy_fn(Args.hipMemPoolDestroy.mem_pool);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolDestroy_fn(mem_pool);
  }
}

static hipError_t hipMemPoolExportPointer_callback(hipMemPoolPtrExportData* export_data, void* dev_ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolExportPointer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolExportPointer.export_data = export_data;
    Args.hipMemPoolExportPointer.dev_ptr = dev_ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolExportPointer_fn(Args.hipMemPoolExportPointer.export_data, Args.hipMemPoolExportPointer.dev_ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolExportPointer_fn(export_data, dev_ptr);
  }
}

static hipError_t hipMemPoolExportToShareableHandle_callback(void* shared_handle, hipMemPool_t mem_pool, hipMemAllocationHandleType handle_type, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolExportToShareableHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolExportToShareableHandle.shared_handle = shared_handle;
    Args.hipMemPoolExportToShareableHandle.mem_pool = mem_pool;
    Args.hipMemPoolExportToShareableHandle.handle_type = handle_type;
    Args.hipMemPoolExportToShareableHandle.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolExportToShareableHandle_fn(Args.hipMemPoolExportToShareableHandle.shared_handle, Args.hipMemPoolExportToShareableHandle.mem_pool, Args.hipMemPoolExportToShareableHandle.handle_type, Args.hipMemPoolExportToShareableHandle.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolExportToShareableHandle_fn(shared_handle, mem_pool, handle_type, flags);
  }
}

static hipError_t hipMemPoolGetAccess_callback(hipMemAccessFlags* flags, hipMemPool_t mem_pool, hipMemLocation* location) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolGetAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolGetAccess.flags = flags;
    Args.hipMemPoolGetAccess.mem_pool = mem_pool;
    Args.hipMemPoolGetAccess.location = location;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolGetAccess_fn(Args.hipMemPoolGetAccess.flags, Args.hipMemPoolGetAccess.mem_pool, Args.hipMemPoolGetAccess.location);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolGetAccess_fn(flags, mem_pool, location);
  }
}

static hipError_t hipMemPoolGetAttribute_callback(hipMemPool_t mem_pool, hipMemPoolAttr attr, void* value) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolGetAttribute.mem_pool = mem_pool;
    Args.hipMemPoolGetAttribute.attr = attr;
    Args.hipMemPoolGetAttribute.value = value;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolGetAttribute_fn(Args.hipMemPoolGetAttribute.mem_pool, Args.hipMemPoolGetAttribute.attr, Args.hipMemPoolGetAttribute.value);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolGetAttribute_fn(mem_pool, attr, value);
  }
}

static hipError_t hipMemPoolImportFromShareableHandle_callback(hipMemPool_t* mem_pool, void* shared_handle, hipMemAllocationHandleType handle_type, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolImportFromShareableHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolImportFromShareableHandle.mem_pool = mem_pool;
    Args.hipMemPoolImportFromShareableHandle.shared_handle = shared_handle;
    Args.hipMemPoolImportFromShareableHandle.handle_type = handle_type;
    Args.hipMemPoolImportFromShareableHandle.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolImportFromShareableHandle_fn(Args.hipMemPoolImportFromShareableHandle.mem_pool, Args.hipMemPoolImportFromShareableHandle.shared_handle, Args.hipMemPoolImportFromShareableHandle.handle_type, Args.hipMemPoolImportFromShareableHandle.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolImportFromShareableHandle_fn(mem_pool, shared_handle, handle_type, flags);
  }
}

static hipError_t hipMemPoolImportPointer_callback(void** dev_ptr, hipMemPool_t mem_pool, hipMemPoolPtrExportData* export_data) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolImportPointer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolImportPointer.dev_ptr = dev_ptr;
    Args.hipMemPoolImportPointer.mem_pool = mem_pool;
    Args.hipMemPoolImportPointer.export_data = export_data;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolImportPointer_fn(Args.hipMemPoolImportPointer.dev_ptr, Args.hipMemPoolImportPointer.mem_pool, Args.hipMemPoolImportPointer.export_data);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolImportPointer_fn(dev_ptr, mem_pool, export_data);
  }
}

static hipError_t hipMemPoolSetAccess_callback(hipMemPool_t mem_pool, const hipMemAccessDesc* desc_list, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolSetAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolSetAccess.mem_pool = mem_pool;
    Args.hipMemPoolSetAccess.desc_list = desc_list;
    Args.hipMemPoolSetAccess.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolSetAccess_fn(Args.hipMemPoolSetAccess.mem_pool, Args.hipMemPoolSetAccess.desc_list, Args.hipMemPoolSetAccess.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolSetAccess_fn(mem_pool, desc_list, count);
  }
}

static hipError_t hipMemPoolSetAttribute_callback(hipMemPool_t mem_pool, hipMemPoolAttr attr, void* value) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolSetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolSetAttribute.mem_pool = mem_pool;
    Args.hipMemPoolSetAttribute.attr = attr;
    Args.hipMemPoolSetAttribute.value = value;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolSetAttribute_fn(Args.hipMemPoolSetAttribute.mem_pool, Args.hipMemPoolSetAttribute.attr, Args.hipMemPoolSetAttribute.value);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolSetAttribute_fn(mem_pool, attr, value);
  }
}

static hipError_t hipMemPoolTrimTo_callback(hipMemPool_t mem_pool, size_t min_bytes_to_hold) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolTrimTo;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolTrimTo.mem_pool = mem_pool;
    Args.hipMemPoolTrimTo.min_bytes_to_hold = min_bytes_to_hold;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolTrimTo_fn(Args.hipMemPoolTrimTo.mem_pool, Args.hipMemPoolTrimTo.min_bytes_to_hold);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolTrimTo_fn(mem_pool, min_bytes_to_hold);
  }
}

static hipError_t hipMemPrefetchAsync_callback(const void* dev_ptr, size_t count, int device, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPrefetchAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPrefetchAsync.dev_ptr = dev_ptr;
    Args.hipMemPrefetchAsync.count = count;
    Args.hipMemPrefetchAsync.device = device;
    Args.hipMemPrefetchAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPrefetchAsync_fn(Args.hipMemPrefetchAsync.dev_ptr, Args.hipMemPrefetchAsync.count, Args.hipMemPrefetchAsync.device, Args.hipMemPrefetchAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPrefetchAsync_fn(dev_ptr, count, device, stream);
  }
}

static hipError_t hipMemPtrGetInfo_callback(void* ptr, size_t* size) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPtrGetInfo;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPtrGetInfo.ptr = ptr;
    Args.hipMemPtrGetInfo.size = size;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPtrGetInfo_fn(Args.hipMemPtrGetInfo.ptr, Args.hipMemPtrGetInfo.size);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPtrGetInfo_fn(ptr, size);
  }
}

static hipError_t hipMemRangeGetAttribute_callback(void* data, size_t data_size, hipMemRangeAttribute attribute, const void* dev_ptr, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemRangeGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemRangeGetAttribute.data = data;
    Args.hipMemRangeGetAttribute.data_size = data_size;
    Args.hipMemRangeGetAttribute.attribute = attribute;
    Args.hipMemRangeGetAttribute.dev_ptr = dev_ptr;
    Args.hipMemRangeGetAttribute.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemRangeGetAttribute_fn(Args.hipMemRangeGetAttribute.data, Args.hipMemRangeGetAttribute.data_size, Args.hipMemRangeGetAttribute.attribute, Args.hipMemRangeGetAttribute.dev_ptr, Args.hipMemRangeGetAttribute.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemRangeGetAttribute_fn(data, data_size, attribute, dev_ptr, count);
  }
}

static hipError_t hipMemRangeGetAttributes_callback(void** data, size_t* data_sizes, hipMemRangeAttribute* attributes, size_t num_attributes, const void* dev_ptr, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemRangeGetAttributes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemRangeGetAttributes.data = data;
    Args.hipMemRangeGetAttributes.data_sizes = data_sizes;
    Args.hipMemRangeGetAttributes.attributes = attributes;
    Args.hipMemRangeGetAttributes.num_attributes = num_attributes;
    Args.hipMemRangeGetAttributes.dev_ptr = dev_ptr;
    Args.hipMemRangeGetAttributes.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemRangeGetAttributes_fn(Args.hipMemRangeGetAttributes.data, Args.hipMemRangeGetAttributes.data_sizes, Args.hipMemRangeGetAttributes.attributes, Args.hipMemRangeGetAttributes.num_attributes, Args.hipMemRangeGetAttributes.dev_ptr, Args.hipMemRangeGetAttributes.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemRangeGetAttributes_fn(data, data_sizes, attributes, num_attributes, dev_ptr, count);
  }
}

static hipError_t hipMemRelease_callback(hipMemGenericAllocationHandle_t handle) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemRelease;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemRelease.handle = handle;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemRelease_fn(Args.hipMemRelease.handle);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemRelease_fn(handle);
  }
}

static hipError_t hipMemRetainAllocationHandle_callback(hipMemGenericAllocationHandle_t* handle, void* addr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemRetainAllocationHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemRetainAllocationHandle.handle = handle;
    Args.hipMemRetainAllocationHandle.addr = addr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemRetainAllocationHandle_fn(Args.hipMemRetainAllocationHandle.handle, Args.hipMemRetainAllocationHandle.addr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemRetainAllocationHandle_fn(handle, addr);
  }
}

static hipError_t hipMemSetAccess_callback(void* ptr, size_t size, const hipMemAccessDesc* desc, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemSetAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemSetAccess.ptr = ptr;
    Args.hipMemSetAccess.size = size;
    Args.hipMemSetAccess.desc = desc;
    Args.hipMemSetAccess.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemSetAccess_fn(Args.hipMemSetAccess.ptr, Args.hipMemSetAccess.size, Args.hipMemSetAccess.desc, Args.hipMemSetAccess.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemSetAccess_fn(ptr, size, desc, count);
  }
}

static hipError_t hipMemUnmap_callback(void* ptr, size_t size) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemUnmap;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemUnmap.ptr = ptr;
    Args.hipMemUnmap.size = size;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemUnmap_fn(Args.hipMemUnmap.ptr, Args.hipMemUnmap.size);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemUnmap_fn(ptr, size);
  }
}

static hipError_t hipMemcpy_callback(void* dst, const void* src, size_t sizeBytes, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy.dst = dst;
    Args.hipMemcpy.src = src;
    Args.hipMemcpy.sizeBytes = sizeBytes;
    Args.hipMemcpy.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy_fn(Args.hipMemcpy.dst, Args.hipMemcpy.src, Args.hipMemcpy.sizeBytes, Args.hipMemcpy.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy_fn(dst, src, sizeBytes, kind);
  }
}

static hipError_t hipMemcpy2D_callback(void* dst, size_t dpitch, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2D.dst = dst;
    Args.hipMemcpy2D.dpitch = dpitch;
    Args.hipMemcpy2D.src = src;
    Args.hipMemcpy2D.spitch = spitch;
    Args.hipMemcpy2D.width = width;
    Args.hipMemcpy2D.height = height;
    Args.hipMemcpy2D.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2D_fn(Args.hipMemcpy2D.dst, Args.hipMemcpy2D.dpitch, Args.hipMemcpy2D.src, Args.hipMemcpy2D.spitch, Args.hipMemcpy2D.width, Args.hipMemcpy2D.height, Args.hipMemcpy2D.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2D_fn(dst, dpitch, src, spitch, width, height, kind);
  }
}

static hipError_t hipMemcpy2DAsync_callback(void* dst, size_t dpitch, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DAsync.dst = dst;
    Args.hipMemcpy2DAsync.dpitch = dpitch;
    Args.hipMemcpy2DAsync.src = src;
    Args.hipMemcpy2DAsync.spitch = spitch;
    Args.hipMemcpy2DAsync.width = width;
    Args.hipMemcpy2DAsync.height = height;
    Args.hipMemcpy2DAsync.kind = kind;
    Args.hipMemcpy2DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DAsync_fn(Args.hipMemcpy2DAsync.dst, Args.hipMemcpy2DAsync.dpitch, Args.hipMemcpy2DAsync.src, Args.hipMemcpy2DAsync.spitch, Args.hipMemcpy2DAsync.width, Args.hipMemcpy2DAsync.height, Args.hipMemcpy2DAsync.kind, Args.hipMemcpy2DAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DAsync_fn(dst, dpitch, src, spitch, width, height, kind, stream);
  }
}

static hipError_t hipMemcpy2DFromArray_callback(void* dst, size_t dpitch, hipArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DFromArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DFromArray.dst = dst;
    Args.hipMemcpy2DFromArray.dpitch = dpitch;
    Args.hipMemcpy2DFromArray.src = src;
    Args.hipMemcpy2DFromArray.wOffset = wOffset;
    Args.hipMemcpy2DFromArray.hOffset = hOffset;
    Args.hipMemcpy2DFromArray.width = width;
    Args.hipMemcpy2DFromArray.height = height;
    Args.hipMemcpy2DFromArray.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DFromArray_fn(Args.hipMemcpy2DFromArray.dst, Args.hipMemcpy2DFromArray.dpitch, Args.hipMemcpy2DFromArray.src, Args.hipMemcpy2DFromArray.wOffset, Args.hipMemcpy2DFromArray.hOffset, Args.hipMemcpy2DFromArray.width, Args.hipMemcpy2DFromArray.height, Args.hipMemcpy2DFromArray.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DFromArray_fn(dst, dpitch, src, wOffset, hOffset, width, height, kind);
  }
}

static hipError_t hipMemcpy2DFromArrayAsync_callback(void* dst, size_t dpitch, hipArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DFromArrayAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DFromArrayAsync.dst = dst;
    Args.hipMemcpy2DFromArrayAsync.dpitch = dpitch;
    Args.hipMemcpy2DFromArrayAsync.src = src;
    Args.hipMemcpy2DFromArrayAsync.wOffset = wOffset;
    Args.hipMemcpy2DFromArrayAsync.hOffset = hOffset;
    Args.hipMemcpy2DFromArrayAsync.width = width;
    Args.hipMemcpy2DFromArrayAsync.height = height;
    Args.hipMemcpy2DFromArrayAsync.kind = kind;
    Args.hipMemcpy2DFromArrayAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DFromArrayAsync_fn(Args.hipMemcpy2DFromArrayAsync.dst, Args.hipMemcpy2DFromArrayAsync.dpitch, Args.hipMemcpy2DFromArrayAsync.src, Args.hipMemcpy2DFromArrayAsync.wOffset, Args.hipMemcpy2DFromArrayAsync.hOffset, Args.hipMemcpy2DFromArrayAsync.width, Args.hipMemcpy2DFromArrayAsync.height, Args.hipMemcpy2DFromArrayAsync.kind, Args.hipMemcpy2DFromArrayAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DFromArrayAsync_fn(dst, dpitch, src, wOffset, hOffset, width, height, kind, stream);
  }
}

static hipError_t hipMemcpy2DToArray_callback(hipArray_t dst, size_t wOffset, size_t hOffset, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DToArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DToArray.dst = dst;
    Args.hipMemcpy2DToArray.wOffset = wOffset;
    Args.hipMemcpy2DToArray.hOffset = hOffset;
    Args.hipMemcpy2DToArray.src = src;
    Args.hipMemcpy2DToArray.spitch = spitch;
    Args.hipMemcpy2DToArray.width = width;
    Args.hipMemcpy2DToArray.height = height;
    Args.hipMemcpy2DToArray.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DToArray_fn(Args.hipMemcpy2DToArray.dst, Args.hipMemcpy2DToArray.wOffset, Args.hipMemcpy2DToArray.hOffset, Args.hipMemcpy2DToArray.src, Args.hipMemcpy2DToArray.spitch, Args.hipMemcpy2DToArray.width, Args.hipMemcpy2DToArray.height, Args.hipMemcpy2DToArray.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DToArray_fn(dst, wOffset, hOffset, src, spitch, width, height, kind);
  }
}

static hipError_t hipMemcpy2DToArrayAsync_callback(hipArray_t dst, size_t wOffset, size_t hOffset, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DToArrayAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DToArrayAsync.dst = dst;
    Args.hipMemcpy2DToArrayAsync.wOffset = wOffset;
    Args.hipMemcpy2DToArrayAsync.hOffset = hOffset;
    Args.hipMemcpy2DToArrayAsync.src = src;
    Args.hipMemcpy2DToArrayAsync.spitch = spitch;
    Args.hipMemcpy2DToArrayAsync.width = width;
    Args.hipMemcpy2DToArrayAsync.height = height;
    Args.hipMemcpy2DToArrayAsync.kind = kind;
    Args.hipMemcpy2DToArrayAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DToArrayAsync_fn(Args.hipMemcpy2DToArrayAsync.dst, Args.hipMemcpy2DToArrayAsync.wOffset, Args.hipMemcpy2DToArrayAsync.hOffset, Args.hipMemcpy2DToArrayAsync.src, Args.hipMemcpy2DToArrayAsync.spitch, Args.hipMemcpy2DToArrayAsync.width, Args.hipMemcpy2DToArrayAsync.height, Args.hipMemcpy2DToArrayAsync.kind, Args.hipMemcpy2DToArrayAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DToArrayAsync_fn(dst, wOffset, hOffset, src, spitch, width, height, kind, stream);
  }
}

static hipError_t hipMemcpy3D_callback(const struct hipMemcpy3DParms* p) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy3D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy3D.p = p;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy3D_fn(Args.hipMemcpy3D.p);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy3D_fn(p);
  }
}

static hipError_t hipMemcpy3DAsync_callback(const struct hipMemcpy3DParms* p, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy3DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy3DAsync.p = p;
    Args.hipMemcpy3DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy3DAsync_fn(Args.hipMemcpy3DAsync.p, Args.hipMemcpy3DAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy3DAsync_fn(p, stream);
  }
}

static hipError_t hipMemcpyAsync_callback(void* dst, const void* src, size_t sizeBytes, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyAsync.dst = dst;
    Args.hipMemcpyAsync.src = src;
    Args.hipMemcpyAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyAsync.kind = kind;
    Args.hipMemcpyAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyAsync_fn(Args.hipMemcpyAsync.dst, Args.hipMemcpyAsync.src, Args.hipMemcpyAsync.sizeBytes, Args.hipMemcpyAsync.kind, Args.hipMemcpyAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyAsync_fn(dst, src, sizeBytes, kind, stream);
  }
}

static hipError_t hipMemcpyAtoH_callback(void* dst, hipArray_t srcArray, size_t srcOffset, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyAtoH;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyAtoH.dst = dst;
    Args.hipMemcpyAtoH.srcArray = srcArray;
    Args.hipMemcpyAtoH.srcOffset = srcOffset;
    Args.hipMemcpyAtoH.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyAtoH_fn(Args.hipMemcpyAtoH.dst, Args.hipMemcpyAtoH.srcArray, Args.hipMemcpyAtoH.srcOffset, Args.hipMemcpyAtoH.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyAtoH_fn(dst, srcArray, srcOffset, count);
  }
}

static hipError_t hipMemcpyDtoD_callback(hipDeviceptr_t dst, hipDeviceptr_t src, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyDtoD;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyDtoD.dst = dst;
    Args.hipMemcpyDtoD.src = src;
    Args.hipMemcpyDtoD.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyDtoD_fn(Args.hipMemcpyDtoD.dst, Args.hipMemcpyDtoD.src, Args.hipMemcpyDtoD.sizeBytes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyDtoD_fn(dst, src, sizeBytes);
  }
}

static hipError_t hipMemcpyDtoDAsync_callback(hipDeviceptr_t dst, hipDeviceptr_t src, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyDtoDAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyDtoDAsync.dst = dst;
    Args.hipMemcpyDtoDAsync.src = src;
    Args.hipMemcpyDtoDAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyDtoDAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyDtoDAsync_fn(Args.hipMemcpyDtoDAsync.dst, Args.hipMemcpyDtoDAsync.src, Args.hipMemcpyDtoDAsync.sizeBytes, Args.hipMemcpyDtoDAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyDtoDAsync_fn(dst, src, sizeBytes, stream);
  }
}

static hipError_t hipMemcpyDtoH_callback(void* dst, hipDeviceptr_t src, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyDtoH;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyDtoH.dst = dst;
    Args.hipMemcpyDtoH.src = src;
    Args.hipMemcpyDtoH.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyDtoH_fn(Args.hipMemcpyDtoH.dst, Args.hipMemcpyDtoH.src, Args.hipMemcpyDtoH.sizeBytes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyDtoH_fn(dst, src, sizeBytes);
  }
}

static hipError_t hipMemcpyDtoHAsync_callback(void* dst, hipDeviceptr_t src, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyDtoHAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyDtoHAsync.dst = dst;
    Args.hipMemcpyDtoHAsync.src = src;
    Args.hipMemcpyDtoHAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyDtoHAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyDtoHAsync_fn(Args.hipMemcpyDtoHAsync.dst, Args.hipMemcpyDtoHAsync.src, Args.hipMemcpyDtoHAsync.sizeBytes, Args.hipMemcpyDtoHAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyDtoHAsync_fn(dst, src, sizeBytes, stream);
  }
}

static hipError_t hipMemcpyFromArray_callback(void* dst, hipArray_const_t srcArray, size_t wOffset, size_t hOffset, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyFromArray.dst = dst;
    Args.hipMemcpyFromArray.srcArray = srcArray;
    Args.hipMemcpyFromArray.wOffset = wOffset;
    Args.hipMemcpyFromArray.hOffset = hOffset;
    Args.hipMemcpyFromArray.count = count;
    Args.hipMemcpyFromArray.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyFromArray_fn(Args.hipMemcpyFromArray.dst, Args.hipMemcpyFromArray.srcArray, Args.hipMemcpyFromArray.wOffset, Args.hipMemcpyFromArray.hOffset, Args.hipMemcpyFromArray.count, Args.hipMemcpyFromArray.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyFromArray_fn(dst, srcArray, wOffset, hOffset, count, kind);
  }
}

static hipError_t hipMemcpyFromSymbol_callback(void* dst, const void* symbol, size_t sizeBytes, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyFromSymbol.dst = dst;
    Args.hipMemcpyFromSymbol.symbol = symbol;
    Args.hipMemcpyFromSymbol.sizeBytes = sizeBytes;
    Args.hipMemcpyFromSymbol.offset = offset;
    Args.hipMemcpyFromSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyFromSymbol_fn(Args.hipMemcpyFromSymbol.dst, Args.hipMemcpyFromSymbol.symbol, Args.hipMemcpyFromSymbol.sizeBytes, Args.hipMemcpyFromSymbol.offset, Args.hipMemcpyFromSymbol.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyFromSymbol_fn(dst, symbol, sizeBytes, offset, kind);
  }
}

static hipError_t hipMemcpyFromSymbolAsync_callback(void* dst, const void* symbol, size_t sizeBytes, size_t offset, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromSymbolAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyFromSymbolAsync.dst = dst;
    Args.hipMemcpyFromSymbolAsync.symbol = symbol;
    Args.hipMemcpyFromSymbolAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyFromSymbolAsync.offset = offset;
    Args.hipMemcpyFromSymbolAsync.kind = kind;
    Args.hipMemcpyFromSymbolAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyFromSymbolAsync_fn(Args.hipMemcpyFromSymbolAsync.dst, Args.hipMemcpyFromSymbolAsync.symbol, Args.hipMemcpyFromSymbolAsync.sizeBytes, Args.hipMemcpyFromSymbolAsync.offset, Args.hipMemcpyFromSymbolAsync.kind, Args.hipMemcpyFromSymbolAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyFromSymbolAsync_fn(dst, symbol, sizeBytes, offset, kind, stream);
  }
}

static hipError_t hipMemcpyHtoA_callback(hipArray_t dstArray, size_t dstOffset, const void* srcHost, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyHtoA;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyHtoA.dstArray = dstArray;
    Args.hipMemcpyHtoA.dstOffset = dstOffset;
    Args.hipMemcpyHtoA.srcHost = srcHost;
    Args.hipMemcpyHtoA.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyHtoA_fn(Args.hipMemcpyHtoA.dstArray, Args.hipMemcpyHtoA.dstOffset, Args.hipMemcpyHtoA.srcHost, Args.hipMemcpyHtoA.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyHtoA_fn(dstArray, dstOffset, srcHost, count);
  }
}

static hipError_t hipMemcpyHtoD_callback(hipDeviceptr_t dst, void* src, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyHtoD;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyHtoD.dst = dst;
    Args.hipMemcpyHtoD.src = src;
    Args.hipMemcpyHtoD.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyHtoD_fn(Args.hipMemcpyHtoD.dst, Args.hipMemcpyHtoD.src, Args.hipMemcpyHtoD.sizeBytes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyHtoD_fn(dst, src, sizeBytes);
  }
}

static hipError_t hipMemcpyHtoDAsync_callback(hipDeviceptr_t dst, void* src, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyHtoDAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyHtoDAsync.dst = dst;
    Args.hipMemcpyHtoDAsync.src = src;
    Args.hipMemcpyHtoDAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyHtoDAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyHtoDAsync_fn(Args.hipMemcpyHtoDAsync.dst, Args.hipMemcpyHtoDAsync.src, Args.hipMemcpyHtoDAsync.sizeBytes, Args.hipMemcpyHtoDAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyHtoDAsync_fn(dst, src, sizeBytes, stream);
  }
}

static hipError_t hipMemcpyParam2D_callback(const hip_Memcpy2D* pCopy) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyParam2D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyParam2D.pCopy = pCopy;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyParam2D_fn(Args.hipMemcpyParam2D.pCopy);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyParam2D_fn(pCopy);
  }
}

static hipError_t hipMemcpyParam2DAsync_callback(const hip_Memcpy2D* pCopy, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyParam2DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyParam2DAsync.pCopy = pCopy;
    Args.hipMemcpyParam2DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyParam2DAsync_fn(Args.hipMemcpyParam2DAsync.pCopy, Args.hipMemcpyParam2DAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyParam2DAsync_fn(pCopy, stream);
  }
}

static hipError_t hipMemcpyPeer_callback(void* dst, int dstDeviceId, const void* src, int srcDeviceId, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyPeer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyPeer.dst = dst;
    Args.hipMemcpyPeer.dstDeviceId = dstDeviceId;
    Args.hipMemcpyPeer.src = src;
    Args.hipMemcpyPeer.srcDeviceId = srcDeviceId;
    Args.hipMemcpyPeer.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyPeer_fn(Args.hipMemcpyPeer.dst, Args.hipMemcpyPeer.dstDeviceId, Args.hipMemcpyPeer.src, Args.hipMemcpyPeer.srcDeviceId, Args.hipMemcpyPeer.sizeBytes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyPeer_fn(dst, dstDeviceId, src, srcDeviceId, sizeBytes);
  }
}

static hipError_t hipMemcpyPeerAsync_callback(void* dst, int dstDeviceId, const void* src, int srcDevice, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyPeerAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyPeerAsync.dst = dst;
    Args.hipMemcpyPeerAsync.dstDeviceId = dstDeviceId;
    Args.hipMemcpyPeerAsync.src = src;
    Args.hipMemcpyPeerAsync.srcDevice = srcDevice;
    Args.hipMemcpyPeerAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyPeerAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyPeerAsync_fn(Args.hipMemcpyPeerAsync.dst, Args.hipMemcpyPeerAsync.dstDeviceId, Args.hipMemcpyPeerAsync.src, Args.hipMemcpyPeerAsync.srcDevice, Args.hipMemcpyPeerAsync.sizeBytes, Args.hipMemcpyPeerAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyPeerAsync_fn(dst, dstDeviceId, src, srcDevice, sizeBytes, stream);
  }
}

static hipError_t hipMemcpyToArray_callback(hipArray_t dst, size_t wOffset, size_t hOffset, const void* src, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyToArray.dst = dst;
    Args.hipMemcpyToArray.wOffset = wOffset;
    Args.hipMemcpyToArray.hOffset = hOffset;
    Args.hipMemcpyToArray.src = src;
    Args.hipMemcpyToArray.count = count;
    Args.hipMemcpyToArray.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyToArray_fn(Args.hipMemcpyToArray.dst, Args.hipMemcpyToArray.wOffset, Args.hipMemcpyToArray.hOffset, Args.hipMemcpyToArray.src, Args.hipMemcpyToArray.count, Args.hipMemcpyToArray.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyToArray_fn(dst, wOffset, hOffset, src, count, kind);
  }
}

static hipError_t hipMemcpyToSymbol_callback(const void* symbol, const void* src, size_t sizeBytes, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyToSymbol.symbol = symbol;
    Args.hipMemcpyToSymbol.src = src;
    Args.hipMemcpyToSymbol.sizeBytes = sizeBytes;
    Args.hipMemcpyToSymbol.offset = offset;
    Args.hipMemcpyToSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyToSymbol_fn(Args.hipMemcpyToSymbol.symbol, Args.hipMemcpyToSymbol.src, Args.hipMemcpyToSymbol.sizeBytes, Args.hipMemcpyToSymbol.offset, Args.hipMemcpyToSymbol.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyToSymbol_fn(symbol, src, sizeBytes, offset, kind);
  }
}

static hipError_t hipMemcpyToSymbolAsync_callback(const void* symbol, const void* src, size_t sizeBytes, size_t offset, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToSymbolAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyToSymbolAsync.symbol = symbol;
    Args.hipMemcpyToSymbolAsync.src = src;
    Args.hipMemcpyToSymbolAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyToSymbolAsync.offset = offset;
    Args.hipMemcpyToSymbolAsync.kind = kind;
    Args.hipMemcpyToSymbolAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyToSymbolAsync_fn(Args.hipMemcpyToSymbolAsync.symbol, Args.hipMemcpyToSymbolAsync.src, Args.hipMemcpyToSymbolAsync.sizeBytes, Args.hipMemcpyToSymbolAsync.offset, Args.hipMemcpyToSymbolAsync.kind, Args.hipMemcpyToSymbolAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyToSymbolAsync_fn(symbol, src, sizeBytes, offset, kind, stream);
  }
}

static hipError_t hipMemcpyWithStream_callback(void* dst, const void* src, size_t sizeBytes, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyWithStream;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyWithStream.dst = dst;
    Args.hipMemcpyWithStream.src = src;
    Args.hipMemcpyWithStream.sizeBytes = sizeBytes;
    Args.hipMemcpyWithStream.kind = kind;
    Args.hipMemcpyWithStream.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyWithStream_fn(Args.hipMemcpyWithStream.dst, Args.hipMemcpyWithStream.src, Args.hipMemcpyWithStream.sizeBytes, Args.hipMemcpyWithStream.kind, Args.hipMemcpyWithStream.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyWithStream_fn(dst, src, sizeBytes, kind, stream);
  }
}

static hipError_t hipMemset_callback(void* dst, int value, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset.dst = dst;
    Args.hipMemset.value = value;
    Args.hipMemset.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset_fn(Args.hipMemset.dst, Args.hipMemset.value, Args.hipMemset.sizeBytes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset_fn(dst, value, sizeBytes);
  }
}

static hipError_t hipMemset2D_callback(void* dst, size_t pitch, int value, size_t width, size_t height) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset2D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset2D.dst = dst;
    Args.hipMemset2D.pitch = pitch;
    Args.hipMemset2D.value = value;
    Args.hipMemset2D.width = width;
    Args.hipMemset2D.height = height;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset2D_fn(Args.hipMemset2D.dst, Args.hipMemset2D.pitch, Args.hipMemset2D.value, Args.hipMemset2D.width, Args.hipMemset2D.height);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset2D_fn(dst, pitch, value, width, height);
  }
}

static hipError_t hipMemset2DAsync_callback(void* dst, size_t pitch, int value, size_t width, size_t height, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset2DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset2DAsync.dst = dst;
    Args.hipMemset2DAsync.pitch = pitch;
    Args.hipMemset2DAsync.value = value;
    Args.hipMemset2DAsync.width = width;
    Args.hipMemset2DAsync.height = height;
    Args.hipMemset2DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset2DAsync_fn(Args.hipMemset2DAsync.dst, Args.hipMemset2DAsync.pitch, Args.hipMemset2DAsync.value, Args.hipMemset2DAsync.width, Args.hipMemset2DAsync.height, Args.hipMemset2DAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset2DAsync_fn(dst, pitch, value, width, height, stream);
  }
}

static hipError_t hipMemset3D_callback(hipPitchedPtr pitchedDevPtr, int value, hipExtent extent) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset3D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset3D.pitchedDevPtr = pitchedDevPtr;
    Args.hipMemset3D.value = value;
    Args.hipMemset3D.extent = extent;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset3D_fn(Args.hipMemset3D.pitchedDevPtr, Args.hipMemset3D.value, Args.hipMemset3D.extent);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset3D_fn(pitchedDevPtr, value, extent);
  }
}

static hipError_t hipMemset3DAsync_callback(hipPitchedPtr pitchedDevPtr, int value, hipExtent extent, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset3DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset3DAsync.pitchedDevPtr = pitchedDevPtr;
    Args.hipMemset3DAsync.value = value;
    Args.hipMemset3DAsync.extent = extent;
    Args.hipMemset3DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset3DAsync_fn(Args.hipMemset3DAsync.pitchedDevPtr, Args.hipMemset3DAsync.value, Args.hipMemset3DAsync.extent, Args.hipMemset3DAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset3DAsync_fn(pitchedDevPtr, value, extent, stream);
  }
}

static hipError_t hipMemsetAsync_callback(void* dst, int value, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemsetAsync.dst = dst;
    Args.hipMemsetAsync.value = value;
    Args.hipMemsetAsync.sizeBytes = sizeBytes;
    Args.hipMemsetAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemsetAsync_fn(Args.hipMemsetAsync.dst, Args.hipMemsetAsync.value, Args.hipMemsetAsync.sizeBytes, Args.hipMemsetAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemsetAsync_fn(dst, value, sizeBytes, stream);
  }
}

static hipError_t hipMemsetD16_callback(hipDeviceptr_t dest, unsigned short value, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD16;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemsetD16.dest = dest;
    Args.hipMemsetD16.value = value;
    Args.hipMemsetD16.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemsetD16_fn(Args.hipMemsetD16.dest, Args.hipMemsetD16.value, Args.hipMemsetD16.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemsetD16_fn(dest, value, count);
  }
}

static hipError_t hipMemsetD16Async_callback(hipDeviceptr_t dest, unsigned short value, size_t count, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD16Async;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemsetD16Async.dest = dest;
    Args.hipMemsetD16Async.value = value;
    Args.hipMemsetD16Async.count = count;
    Args.hipMemsetD16Async.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemsetD16Async_fn(Args.hipMemsetD16Async.dest, Args.hipMemsetD16Async.value, Args.hipMemsetD16Async.count, Args.hipMemsetD16Async.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemsetD16Async_fn(dest, value, count, stream);
  }
}

static hipError_t hipMemsetD32_callback(hipDeviceptr_t dest, int value, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD32;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemsetD32.dest = dest;
    Args.hipMemsetD32.value = value;
    Args.hipMemsetD32.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemsetD32_fn(Args.hipMemsetD32.dest, Args.hipMemsetD32.value, Args.hipMemsetD32.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemsetD32_fn(dest, value, count);
  }
}

static hipError_t hipMemsetD32Async_callback(hipDeviceptr_t dst, int value, size_t count, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD32Async;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemsetD32Async.dst = dst;
    Args.hipMemsetD32Async.value = value;
    Args.hipMemsetD32Async.count = count;
    Args.hipMemsetD32Async.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemsetD32Async_fn(Args.hipMemsetD32Async.dst, Args.hipMemsetD32Async.value, Args.hipMemsetD32Async.count, Args.hipMemsetD32Async.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemsetD32Async_fn(dst, value, count, stream);
  }
}

static hipError_t hipMemsetD8_callback(hipDeviceptr_t dest, unsigned char value, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD8;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemsetD8.dest = dest;
    Args.hipMemsetD8.value = value;
    Args.hipMemsetD8.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemsetD8_fn(Args.hipMemsetD8.dest, Args.hipMemsetD8.value, Args.hipMemsetD8.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemsetD8_fn(dest, value, count);
  }
}

static hipError_t hipMemsetD8Async_callback(hipDeviceptr_t dest, unsigned char value, size_t count, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD8Async;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemsetD8Async.dest = dest;
    Args.hipMemsetD8Async.value = value;
    Args.hipMemsetD8Async.count = count;
    Args.hipMemsetD8Async.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemsetD8Async_fn(Args.hipMemsetD8Async.dest, Args.hipMemsetD8Async.value, Args.hipMemsetD8Async.count, Args.hipMemsetD8Async.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemsetD8Async_fn(dest, value, count, stream);
  }
}

static hipError_t hipMipmappedArrayCreate_callback(hipMipmappedArray_t* pHandle, HIP_ARRAY3D_DESCRIPTOR* pMipmappedArrayDesc, unsigned int numMipmapLevels) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMipmappedArrayCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMipmappedArrayCreate.pHandle = pHandle;
    Args.hipMipmappedArrayCreate.pMipmappedArrayDesc = pMipmappedArrayDesc;
    Args.hipMipmappedArrayCreate.numMipmapLevels = numMipmapLevels;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMipmappedArrayCreate_fn(Args.hipMipmappedArrayCreate.pHandle, Args.hipMipmappedArrayCreate.pMipmappedArrayDesc, Args.hipMipmappedArrayCreate.numMipmapLevels);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMipmappedArrayCreate_fn(pHandle, pMipmappedArrayDesc, numMipmapLevels);
  }
}

static hipError_t hipMipmappedArrayDestroy_callback(hipMipmappedArray_t hMipmappedArray) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMipmappedArrayDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMipmappedArrayDestroy.hMipmappedArray = hMipmappedArray;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMipmappedArrayDestroy_fn(Args.hipMipmappedArrayDestroy.hMipmappedArray);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMipmappedArrayDestroy_fn(hMipmappedArray);
  }
}

static hipError_t hipMipmappedArrayGetLevel_callback(hipArray_t* pLevelArray, hipMipmappedArray_t hMipMappedArray, unsigned int level) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMipmappedArrayGetLevel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMipmappedArrayGetLevel.pLevelArray = pLevelArray;
    Args.hipMipmappedArrayGetLevel.hMipMappedArray = hMipMappedArray;
    Args.hipMipmappedArrayGetLevel.level = level;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMipmappedArrayGetLevel_fn(Args.hipMipmappedArrayGetLevel.pLevelArray, Args.hipMipmappedArrayGetLevel.hMipMappedArray, Args.hipMipmappedArrayGetLevel.level);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMipmappedArrayGetLevel_fn(pLevelArray, hMipMappedArray, level);
  }
}

static hipError_t hipModuleGetFunction_callback(hipFunction_t* function, hipModule_t module, const char* kname) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleGetFunction;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleGetFunction.function = function;
    Args.hipModuleGetFunction.module = module;
    Args.hipModuleGetFunction.kname = kname;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleGetFunction_fn(Args.hipModuleGetFunction.function, Args.hipModuleGetFunction.module, Args.hipModuleGetFunction.kname);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleGetFunction_fn(function, module, kname);
  }
}

static hipError_t hipModuleGetGlobal_callback(hipDeviceptr_t* dptr, size_t* bytes, hipModule_t hmod, const char* name) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleGetGlobal;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleGetGlobal.dptr = dptr;
    Args.hipModuleGetGlobal.bytes = bytes;
    Args.hipModuleGetGlobal.hmod = hmod;
    Args.hipModuleGetGlobal.name = name;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleGetGlobal_fn(Args.hipModuleGetGlobal.dptr, Args.hipModuleGetGlobal.bytes, Args.hipModuleGetGlobal.hmod, Args.hipModuleGetGlobal.name);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleGetGlobal_fn(dptr, bytes, hmod, name);
  }
}

static hipError_t hipModuleGetTexRef_callback(textureReference** texRef, hipModule_t hmod, const char* name) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleGetTexRef;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleGetTexRef.texRef = texRef;
    Args.hipModuleGetTexRef.hmod = hmod;
    Args.hipModuleGetTexRef.name = name;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleGetTexRef_fn(Args.hipModuleGetTexRef.texRef, Args.hipModuleGetTexRef.hmod, Args.hipModuleGetTexRef.name);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleGetTexRef_fn(texRef, hmod, name);
  }
}

static hipError_t hipModuleLaunchCooperativeKernelMultiDevice_callback(hipFunctionLaunchParams* launchParamsList, unsigned int numDevices, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleLaunchCooperativeKernelMultiDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleLaunchCooperativeKernelMultiDevice.launchParamsList = launchParamsList;
    Args.hipModuleLaunchCooperativeKernelMultiDevice.numDevices = numDevices;
    Args.hipModuleLaunchCooperativeKernelMultiDevice.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleLaunchCooperativeKernelMultiDevice_fn(Args.hipModuleLaunchCooperativeKernelMultiDevice.launchParamsList, Args.hipModuleLaunchCooperativeKernelMultiDevice.numDevices, Args.hipModuleLaunchCooperativeKernelMultiDevice.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleLaunchCooperativeKernelMultiDevice_fn(launchParamsList, numDevices, flags);
  }
}

static hipError_t hipModuleLoad_callback(hipModule_t* module, const char* fname) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleLoad;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleLoad.module = module;
    Args.hipModuleLoad.fname = fname;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleLoad_fn(Args.hipModuleLoad.module, Args.hipModuleLoad.fname);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleLoad_fn(module, fname);
  }
}

static hipError_t hipModuleLoadData_callback(hipModule_t* module, const void* image) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleLoadData;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleLoadData.module = module;
    Args.hipModuleLoadData.image = image;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleLoadData_fn(Args.hipModuleLoadData.module, Args.hipModuleLoadData.image);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleLoadData_fn(module, image);
  }
}

static hipError_t hipModuleLoadDataEx_callback(hipModule_t* module, const void* image, unsigned int numOptions, hipJitOption* options, void** optionValues) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleLoadDataEx;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleLoadDataEx.module = module;
    Args.hipModuleLoadDataEx.image = image;
    Args.hipModuleLoadDataEx.numOptions = numOptions;
    Args.hipModuleLoadDataEx.options = options;
    Args.hipModuleLoadDataEx.optionValues = optionValues;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleLoadDataEx_fn(Args.hipModuleLoadDataEx.module, Args.hipModuleLoadDataEx.image, Args.hipModuleLoadDataEx.numOptions, Args.hipModuleLoadDataEx.options, Args.hipModuleLoadDataEx.optionValues);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleLoadDataEx_fn(module, image, numOptions, options, optionValues);
  }
}

static hipError_t hipModuleUnload_callback(hipModule_t module) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleUnload;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleUnload.module = module;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleUnload_fn(Args.hipModuleUnload.module);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleUnload_fn(module);
  }
}

static hipError_t hipPeekAtLastError_callback() {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipPeekAtLastError;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipPeekAtLastError_fn();
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipPeekAtLastError_fn();
  }
}

static hipError_t hipPointerGetAttribute_callback(void* data, hipPointer_attribute attribute, hipDeviceptr_t ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipPointerGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipPointerGetAttribute.data = data;
    Args.hipPointerGetAttribute.attribute = attribute;
    Args.hipPointerGetAttribute.ptr = ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipPointerGetAttribute_fn(Args.hipPointerGetAttribute.data, Args.hipPointerGetAttribute.attribute, Args.hipPointerGetAttribute.ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipPointerGetAttribute_fn(data, attribute, ptr);
  }
}

static hipError_t hipPointerGetAttributes_callback(hipPointerAttribute_t* attributes, const void* ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipPointerGetAttributes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipPointerGetAttributes.attributes = attributes;
    Args.hipPointerGetAttributes.ptr = ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipPointerGetAttributes_fn(Args.hipPointerGetAttributes.attributes, Args.hipPointerGetAttributes.ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipPointerGetAttributes_fn(attributes, ptr);
  }
}

static hipError_t hipPointerSetAttribute_callback(const void* value, hipPointer_attribute attribute, hipDeviceptr_t ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipPointerSetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipPointerSetAttribute.value = value;
    Args.hipPointerSetAttribute.attribute = attribute;
    Args.hipPointerSetAttribute.ptr = ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipPointerSetAttribute_fn(Args.hipPointerSetAttribute.value, Args.hipPointerSetAttribute.attribute, Args.hipPointerSetAttribute.ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipPointerSetAttribute_fn(value, attribute, ptr);
  }
}

static hipError_t hipProfilerStart_callback() {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipProfilerStart;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipProfilerStart_fn();
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipProfilerStart_fn();
  }
}

static hipError_t hipProfilerStop_callback() {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipProfilerStop;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipProfilerStop_fn();
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipProfilerStop_fn();
  }
}

static hipError_t hipRuntimeGetVersion_callback(int* runtimeVersion) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipRuntimeGetVersion;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipRuntimeGetVersion.runtimeVersion = runtimeVersion;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipRuntimeGetVersion_fn(Args.hipRuntimeGetVersion.runtimeVersion);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipRuntimeGetVersion_fn(runtimeVersion);
  }
}

static hipError_t hipSetDevice_callback(int deviceId) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipSetDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipSetDevice.deviceId = deviceId;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipSetDevice_fn(Args.hipSetDevice.deviceId);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipSetDevice_fn(deviceId);
  }
}

static hipError_t hipSetDeviceFlags_callback(unsigned flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipSetDeviceFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipSetDeviceFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipSetDeviceFlags_fn(Args.hipSetDeviceFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipSetDeviceFlags_fn(flags);
  }
}

static hipError_t hipSetupArgument_callback(const void* arg, size_t size, size_t offset) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipSetupArgument;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipSetupArgument.arg = arg;
    Args.hipSetupArgument.size = size;
    Args.hipSetupArgument.offset = offset;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipSetupArgument_fn(Args.hipSetupArgument.arg, Args.hipSetupArgument.size, Args.hipSetupArgument.offset);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipSetupArgument_fn(arg, size, offset);
  }
}

static hipError_t hipSignalExternalSemaphoresAsync_callback(const hipExternalSemaphore_t* extSemArray, const hipExternalSemaphoreSignalParams* paramsArray, unsigned int numExtSems, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipSignalExternalSemaphoresAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipSignalExternalSemaphoresAsync.extSemArray = extSemArray;
    Args.hipSignalExternalSemaphoresAsync.paramsArray = paramsArray;
    Args.hipSignalExternalSemaphoresAsync.numExtSems = numExtSems;
    Args.hipSignalExternalSemaphoresAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipSignalExternalSemaphoresAsync_fn(Args.hipSignalExternalSemaphoresAsync.extSemArray, Args.hipSignalExternalSemaphoresAsync.paramsArray, Args.hipSignalExternalSemaphoresAsync.numExtSems, Args.hipSignalExternalSemaphoresAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipSignalExternalSemaphoresAsync_fn(extSemArray, paramsArray, numExtSems, stream);
  }
}

static hipError_t hipStreamAddCallback_callback(hipStream_t stream, hipStreamCallback_t callback, void* userData, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamAddCallback;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamAddCallback.stream = stream;
    Args.hipStreamAddCallback.callback = callback;
    Args.hipStreamAddCallback.userData = userData;
    Args.hipStreamAddCallback.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamAddCallback_fn(Args.hipStreamAddCallback.stream, Args.hipStreamAddCallback.callback, Args.hipStreamAddCallback.userData, Args.hipStreamAddCallback.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamAddCallback_fn(stream, callback, userData, flags);
  }
}

static hipError_t hipStreamAttachMemAsync_callback(hipStream_t stream, void* dev_ptr, size_t length, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamAttachMemAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamAttachMemAsync.stream = stream;
    Args.hipStreamAttachMemAsync.dev_ptr = dev_ptr;
    Args.hipStreamAttachMemAsync.length = length;
    Args.hipStreamAttachMemAsync.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamAttachMemAsync_fn(Args.hipStreamAttachMemAsync.stream, Args.hipStreamAttachMemAsync.dev_ptr, Args.hipStreamAttachMemAsync.length, Args.hipStreamAttachMemAsync.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamAttachMemAsync_fn(stream, dev_ptr, length, flags);
  }
}

static hipError_t hipStreamBeginCapture_callback(hipStream_t stream, hipStreamCaptureMode mode) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamBeginCapture;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamBeginCapture.stream = stream;
    Args.hipStreamBeginCapture.mode = mode;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamBeginCapture_fn(Args.hipStreamBeginCapture.stream, Args.hipStreamBeginCapture.mode);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamBeginCapture_fn(stream, mode);
  }
}

static hipError_t hipStreamCreate_callback(hipStream_t* stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamCreate.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamCreate_fn(Args.hipStreamCreate.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamCreate_fn(stream);
  }
}

static hipError_t hipStreamCreateWithFlags_callback(hipStream_t* stream, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamCreateWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamCreateWithFlags.stream = stream;
    Args.hipStreamCreateWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamCreateWithFlags_fn(Args.hipStreamCreateWithFlags.stream, Args.hipStreamCreateWithFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamCreateWithFlags_fn(stream, flags);
  }
}

static hipError_t hipStreamCreateWithPriority_callback(hipStream_t* stream, unsigned int flags, int priority) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamCreateWithPriority;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamCreateWithPriority.stream = stream;
    Args.hipStreamCreateWithPriority.flags = flags;
    Args.hipStreamCreateWithPriority.priority = priority;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamCreateWithPriority_fn(Args.hipStreamCreateWithPriority.stream, Args.hipStreamCreateWithPriority.flags, Args.hipStreamCreateWithPriority.priority);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamCreateWithPriority_fn(stream, flags, priority);
  }
}

static hipError_t hipStreamDestroy_callback(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamDestroy.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamDestroy_fn(Args.hipStreamDestroy.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamDestroy_fn(stream);
  }
}

static hipError_t hipStreamEndCapture_callback(hipStream_t stream, hipGraph_t* pGraph) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamEndCapture;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamEndCapture.stream = stream;
    Args.hipStreamEndCapture.pGraph = pGraph;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamEndCapture_fn(Args.hipStreamEndCapture.stream, Args.hipStreamEndCapture.pGraph);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamEndCapture_fn(stream, pGraph);
  }
}

static hipError_t hipStreamGetCaptureInfo_callback(hipStream_t stream, hipStreamCaptureStatus* pCaptureStatus, unsigned long long* pId) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetCaptureInfo;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetCaptureInfo.stream = stream;
    Args.hipStreamGetCaptureInfo.pCaptureStatus = pCaptureStatus;
    Args.hipStreamGetCaptureInfo.pId = pId;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetCaptureInfo_fn(Args.hipStreamGetCaptureInfo.stream, Args.hipStreamGetCaptureInfo.pCaptureStatus, Args.hipStreamGetCaptureInfo.pId);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetCaptureInfo_fn(stream, pCaptureStatus, pId);
  }
}

static hipError_t hipStreamGetCaptureInfo_v2_callback(hipStream_t stream, hipStreamCaptureStatus* captureStatus_out, unsigned long long* id_out, hipGraph_t* graph_out, const hipGraphNode_t** dependencies_out, size_t* numDependencies_out) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetCaptureInfo_v2;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetCaptureInfo_v2.stream = stream;
    Args.hipStreamGetCaptureInfo_v2.captureStatus_out = captureStatus_out;
    Args.hipStreamGetCaptureInfo_v2.id_out = id_out;
    Args.hipStreamGetCaptureInfo_v2.graph_out = graph_out;
    Args.hipStreamGetCaptureInfo_v2.dependencies_out = dependencies_out;
    Args.hipStreamGetCaptureInfo_v2.numDependencies_out = numDependencies_out;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetCaptureInfo_v2_fn(Args.hipStreamGetCaptureInfo_v2.stream, Args.hipStreamGetCaptureInfo_v2.captureStatus_out, Args.hipStreamGetCaptureInfo_v2.id_out, Args.hipStreamGetCaptureInfo_v2.graph_out, Args.hipStreamGetCaptureInfo_v2.dependencies_out, Args.hipStreamGetCaptureInfo_v2.numDependencies_out);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetCaptureInfo_v2_fn(stream, captureStatus_out, id_out, graph_out, dependencies_out, numDependencies_out);
  }
}

static hipError_t hipStreamGetDevice_callback(hipStream_t stream, hipDevice_t* device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetDevice.stream = stream;
    Args.hipStreamGetDevice.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetDevice_fn(Args.hipStreamGetDevice.stream, Args.hipStreamGetDevice.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetDevice_fn(stream, device);
  }
}

static hipError_t hipStreamGetFlags_callback(hipStream_t stream, unsigned int* flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetFlags.stream = stream;
    Args.hipStreamGetFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetFlags_fn(Args.hipStreamGetFlags.stream, Args.hipStreamGetFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetFlags_fn(stream, flags);
  }
}

static hipError_t hipStreamGetPriority_callback(hipStream_t stream, int* priority) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetPriority;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetPriority.stream = stream;
    Args.hipStreamGetPriority.priority = priority;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetPriority_fn(Args.hipStreamGetPriority.stream, Args.hipStreamGetPriority.priority);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetPriority_fn(stream, priority);
  }
}

static hipError_t hipStreamIsCapturing_callback(hipStream_t stream, hipStreamCaptureStatus* pCaptureStatus) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamIsCapturing;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamIsCapturing.stream = stream;
    Args.hipStreamIsCapturing.pCaptureStatus = pCaptureStatus;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamIsCapturing_fn(Args.hipStreamIsCapturing.stream, Args.hipStreamIsCapturing.pCaptureStatus);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamIsCapturing_fn(stream, pCaptureStatus);
  }
}

static hipError_t hipStreamQuery_callback(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamQuery;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamQuery.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamQuery_fn(Args.hipStreamQuery.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamQuery_fn(stream);
  }
}

static hipError_t hipStreamSynchronize_callback(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamSynchronize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamSynchronize.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamSynchronize_fn(Args.hipStreamSynchronize.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamSynchronize_fn(stream);
  }
}

static hipError_t hipStreamUpdateCaptureDependencies_callback(hipStream_t stream, hipGraphNode_t* dependencies, size_t numDependencies, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamUpdateCaptureDependencies;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamUpdateCaptureDependencies.stream = stream;
    Args.hipStreamUpdateCaptureDependencies.dependencies = dependencies;
    Args.hipStreamUpdateCaptureDependencies.numDependencies = numDependencies;
    Args.hipStreamUpdateCaptureDependencies.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamUpdateCaptureDependencies_fn(Args.hipStreamUpdateCaptureDependencies.stream, Args.hipStreamUpdateCaptureDependencies.dependencies, Args.hipStreamUpdateCaptureDependencies.numDependencies, Args.hipStreamUpdateCaptureDependencies.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamUpdateCaptureDependencies_fn(stream, dependencies, numDependencies, flags);
  }
}

static hipError_t hipStreamWaitEvent_callback(hipStream_t stream, hipEvent_t event, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWaitEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamWaitEvent.stream = stream;
    Args.hipStreamWaitEvent.event = event;
    Args.hipStreamWaitEvent.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamWaitEvent_fn(Args.hipStreamWaitEvent.stream, Args.hipStreamWaitEvent.event, Args.hipStreamWaitEvent.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamWaitEvent_fn(stream, event, flags);
  }
}

static hipError_t hipStreamWaitValue32_callback(hipStream_t stream, void* ptr, uint32_t value, unsigned int flags, uint32_t mask) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWaitValue32;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamWaitValue32.stream = stream;
    Args.hipStreamWaitValue32.ptr = ptr;
    Args.hipStreamWaitValue32.value = value;
    Args.hipStreamWaitValue32.flags = flags;
    Args.hipStreamWaitValue32.mask = mask;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamWaitValue32_fn(Args.hipStreamWaitValue32.stream, Args.hipStreamWaitValue32.ptr, Args.hipStreamWaitValue32.value, Args.hipStreamWaitValue32.flags, Args.hipStreamWaitValue32.mask);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamWaitValue32_fn(stream, ptr, value, flags, mask);
  }
}

static hipError_t hipStreamWaitValue64_callback(hipStream_t stream, void* ptr, uint64_t value, unsigned int flags, uint64_t mask) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWaitValue64;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamWaitValue64.stream = stream;
    Args.hipStreamWaitValue64.ptr = ptr;
    Args.hipStreamWaitValue64.value = value;
    Args.hipStreamWaitValue64.flags = flags;
    Args.hipStreamWaitValue64.mask = mask;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamWaitValue64_fn(Args.hipStreamWaitValue64.stream, Args.hipStreamWaitValue64.ptr, Args.hipStreamWaitValue64.value, Args.hipStreamWaitValue64.flags, Args.hipStreamWaitValue64.mask);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamWaitValue64_fn(stream, ptr, value, flags, mask);
  }
}

static hipError_t hipStreamWriteValue32_callback(hipStream_t stream, void* ptr, uint32_t value, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWriteValue32;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamWriteValue32.stream = stream;
    Args.hipStreamWriteValue32.ptr = ptr;
    Args.hipStreamWriteValue32.value = value;
    Args.hipStreamWriteValue32.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamWriteValue32_fn(Args.hipStreamWriteValue32.stream, Args.hipStreamWriteValue32.ptr, Args.hipStreamWriteValue32.value, Args.hipStreamWriteValue32.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamWriteValue32_fn(stream, ptr, value, flags);
  }
}

static hipError_t hipStreamWriteValue64_callback(hipStream_t stream, void* ptr, uint64_t value, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWriteValue64;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamWriteValue64.stream = stream;
    Args.hipStreamWriteValue64.ptr = ptr;
    Args.hipStreamWriteValue64.value = value;
    Args.hipStreamWriteValue64.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamWriteValue64_fn(Args.hipStreamWriteValue64.stream, Args.hipStreamWriteValue64.ptr, Args.hipStreamWriteValue64.value, Args.hipStreamWriteValue64.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamWriteValue64_fn(stream, ptr, value, flags);
  }
}

static hipError_t hipTexObjectCreate_callback(hipTextureObject_t* pTexObject, const HIP_RESOURCE_DESC* pResDesc, const HIP_TEXTURE_DESC* pTexDesc, const HIP_RESOURCE_VIEW_DESC* pResViewDesc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexObjectCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexObjectCreate.pTexObject = pTexObject;
    Args.hipTexObjectCreate.pResDesc = pResDesc;
    Args.hipTexObjectCreate.pTexDesc = pTexDesc;
    Args.hipTexObjectCreate.pResViewDesc = pResViewDesc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexObjectCreate_fn(Args.hipTexObjectCreate.pTexObject, Args.hipTexObjectCreate.pResDesc, Args.hipTexObjectCreate.pTexDesc, Args.hipTexObjectCreate.pResViewDesc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexObjectCreate_fn(pTexObject, pResDesc, pTexDesc, pResViewDesc);
  }
}

static hipError_t hipTexObjectDestroy_callback(hipTextureObject_t texObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexObjectDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexObjectDestroy.texObject = texObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexObjectDestroy_fn(Args.hipTexObjectDestroy.texObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexObjectDestroy_fn(texObject);
  }
}

static hipError_t hipTexObjectGetResourceDesc_callback(HIP_RESOURCE_DESC* pResDesc, hipTextureObject_t texObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexObjectGetResourceDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexObjectGetResourceDesc.pResDesc = pResDesc;
    Args.hipTexObjectGetResourceDesc.texObject = texObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexObjectGetResourceDesc_fn(Args.hipTexObjectGetResourceDesc.pResDesc, Args.hipTexObjectGetResourceDesc.texObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexObjectGetResourceDesc_fn(pResDesc, texObject);
  }
}

static hipError_t hipTexObjectGetResourceViewDesc_callback(HIP_RESOURCE_VIEW_DESC* pResViewDesc, hipTextureObject_t texObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexObjectGetResourceViewDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexObjectGetResourceViewDesc.pResViewDesc = pResViewDesc;
    Args.hipTexObjectGetResourceViewDesc.texObject = texObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexObjectGetResourceViewDesc_fn(Args.hipTexObjectGetResourceViewDesc.pResViewDesc, Args.hipTexObjectGetResourceViewDesc.texObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexObjectGetResourceViewDesc_fn(pResViewDesc, texObject);
  }
}

static hipError_t hipTexObjectGetTextureDesc_callback(HIP_TEXTURE_DESC* pTexDesc, hipTextureObject_t texObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexObjectGetTextureDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexObjectGetTextureDesc.pTexDesc = pTexDesc;
    Args.hipTexObjectGetTextureDesc.texObject = texObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexObjectGetTextureDesc_fn(Args.hipTexObjectGetTextureDesc.pTexDesc, Args.hipTexObjectGetTextureDesc.texObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexObjectGetTextureDesc_fn(pTexDesc, texObject);
  }
}

static hipError_t hipTexRefGetAddress_callback(hipDeviceptr_t* dev_ptr, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetAddress;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetAddress.dev_ptr = dev_ptr;
    Args.hipTexRefGetAddress.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetAddress_fn(Args.hipTexRefGetAddress.dev_ptr, Args.hipTexRefGetAddress.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetAddress_fn(dev_ptr, texRef);
  }
}

static hipError_t hipTexRefGetAddressMode_callback(enum hipTextureAddressMode* pam, const textureReference* texRef, int dim) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetAddressMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetAddressMode.pam = pam;
    Args.hipTexRefGetAddressMode.texRef = texRef;
    Args.hipTexRefGetAddressMode.dim = dim;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetAddressMode_fn(Args.hipTexRefGetAddressMode.pam, Args.hipTexRefGetAddressMode.texRef, Args.hipTexRefGetAddressMode.dim);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetAddressMode_fn(pam, texRef, dim);
  }
}

static hipError_t hipTexRefGetFilterMode_callback(enum hipTextureFilterMode* pfm, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetFilterMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetFilterMode.pfm = pfm;
    Args.hipTexRefGetFilterMode.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetFilterMode_fn(Args.hipTexRefGetFilterMode.pfm, Args.hipTexRefGetFilterMode.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetFilterMode_fn(pfm, texRef);
  }
}

static hipError_t hipTexRefGetFlags_callback(unsigned int* pFlags, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetFlags.pFlags = pFlags;
    Args.hipTexRefGetFlags.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetFlags_fn(Args.hipTexRefGetFlags.pFlags, Args.hipTexRefGetFlags.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetFlags_fn(pFlags, texRef);
  }
}

static hipError_t hipTexRefGetFormat_callback(hipArray_Format* pFormat, int* pNumChannels, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetFormat;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetFormat.pFormat = pFormat;
    Args.hipTexRefGetFormat.pNumChannels = pNumChannels;
    Args.hipTexRefGetFormat.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetFormat_fn(Args.hipTexRefGetFormat.pFormat, Args.hipTexRefGetFormat.pNumChannels, Args.hipTexRefGetFormat.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetFormat_fn(pFormat, pNumChannels, texRef);
  }
}

static hipError_t hipTexRefGetMaxAnisotropy_callback(int* pmaxAnsio, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetMaxAnisotropy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetMaxAnisotropy.pmaxAnsio = pmaxAnsio;
    Args.hipTexRefGetMaxAnisotropy.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetMaxAnisotropy_fn(Args.hipTexRefGetMaxAnisotropy.pmaxAnsio, Args.hipTexRefGetMaxAnisotropy.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetMaxAnisotropy_fn(pmaxAnsio, texRef);
  }
}

static hipError_t hipTexRefGetMipMappedArray_callback(hipMipmappedArray_t* pArray, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetMipMappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetMipMappedArray.pArray = pArray;
    Args.hipTexRefGetMipMappedArray.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetMipMappedArray_fn(Args.hipTexRefGetMipMappedArray.pArray, Args.hipTexRefGetMipMappedArray.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetMipMappedArray_fn(pArray, texRef);
  }
}

static hipError_t hipTexRefGetMipmapFilterMode_callback(enum hipTextureFilterMode* pfm, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetMipmapFilterMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetMipmapFilterMode.pfm = pfm;
    Args.hipTexRefGetMipmapFilterMode.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetMipmapFilterMode_fn(Args.hipTexRefGetMipmapFilterMode.pfm, Args.hipTexRefGetMipmapFilterMode.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetMipmapFilterMode_fn(pfm, texRef);
  }
}

static hipError_t hipTexRefGetMipmapLevelBias_callback(float* pbias, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetMipmapLevelBias;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetMipmapLevelBias.pbias = pbias;
    Args.hipTexRefGetMipmapLevelBias.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetMipmapLevelBias_fn(Args.hipTexRefGetMipmapLevelBias.pbias, Args.hipTexRefGetMipmapLevelBias.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetMipmapLevelBias_fn(pbias, texRef);
  }
}

static hipError_t hipTexRefGetMipmapLevelClamp_callback(float* pminMipmapLevelClamp, float* pmaxMipmapLevelClamp, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetMipmapLevelClamp;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetMipmapLevelClamp.pminMipmapLevelClamp = pminMipmapLevelClamp;
    Args.hipTexRefGetMipmapLevelClamp.pmaxMipmapLevelClamp = pmaxMipmapLevelClamp;
    Args.hipTexRefGetMipmapLevelClamp.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetMipmapLevelClamp_fn(Args.hipTexRefGetMipmapLevelClamp.pminMipmapLevelClamp, Args.hipTexRefGetMipmapLevelClamp.pmaxMipmapLevelClamp, Args.hipTexRefGetMipmapLevelClamp.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetMipmapLevelClamp_fn(pminMipmapLevelClamp, pmaxMipmapLevelClamp, texRef);
  }
}

static hipError_t hipTexRefSetAddress_callback(size_t* ByteOffset, textureReference* texRef, hipDeviceptr_t dptr, size_t bytes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetAddress;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetAddress.ByteOffset = ByteOffset;
    Args.hipTexRefSetAddress.texRef = texRef;
    Args.hipTexRefSetAddress.dptr = dptr;
    Args.hipTexRefSetAddress.bytes = bytes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetAddress_fn(Args.hipTexRefSetAddress.ByteOffset, Args.hipTexRefSetAddress.texRef, Args.hipTexRefSetAddress.dptr, Args.hipTexRefSetAddress.bytes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetAddress_fn(ByteOffset, texRef, dptr, bytes);
  }
}

static hipError_t hipTexRefSetAddress2D_callback(textureReference* texRef, const HIP_ARRAY_DESCRIPTOR* desc, hipDeviceptr_t dptr, size_t Pitch) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetAddress2D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetAddress2D.texRef = texRef;
    Args.hipTexRefSetAddress2D.desc = desc;
    Args.hipTexRefSetAddress2D.dptr = dptr;
    Args.hipTexRefSetAddress2D.Pitch = Pitch;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetAddress2D_fn(Args.hipTexRefSetAddress2D.texRef, Args.hipTexRefSetAddress2D.desc, Args.hipTexRefSetAddress2D.dptr, Args.hipTexRefSetAddress2D.Pitch);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetAddress2D_fn(texRef, desc, dptr, Pitch);
  }
}

static hipError_t hipTexRefSetAddressMode_callback(textureReference* texRef, int dim, enum hipTextureAddressMode am) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetAddressMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetAddressMode.texRef = texRef;
    Args.hipTexRefSetAddressMode.dim = dim;
    Args.hipTexRefSetAddressMode.am = am;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetAddressMode_fn(Args.hipTexRefSetAddressMode.texRef, Args.hipTexRefSetAddressMode.dim, Args.hipTexRefSetAddressMode.am);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetAddressMode_fn(texRef, dim, am);
  }
}

static hipError_t hipTexRefSetArray_callback(textureReference* tex, hipArray_const_t array, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetArray.tex = tex;
    Args.hipTexRefSetArray.array = array;
    Args.hipTexRefSetArray.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetArray_fn(Args.hipTexRefSetArray.tex, Args.hipTexRefSetArray.array, Args.hipTexRefSetArray.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetArray_fn(tex, array, flags);
  }
}

static hipError_t hipTexRefSetBorderColor_callback(textureReference* texRef, float* pBorderColor) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetBorderColor;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetBorderColor.texRef = texRef;
    Args.hipTexRefSetBorderColor.pBorderColor = pBorderColor;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetBorderColor_fn(Args.hipTexRefSetBorderColor.texRef, Args.hipTexRefSetBorderColor.pBorderColor);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetBorderColor_fn(texRef, pBorderColor);
  }
}

static hipError_t hipTexRefSetFilterMode_callback(textureReference* texRef, enum hipTextureFilterMode fm) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetFilterMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetFilterMode.texRef = texRef;
    Args.hipTexRefSetFilterMode.fm = fm;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetFilterMode_fn(Args.hipTexRefSetFilterMode.texRef, Args.hipTexRefSetFilterMode.fm);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetFilterMode_fn(texRef, fm);
  }
}

static hipError_t hipTexRefSetFlags_callback(textureReference* texRef, unsigned int Flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetFlags.texRef = texRef;
    Args.hipTexRefSetFlags.Flags = Flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetFlags_fn(Args.hipTexRefSetFlags.texRef, Args.hipTexRefSetFlags.Flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetFlags_fn(texRef, Flags);
  }
}

static hipError_t hipTexRefSetFormat_callback(textureReference* texRef, hipArray_Format fmt, int NumPackedComponents) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetFormat;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetFormat.texRef = texRef;
    Args.hipTexRefSetFormat.fmt = fmt;
    Args.hipTexRefSetFormat.NumPackedComponents = NumPackedComponents;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetFormat_fn(Args.hipTexRefSetFormat.texRef, Args.hipTexRefSetFormat.fmt, Args.hipTexRefSetFormat.NumPackedComponents);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetFormat_fn(texRef, fmt, NumPackedComponents);
  }
}

static hipError_t hipTexRefSetMaxAnisotropy_callback(textureReference* texRef, unsigned int maxAniso) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetMaxAnisotropy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetMaxAnisotropy.texRef = texRef;
    Args.hipTexRefSetMaxAnisotropy.maxAniso = maxAniso;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetMaxAnisotropy_fn(Args.hipTexRefSetMaxAnisotropy.texRef, Args.hipTexRefSetMaxAnisotropy.maxAniso);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetMaxAnisotropy_fn(texRef, maxAniso);
  }
}

static hipError_t hipTexRefSetMipmapFilterMode_callback(textureReference* texRef, enum hipTextureFilterMode fm) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetMipmapFilterMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetMipmapFilterMode.texRef = texRef;
    Args.hipTexRefSetMipmapFilterMode.fm = fm;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetMipmapFilterMode_fn(Args.hipTexRefSetMipmapFilterMode.texRef, Args.hipTexRefSetMipmapFilterMode.fm);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetMipmapFilterMode_fn(texRef, fm);
  }
}

static hipError_t hipTexRefSetMipmapLevelBias_callback(textureReference* texRef, float bias) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetMipmapLevelBias;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetMipmapLevelBias.texRef = texRef;
    Args.hipTexRefSetMipmapLevelBias.bias = bias;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetMipmapLevelBias_fn(Args.hipTexRefSetMipmapLevelBias.texRef, Args.hipTexRefSetMipmapLevelBias.bias);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetMipmapLevelBias_fn(texRef, bias);
  }
}

static hipError_t hipTexRefSetMipmapLevelClamp_callback(textureReference* texRef, float minMipMapLevelClamp, float maxMipMapLevelClamp) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetMipmapLevelClamp;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetMipmapLevelClamp.texRef = texRef;
    Args.hipTexRefSetMipmapLevelClamp.minMipMapLevelClamp = minMipMapLevelClamp;
    Args.hipTexRefSetMipmapLevelClamp.maxMipMapLevelClamp = maxMipMapLevelClamp;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetMipmapLevelClamp_fn(Args.hipTexRefSetMipmapLevelClamp.texRef, Args.hipTexRefSetMipmapLevelClamp.minMipMapLevelClamp, Args.hipTexRefSetMipmapLevelClamp.maxMipMapLevelClamp);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetMipmapLevelClamp_fn(texRef, minMipMapLevelClamp, maxMipMapLevelClamp);
  }
}

static hipError_t hipTexRefSetMipmappedArray_callback(textureReference* texRef, struct hipMipmappedArray* mipmappedArray, unsigned int Flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetMipmappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetMipmappedArray.texRef = texRef;
    Args.hipTexRefSetMipmappedArray.mipmappedArray = mipmappedArray;
    Args.hipTexRefSetMipmappedArray.Flags = Flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetMipmappedArray_fn(Args.hipTexRefSetMipmappedArray.texRef, Args.hipTexRefSetMipmappedArray.mipmappedArray, Args.hipTexRefSetMipmappedArray.Flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetMipmappedArray_fn(texRef, mipmappedArray, Flags);
  }
}

static hipError_t hipThreadExchangeStreamCaptureMode_callback(hipStreamCaptureMode* mode) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipThreadExchangeStreamCaptureMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipThreadExchangeStreamCaptureMode.mode = mode;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipThreadExchangeStreamCaptureMode_fn(Args.hipThreadExchangeStreamCaptureMode.mode);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipThreadExchangeStreamCaptureMode_fn(mode);
  }
}

static hipError_t hipUnbindTexture_callback(const textureReference* tex) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipUnbindTexture;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipUnbindTexture.tex = tex;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipUnbindTexture_fn(Args.hipUnbindTexture.tex);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipUnbindTexture_fn(tex);
  }
}

static hipError_t hipUserObjectCreate_callback(hipUserObject_t* object_out, void* ptr, hipHostFn_t destroy, unsigned int initialRefcount, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipUserObjectCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipUserObjectCreate.object_out = object_out;
    Args.hipUserObjectCreate.ptr = ptr;
    Args.hipUserObjectCreate.destroy = destroy;
    Args.hipUserObjectCreate.initialRefcount = initialRefcount;
    Args.hipUserObjectCreate.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipUserObjectCreate_fn(Args.hipUserObjectCreate.object_out, Args.hipUserObjectCreate.ptr, Args.hipUserObjectCreate.destroy, Args.hipUserObjectCreate.initialRefcount, Args.hipUserObjectCreate.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipUserObjectCreate_fn(object_out, ptr, destroy, initialRefcount, flags);
  }
}

static hipError_t hipUserObjectRelease_callback(hipUserObject_t object, unsigned int count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipUserObjectRelease;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipUserObjectRelease.object = object;
    Args.hipUserObjectRelease.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipUserObjectRelease_fn(Args.hipUserObjectRelease.object, Args.hipUserObjectRelease.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipUserObjectRelease_fn(object, count);
  }
}

static hipError_t hipUserObjectRetain_callback(hipUserObject_t object, unsigned int count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipUserObjectRetain;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipUserObjectRetain.object = object;
    Args.hipUserObjectRetain.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipUserObjectRetain_fn(Args.hipUserObjectRetain.object, Args.hipUserObjectRetain.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipUserObjectRetain_fn(object, count);
  }
}

static hipError_t hipWaitExternalSemaphoresAsync_callback(const hipExternalSemaphore_t* extSemArray, const hipExternalSemaphoreWaitParams* paramsArray, unsigned int numExtSems, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipWaitExternalSemaphoresAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipWaitExternalSemaphoresAsync.extSemArray = extSemArray;
    Args.hipWaitExternalSemaphoresAsync.paramsArray = paramsArray;
    Args.hipWaitExternalSemaphoresAsync.numExtSems = numExtSems;
    Args.hipWaitExternalSemaphoresAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipWaitExternalSemaphoresAsync_fn(Args.hipWaitExternalSemaphoresAsync.extSemArray, Args.hipWaitExternalSemaphoresAsync.paramsArray, Args.hipWaitExternalSemaphoresAsync.numExtSems, Args.hipWaitExternalSemaphoresAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipWaitExternalSemaphoresAsync_fn(extSemArray, paramsArray, numExtSems, stream);
  }
}

static hipChannelFormatDesc hipCreateChannelDesc_callback(int x, int y, int z, int w, hipChannelFormatKind f) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCreateChannelDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipChannelFormatDesc Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCreateChannelDesc.x = x;
    Args.hipCreateChannelDesc.y = y;
    Args.hipCreateChannelDesc.z = z;
    Args.hipCreateChannelDesc.w = w;
    Args.hipCreateChannelDesc.f = f;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCreateChannelDesc_fn(Args.hipCreateChannelDesc.x, Args.hipCreateChannelDesc.y, Args.hipCreateChannelDesc.z, Args.hipCreateChannelDesc.w, Args.hipCreateChannelDesc.f);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCreateChannelDesc_fn(x, y, z, w, f);
  }
}

static hipError_t hipMemcpy_spt_callback(void* dst, const void* src, size_t sizeBytes, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy_spt.dst = dst;
    Args.hipMemcpy_spt.src = src;
    Args.hipMemcpy_spt.sizeBytes = sizeBytes;
    Args.hipMemcpy_spt.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy_spt_fn(Args.hipMemcpy_spt.dst, Args.hipMemcpy_spt.src, Args.hipMemcpy_spt.sizeBytes, Args.hipMemcpy_spt.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy_spt_fn(dst, src, sizeBytes, kind);
  }
}

static hipError_t hipMemcpyToSymbol_spt_callback(const void* symbol, const void* src, size_t sizeBytes, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToSymbol_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyToSymbol_spt.symbol = symbol;
    Args.hipMemcpyToSymbol_spt.src = src;
    Args.hipMemcpyToSymbol_spt.sizeBytes = sizeBytes;
    Args.hipMemcpyToSymbol_spt.offset = offset;
    Args.hipMemcpyToSymbol_spt.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyToSymbol_spt_fn(Args.hipMemcpyToSymbol_spt.symbol, Args.hipMemcpyToSymbol_spt.src, Args.hipMemcpyToSymbol_spt.sizeBytes, Args.hipMemcpyToSymbol_spt.offset, Args.hipMemcpyToSymbol_spt.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyToSymbol_spt_fn(symbol, src, sizeBytes, offset, kind);
  }
}

static hipError_t hipMemcpyFromSymbol_spt_callback(void* dst, const void* symbol, size_t sizeBytes, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromSymbol_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyFromSymbol_spt.dst = dst;
    Args.hipMemcpyFromSymbol_spt.symbol = symbol;
    Args.hipMemcpyFromSymbol_spt.sizeBytes = sizeBytes;
    Args.hipMemcpyFromSymbol_spt.offset = offset;
    Args.hipMemcpyFromSymbol_spt.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyFromSymbol_spt_fn(Args.hipMemcpyFromSymbol_spt.dst, Args.hipMemcpyFromSymbol_spt.symbol, Args.hipMemcpyFromSymbol_spt.sizeBytes, Args.hipMemcpyFromSymbol_spt.offset, Args.hipMemcpyFromSymbol_spt.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyFromSymbol_spt_fn(dst, symbol, sizeBytes, offset, kind);
  }
}

static hipError_t hipMemcpy2D_spt_callback(void* dst, size_t dpitch, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2D_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2D_spt.dst = dst;
    Args.hipMemcpy2D_spt.dpitch = dpitch;
    Args.hipMemcpy2D_spt.src = src;
    Args.hipMemcpy2D_spt.spitch = spitch;
    Args.hipMemcpy2D_spt.width = width;
    Args.hipMemcpy2D_spt.height = height;
    Args.hipMemcpy2D_spt.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2D_spt_fn(Args.hipMemcpy2D_spt.dst, Args.hipMemcpy2D_spt.dpitch, Args.hipMemcpy2D_spt.src, Args.hipMemcpy2D_spt.spitch, Args.hipMemcpy2D_spt.width, Args.hipMemcpy2D_spt.height, Args.hipMemcpy2D_spt.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2D_spt_fn(dst, dpitch, src, spitch, width, height, kind);
  }
}

static hipError_t hipMemcpy2DFromArray_spt_callback(void* dst, size_t dpitch, hipArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DFromArray_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DFromArray_spt.dst = dst;
    Args.hipMemcpy2DFromArray_spt.dpitch = dpitch;
    Args.hipMemcpy2DFromArray_spt.src = src;
    Args.hipMemcpy2DFromArray_spt.wOffset = wOffset;
    Args.hipMemcpy2DFromArray_spt.hOffset = hOffset;
    Args.hipMemcpy2DFromArray_spt.width = width;
    Args.hipMemcpy2DFromArray_spt.height = height;
    Args.hipMemcpy2DFromArray_spt.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DFromArray_spt_fn(Args.hipMemcpy2DFromArray_spt.dst, Args.hipMemcpy2DFromArray_spt.dpitch, Args.hipMemcpy2DFromArray_spt.src, Args.hipMemcpy2DFromArray_spt.wOffset, Args.hipMemcpy2DFromArray_spt.hOffset, Args.hipMemcpy2DFromArray_spt.width, Args.hipMemcpy2DFromArray_spt.height, Args.hipMemcpy2DFromArray_spt.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DFromArray_spt_fn(dst, dpitch, src, wOffset, hOffset, width, height, kind);
  }
}

static hipError_t hipMemcpy3D_spt_callback(const struct hipMemcpy3DParms* p) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy3D_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy3D_spt.p = p;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy3D_spt_fn(Args.hipMemcpy3D_spt.p);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy3D_spt_fn(p);
  }
}

static hipError_t hipMemset_spt_callback(void* dst, int value, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset_spt.dst = dst;
    Args.hipMemset_spt.value = value;
    Args.hipMemset_spt.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset_spt_fn(Args.hipMemset_spt.dst, Args.hipMemset_spt.value, Args.hipMemset_spt.sizeBytes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset_spt_fn(dst, value, sizeBytes);
  }
}

static hipError_t hipMemsetAsync_spt_callback(void* dst, int value, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemsetAsync_spt.dst = dst;
    Args.hipMemsetAsync_spt.value = value;
    Args.hipMemsetAsync_spt.sizeBytes = sizeBytes;
    Args.hipMemsetAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemsetAsync_spt_fn(Args.hipMemsetAsync_spt.dst, Args.hipMemsetAsync_spt.value, Args.hipMemsetAsync_spt.sizeBytes, Args.hipMemsetAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemsetAsync_spt_fn(dst, value, sizeBytes, stream);
  }
}

static hipError_t hipMemset2D_spt_callback(void* dst, size_t pitch, int value, size_t width, size_t height) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset2D_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset2D_spt.dst = dst;
    Args.hipMemset2D_spt.pitch = pitch;
    Args.hipMemset2D_spt.value = value;
    Args.hipMemset2D_spt.width = width;
    Args.hipMemset2D_spt.height = height;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset2D_spt_fn(Args.hipMemset2D_spt.dst, Args.hipMemset2D_spt.pitch, Args.hipMemset2D_spt.value, Args.hipMemset2D_spt.width, Args.hipMemset2D_spt.height);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset2D_spt_fn(dst, pitch, value, width, height);
  }
}

static hipError_t hipMemset2DAsync_spt_callback(void* dst, size_t pitch, int value, size_t width, size_t height, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset2DAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset2DAsync_spt.dst = dst;
    Args.hipMemset2DAsync_spt.pitch = pitch;
    Args.hipMemset2DAsync_spt.value = value;
    Args.hipMemset2DAsync_spt.width = width;
    Args.hipMemset2DAsync_spt.height = height;
    Args.hipMemset2DAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset2DAsync_spt_fn(Args.hipMemset2DAsync_spt.dst, Args.hipMemset2DAsync_spt.pitch, Args.hipMemset2DAsync_spt.value, Args.hipMemset2DAsync_spt.width, Args.hipMemset2DAsync_spt.height, Args.hipMemset2DAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset2DAsync_spt_fn(dst, pitch, value, width, height, stream);
  }
}

static hipError_t hipMemset3DAsync_spt_callback(hipPitchedPtr pitchedDevPtr, int value, hipExtent extent, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset3DAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset3DAsync_spt.pitchedDevPtr = pitchedDevPtr;
    Args.hipMemset3DAsync_spt.value = value;
    Args.hipMemset3DAsync_spt.extent = extent;
    Args.hipMemset3DAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset3DAsync_spt_fn(Args.hipMemset3DAsync_spt.pitchedDevPtr, Args.hipMemset3DAsync_spt.value, Args.hipMemset3DAsync_spt.extent, Args.hipMemset3DAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset3DAsync_spt_fn(pitchedDevPtr, value, extent, stream);
  }
}

static hipError_t hipMemset3D_spt_callback(hipPitchedPtr pitchedDevPtr, int value, hipExtent extent) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset3D_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset3D_spt.pitchedDevPtr = pitchedDevPtr;
    Args.hipMemset3D_spt.value = value;
    Args.hipMemset3D_spt.extent = extent;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset3D_spt_fn(Args.hipMemset3D_spt.pitchedDevPtr, Args.hipMemset3D_spt.value, Args.hipMemset3D_spt.extent);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset3D_spt_fn(pitchedDevPtr, value, extent);
  }
}

static hipError_t hipMemcpyAsync_spt_callback(void* dst, const void* src, size_t sizeBytes, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyAsync_spt.dst = dst;
    Args.hipMemcpyAsync_spt.src = src;
    Args.hipMemcpyAsync_spt.sizeBytes = sizeBytes;
    Args.hipMemcpyAsync_spt.kind = kind;
    Args.hipMemcpyAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyAsync_spt_fn(Args.hipMemcpyAsync_spt.dst, Args.hipMemcpyAsync_spt.src, Args.hipMemcpyAsync_spt.sizeBytes, Args.hipMemcpyAsync_spt.kind, Args.hipMemcpyAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyAsync_spt_fn(dst, src, sizeBytes, kind, stream);
  }
}

static hipError_t hipMemcpy3DAsync_spt_callback(const hipMemcpy3DParms* p, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy3DAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy3DAsync_spt.p = p;
    Args.hipMemcpy3DAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy3DAsync_spt_fn(Args.hipMemcpy3DAsync_spt.p, Args.hipMemcpy3DAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy3DAsync_spt_fn(p, stream);
  }
}

static hipError_t hipMemcpy2DAsync_spt_callback(void* dst, size_t dpitch, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DAsync_spt.dst = dst;
    Args.hipMemcpy2DAsync_spt.dpitch = dpitch;
    Args.hipMemcpy2DAsync_spt.src = src;
    Args.hipMemcpy2DAsync_spt.spitch = spitch;
    Args.hipMemcpy2DAsync_spt.width = width;
    Args.hipMemcpy2DAsync_spt.height = height;
    Args.hipMemcpy2DAsync_spt.kind = kind;
    Args.hipMemcpy2DAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DAsync_spt_fn(Args.hipMemcpy2DAsync_spt.dst, Args.hipMemcpy2DAsync_spt.dpitch, Args.hipMemcpy2DAsync_spt.src, Args.hipMemcpy2DAsync_spt.spitch, Args.hipMemcpy2DAsync_spt.width, Args.hipMemcpy2DAsync_spt.height, Args.hipMemcpy2DAsync_spt.kind, Args.hipMemcpy2DAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DAsync_spt_fn(dst, dpitch, src, spitch, width, height, kind, stream);
  }
}

static hipError_t hipMemcpyFromSymbolAsync_spt_callback(void* dst, const void* symbol, size_t sizeBytes, size_t offset, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromSymbolAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyFromSymbolAsync_spt.dst = dst;
    Args.hipMemcpyFromSymbolAsync_spt.symbol = symbol;
    Args.hipMemcpyFromSymbolAsync_spt.sizeBytes = sizeBytes;
    Args.hipMemcpyFromSymbolAsync_spt.offset = offset;
    Args.hipMemcpyFromSymbolAsync_spt.kind = kind;
    Args.hipMemcpyFromSymbolAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyFromSymbolAsync_spt_fn(Args.hipMemcpyFromSymbolAsync_spt.dst, Args.hipMemcpyFromSymbolAsync_spt.symbol, Args.hipMemcpyFromSymbolAsync_spt.sizeBytes, Args.hipMemcpyFromSymbolAsync_spt.offset, Args.hipMemcpyFromSymbolAsync_spt.kind, Args.hipMemcpyFromSymbolAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyFromSymbolAsync_spt_fn(dst, symbol, sizeBytes, offset, kind, stream);
  }
}

static hipError_t hipMemcpyToSymbolAsync_spt_callback(const void* symbol, const void* src, size_t sizeBytes, size_t offset, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToSymbolAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyToSymbolAsync_spt.symbol = symbol;
    Args.hipMemcpyToSymbolAsync_spt.src = src;
    Args.hipMemcpyToSymbolAsync_spt.sizeBytes = sizeBytes;
    Args.hipMemcpyToSymbolAsync_spt.offset = offset;
    Args.hipMemcpyToSymbolAsync_spt.kind = kind;
    Args.hipMemcpyToSymbolAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyToSymbolAsync_spt_fn(Args.hipMemcpyToSymbolAsync_spt.symbol, Args.hipMemcpyToSymbolAsync_spt.src, Args.hipMemcpyToSymbolAsync_spt.sizeBytes, Args.hipMemcpyToSymbolAsync_spt.offset, Args.hipMemcpyToSymbolAsync_spt.kind, Args.hipMemcpyToSymbolAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyToSymbolAsync_spt_fn(symbol, src, sizeBytes, offset, kind, stream);
  }
}

static hipError_t hipMemcpyFromArray_spt_callback(void* dst, hipArray_const_t src, size_t wOffsetSrc, size_t hOffset, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromArray_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyFromArray_spt.dst = dst;
    Args.hipMemcpyFromArray_spt.src = src;
    Args.hipMemcpyFromArray_spt.wOffsetSrc = wOffsetSrc;
    Args.hipMemcpyFromArray_spt.hOffset = hOffset;
    Args.hipMemcpyFromArray_spt.count = count;
    Args.hipMemcpyFromArray_spt.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyFromArray_spt_fn(Args.hipMemcpyFromArray_spt.dst, Args.hipMemcpyFromArray_spt.src, Args.hipMemcpyFromArray_spt.wOffsetSrc, Args.hipMemcpyFromArray_spt.hOffset, Args.hipMemcpyFromArray_spt.count, Args.hipMemcpyFromArray_spt.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyFromArray_spt_fn(dst, src, wOffsetSrc, hOffset, count, kind);
  }
}

static hipError_t hipMemcpy2DToArray_spt_callback(hipArray_t dst, size_t wOffset, size_t hOffset, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DToArray_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DToArray_spt.dst = dst;
    Args.hipMemcpy2DToArray_spt.wOffset = wOffset;
    Args.hipMemcpy2DToArray_spt.hOffset = hOffset;
    Args.hipMemcpy2DToArray_spt.src = src;
    Args.hipMemcpy2DToArray_spt.spitch = spitch;
    Args.hipMemcpy2DToArray_spt.width = width;
    Args.hipMemcpy2DToArray_spt.height = height;
    Args.hipMemcpy2DToArray_spt.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DToArray_spt_fn(Args.hipMemcpy2DToArray_spt.dst, Args.hipMemcpy2DToArray_spt.wOffset, Args.hipMemcpy2DToArray_spt.hOffset, Args.hipMemcpy2DToArray_spt.src, Args.hipMemcpy2DToArray_spt.spitch, Args.hipMemcpy2DToArray_spt.width, Args.hipMemcpy2DToArray_spt.height, Args.hipMemcpy2DToArray_spt.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DToArray_spt_fn(dst, wOffset, hOffset, src, spitch, width, height, kind);
  }
}

static hipError_t hipMemcpy2DFromArrayAsync_spt_callback(void* dst, size_t dpitch, hipArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DFromArrayAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DFromArrayAsync_spt.dst = dst;
    Args.hipMemcpy2DFromArrayAsync_spt.dpitch = dpitch;
    Args.hipMemcpy2DFromArrayAsync_spt.src = src;
    Args.hipMemcpy2DFromArrayAsync_spt.wOffsetSrc = wOffsetSrc;
    Args.hipMemcpy2DFromArrayAsync_spt.hOffsetSrc = hOffsetSrc;
    Args.hipMemcpy2DFromArrayAsync_spt.width = width;
    Args.hipMemcpy2DFromArrayAsync_spt.height = height;
    Args.hipMemcpy2DFromArrayAsync_spt.kind = kind;
    Args.hipMemcpy2DFromArrayAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DFromArrayAsync_spt_fn(Args.hipMemcpy2DFromArrayAsync_spt.dst, Args.hipMemcpy2DFromArrayAsync_spt.dpitch, Args.hipMemcpy2DFromArrayAsync_spt.src, Args.hipMemcpy2DFromArrayAsync_spt.wOffsetSrc, Args.hipMemcpy2DFromArrayAsync_spt.hOffsetSrc, Args.hipMemcpy2DFromArrayAsync_spt.width, Args.hipMemcpy2DFromArrayAsync_spt.height, Args.hipMemcpy2DFromArrayAsync_spt.kind, Args.hipMemcpy2DFromArrayAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DFromArrayAsync_spt_fn(dst, dpitch, src, wOffsetSrc, hOffsetSrc, width, height, kind, stream);
  }
}

static hipError_t hipMemcpy2DToArrayAsync_spt_callback(hipArray_t dst, size_t wOffset, size_t hOffset, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DToArrayAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DToArrayAsync_spt.dst = dst;
    Args.hipMemcpy2DToArrayAsync_spt.wOffset = wOffset;
    Args.hipMemcpy2DToArrayAsync_spt.hOffset = hOffset;
    Args.hipMemcpy2DToArrayAsync_spt.src = src;
    Args.hipMemcpy2DToArrayAsync_spt.spitch = spitch;
    Args.hipMemcpy2DToArrayAsync_spt.width = width;
    Args.hipMemcpy2DToArrayAsync_spt.height = height;
    Args.hipMemcpy2DToArrayAsync_spt.kind = kind;
    Args.hipMemcpy2DToArrayAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DToArrayAsync_spt_fn(Args.hipMemcpy2DToArrayAsync_spt.dst, Args.hipMemcpy2DToArrayAsync_spt.wOffset, Args.hipMemcpy2DToArrayAsync_spt.hOffset, Args.hipMemcpy2DToArrayAsync_spt.src, Args.hipMemcpy2DToArrayAsync_spt.spitch, Args.hipMemcpy2DToArrayAsync_spt.width, Args.hipMemcpy2DToArrayAsync_spt.height, Args.hipMemcpy2DToArrayAsync_spt.kind, Args.hipMemcpy2DToArrayAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DToArrayAsync_spt_fn(dst, wOffset, hOffset, src, spitch, width, height, kind, stream);
  }
}

static hipError_t hipStreamQuery_spt_callback(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamQuery_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamQuery_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamQuery_spt_fn(Args.hipStreamQuery_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamQuery_spt_fn(stream);
  }
}

static hipError_t hipStreamSynchronize_spt_callback(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamSynchronize_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamSynchronize_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamSynchronize_spt_fn(Args.hipStreamSynchronize_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamSynchronize_spt_fn(stream);
  }
}

static hipError_t hipStreamGetPriority_spt_callback(hipStream_t stream, int* priority) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetPriority_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetPriority_spt.stream = stream;
    Args.hipStreamGetPriority_spt.priority = priority;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetPriority_spt_fn(Args.hipStreamGetPriority_spt.stream, Args.hipStreamGetPriority_spt.priority);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetPriority_spt_fn(stream, priority);
  }
}

static hipError_t hipStreamWaitEvent_spt_callback(hipStream_t stream, hipEvent_t event, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWaitEvent_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamWaitEvent_spt.stream = stream;
    Args.hipStreamWaitEvent_spt.event = event;
    Args.hipStreamWaitEvent_spt.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamWaitEvent_spt_fn(Args.hipStreamWaitEvent_spt.stream, Args.hipStreamWaitEvent_spt.event, Args.hipStreamWaitEvent_spt.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamWaitEvent_spt_fn(stream, event, flags);
  }
}

static hipError_t hipStreamGetFlags_spt_callback(hipStream_t stream, unsigned int* flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetFlags_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetFlags_spt.stream = stream;
    Args.hipStreamGetFlags_spt.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetFlags_spt_fn(Args.hipStreamGetFlags_spt.stream, Args.hipStreamGetFlags_spt.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetFlags_spt_fn(stream, flags);
  }
}

static hipError_t hipStreamAddCallback_spt_callback(hipStream_t stream, hipStreamCallback_t callback, void* userData, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamAddCallback_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamAddCallback_spt.stream = stream;
    Args.hipStreamAddCallback_spt.callback = callback;
    Args.hipStreamAddCallback_spt.userData = userData;
    Args.hipStreamAddCallback_spt.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamAddCallback_spt_fn(Args.hipStreamAddCallback_spt.stream, Args.hipStreamAddCallback_spt.callback, Args.hipStreamAddCallback_spt.userData, Args.hipStreamAddCallback_spt.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamAddCallback_spt_fn(stream, callback, userData, flags);
  }
}

static hipError_t hipEventRecord_spt_callback(hipEvent_t event, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipEventRecord_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipEventRecord_spt.event = event;
    Args.hipEventRecord_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipEventRecord_spt_fn(Args.hipEventRecord_spt.event, Args.hipEventRecord_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipEventRecord_spt_fn(event, stream);
  }
}

static hipError_t hipLaunchKernel_spt_callback(const void* function_address, dim3 numBlocks, dim3 dimBlocks, void** args, size_t sharedMemBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchKernel_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipLaunchKernel_spt.function_address = function_address;
    Args.hipLaunchKernel_spt.numBlocks = luthier::convertToRocprofilerDim3(numBlocks);
    Args.hipLaunchKernel_spt.dimBlocks = luthier::convertToRocprofilerDim3(dimBlocks);
    Args.hipLaunchKernel_spt.args = args;
    Args.hipLaunchKernel_spt.sharedMemBytes = sharedMemBytes;
    Args.hipLaunchKernel_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipLaunchKernel_spt_fn(Args.hipLaunchKernel_spt.function_address, numBlocks, dimBlocks, Args.hipLaunchKernel_spt.args, Args.hipLaunchKernel_spt.sharedMemBytes, Args.hipLaunchKernel_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipLaunchKernel_spt_fn(function_address, numBlocks, dimBlocks, args, sharedMemBytes, stream);
  }
}

static hipError_t hipGraphLaunch_spt_callback(hipGraphExec_t graphExec, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphLaunch_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphLaunch_spt.graphExec = graphExec;
    Args.hipGraphLaunch_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphLaunch_spt_fn(Args.hipGraphLaunch_spt.graphExec, Args.hipGraphLaunch_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphLaunch_spt_fn(graphExec, stream);
  }
}

static hipError_t hipStreamBeginCapture_spt_callback(hipStream_t stream, hipStreamCaptureMode mode) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamBeginCapture_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamBeginCapture_spt.stream = stream;
    Args.hipStreamBeginCapture_spt.mode = mode;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamBeginCapture_spt_fn(Args.hipStreamBeginCapture_spt.stream, Args.hipStreamBeginCapture_spt.mode);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamBeginCapture_spt_fn(stream, mode);
  }
}

static hipError_t hipStreamEndCapture_spt_callback(hipStream_t stream, hipGraph_t* pGraph) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamEndCapture_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamEndCapture_spt.stream = stream;
    Args.hipStreamEndCapture_spt.pGraph = pGraph;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamEndCapture_spt_fn(Args.hipStreamEndCapture_spt.stream, Args.hipStreamEndCapture_spt.pGraph);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamEndCapture_spt_fn(stream, pGraph);
  }
}

static hipError_t hipStreamIsCapturing_spt_callback(hipStream_t stream, hipStreamCaptureStatus* pCaptureStatus) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamIsCapturing_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamIsCapturing_spt.stream = stream;
    Args.hipStreamIsCapturing_spt.pCaptureStatus = pCaptureStatus;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamIsCapturing_spt_fn(Args.hipStreamIsCapturing_spt.stream, Args.hipStreamIsCapturing_spt.pCaptureStatus);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamIsCapturing_spt_fn(stream, pCaptureStatus);
  }
}

static hipError_t hipStreamGetCaptureInfo_spt_callback(hipStream_t stream, hipStreamCaptureStatus* pCaptureStatus, unsigned long long* pId) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetCaptureInfo_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetCaptureInfo_spt.stream = stream;
    Args.hipStreamGetCaptureInfo_spt.pCaptureStatus = pCaptureStatus;
    Args.hipStreamGetCaptureInfo_spt.pId = pId;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetCaptureInfo_spt_fn(Args.hipStreamGetCaptureInfo_spt.stream, Args.hipStreamGetCaptureInfo_spt.pCaptureStatus, Args.hipStreamGetCaptureInfo_spt.pId);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetCaptureInfo_spt_fn(stream, pCaptureStatus, pId);
  }
}

static hipError_t hipStreamGetCaptureInfo_v2_spt_callback(hipStream_t stream, hipStreamCaptureStatus* captureStatus_out, unsigned long long* id_out, hipGraph_t* graph_out, const hipGraphNode_t** dependencies_out, size_t* numDependencies_out) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetCaptureInfo_v2_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetCaptureInfo_v2_spt.stream = stream;
    Args.hipStreamGetCaptureInfo_v2_spt.captureStatus_out = captureStatus_out;
    Args.hipStreamGetCaptureInfo_v2_spt.id_out = id_out;
    Args.hipStreamGetCaptureInfo_v2_spt.graph_out = graph_out;
    Args.hipStreamGetCaptureInfo_v2_spt.dependencies_out = dependencies_out;
    Args.hipStreamGetCaptureInfo_v2_spt.numDependencies_out = numDependencies_out;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetCaptureInfo_v2_spt_fn(Args.hipStreamGetCaptureInfo_v2_spt.stream, Args.hipStreamGetCaptureInfo_v2_spt.captureStatus_out, Args.hipStreamGetCaptureInfo_v2_spt.id_out, Args.hipStreamGetCaptureInfo_v2_spt.graph_out, Args.hipStreamGetCaptureInfo_v2_spt.dependencies_out, Args.hipStreamGetCaptureInfo_v2_spt.numDependencies_out);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetCaptureInfo_v2_spt_fn(stream, captureStatus_out, id_out, graph_out, dependencies_out, numDependencies_out);
  }
}

static hipError_t hipLaunchHostFunc_spt_callback(hipStream_t stream, hipHostFn_t fn, void* userData) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchHostFunc_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipLaunchHostFunc_spt.stream = stream;
    Args.hipLaunchHostFunc_spt.fn = fn;
    Args.hipLaunchHostFunc_spt.userData = userData;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipLaunchHostFunc_spt_fn(Args.hipLaunchHostFunc_spt.stream, Args.hipLaunchHostFunc_spt.fn, Args.hipLaunchHostFunc_spt.userData);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipLaunchHostFunc_spt_fn(stream, fn, userData);
  }
}

static int hipGetStreamDeviceId_callback(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetStreamDeviceId;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    int Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetStreamDeviceId.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetStreamDeviceId_fn(Args.hipGetStreamDeviceId.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetStreamDeviceId_fn(stream);
  }
}

static hipError_t hipDrvGraphAddMemsetNode_callback(hipGraphNode_t* phGraphNode, hipGraph_t hGraph, const hipGraphNode_t* dependencies, size_t numDependencies, const HIP_MEMSET_NODE_PARAMS* memsetParams, hipCtx_t ctx) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvGraphAddMemsetNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDrvGraphAddMemsetNode.phGraphNode = phGraphNode;
    Args.hipDrvGraphAddMemsetNode.hGraph = hGraph;
    Args.hipDrvGraphAddMemsetNode.dependencies = dependencies;
    Args.hipDrvGraphAddMemsetNode.numDependencies = numDependencies;
    Args.hipDrvGraphAddMemsetNode.memsetParams = memsetParams;
    Args.hipDrvGraphAddMemsetNode.ctx = ctx;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDrvGraphAddMemsetNode_fn(Args.hipDrvGraphAddMemsetNode.phGraphNode, Args.hipDrvGraphAddMemsetNode.hGraph, Args.hipDrvGraphAddMemsetNode.dependencies, Args.hipDrvGraphAddMemsetNode.numDependencies, Args.hipDrvGraphAddMemsetNode.memsetParams, Args.hipDrvGraphAddMemsetNode.ctx);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDrvGraphAddMemsetNode_fn(phGraphNode, hGraph, dependencies, numDependencies, memsetParams, ctx);
  }
}

static hipError_t hipGraphAddExternalSemaphoresWaitNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const hipExternalSemaphoreWaitNodeParams* nodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddExternalSemaphoresWaitNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddExternalSemaphoresWaitNode.pGraphNode = pGraphNode;
    Args.hipGraphAddExternalSemaphoresWaitNode.graph = graph;
    Args.hipGraphAddExternalSemaphoresWaitNode.pDependencies = pDependencies;
    Args.hipGraphAddExternalSemaphoresWaitNode.numDependencies = numDependencies;
    Args.hipGraphAddExternalSemaphoresWaitNode.nodeParams = nodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddExternalSemaphoresWaitNode_fn(Args.hipGraphAddExternalSemaphoresWaitNode.pGraphNode, Args.hipGraphAddExternalSemaphoresWaitNode.graph, Args.hipGraphAddExternalSemaphoresWaitNode.pDependencies, Args.hipGraphAddExternalSemaphoresWaitNode.numDependencies, Args.hipGraphAddExternalSemaphoresWaitNode.nodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddExternalSemaphoresWaitNode_fn(pGraphNode, graph, pDependencies, numDependencies, nodeParams);
  }
}

static hipError_t hipGraphAddExternalSemaphoresSignalNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const hipExternalSemaphoreSignalNodeParams* nodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddExternalSemaphoresSignalNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddExternalSemaphoresSignalNode.pGraphNode = pGraphNode;
    Args.hipGraphAddExternalSemaphoresSignalNode.graph = graph;
    Args.hipGraphAddExternalSemaphoresSignalNode.pDependencies = pDependencies;
    Args.hipGraphAddExternalSemaphoresSignalNode.numDependencies = numDependencies;
    Args.hipGraphAddExternalSemaphoresSignalNode.nodeParams = nodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddExternalSemaphoresSignalNode_fn(Args.hipGraphAddExternalSemaphoresSignalNode.pGraphNode, Args.hipGraphAddExternalSemaphoresSignalNode.graph, Args.hipGraphAddExternalSemaphoresSignalNode.pDependencies, Args.hipGraphAddExternalSemaphoresSignalNode.numDependencies, Args.hipGraphAddExternalSemaphoresSignalNode.nodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddExternalSemaphoresSignalNode_fn(pGraphNode, graph, pDependencies, numDependencies, nodeParams);
  }
}

static hipError_t hipGraphExternalSemaphoresSignalNodeSetParams_callback(hipGraphNode_t hNode, const hipExternalSemaphoreSignalNodeParams* nodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExternalSemaphoresSignalNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExternalSemaphoresSignalNodeSetParams.hNode = hNode;
    Args.hipGraphExternalSemaphoresSignalNodeSetParams.nodeParams = nodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExternalSemaphoresSignalNodeSetParams_fn(Args.hipGraphExternalSemaphoresSignalNodeSetParams.hNode, Args.hipGraphExternalSemaphoresSignalNodeSetParams.nodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExternalSemaphoresSignalNodeSetParams_fn(hNode, nodeParams);
  }
}

static hipError_t hipGraphExternalSemaphoresWaitNodeSetParams_callback(hipGraphNode_t hNode, const hipExternalSemaphoreWaitNodeParams* nodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExternalSemaphoresWaitNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExternalSemaphoresWaitNodeSetParams.hNode = hNode;
    Args.hipGraphExternalSemaphoresWaitNodeSetParams.nodeParams = nodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExternalSemaphoresWaitNodeSetParams_fn(Args.hipGraphExternalSemaphoresWaitNodeSetParams.hNode, Args.hipGraphExternalSemaphoresWaitNodeSetParams.nodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExternalSemaphoresWaitNodeSetParams_fn(hNode, nodeParams);
  }
}

static hipError_t hipGraphExternalSemaphoresSignalNodeGetParams_callback(hipGraphNode_t hNode, hipExternalSemaphoreSignalNodeParams* params_out) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExternalSemaphoresSignalNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExternalSemaphoresSignalNodeGetParams.hNode = hNode;
    Args.hipGraphExternalSemaphoresSignalNodeGetParams.params_out = params_out;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExternalSemaphoresSignalNodeGetParams_fn(Args.hipGraphExternalSemaphoresSignalNodeGetParams.hNode, Args.hipGraphExternalSemaphoresSignalNodeGetParams.params_out);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExternalSemaphoresSignalNodeGetParams_fn(hNode, params_out);
  }
}

static hipError_t hipGraphExternalSemaphoresWaitNodeGetParams_callback(hipGraphNode_t hNode, hipExternalSemaphoreWaitNodeParams* params_out) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExternalSemaphoresWaitNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExternalSemaphoresWaitNodeGetParams.hNode = hNode;
    Args.hipGraphExternalSemaphoresWaitNodeGetParams.params_out = params_out;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExternalSemaphoresWaitNodeGetParams_fn(Args.hipGraphExternalSemaphoresWaitNodeGetParams.hNode, Args.hipGraphExternalSemaphoresWaitNodeGetParams.params_out);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExternalSemaphoresWaitNodeGetParams_fn(hNode, params_out);
  }
}

static hipError_t hipGraphExecExternalSemaphoresSignalNodeSetParams_callback(hipGraphExec_t hGraphExec, hipGraphNode_t hNode, const hipExternalSemaphoreSignalNodeParams* nodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecExternalSemaphoresSignalNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecExternalSemaphoresSignalNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecExternalSemaphoresSignalNodeSetParams.hNode = hNode;
    Args.hipGraphExecExternalSemaphoresSignalNodeSetParams.nodeParams = nodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecExternalSemaphoresSignalNodeSetParams_fn(Args.hipGraphExecExternalSemaphoresSignalNodeSetParams.hGraphExec, Args.hipGraphExecExternalSemaphoresSignalNodeSetParams.hNode, Args.hipGraphExecExternalSemaphoresSignalNodeSetParams.nodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecExternalSemaphoresSignalNodeSetParams_fn(hGraphExec, hNode, nodeParams);
  }
}

static hipError_t hipGraphExecExternalSemaphoresWaitNodeSetParams_callback(hipGraphExec_t hGraphExec, hipGraphNode_t hNode, const hipExternalSemaphoreWaitNodeParams* nodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecExternalSemaphoresWaitNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecExternalSemaphoresWaitNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecExternalSemaphoresWaitNodeSetParams.hNode = hNode;
    Args.hipGraphExecExternalSemaphoresWaitNodeSetParams.nodeParams = nodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecExternalSemaphoresWaitNodeSetParams_fn(Args.hipGraphExecExternalSemaphoresWaitNodeSetParams.hGraphExec, Args.hipGraphExecExternalSemaphoresWaitNodeSetParams.hNode, Args.hipGraphExecExternalSemaphoresWaitNodeSetParams.nodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecExternalSemaphoresWaitNodeSetParams_fn(hGraphExec, hNode, nodeParams);
  }
}

static hipError_t hipGraphAddNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, hipGraphNodeParams* nodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddNode.pGraphNode = pGraphNode;
    Args.hipGraphAddNode.graph = graph;
    Args.hipGraphAddNode.pDependencies = pDependencies;
    Args.hipGraphAddNode.numDependencies = numDependencies;
    Args.hipGraphAddNode.nodeParams = nodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddNode_fn(Args.hipGraphAddNode.pGraphNode, Args.hipGraphAddNode.graph, Args.hipGraphAddNode.pDependencies, Args.hipGraphAddNode.numDependencies, Args.hipGraphAddNode.nodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddNode_fn(pGraphNode, graph, pDependencies, numDependencies, nodeParams);
  }
}

static hipError_t hipGraphInstantiateWithParams_callback(hipGraphExec_t* pGraphExec, hipGraph_t graph, hipGraphInstantiateParams* instantiateParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphInstantiateWithParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphInstantiateWithParams.pGraphExec = pGraphExec;
    Args.hipGraphInstantiateWithParams.graph = graph;
    Args.hipGraphInstantiateWithParams.instantiateParams = instantiateParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphInstantiateWithParams_fn(Args.hipGraphInstantiateWithParams.pGraphExec, Args.hipGraphInstantiateWithParams.graph, Args.hipGraphInstantiateWithParams.instantiateParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphInstantiateWithParams_fn(pGraphExec, graph, instantiateParams);
  }
}

static hipError_t hipExtGetLastError_callback() {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipExtGetLastError;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipExtGetLastError_fn();
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipExtGetLastError_fn();
  }
}

static hipError_t hipTexRefGetBorderColor_callback(float* pBorderColor, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetBorderColor;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetBorderColor.pBorderColor = pBorderColor;
    Args.hipTexRefGetBorderColor.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetBorderColor_fn(Args.hipTexRefGetBorderColor.pBorderColor, Args.hipTexRefGetBorderColor.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetBorderColor_fn(pBorderColor, texRef);
  }
}

static hipError_t hipTexRefGetArray_callback(hipArray_t* pArray, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetArray.pArray = pArray;
    Args.hipTexRefGetArray.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetArray_fn(Args.hipTexRefGetArray.pArray, Args.hipTexRefGetArray.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetArray_fn(pArray, texRef);
  }
}


void luthier::hip::RuntimeInterceptor::captureRuntimeTable(HipDispatchTable *RuntimeTable) {
	SavedDispatchTable = *RuntimeTable;
};


static void toggle_hipApiName(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipApiName_fn = hipApiName_callback;
  else
    InternalRuntimeDispatchTable->hipApiName_fn = SavedTable.hipApiName_fn;
}

static void toggle_hipArray3DCreate(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipArray3DCreate_fn = hipArray3DCreate_callback;
  else
    InternalRuntimeDispatchTable->hipArray3DCreate_fn = SavedTable.hipArray3DCreate_fn;
}

static void toggle_hipArray3DGetDescriptor(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipArray3DGetDescriptor_fn = hipArray3DGetDescriptor_callback;
  else
    InternalRuntimeDispatchTable->hipArray3DGetDescriptor_fn = SavedTable.hipArray3DGetDescriptor_fn;
}

static void toggle_hipArrayCreate(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipArrayCreate_fn = hipArrayCreate_callback;
  else
    InternalRuntimeDispatchTable->hipArrayCreate_fn = SavedTable.hipArrayCreate_fn;
}

static void toggle_hipArrayDestroy(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipArrayDestroy_fn = hipArrayDestroy_callback;
  else
    InternalRuntimeDispatchTable->hipArrayDestroy_fn = SavedTable.hipArrayDestroy_fn;
}

static void toggle_hipArrayGetDescriptor(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipArrayGetDescriptor_fn = hipArrayGetDescriptor_callback;
  else
    InternalRuntimeDispatchTable->hipArrayGetDescriptor_fn = SavedTable.hipArrayGetDescriptor_fn;
}

static void toggle_hipArrayGetInfo(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipArrayGetInfo_fn = hipArrayGetInfo_callback;
  else
    InternalRuntimeDispatchTable->hipArrayGetInfo_fn = SavedTable.hipArrayGetInfo_fn;
}

static void toggle_hipBindTexture(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipBindTexture_fn = hipBindTexture_callback;
  else
    InternalRuntimeDispatchTable->hipBindTexture_fn = SavedTable.hipBindTexture_fn;
}

static void toggle_hipBindTexture2D(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipBindTexture2D_fn = hipBindTexture2D_callback;
  else
    InternalRuntimeDispatchTable->hipBindTexture2D_fn = SavedTable.hipBindTexture2D_fn;
}

static void toggle_hipBindTextureToArray(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipBindTextureToArray_fn = hipBindTextureToArray_callback;
  else
    InternalRuntimeDispatchTable->hipBindTextureToArray_fn = SavedTable.hipBindTextureToArray_fn;
}

static void toggle_hipBindTextureToMipmappedArray(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipBindTextureToMipmappedArray_fn = hipBindTextureToMipmappedArray_callback;
  else
    InternalRuntimeDispatchTable->hipBindTextureToMipmappedArray_fn = SavedTable.hipBindTextureToMipmappedArray_fn;
}

static void toggle_hipChooseDevice(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipChooseDevice_fn = hipChooseDevice_callback;
  else
    InternalRuntimeDispatchTable->hipChooseDevice_fn = SavedTable.hipChooseDevice_fn;
}

static void toggle_hipConfigureCall(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipConfigureCall_fn = hipConfigureCall_callback;
  else
    InternalRuntimeDispatchTable->hipConfigureCall_fn = SavedTable.hipConfigureCall_fn;
}

static void toggle_hipCreateSurfaceObject(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCreateSurfaceObject_fn = hipCreateSurfaceObject_callback;
  else
    InternalRuntimeDispatchTable->hipCreateSurfaceObject_fn = SavedTable.hipCreateSurfaceObject_fn;
}

static void toggle_hipCreateTextureObject(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCreateTextureObject_fn = hipCreateTextureObject_callback;
  else
    InternalRuntimeDispatchTable->hipCreateTextureObject_fn = SavedTable.hipCreateTextureObject_fn;
}

static void toggle_hipCtxCreate(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCtxCreate_fn = hipCtxCreate_callback;
  else
    InternalRuntimeDispatchTable->hipCtxCreate_fn = SavedTable.hipCtxCreate_fn;
}

static void toggle_hipCtxDestroy(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCtxDestroy_fn = hipCtxDestroy_callback;
  else
    InternalRuntimeDispatchTable->hipCtxDestroy_fn = SavedTable.hipCtxDestroy_fn;
}

static void toggle_hipCtxDisablePeerAccess(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCtxDisablePeerAccess_fn = hipCtxDisablePeerAccess_callback;
  else
    InternalRuntimeDispatchTable->hipCtxDisablePeerAccess_fn = SavedTable.hipCtxDisablePeerAccess_fn;
}

static void toggle_hipCtxEnablePeerAccess(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCtxEnablePeerAccess_fn = hipCtxEnablePeerAccess_callback;
  else
    InternalRuntimeDispatchTable->hipCtxEnablePeerAccess_fn = SavedTable.hipCtxEnablePeerAccess_fn;
}

static void toggle_hipCtxGetApiVersion(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCtxGetApiVersion_fn = hipCtxGetApiVersion_callback;
  else
    InternalRuntimeDispatchTable->hipCtxGetApiVersion_fn = SavedTable.hipCtxGetApiVersion_fn;
}

static void toggle_hipCtxGetCacheConfig(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCtxGetCacheConfig_fn = hipCtxGetCacheConfig_callback;
  else
    InternalRuntimeDispatchTable->hipCtxGetCacheConfig_fn = SavedTable.hipCtxGetCacheConfig_fn;
}

static void toggle_hipCtxGetCurrent(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCtxGetCurrent_fn = hipCtxGetCurrent_callback;
  else
    InternalRuntimeDispatchTable->hipCtxGetCurrent_fn = SavedTable.hipCtxGetCurrent_fn;
}

static void toggle_hipCtxGetDevice(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCtxGetDevice_fn = hipCtxGetDevice_callback;
  else
    InternalRuntimeDispatchTable->hipCtxGetDevice_fn = SavedTable.hipCtxGetDevice_fn;
}

static void toggle_hipCtxGetFlags(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCtxGetFlags_fn = hipCtxGetFlags_callback;
  else
    InternalRuntimeDispatchTable->hipCtxGetFlags_fn = SavedTable.hipCtxGetFlags_fn;
}

static void toggle_hipCtxGetSharedMemConfig(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCtxGetSharedMemConfig_fn = hipCtxGetSharedMemConfig_callback;
  else
    InternalRuntimeDispatchTable->hipCtxGetSharedMemConfig_fn = SavedTable.hipCtxGetSharedMemConfig_fn;
}

static void toggle_hipCtxPopCurrent(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCtxPopCurrent_fn = hipCtxPopCurrent_callback;
  else
    InternalRuntimeDispatchTable->hipCtxPopCurrent_fn = SavedTable.hipCtxPopCurrent_fn;
}

static void toggle_hipCtxPushCurrent(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCtxPushCurrent_fn = hipCtxPushCurrent_callback;
  else
    InternalRuntimeDispatchTable->hipCtxPushCurrent_fn = SavedTable.hipCtxPushCurrent_fn;
}

static void toggle_hipCtxSetCacheConfig(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCtxSetCacheConfig_fn = hipCtxSetCacheConfig_callback;
  else
    InternalRuntimeDispatchTable->hipCtxSetCacheConfig_fn = SavedTable.hipCtxSetCacheConfig_fn;
}

static void toggle_hipCtxSetCurrent(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCtxSetCurrent_fn = hipCtxSetCurrent_callback;
  else
    InternalRuntimeDispatchTable->hipCtxSetCurrent_fn = SavedTable.hipCtxSetCurrent_fn;
}

static void toggle_hipCtxSetSharedMemConfig(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCtxSetSharedMemConfig_fn = hipCtxSetSharedMemConfig_callback;
  else
    InternalRuntimeDispatchTable->hipCtxSetSharedMemConfig_fn = SavedTable.hipCtxSetSharedMemConfig_fn;
}

static void toggle_hipCtxSynchronize(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCtxSynchronize_fn = hipCtxSynchronize_callback;
  else
    InternalRuntimeDispatchTable->hipCtxSynchronize_fn = SavedTable.hipCtxSynchronize_fn;
}

static void toggle_hipDestroyExternalMemory(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDestroyExternalMemory_fn = hipDestroyExternalMemory_callback;
  else
    InternalRuntimeDispatchTable->hipDestroyExternalMemory_fn = SavedTable.hipDestroyExternalMemory_fn;
}

static void toggle_hipDestroyExternalSemaphore(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDestroyExternalSemaphore_fn = hipDestroyExternalSemaphore_callback;
  else
    InternalRuntimeDispatchTable->hipDestroyExternalSemaphore_fn = SavedTable.hipDestroyExternalSemaphore_fn;
}

static void toggle_hipDestroySurfaceObject(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDestroySurfaceObject_fn = hipDestroySurfaceObject_callback;
  else
    InternalRuntimeDispatchTable->hipDestroySurfaceObject_fn = SavedTable.hipDestroySurfaceObject_fn;
}

static void toggle_hipDestroyTextureObject(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDestroyTextureObject_fn = hipDestroyTextureObject_callback;
  else
    InternalRuntimeDispatchTable->hipDestroyTextureObject_fn = SavedTable.hipDestroyTextureObject_fn;
}

static void toggle_hipDeviceCanAccessPeer(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceCanAccessPeer_fn = hipDeviceCanAccessPeer_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceCanAccessPeer_fn = SavedTable.hipDeviceCanAccessPeer_fn;
}

static void toggle_hipDeviceComputeCapability(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceComputeCapability_fn = hipDeviceComputeCapability_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceComputeCapability_fn = SavedTable.hipDeviceComputeCapability_fn;
}

static void toggle_hipDeviceDisablePeerAccess(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceDisablePeerAccess_fn = hipDeviceDisablePeerAccess_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceDisablePeerAccess_fn = SavedTable.hipDeviceDisablePeerAccess_fn;
}

static void toggle_hipDeviceEnablePeerAccess(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceEnablePeerAccess_fn = hipDeviceEnablePeerAccess_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceEnablePeerAccess_fn = SavedTable.hipDeviceEnablePeerAccess_fn;
}

static void toggle_hipDeviceGet(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceGet_fn = hipDeviceGet_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceGet_fn = SavedTable.hipDeviceGet_fn;
}

static void toggle_hipDeviceGetAttribute(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceGetAttribute_fn = hipDeviceGetAttribute_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceGetAttribute_fn = SavedTable.hipDeviceGetAttribute_fn;
}

static void toggle_hipDeviceGetByPCIBusId(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceGetByPCIBusId_fn = hipDeviceGetByPCIBusId_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceGetByPCIBusId_fn = SavedTable.hipDeviceGetByPCIBusId_fn;
}

static void toggle_hipDeviceGetCacheConfig(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceGetCacheConfig_fn = hipDeviceGetCacheConfig_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceGetCacheConfig_fn = SavedTable.hipDeviceGetCacheConfig_fn;
}

static void toggle_hipDeviceGetDefaultMemPool(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceGetDefaultMemPool_fn = hipDeviceGetDefaultMemPool_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceGetDefaultMemPool_fn = SavedTable.hipDeviceGetDefaultMemPool_fn;
}

static void toggle_hipDeviceGetGraphMemAttribute(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceGetGraphMemAttribute_fn = hipDeviceGetGraphMemAttribute_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceGetGraphMemAttribute_fn = SavedTable.hipDeviceGetGraphMemAttribute_fn;
}

static void toggle_hipDeviceGetLimit(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceGetLimit_fn = hipDeviceGetLimit_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceGetLimit_fn = SavedTable.hipDeviceGetLimit_fn;
}

static void toggle_hipDeviceGetMemPool(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceGetMemPool_fn = hipDeviceGetMemPool_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceGetMemPool_fn = SavedTable.hipDeviceGetMemPool_fn;
}

static void toggle_hipDeviceGetName(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceGetName_fn = hipDeviceGetName_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceGetName_fn = SavedTable.hipDeviceGetName_fn;
}

static void toggle_hipDeviceGetP2PAttribute(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceGetP2PAttribute_fn = hipDeviceGetP2PAttribute_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceGetP2PAttribute_fn = SavedTable.hipDeviceGetP2PAttribute_fn;
}

static void toggle_hipDeviceGetPCIBusId(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceGetPCIBusId_fn = hipDeviceGetPCIBusId_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceGetPCIBusId_fn = SavedTable.hipDeviceGetPCIBusId_fn;
}

static void toggle_hipDeviceGetSharedMemConfig(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceGetSharedMemConfig_fn = hipDeviceGetSharedMemConfig_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceGetSharedMemConfig_fn = SavedTable.hipDeviceGetSharedMemConfig_fn;
}

static void toggle_hipDeviceGetStreamPriorityRange(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceGetStreamPriorityRange_fn = hipDeviceGetStreamPriorityRange_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceGetStreamPriorityRange_fn = SavedTable.hipDeviceGetStreamPriorityRange_fn;
}

static void toggle_hipDeviceGetUuid(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceGetUuid_fn = hipDeviceGetUuid_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceGetUuid_fn = SavedTable.hipDeviceGetUuid_fn;
}

static void toggle_hipDeviceGraphMemTrim(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceGraphMemTrim_fn = hipDeviceGraphMemTrim_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceGraphMemTrim_fn = SavedTable.hipDeviceGraphMemTrim_fn;
}

static void toggle_hipDevicePrimaryCtxGetState(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDevicePrimaryCtxGetState_fn = hipDevicePrimaryCtxGetState_callback;
  else
    InternalRuntimeDispatchTable->hipDevicePrimaryCtxGetState_fn = SavedTable.hipDevicePrimaryCtxGetState_fn;
}

static void toggle_hipDevicePrimaryCtxRelease(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDevicePrimaryCtxRelease_fn = hipDevicePrimaryCtxRelease_callback;
  else
    InternalRuntimeDispatchTable->hipDevicePrimaryCtxRelease_fn = SavedTable.hipDevicePrimaryCtxRelease_fn;
}

static void toggle_hipDevicePrimaryCtxReset(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDevicePrimaryCtxReset_fn = hipDevicePrimaryCtxReset_callback;
  else
    InternalRuntimeDispatchTable->hipDevicePrimaryCtxReset_fn = SavedTable.hipDevicePrimaryCtxReset_fn;
}

static void toggle_hipDevicePrimaryCtxRetain(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDevicePrimaryCtxRetain_fn = hipDevicePrimaryCtxRetain_callback;
  else
    InternalRuntimeDispatchTable->hipDevicePrimaryCtxRetain_fn = SavedTable.hipDevicePrimaryCtxRetain_fn;
}

static void toggle_hipDevicePrimaryCtxSetFlags(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDevicePrimaryCtxSetFlags_fn = hipDevicePrimaryCtxSetFlags_callback;
  else
    InternalRuntimeDispatchTable->hipDevicePrimaryCtxSetFlags_fn = SavedTable.hipDevicePrimaryCtxSetFlags_fn;
}

static void toggle_hipDeviceReset(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceReset_fn = hipDeviceReset_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceReset_fn = SavedTable.hipDeviceReset_fn;
}

static void toggle_hipDeviceSetCacheConfig(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceSetCacheConfig_fn = hipDeviceSetCacheConfig_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceSetCacheConfig_fn = SavedTable.hipDeviceSetCacheConfig_fn;
}

static void toggle_hipDeviceSetGraphMemAttribute(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceSetGraphMemAttribute_fn = hipDeviceSetGraphMemAttribute_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceSetGraphMemAttribute_fn = SavedTable.hipDeviceSetGraphMemAttribute_fn;
}

static void toggle_hipDeviceSetLimit(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceSetLimit_fn = hipDeviceSetLimit_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceSetLimit_fn = SavedTable.hipDeviceSetLimit_fn;
}

static void toggle_hipDeviceSetMemPool(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceSetMemPool_fn = hipDeviceSetMemPool_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceSetMemPool_fn = SavedTable.hipDeviceSetMemPool_fn;
}

static void toggle_hipDeviceSetSharedMemConfig(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceSetSharedMemConfig_fn = hipDeviceSetSharedMemConfig_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceSetSharedMemConfig_fn = SavedTable.hipDeviceSetSharedMemConfig_fn;
}

static void toggle_hipDeviceSynchronize(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceSynchronize_fn = hipDeviceSynchronize_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceSynchronize_fn = SavedTable.hipDeviceSynchronize_fn;
}

static void toggle_hipDeviceTotalMem(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDeviceTotalMem_fn = hipDeviceTotalMem_callback;
  else
    InternalRuntimeDispatchTable->hipDeviceTotalMem_fn = SavedTable.hipDeviceTotalMem_fn;
}

static void toggle_hipDriverGetVersion(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDriverGetVersion_fn = hipDriverGetVersion_callback;
  else
    InternalRuntimeDispatchTable->hipDriverGetVersion_fn = SavedTable.hipDriverGetVersion_fn;
}

static void toggle_hipDrvGetErrorName(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDrvGetErrorName_fn = hipDrvGetErrorName_callback;
  else
    InternalRuntimeDispatchTable->hipDrvGetErrorName_fn = SavedTable.hipDrvGetErrorName_fn;
}

static void toggle_hipDrvGetErrorString(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDrvGetErrorString_fn = hipDrvGetErrorString_callback;
  else
    InternalRuntimeDispatchTable->hipDrvGetErrorString_fn = SavedTable.hipDrvGetErrorString_fn;
}

static void toggle_hipDrvGraphAddMemcpyNode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDrvGraphAddMemcpyNode_fn = hipDrvGraphAddMemcpyNode_callback;
  else
    InternalRuntimeDispatchTable->hipDrvGraphAddMemcpyNode_fn = SavedTable.hipDrvGraphAddMemcpyNode_fn;
}

static void toggle_hipDrvMemcpy2DUnaligned(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDrvMemcpy2DUnaligned_fn = hipDrvMemcpy2DUnaligned_callback;
  else
    InternalRuntimeDispatchTable->hipDrvMemcpy2DUnaligned_fn = SavedTable.hipDrvMemcpy2DUnaligned_fn;
}

static void toggle_hipDrvMemcpy3D(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDrvMemcpy3D_fn = hipDrvMemcpy3D_callback;
  else
    InternalRuntimeDispatchTable->hipDrvMemcpy3D_fn = SavedTable.hipDrvMemcpy3D_fn;
}

static void toggle_hipDrvMemcpy3DAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDrvMemcpy3DAsync_fn = hipDrvMemcpy3DAsync_callback;
  else
    InternalRuntimeDispatchTable->hipDrvMemcpy3DAsync_fn = SavedTable.hipDrvMemcpy3DAsync_fn;
}

static void toggle_hipDrvPointerGetAttributes(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDrvPointerGetAttributes_fn = hipDrvPointerGetAttributes_callback;
  else
    InternalRuntimeDispatchTable->hipDrvPointerGetAttributes_fn = SavedTable.hipDrvPointerGetAttributes_fn;
}

static void toggle_hipEventCreate(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipEventCreate_fn = hipEventCreate_callback;
  else
    InternalRuntimeDispatchTable->hipEventCreate_fn = SavedTable.hipEventCreate_fn;
}

static void toggle_hipEventCreateWithFlags(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipEventCreateWithFlags_fn = hipEventCreateWithFlags_callback;
  else
    InternalRuntimeDispatchTable->hipEventCreateWithFlags_fn = SavedTable.hipEventCreateWithFlags_fn;
}

static void toggle_hipEventDestroy(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipEventDestroy_fn = hipEventDestroy_callback;
  else
    InternalRuntimeDispatchTable->hipEventDestroy_fn = SavedTable.hipEventDestroy_fn;
}

static void toggle_hipEventElapsedTime(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipEventElapsedTime_fn = hipEventElapsedTime_callback;
  else
    InternalRuntimeDispatchTable->hipEventElapsedTime_fn = SavedTable.hipEventElapsedTime_fn;
}

static void toggle_hipEventQuery(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipEventQuery_fn = hipEventQuery_callback;
  else
    InternalRuntimeDispatchTable->hipEventQuery_fn = SavedTable.hipEventQuery_fn;
}

static void toggle_hipEventRecord(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipEventRecord_fn = hipEventRecord_callback;
  else
    InternalRuntimeDispatchTable->hipEventRecord_fn = SavedTable.hipEventRecord_fn;
}

static void toggle_hipEventSynchronize(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipEventSynchronize_fn = hipEventSynchronize_callback;
  else
    InternalRuntimeDispatchTable->hipEventSynchronize_fn = SavedTable.hipEventSynchronize_fn;
}

static void toggle_hipExtGetLinkTypeAndHopCount(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipExtGetLinkTypeAndHopCount_fn = hipExtGetLinkTypeAndHopCount_callback;
  else
    InternalRuntimeDispatchTable->hipExtGetLinkTypeAndHopCount_fn = SavedTable.hipExtGetLinkTypeAndHopCount_fn;
}

static void toggle_hipExtLaunchKernel(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipExtLaunchKernel_fn = hipExtLaunchKernel_callback;
  else
    InternalRuntimeDispatchTable->hipExtLaunchKernel_fn = SavedTable.hipExtLaunchKernel_fn;
}

static void toggle_hipExtLaunchMultiKernelMultiDevice(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipExtLaunchMultiKernelMultiDevice_fn = hipExtLaunchMultiKernelMultiDevice_callback;
  else
    InternalRuntimeDispatchTable->hipExtLaunchMultiKernelMultiDevice_fn = SavedTable.hipExtLaunchMultiKernelMultiDevice_fn;
}

static void toggle_hipExtMallocWithFlags(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipExtMallocWithFlags_fn = hipExtMallocWithFlags_callback;
  else
    InternalRuntimeDispatchTable->hipExtMallocWithFlags_fn = SavedTable.hipExtMallocWithFlags_fn;
}

static void toggle_hipExtStreamCreateWithCUMask(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipExtStreamCreateWithCUMask_fn = hipExtStreamCreateWithCUMask_callback;
  else
    InternalRuntimeDispatchTable->hipExtStreamCreateWithCUMask_fn = SavedTable.hipExtStreamCreateWithCUMask_fn;
}

static void toggle_hipExtStreamGetCUMask(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipExtStreamGetCUMask_fn = hipExtStreamGetCUMask_callback;
  else
    InternalRuntimeDispatchTable->hipExtStreamGetCUMask_fn = SavedTable.hipExtStreamGetCUMask_fn;
}

static void toggle_hipExternalMemoryGetMappedBuffer(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipExternalMemoryGetMappedBuffer_fn = hipExternalMemoryGetMappedBuffer_callback;
  else
    InternalRuntimeDispatchTable->hipExternalMemoryGetMappedBuffer_fn = SavedTable.hipExternalMemoryGetMappedBuffer_fn;
}

static void toggle_hipFree(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipFree_fn = hipFree_callback;
  else
    InternalRuntimeDispatchTable->hipFree_fn = SavedTable.hipFree_fn;
}

static void toggle_hipFreeArray(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipFreeArray_fn = hipFreeArray_callback;
  else
    InternalRuntimeDispatchTable->hipFreeArray_fn = SavedTable.hipFreeArray_fn;
}

static void toggle_hipFreeAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipFreeAsync_fn = hipFreeAsync_callback;
  else
    InternalRuntimeDispatchTable->hipFreeAsync_fn = SavedTable.hipFreeAsync_fn;
}

static void toggle_hipFreeHost(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipFreeHost_fn = hipFreeHost_callback;
  else
    InternalRuntimeDispatchTable->hipFreeHost_fn = SavedTable.hipFreeHost_fn;
}

static void toggle_hipFreeMipmappedArray(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipFreeMipmappedArray_fn = hipFreeMipmappedArray_callback;
  else
    InternalRuntimeDispatchTable->hipFreeMipmappedArray_fn = SavedTable.hipFreeMipmappedArray_fn;
}

static void toggle_hipFuncGetAttribute(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipFuncGetAttribute_fn = hipFuncGetAttribute_callback;
  else
    InternalRuntimeDispatchTable->hipFuncGetAttribute_fn = SavedTable.hipFuncGetAttribute_fn;
}

static void toggle_hipFuncGetAttributes(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipFuncGetAttributes_fn = hipFuncGetAttributes_callback;
  else
    InternalRuntimeDispatchTable->hipFuncGetAttributes_fn = SavedTable.hipFuncGetAttributes_fn;
}

static void toggle_hipFuncSetAttribute(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipFuncSetAttribute_fn = hipFuncSetAttribute_callback;
  else
    InternalRuntimeDispatchTable->hipFuncSetAttribute_fn = SavedTable.hipFuncSetAttribute_fn;
}

static void toggle_hipFuncSetCacheConfig(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipFuncSetCacheConfig_fn = hipFuncSetCacheConfig_callback;
  else
    InternalRuntimeDispatchTable->hipFuncSetCacheConfig_fn = SavedTable.hipFuncSetCacheConfig_fn;
}

static void toggle_hipFuncSetSharedMemConfig(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipFuncSetSharedMemConfig_fn = hipFuncSetSharedMemConfig_callback;
  else
    InternalRuntimeDispatchTable->hipFuncSetSharedMemConfig_fn = SavedTable.hipFuncSetSharedMemConfig_fn;
}

static void toggle_hipGLGetDevices(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGLGetDevices_fn = hipGLGetDevices_callback;
  else
    InternalRuntimeDispatchTable->hipGLGetDevices_fn = SavedTable.hipGLGetDevices_fn;
}

static void toggle_hipGetChannelDesc(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGetChannelDesc_fn = hipGetChannelDesc_callback;
  else
    InternalRuntimeDispatchTable->hipGetChannelDesc_fn = SavedTable.hipGetChannelDesc_fn;
}

static void toggle_hipGetDevice(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGetDevice_fn = hipGetDevice_callback;
  else
    InternalRuntimeDispatchTable->hipGetDevice_fn = SavedTable.hipGetDevice_fn;
}

static void toggle_hipGetDeviceCount(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGetDeviceCount_fn = hipGetDeviceCount_callback;
  else
    InternalRuntimeDispatchTable->hipGetDeviceCount_fn = SavedTable.hipGetDeviceCount_fn;
}

static void toggle_hipGetDeviceFlags(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGetDeviceFlags_fn = hipGetDeviceFlags_callback;
  else
    InternalRuntimeDispatchTable->hipGetDeviceFlags_fn = SavedTable.hipGetDeviceFlags_fn;
}

static void toggle_hipGetErrorName(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGetErrorName_fn = hipGetErrorName_callback;
  else
    InternalRuntimeDispatchTable->hipGetErrorName_fn = SavedTable.hipGetErrorName_fn;
}

static void toggle_hipGetErrorString(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGetErrorString_fn = hipGetErrorString_callback;
  else
    InternalRuntimeDispatchTable->hipGetErrorString_fn = SavedTable.hipGetErrorString_fn;
}

static void toggle_hipGetLastError(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGetLastError_fn = hipGetLastError_callback;
  else
    InternalRuntimeDispatchTable->hipGetLastError_fn = SavedTable.hipGetLastError_fn;
}

static void toggle_hipGetMipmappedArrayLevel(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGetMipmappedArrayLevel_fn = hipGetMipmappedArrayLevel_callback;
  else
    InternalRuntimeDispatchTable->hipGetMipmappedArrayLevel_fn = SavedTable.hipGetMipmappedArrayLevel_fn;
}

static void toggle_hipGetSymbolAddress(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGetSymbolAddress_fn = hipGetSymbolAddress_callback;
  else
    InternalRuntimeDispatchTable->hipGetSymbolAddress_fn = SavedTable.hipGetSymbolAddress_fn;
}

static void toggle_hipGetSymbolSize(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGetSymbolSize_fn = hipGetSymbolSize_callback;
  else
    InternalRuntimeDispatchTable->hipGetSymbolSize_fn = SavedTable.hipGetSymbolSize_fn;
}

static void toggle_hipGetTextureAlignmentOffset(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGetTextureAlignmentOffset_fn = hipGetTextureAlignmentOffset_callback;
  else
    InternalRuntimeDispatchTable->hipGetTextureAlignmentOffset_fn = SavedTable.hipGetTextureAlignmentOffset_fn;
}

static void toggle_hipGetTextureObjectResourceDesc(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGetTextureObjectResourceDesc_fn = hipGetTextureObjectResourceDesc_callback;
  else
    InternalRuntimeDispatchTable->hipGetTextureObjectResourceDesc_fn = SavedTable.hipGetTextureObjectResourceDesc_fn;
}

static void toggle_hipGetTextureObjectResourceViewDesc(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGetTextureObjectResourceViewDesc_fn = hipGetTextureObjectResourceViewDesc_callback;
  else
    InternalRuntimeDispatchTable->hipGetTextureObjectResourceViewDesc_fn = SavedTable.hipGetTextureObjectResourceViewDesc_fn;
}

static void toggle_hipGetTextureObjectTextureDesc(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGetTextureObjectTextureDesc_fn = hipGetTextureObjectTextureDesc_callback;
  else
    InternalRuntimeDispatchTable->hipGetTextureObjectTextureDesc_fn = SavedTable.hipGetTextureObjectTextureDesc_fn;
}

static void toggle_hipGetTextureReference(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGetTextureReference_fn = hipGetTextureReference_callback;
  else
    InternalRuntimeDispatchTable->hipGetTextureReference_fn = SavedTable.hipGetTextureReference_fn;
}

static void toggle_hipGraphAddChildGraphNode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphAddChildGraphNode_fn = hipGraphAddChildGraphNode_callback;
  else
    InternalRuntimeDispatchTable->hipGraphAddChildGraphNode_fn = SavedTable.hipGraphAddChildGraphNode_fn;
}

static void toggle_hipGraphAddDependencies(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphAddDependencies_fn = hipGraphAddDependencies_callback;
  else
    InternalRuntimeDispatchTable->hipGraphAddDependencies_fn = SavedTable.hipGraphAddDependencies_fn;
}

static void toggle_hipGraphAddEmptyNode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphAddEmptyNode_fn = hipGraphAddEmptyNode_callback;
  else
    InternalRuntimeDispatchTable->hipGraphAddEmptyNode_fn = SavedTable.hipGraphAddEmptyNode_fn;
}

static void toggle_hipGraphAddEventRecordNode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphAddEventRecordNode_fn = hipGraphAddEventRecordNode_callback;
  else
    InternalRuntimeDispatchTable->hipGraphAddEventRecordNode_fn = SavedTable.hipGraphAddEventRecordNode_fn;
}

static void toggle_hipGraphAddEventWaitNode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphAddEventWaitNode_fn = hipGraphAddEventWaitNode_callback;
  else
    InternalRuntimeDispatchTable->hipGraphAddEventWaitNode_fn = SavedTable.hipGraphAddEventWaitNode_fn;
}

static void toggle_hipGraphAddHostNode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphAddHostNode_fn = hipGraphAddHostNode_callback;
  else
    InternalRuntimeDispatchTable->hipGraphAddHostNode_fn = SavedTable.hipGraphAddHostNode_fn;
}

static void toggle_hipGraphAddKernelNode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphAddKernelNode_fn = hipGraphAddKernelNode_callback;
  else
    InternalRuntimeDispatchTable->hipGraphAddKernelNode_fn = SavedTable.hipGraphAddKernelNode_fn;
}

static void toggle_hipGraphAddMemAllocNode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphAddMemAllocNode_fn = hipGraphAddMemAllocNode_callback;
  else
    InternalRuntimeDispatchTable->hipGraphAddMemAllocNode_fn = SavedTable.hipGraphAddMemAllocNode_fn;
}

static void toggle_hipGraphAddMemFreeNode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphAddMemFreeNode_fn = hipGraphAddMemFreeNode_callback;
  else
    InternalRuntimeDispatchTable->hipGraphAddMemFreeNode_fn = SavedTable.hipGraphAddMemFreeNode_fn;
}

static void toggle_hipGraphAddMemcpyNode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphAddMemcpyNode_fn = hipGraphAddMemcpyNode_callback;
  else
    InternalRuntimeDispatchTable->hipGraphAddMemcpyNode_fn = SavedTable.hipGraphAddMemcpyNode_fn;
}

static void toggle_hipGraphAddMemcpyNode1D(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphAddMemcpyNode1D_fn = hipGraphAddMemcpyNode1D_callback;
  else
    InternalRuntimeDispatchTable->hipGraphAddMemcpyNode1D_fn = SavedTable.hipGraphAddMemcpyNode1D_fn;
}

static void toggle_hipGraphAddMemcpyNodeFromSymbol(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphAddMemcpyNodeFromSymbol_fn = hipGraphAddMemcpyNodeFromSymbol_callback;
  else
    InternalRuntimeDispatchTable->hipGraphAddMemcpyNodeFromSymbol_fn = SavedTable.hipGraphAddMemcpyNodeFromSymbol_fn;
}

static void toggle_hipGraphAddMemcpyNodeToSymbol(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphAddMemcpyNodeToSymbol_fn = hipGraphAddMemcpyNodeToSymbol_callback;
  else
    InternalRuntimeDispatchTable->hipGraphAddMemcpyNodeToSymbol_fn = SavedTable.hipGraphAddMemcpyNodeToSymbol_fn;
}

static void toggle_hipGraphAddMemsetNode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphAddMemsetNode_fn = hipGraphAddMemsetNode_callback;
  else
    InternalRuntimeDispatchTable->hipGraphAddMemsetNode_fn = SavedTable.hipGraphAddMemsetNode_fn;
}

static void toggle_hipGraphChildGraphNodeGetGraph(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphChildGraphNodeGetGraph_fn = hipGraphChildGraphNodeGetGraph_callback;
  else
    InternalRuntimeDispatchTable->hipGraphChildGraphNodeGetGraph_fn = SavedTable.hipGraphChildGraphNodeGetGraph_fn;
}

static void toggle_hipGraphClone(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphClone_fn = hipGraphClone_callback;
  else
    InternalRuntimeDispatchTable->hipGraphClone_fn = SavedTable.hipGraphClone_fn;
}

static void toggle_hipGraphCreate(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphCreate_fn = hipGraphCreate_callback;
  else
    InternalRuntimeDispatchTable->hipGraphCreate_fn = SavedTable.hipGraphCreate_fn;
}

static void toggle_hipGraphDebugDotPrint(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphDebugDotPrint_fn = hipGraphDebugDotPrint_callback;
  else
    InternalRuntimeDispatchTable->hipGraphDebugDotPrint_fn = SavedTable.hipGraphDebugDotPrint_fn;
}

static void toggle_hipGraphDestroy(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphDestroy_fn = hipGraphDestroy_callback;
  else
    InternalRuntimeDispatchTable->hipGraphDestroy_fn = SavedTable.hipGraphDestroy_fn;
}

static void toggle_hipGraphDestroyNode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphDestroyNode_fn = hipGraphDestroyNode_callback;
  else
    InternalRuntimeDispatchTable->hipGraphDestroyNode_fn = SavedTable.hipGraphDestroyNode_fn;
}

static void toggle_hipGraphEventRecordNodeGetEvent(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphEventRecordNodeGetEvent_fn = hipGraphEventRecordNodeGetEvent_callback;
  else
    InternalRuntimeDispatchTable->hipGraphEventRecordNodeGetEvent_fn = SavedTable.hipGraphEventRecordNodeGetEvent_fn;
}

static void toggle_hipGraphEventRecordNodeSetEvent(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphEventRecordNodeSetEvent_fn = hipGraphEventRecordNodeSetEvent_callback;
  else
    InternalRuntimeDispatchTable->hipGraphEventRecordNodeSetEvent_fn = SavedTable.hipGraphEventRecordNodeSetEvent_fn;
}

static void toggle_hipGraphEventWaitNodeGetEvent(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphEventWaitNodeGetEvent_fn = hipGraphEventWaitNodeGetEvent_callback;
  else
    InternalRuntimeDispatchTable->hipGraphEventWaitNodeGetEvent_fn = SavedTable.hipGraphEventWaitNodeGetEvent_fn;
}

static void toggle_hipGraphEventWaitNodeSetEvent(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphEventWaitNodeSetEvent_fn = hipGraphEventWaitNodeSetEvent_callback;
  else
    InternalRuntimeDispatchTable->hipGraphEventWaitNodeSetEvent_fn = SavedTable.hipGraphEventWaitNodeSetEvent_fn;
}

static void toggle_hipGraphExecChildGraphNodeSetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExecChildGraphNodeSetParams_fn = hipGraphExecChildGraphNodeSetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExecChildGraphNodeSetParams_fn = SavedTable.hipGraphExecChildGraphNodeSetParams_fn;
}

static void toggle_hipGraphExecDestroy(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExecDestroy_fn = hipGraphExecDestroy_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExecDestroy_fn = SavedTable.hipGraphExecDestroy_fn;
}

static void toggle_hipGraphExecEventRecordNodeSetEvent(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExecEventRecordNodeSetEvent_fn = hipGraphExecEventRecordNodeSetEvent_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExecEventRecordNodeSetEvent_fn = SavedTable.hipGraphExecEventRecordNodeSetEvent_fn;
}

static void toggle_hipGraphExecEventWaitNodeSetEvent(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExecEventWaitNodeSetEvent_fn = hipGraphExecEventWaitNodeSetEvent_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExecEventWaitNodeSetEvent_fn = SavedTable.hipGraphExecEventWaitNodeSetEvent_fn;
}

static void toggle_hipGraphExecHostNodeSetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExecHostNodeSetParams_fn = hipGraphExecHostNodeSetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExecHostNodeSetParams_fn = SavedTable.hipGraphExecHostNodeSetParams_fn;
}

static void toggle_hipGraphExecKernelNodeSetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExecKernelNodeSetParams_fn = hipGraphExecKernelNodeSetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExecKernelNodeSetParams_fn = SavedTable.hipGraphExecKernelNodeSetParams_fn;
}

static void toggle_hipGraphExecMemcpyNodeSetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExecMemcpyNodeSetParams_fn = hipGraphExecMemcpyNodeSetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExecMemcpyNodeSetParams_fn = SavedTable.hipGraphExecMemcpyNodeSetParams_fn;
}

static void toggle_hipGraphExecMemcpyNodeSetParams1D(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExecMemcpyNodeSetParams1D_fn = hipGraphExecMemcpyNodeSetParams1D_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExecMemcpyNodeSetParams1D_fn = SavedTable.hipGraphExecMemcpyNodeSetParams1D_fn;
}

static void toggle_hipGraphExecMemcpyNodeSetParamsFromSymbol(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExecMemcpyNodeSetParamsFromSymbol_fn = hipGraphExecMemcpyNodeSetParamsFromSymbol_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExecMemcpyNodeSetParamsFromSymbol_fn = SavedTable.hipGraphExecMemcpyNodeSetParamsFromSymbol_fn;
}

static void toggle_hipGraphExecMemcpyNodeSetParamsToSymbol(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExecMemcpyNodeSetParamsToSymbol_fn = hipGraphExecMemcpyNodeSetParamsToSymbol_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExecMemcpyNodeSetParamsToSymbol_fn = SavedTable.hipGraphExecMemcpyNodeSetParamsToSymbol_fn;
}

static void toggle_hipGraphExecMemsetNodeSetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExecMemsetNodeSetParams_fn = hipGraphExecMemsetNodeSetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExecMemsetNodeSetParams_fn = SavedTable.hipGraphExecMemsetNodeSetParams_fn;
}

static void toggle_hipGraphExecUpdate(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExecUpdate_fn = hipGraphExecUpdate_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExecUpdate_fn = SavedTable.hipGraphExecUpdate_fn;
}

static void toggle_hipGraphGetEdges(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphGetEdges_fn = hipGraphGetEdges_callback;
  else
    InternalRuntimeDispatchTable->hipGraphGetEdges_fn = SavedTable.hipGraphGetEdges_fn;
}

static void toggle_hipGraphGetNodes(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphGetNodes_fn = hipGraphGetNodes_callback;
  else
    InternalRuntimeDispatchTable->hipGraphGetNodes_fn = SavedTable.hipGraphGetNodes_fn;
}

static void toggle_hipGraphGetRootNodes(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphGetRootNodes_fn = hipGraphGetRootNodes_callback;
  else
    InternalRuntimeDispatchTable->hipGraphGetRootNodes_fn = SavedTable.hipGraphGetRootNodes_fn;
}

static void toggle_hipGraphHostNodeGetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphHostNodeGetParams_fn = hipGraphHostNodeGetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphHostNodeGetParams_fn = SavedTable.hipGraphHostNodeGetParams_fn;
}

static void toggle_hipGraphHostNodeSetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphHostNodeSetParams_fn = hipGraphHostNodeSetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphHostNodeSetParams_fn = SavedTable.hipGraphHostNodeSetParams_fn;
}

static void toggle_hipGraphInstantiate(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphInstantiate_fn = hipGraphInstantiate_callback;
  else
    InternalRuntimeDispatchTable->hipGraphInstantiate_fn = SavedTable.hipGraphInstantiate_fn;
}

static void toggle_hipGraphInstantiateWithFlags(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphInstantiateWithFlags_fn = hipGraphInstantiateWithFlags_callback;
  else
    InternalRuntimeDispatchTable->hipGraphInstantiateWithFlags_fn = SavedTable.hipGraphInstantiateWithFlags_fn;
}

static void toggle_hipGraphKernelNodeCopyAttributes(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphKernelNodeCopyAttributes_fn = hipGraphKernelNodeCopyAttributes_callback;
  else
    InternalRuntimeDispatchTable->hipGraphKernelNodeCopyAttributes_fn = SavedTable.hipGraphKernelNodeCopyAttributes_fn;
}

static void toggle_hipGraphKernelNodeGetAttribute(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphKernelNodeGetAttribute_fn = hipGraphKernelNodeGetAttribute_callback;
  else
    InternalRuntimeDispatchTable->hipGraphKernelNodeGetAttribute_fn = SavedTable.hipGraphKernelNodeGetAttribute_fn;
}

static void toggle_hipGraphKernelNodeGetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphKernelNodeGetParams_fn = hipGraphKernelNodeGetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphKernelNodeGetParams_fn = SavedTable.hipGraphKernelNodeGetParams_fn;
}

static void toggle_hipGraphKernelNodeSetAttribute(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphKernelNodeSetAttribute_fn = hipGraphKernelNodeSetAttribute_callback;
  else
    InternalRuntimeDispatchTable->hipGraphKernelNodeSetAttribute_fn = SavedTable.hipGraphKernelNodeSetAttribute_fn;
}

static void toggle_hipGraphKernelNodeSetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphKernelNodeSetParams_fn = hipGraphKernelNodeSetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphKernelNodeSetParams_fn = SavedTable.hipGraphKernelNodeSetParams_fn;
}

static void toggle_hipGraphLaunch(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphLaunch_fn = hipGraphLaunch_callback;
  else
    InternalRuntimeDispatchTable->hipGraphLaunch_fn = SavedTable.hipGraphLaunch_fn;
}

static void toggle_hipGraphMemAllocNodeGetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphMemAllocNodeGetParams_fn = hipGraphMemAllocNodeGetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphMemAllocNodeGetParams_fn = SavedTable.hipGraphMemAllocNodeGetParams_fn;
}

static void toggle_hipGraphMemFreeNodeGetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphMemFreeNodeGetParams_fn = hipGraphMemFreeNodeGetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphMemFreeNodeGetParams_fn = SavedTable.hipGraphMemFreeNodeGetParams_fn;
}

static void toggle_hipGraphMemcpyNodeGetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphMemcpyNodeGetParams_fn = hipGraphMemcpyNodeGetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphMemcpyNodeGetParams_fn = SavedTable.hipGraphMemcpyNodeGetParams_fn;
}

static void toggle_hipGraphMemcpyNodeSetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphMemcpyNodeSetParams_fn = hipGraphMemcpyNodeSetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphMemcpyNodeSetParams_fn = SavedTable.hipGraphMemcpyNodeSetParams_fn;
}

static void toggle_hipGraphMemcpyNodeSetParams1D(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphMemcpyNodeSetParams1D_fn = hipGraphMemcpyNodeSetParams1D_callback;
  else
    InternalRuntimeDispatchTable->hipGraphMemcpyNodeSetParams1D_fn = SavedTable.hipGraphMemcpyNodeSetParams1D_fn;
}

static void toggle_hipGraphMemcpyNodeSetParamsFromSymbol(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphMemcpyNodeSetParamsFromSymbol_fn = hipGraphMemcpyNodeSetParamsFromSymbol_callback;
  else
    InternalRuntimeDispatchTable->hipGraphMemcpyNodeSetParamsFromSymbol_fn = SavedTable.hipGraphMemcpyNodeSetParamsFromSymbol_fn;
}

static void toggle_hipGraphMemcpyNodeSetParamsToSymbol(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphMemcpyNodeSetParamsToSymbol_fn = hipGraphMemcpyNodeSetParamsToSymbol_callback;
  else
    InternalRuntimeDispatchTable->hipGraphMemcpyNodeSetParamsToSymbol_fn = SavedTable.hipGraphMemcpyNodeSetParamsToSymbol_fn;
}

static void toggle_hipGraphMemsetNodeGetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphMemsetNodeGetParams_fn = hipGraphMemsetNodeGetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphMemsetNodeGetParams_fn = SavedTable.hipGraphMemsetNodeGetParams_fn;
}

static void toggle_hipGraphMemsetNodeSetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphMemsetNodeSetParams_fn = hipGraphMemsetNodeSetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphMemsetNodeSetParams_fn = SavedTable.hipGraphMemsetNodeSetParams_fn;
}

static void toggle_hipGraphNodeFindInClone(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphNodeFindInClone_fn = hipGraphNodeFindInClone_callback;
  else
    InternalRuntimeDispatchTable->hipGraphNodeFindInClone_fn = SavedTable.hipGraphNodeFindInClone_fn;
}

static void toggle_hipGraphNodeGetDependencies(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphNodeGetDependencies_fn = hipGraphNodeGetDependencies_callback;
  else
    InternalRuntimeDispatchTable->hipGraphNodeGetDependencies_fn = SavedTable.hipGraphNodeGetDependencies_fn;
}

static void toggle_hipGraphNodeGetDependentNodes(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphNodeGetDependentNodes_fn = hipGraphNodeGetDependentNodes_callback;
  else
    InternalRuntimeDispatchTable->hipGraphNodeGetDependentNodes_fn = SavedTable.hipGraphNodeGetDependentNodes_fn;
}

static void toggle_hipGraphNodeGetEnabled(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphNodeGetEnabled_fn = hipGraphNodeGetEnabled_callback;
  else
    InternalRuntimeDispatchTable->hipGraphNodeGetEnabled_fn = SavedTable.hipGraphNodeGetEnabled_fn;
}

static void toggle_hipGraphNodeGetType(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphNodeGetType_fn = hipGraphNodeGetType_callback;
  else
    InternalRuntimeDispatchTable->hipGraphNodeGetType_fn = SavedTable.hipGraphNodeGetType_fn;
}

static void toggle_hipGraphNodeSetEnabled(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphNodeSetEnabled_fn = hipGraphNodeSetEnabled_callback;
  else
    InternalRuntimeDispatchTable->hipGraphNodeSetEnabled_fn = SavedTable.hipGraphNodeSetEnabled_fn;
}

static void toggle_hipGraphReleaseUserObject(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphReleaseUserObject_fn = hipGraphReleaseUserObject_callback;
  else
    InternalRuntimeDispatchTable->hipGraphReleaseUserObject_fn = SavedTable.hipGraphReleaseUserObject_fn;
}

static void toggle_hipGraphRemoveDependencies(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphRemoveDependencies_fn = hipGraphRemoveDependencies_callback;
  else
    InternalRuntimeDispatchTable->hipGraphRemoveDependencies_fn = SavedTable.hipGraphRemoveDependencies_fn;
}

static void toggle_hipGraphRetainUserObject(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphRetainUserObject_fn = hipGraphRetainUserObject_callback;
  else
    InternalRuntimeDispatchTable->hipGraphRetainUserObject_fn = SavedTable.hipGraphRetainUserObject_fn;
}

static void toggle_hipGraphUpload(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphUpload_fn = hipGraphUpload_callback;
  else
    InternalRuntimeDispatchTable->hipGraphUpload_fn = SavedTable.hipGraphUpload_fn;
}

static void toggle_hipGraphicsGLRegisterBuffer(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphicsGLRegisterBuffer_fn = hipGraphicsGLRegisterBuffer_callback;
  else
    InternalRuntimeDispatchTable->hipGraphicsGLRegisterBuffer_fn = SavedTable.hipGraphicsGLRegisterBuffer_fn;
}

static void toggle_hipGraphicsGLRegisterImage(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphicsGLRegisterImage_fn = hipGraphicsGLRegisterImage_callback;
  else
    InternalRuntimeDispatchTable->hipGraphicsGLRegisterImage_fn = SavedTable.hipGraphicsGLRegisterImage_fn;
}

static void toggle_hipGraphicsMapResources(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphicsMapResources_fn = hipGraphicsMapResources_callback;
  else
    InternalRuntimeDispatchTable->hipGraphicsMapResources_fn = SavedTable.hipGraphicsMapResources_fn;
}

static void toggle_hipGraphicsResourceGetMappedPointer(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphicsResourceGetMappedPointer_fn = hipGraphicsResourceGetMappedPointer_callback;
  else
    InternalRuntimeDispatchTable->hipGraphicsResourceGetMappedPointer_fn = SavedTable.hipGraphicsResourceGetMappedPointer_fn;
}

static void toggle_hipGraphicsSubResourceGetMappedArray(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphicsSubResourceGetMappedArray_fn = hipGraphicsSubResourceGetMappedArray_callback;
  else
    InternalRuntimeDispatchTable->hipGraphicsSubResourceGetMappedArray_fn = SavedTable.hipGraphicsSubResourceGetMappedArray_fn;
}

static void toggle_hipGraphicsUnmapResources(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphicsUnmapResources_fn = hipGraphicsUnmapResources_callback;
  else
    InternalRuntimeDispatchTable->hipGraphicsUnmapResources_fn = SavedTable.hipGraphicsUnmapResources_fn;
}

static void toggle_hipGraphicsUnregisterResource(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphicsUnregisterResource_fn = hipGraphicsUnregisterResource_callback;
  else
    InternalRuntimeDispatchTable->hipGraphicsUnregisterResource_fn = SavedTable.hipGraphicsUnregisterResource_fn;
}

static void toggle_hipHostAlloc(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipHostAlloc_fn = hipHostAlloc_callback;
  else
    InternalRuntimeDispatchTable->hipHostAlloc_fn = SavedTable.hipHostAlloc_fn;
}

static void toggle_hipHostFree(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipHostFree_fn = hipHostFree_callback;
  else
    InternalRuntimeDispatchTable->hipHostFree_fn = SavedTable.hipHostFree_fn;
}

static void toggle_hipHostGetDevicePointer(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipHostGetDevicePointer_fn = hipHostGetDevicePointer_callback;
  else
    InternalRuntimeDispatchTable->hipHostGetDevicePointer_fn = SavedTable.hipHostGetDevicePointer_fn;
}

static void toggle_hipHostGetFlags(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipHostGetFlags_fn = hipHostGetFlags_callback;
  else
    InternalRuntimeDispatchTable->hipHostGetFlags_fn = SavedTable.hipHostGetFlags_fn;
}

static void toggle_hipHostMalloc(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipHostMalloc_fn = hipHostMalloc_callback;
  else
    InternalRuntimeDispatchTable->hipHostMalloc_fn = SavedTable.hipHostMalloc_fn;
}

static void toggle_hipHostRegister(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipHostRegister_fn = hipHostRegister_callback;
  else
    InternalRuntimeDispatchTable->hipHostRegister_fn = SavedTable.hipHostRegister_fn;
}

static void toggle_hipHostUnregister(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipHostUnregister_fn = hipHostUnregister_callback;
  else
    InternalRuntimeDispatchTable->hipHostUnregister_fn = SavedTable.hipHostUnregister_fn;
}

static void toggle_hipImportExternalMemory(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipImportExternalMemory_fn = hipImportExternalMemory_callback;
  else
    InternalRuntimeDispatchTable->hipImportExternalMemory_fn = SavedTable.hipImportExternalMemory_fn;
}

static void toggle_hipImportExternalSemaphore(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipImportExternalSemaphore_fn = hipImportExternalSemaphore_callback;
  else
    InternalRuntimeDispatchTable->hipImportExternalSemaphore_fn = SavedTable.hipImportExternalSemaphore_fn;
}

static void toggle_hipInit(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipInit_fn = hipInit_callback;
  else
    InternalRuntimeDispatchTable->hipInit_fn = SavedTable.hipInit_fn;
}

static void toggle_hipIpcCloseMemHandle(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipIpcCloseMemHandle_fn = hipIpcCloseMemHandle_callback;
  else
    InternalRuntimeDispatchTable->hipIpcCloseMemHandle_fn = SavedTable.hipIpcCloseMemHandle_fn;
}

static void toggle_hipIpcGetEventHandle(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipIpcGetEventHandle_fn = hipIpcGetEventHandle_callback;
  else
    InternalRuntimeDispatchTable->hipIpcGetEventHandle_fn = SavedTable.hipIpcGetEventHandle_fn;
}

static void toggle_hipIpcGetMemHandle(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipIpcGetMemHandle_fn = hipIpcGetMemHandle_callback;
  else
    InternalRuntimeDispatchTable->hipIpcGetMemHandle_fn = SavedTable.hipIpcGetMemHandle_fn;
}

static void toggle_hipIpcOpenEventHandle(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipIpcOpenEventHandle_fn = hipIpcOpenEventHandle_callback;
  else
    InternalRuntimeDispatchTable->hipIpcOpenEventHandle_fn = SavedTable.hipIpcOpenEventHandle_fn;
}

static void toggle_hipIpcOpenMemHandle(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipIpcOpenMemHandle_fn = hipIpcOpenMemHandle_callback;
  else
    InternalRuntimeDispatchTable->hipIpcOpenMemHandle_fn = SavedTable.hipIpcOpenMemHandle_fn;
}

static void toggle_hipKernelNameRefByPtr(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipKernelNameRefByPtr_fn = hipKernelNameRefByPtr_callback;
  else
    InternalRuntimeDispatchTable->hipKernelNameRefByPtr_fn = SavedTable.hipKernelNameRefByPtr_fn;
}

static void toggle_hipLaunchByPtr(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipLaunchByPtr_fn = hipLaunchByPtr_callback;
  else
    InternalRuntimeDispatchTable->hipLaunchByPtr_fn = SavedTable.hipLaunchByPtr_fn;
}

static void toggle_hipLaunchCooperativeKernelMultiDevice(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipLaunchCooperativeKernelMultiDevice_fn = hipLaunchCooperativeKernelMultiDevice_callback;
  else
    InternalRuntimeDispatchTable->hipLaunchCooperativeKernelMultiDevice_fn = SavedTable.hipLaunchCooperativeKernelMultiDevice_fn;
}

static void toggle_hipLaunchHostFunc(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipLaunchHostFunc_fn = hipLaunchHostFunc_callback;
  else
    InternalRuntimeDispatchTable->hipLaunchHostFunc_fn = SavedTable.hipLaunchHostFunc_fn;
}

static void toggle_hipLaunchKernel(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipLaunchKernel_fn = hipLaunchKernel_callback;
  else
    InternalRuntimeDispatchTable->hipLaunchKernel_fn = SavedTable.hipLaunchKernel_fn;
}

static void toggle_hipMalloc(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMalloc_fn = hipMalloc_callback;
  else
    InternalRuntimeDispatchTable->hipMalloc_fn = SavedTable.hipMalloc_fn;
}

static void toggle_hipMalloc3D(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMalloc3D_fn = hipMalloc3D_callback;
  else
    InternalRuntimeDispatchTable->hipMalloc3D_fn = SavedTable.hipMalloc3D_fn;
}

static void toggle_hipMalloc3DArray(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMalloc3DArray_fn = hipMalloc3DArray_callback;
  else
    InternalRuntimeDispatchTable->hipMalloc3DArray_fn = SavedTable.hipMalloc3DArray_fn;
}

static void toggle_hipMallocArray(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMallocArray_fn = hipMallocArray_callback;
  else
    InternalRuntimeDispatchTable->hipMallocArray_fn = SavedTable.hipMallocArray_fn;
}

static void toggle_hipMallocAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMallocAsync_fn = hipMallocAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMallocAsync_fn = SavedTable.hipMallocAsync_fn;
}

static void toggle_hipMallocFromPoolAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMallocFromPoolAsync_fn = hipMallocFromPoolAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMallocFromPoolAsync_fn = SavedTable.hipMallocFromPoolAsync_fn;
}

static void toggle_hipMallocHost(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMallocHost_fn = hipMallocHost_callback;
  else
    InternalRuntimeDispatchTable->hipMallocHost_fn = SavedTable.hipMallocHost_fn;
}

static void toggle_hipMallocManaged(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMallocManaged_fn = hipMallocManaged_callback;
  else
    InternalRuntimeDispatchTable->hipMallocManaged_fn = SavedTable.hipMallocManaged_fn;
}

static void toggle_hipMallocMipmappedArray(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMallocMipmappedArray_fn = hipMallocMipmappedArray_callback;
  else
    InternalRuntimeDispatchTable->hipMallocMipmappedArray_fn = SavedTable.hipMallocMipmappedArray_fn;
}

static void toggle_hipMallocPitch(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMallocPitch_fn = hipMallocPitch_callback;
  else
    InternalRuntimeDispatchTable->hipMallocPitch_fn = SavedTable.hipMallocPitch_fn;
}

static void toggle_hipMemAddressFree(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemAddressFree_fn = hipMemAddressFree_callback;
  else
    InternalRuntimeDispatchTable->hipMemAddressFree_fn = SavedTable.hipMemAddressFree_fn;
}

static void toggle_hipMemAddressReserve(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemAddressReserve_fn = hipMemAddressReserve_callback;
  else
    InternalRuntimeDispatchTable->hipMemAddressReserve_fn = SavedTable.hipMemAddressReserve_fn;
}

static void toggle_hipMemAdvise(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemAdvise_fn = hipMemAdvise_callback;
  else
    InternalRuntimeDispatchTable->hipMemAdvise_fn = SavedTable.hipMemAdvise_fn;
}

static void toggle_hipMemAllocHost(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemAllocHost_fn = hipMemAllocHost_callback;
  else
    InternalRuntimeDispatchTable->hipMemAllocHost_fn = SavedTable.hipMemAllocHost_fn;
}

static void toggle_hipMemAllocPitch(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemAllocPitch_fn = hipMemAllocPitch_callback;
  else
    InternalRuntimeDispatchTable->hipMemAllocPitch_fn = SavedTable.hipMemAllocPitch_fn;
}

static void toggle_hipMemCreate(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemCreate_fn = hipMemCreate_callback;
  else
    InternalRuntimeDispatchTable->hipMemCreate_fn = SavedTable.hipMemCreate_fn;
}

static void toggle_hipMemExportToShareableHandle(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemExportToShareableHandle_fn = hipMemExportToShareableHandle_callback;
  else
    InternalRuntimeDispatchTable->hipMemExportToShareableHandle_fn = SavedTable.hipMemExportToShareableHandle_fn;
}

static void toggle_hipMemGetAccess(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemGetAccess_fn = hipMemGetAccess_callback;
  else
    InternalRuntimeDispatchTable->hipMemGetAccess_fn = SavedTable.hipMemGetAccess_fn;
}

static void toggle_hipMemGetAddressRange(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemGetAddressRange_fn = hipMemGetAddressRange_callback;
  else
    InternalRuntimeDispatchTable->hipMemGetAddressRange_fn = SavedTable.hipMemGetAddressRange_fn;
}

static void toggle_hipMemGetAllocationGranularity(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemGetAllocationGranularity_fn = hipMemGetAllocationGranularity_callback;
  else
    InternalRuntimeDispatchTable->hipMemGetAllocationGranularity_fn = SavedTable.hipMemGetAllocationGranularity_fn;
}

static void toggle_hipMemGetAllocationPropertiesFromHandle(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemGetAllocationPropertiesFromHandle_fn = hipMemGetAllocationPropertiesFromHandle_callback;
  else
    InternalRuntimeDispatchTable->hipMemGetAllocationPropertiesFromHandle_fn = SavedTable.hipMemGetAllocationPropertiesFromHandle_fn;
}

static void toggle_hipMemGetInfo(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemGetInfo_fn = hipMemGetInfo_callback;
  else
    InternalRuntimeDispatchTable->hipMemGetInfo_fn = SavedTable.hipMemGetInfo_fn;
}

static void toggle_hipMemImportFromShareableHandle(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemImportFromShareableHandle_fn = hipMemImportFromShareableHandle_callback;
  else
    InternalRuntimeDispatchTable->hipMemImportFromShareableHandle_fn = SavedTable.hipMemImportFromShareableHandle_fn;
}

static void toggle_hipMemMap(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemMap_fn = hipMemMap_callback;
  else
    InternalRuntimeDispatchTable->hipMemMap_fn = SavedTable.hipMemMap_fn;
}

static void toggle_hipMemMapArrayAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemMapArrayAsync_fn = hipMemMapArrayAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMemMapArrayAsync_fn = SavedTable.hipMemMapArrayAsync_fn;
}

static void toggle_hipMemPoolCreate(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemPoolCreate_fn = hipMemPoolCreate_callback;
  else
    InternalRuntimeDispatchTable->hipMemPoolCreate_fn = SavedTable.hipMemPoolCreate_fn;
}

static void toggle_hipMemPoolDestroy(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemPoolDestroy_fn = hipMemPoolDestroy_callback;
  else
    InternalRuntimeDispatchTable->hipMemPoolDestroy_fn = SavedTable.hipMemPoolDestroy_fn;
}

static void toggle_hipMemPoolExportPointer(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemPoolExportPointer_fn = hipMemPoolExportPointer_callback;
  else
    InternalRuntimeDispatchTable->hipMemPoolExportPointer_fn = SavedTable.hipMemPoolExportPointer_fn;
}

static void toggle_hipMemPoolExportToShareableHandle(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemPoolExportToShareableHandle_fn = hipMemPoolExportToShareableHandle_callback;
  else
    InternalRuntimeDispatchTable->hipMemPoolExportToShareableHandle_fn = SavedTable.hipMemPoolExportToShareableHandle_fn;
}

static void toggle_hipMemPoolGetAccess(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemPoolGetAccess_fn = hipMemPoolGetAccess_callback;
  else
    InternalRuntimeDispatchTable->hipMemPoolGetAccess_fn = SavedTable.hipMemPoolGetAccess_fn;
}

static void toggle_hipMemPoolGetAttribute(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemPoolGetAttribute_fn = hipMemPoolGetAttribute_callback;
  else
    InternalRuntimeDispatchTable->hipMemPoolGetAttribute_fn = SavedTable.hipMemPoolGetAttribute_fn;
}

static void toggle_hipMemPoolImportFromShareableHandle(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemPoolImportFromShareableHandle_fn = hipMemPoolImportFromShareableHandle_callback;
  else
    InternalRuntimeDispatchTable->hipMemPoolImportFromShareableHandle_fn = SavedTable.hipMemPoolImportFromShareableHandle_fn;
}

static void toggle_hipMemPoolImportPointer(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemPoolImportPointer_fn = hipMemPoolImportPointer_callback;
  else
    InternalRuntimeDispatchTable->hipMemPoolImportPointer_fn = SavedTable.hipMemPoolImportPointer_fn;
}

static void toggle_hipMemPoolSetAccess(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemPoolSetAccess_fn = hipMemPoolSetAccess_callback;
  else
    InternalRuntimeDispatchTable->hipMemPoolSetAccess_fn = SavedTable.hipMemPoolSetAccess_fn;
}

static void toggle_hipMemPoolSetAttribute(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemPoolSetAttribute_fn = hipMemPoolSetAttribute_callback;
  else
    InternalRuntimeDispatchTable->hipMemPoolSetAttribute_fn = SavedTable.hipMemPoolSetAttribute_fn;
}

static void toggle_hipMemPoolTrimTo(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemPoolTrimTo_fn = hipMemPoolTrimTo_callback;
  else
    InternalRuntimeDispatchTable->hipMemPoolTrimTo_fn = SavedTable.hipMemPoolTrimTo_fn;
}

static void toggle_hipMemPrefetchAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemPrefetchAsync_fn = hipMemPrefetchAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMemPrefetchAsync_fn = SavedTable.hipMemPrefetchAsync_fn;
}

static void toggle_hipMemPtrGetInfo(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemPtrGetInfo_fn = hipMemPtrGetInfo_callback;
  else
    InternalRuntimeDispatchTable->hipMemPtrGetInfo_fn = SavedTable.hipMemPtrGetInfo_fn;
}

static void toggle_hipMemRangeGetAttribute(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemRangeGetAttribute_fn = hipMemRangeGetAttribute_callback;
  else
    InternalRuntimeDispatchTable->hipMemRangeGetAttribute_fn = SavedTable.hipMemRangeGetAttribute_fn;
}

static void toggle_hipMemRangeGetAttributes(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemRangeGetAttributes_fn = hipMemRangeGetAttributes_callback;
  else
    InternalRuntimeDispatchTable->hipMemRangeGetAttributes_fn = SavedTable.hipMemRangeGetAttributes_fn;
}

static void toggle_hipMemRelease(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemRelease_fn = hipMemRelease_callback;
  else
    InternalRuntimeDispatchTable->hipMemRelease_fn = SavedTable.hipMemRelease_fn;
}

static void toggle_hipMemRetainAllocationHandle(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemRetainAllocationHandle_fn = hipMemRetainAllocationHandle_callback;
  else
    InternalRuntimeDispatchTable->hipMemRetainAllocationHandle_fn = SavedTable.hipMemRetainAllocationHandle_fn;
}

static void toggle_hipMemSetAccess(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemSetAccess_fn = hipMemSetAccess_callback;
  else
    InternalRuntimeDispatchTable->hipMemSetAccess_fn = SavedTable.hipMemSetAccess_fn;
}

static void toggle_hipMemUnmap(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemUnmap_fn = hipMemUnmap_callback;
  else
    InternalRuntimeDispatchTable->hipMemUnmap_fn = SavedTable.hipMemUnmap_fn;
}

static void toggle_hipMemcpy(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy_fn = hipMemcpy_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy_fn = SavedTable.hipMemcpy_fn;
}

static void toggle_hipMemcpy2D(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy2D_fn = hipMemcpy2D_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy2D_fn = SavedTable.hipMemcpy2D_fn;
}

static void toggle_hipMemcpy2DAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy2DAsync_fn = hipMemcpy2DAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy2DAsync_fn = SavedTable.hipMemcpy2DAsync_fn;
}

static void toggle_hipMemcpy2DFromArray(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy2DFromArray_fn = hipMemcpy2DFromArray_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy2DFromArray_fn = SavedTable.hipMemcpy2DFromArray_fn;
}

static void toggle_hipMemcpy2DFromArrayAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy2DFromArrayAsync_fn = hipMemcpy2DFromArrayAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy2DFromArrayAsync_fn = SavedTable.hipMemcpy2DFromArrayAsync_fn;
}

static void toggle_hipMemcpy2DToArray(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy2DToArray_fn = hipMemcpy2DToArray_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy2DToArray_fn = SavedTable.hipMemcpy2DToArray_fn;
}

static void toggle_hipMemcpy2DToArrayAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy2DToArrayAsync_fn = hipMemcpy2DToArrayAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy2DToArrayAsync_fn = SavedTable.hipMemcpy2DToArrayAsync_fn;
}

static void toggle_hipMemcpy3D(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy3D_fn = hipMemcpy3D_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy3D_fn = SavedTable.hipMemcpy3D_fn;
}

static void toggle_hipMemcpy3DAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy3DAsync_fn = hipMemcpy3DAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy3DAsync_fn = SavedTable.hipMemcpy3DAsync_fn;
}

static void toggle_hipMemcpyAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyAsync_fn = hipMemcpyAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyAsync_fn = SavedTable.hipMemcpyAsync_fn;
}

static void toggle_hipMemcpyAtoH(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyAtoH_fn = hipMemcpyAtoH_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyAtoH_fn = SavedTable.hipMemcpyAtoH_fn;
}

static void toggle_hipMemcpyDtoD(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyDtoD_fn = hipMemcpyDtoD_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyDtoD_fn = SavedTable.hipMemcpyDtoD_fn;
}

static void toggle_hipMemcpyDtoDAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyDtoDAsync_fn = hipMemcpyDtoDAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyDtoDAsync_fn = SavedTable.hipMemcpyDtoDAsync_fn;
}

static void toggle_hipMemcpyDtoH(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyDtoH_fn = hipMemcpyDtoH_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyDtoH_fn = SavedTable.hipMemcpyDtoH_fn;
}

static void toggle_hipMemcpyDtoHAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyDtoHAsync_fn = hipMemcpyDtoHAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyDtoHAsync_fn = SavedTable.hipMemcpyDtoHAsync_fn;
}

static void toggle_hipMemcpyFromArray(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyFromArray_fn = hipMemcpyFromArray_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyFromArray_fn = SavedTable.hipMemcpyFromArray_fn;
}

static void toggle_hipMemcpyFromSymbol(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyFromSymbol_fn = hipMemcpyFromSymbol_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyFromSymbol_fn = SavedTable.hipMemcpyFromSymbol_fn;
}

static void toggle_hipMemcpyFromSymbolAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyFromSymbolAsync_fn = hipMemcpyFromSymbolAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyFromSymbolAsync_fn = SavedTable.hipMemcpyFromSymbolAsync_fn;
}

static void toggle_hipMemcpyHtoA(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyHtoA_fn = hipMemcpyHtoA_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyHtoA_fn = SavedTable.hipMemcpyHtoA_fn;
}

static void toggle_hipMemcpyHtoD(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyHtoD_fn = hipMemcpyHtoD_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyHtoD_fn = SavedTable.hipMemcpyHtoD_fn;
}

static void toggle_hipMemcpyHtoDAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyHtoDAsync_fn = hipMemcpyHtoDAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyHtoDAsync_fn = SavedTable.hipMemcpyHtoDAsync_fn;
}

static void toggle_hipMemcpyParam2D(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyParam2D_fn = hipMemcpyParam2D_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyParam2D_fn = SavedTable.hipMemcpyParam2D_fn;
}

static void toggle_hipMemcpyParam2DAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyParam2DAsync_fn = hipMemcpyParam2DAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyParam2DAsync_fn = SavedTable.hipMemcpyParam2DAsync_fn;
}

static void toggle_hipMemcpyPeer(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyPeer_fn = hipMemcpyPeer_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyPeer_fn = SavedTable.hipMemcpyPeer_fn;
}

static void toggle_hipMemcpyPeerAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyPeerAsync_fn = hipMemcpyPeerAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyPeerAsync_fn = SavedTable.hipMemcpyPeerAsync_fn;
}

static void toggle_hipMemcpyToArray(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyToArray_fn = hipMemcpyToArray_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyToArray_fn = SavedTable.hipMemcpyToArray_fn;
}

static void toggle_hipMemcpyToSymbol(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyToSymbol_fn = hipMemcpyToSymbol_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyToSymbol_fn = SavedTable.hipMemcpyToSymbol_fn;
}

static void toggle_hipMemcpyToSymbolAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyToSymbolAsync_fn = hipMemcpyToSymbolAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyToSymbolAsync_fn = SavedTable.hipMemcpyToSymbolAsync_fn;
}

static void toggle_hipMemcpyWithStream(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyWithStream_fn = hipMemcpyWithStream_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyWithStream_fn = SavedTable.hipMemcpyWithStream_fn;
}

static void toggle_hipMemset(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemset_fn = hipMemset_callback;
  else
    InternalRuntimeDispatchTable->hipMemset_fn = SavedTable.hipMemset_fn;
}

static void toggle_hipMemset2D(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemset2D_fn = hipMemset2D_callback;
  else
    InternalRuntimeDispatchTable->hipMemset2D_fn = SavedTable.hipMemset2D_fn;
}

static void toggle_hipMemset2DAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemset2DAsync_fn = hipMemset2DAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMemset2DAsync_fn = SavedTable.hipMemset2DAsync_fn;
}

static void toggle_hipMemset3D(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemset3D_fn = hipMemset3D_callback;
  else
    InternalRuntimeDispatchTable->hipMemset3D_fn = SavedTable.hipMemset3D_fn;
}

static void toggle_hipMemset3DAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemset3DAsync_fn = hipMemset3DAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMemset3DAsync_fn = SavedTable.hipMemset3DAsync_fn;
}

static void toggle_hipMemsetAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemsetAsync_fn = hipMemsetAsync_callback;
  else
    InternalRuntimeDispatchTable->hipMemsetAsync_fn = SavedTable.hipMemsetAsync_fn;
}

static void toggle_hipMemsetD16(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemsetD16_fn = hipMemsetD16_callback;
  else
    InternalRuntimeDispatchTable->hipMemsetD16_fn = SavedTable.hipMemsetD16_fn;
}

static void toggle_hipMemsetD16Async(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemsetD16Async_fn = hipMemsetD16Async_callback;
  else
    InternalRuntimeDispatchTable->hipMemsetD16Async_fn = SavedTable.hipMemsetD16Async_fn;
}

static void toggle_hipMemsetD32(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemsetD32_fn = hipMemsetD32_callback;
  else
    InternalRuntimeDispatchTable->hipMemsetD32_fn = SavedTable.hipMemsetD32_fn;
}

static void toggle_hipMemsetD32Async(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemsetD32Async_fn = hipMemsetD32Async_callback;
  else
    InternalRuntimeDispatchTable->hipMemsetD32Async_fn = SavedTable.hipMemsetD32Async_fn;
}

static void toggle_hipMemsetD8(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemsetD8_fn = hipMemsetD8_callback;
  else
    InternalRuntimeDispatchTable->hipMemsetD8_fn = SavedTable.hipMemsetD8_fn;
}

static void toggle_hipMemsetD8Async(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemsetD8Async_fn = hipMemsetD8Async_callback;
  else
    InternalRuntimeDispatchTable->hipMemsetD8Async_fn = SavedTable.hipMemsetD8Async_fn;
}

static void toggle_hipMipmappedArrayCreate(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMipmappedArrayCreate_fn = hipMipmappedArrayCreate_callback;
  else
    InternalRuntimeDispatchTable->hipMipmappedArrayCreate_fn = SavedTable.hipMipmappedArrayCreate_fn;
}

static void toggle_hipMipmappedArrayDestroy(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMipmappedArrayDestroy_fn = hipMipmappedArrayDestroy_callback;
  else
    InternalRuntimeDispatchTable->hipMipmappedArrayDestroy_fn = SavedTable.hipMipmappedArrayDestroy_fn;
}

static void toggle_hipMipmappedArrayGetLevel(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMipmappedArrayGetLevel_fn = hipMipmappedArrayGetLevel_callback;
  else
    InternalRuntimeDispatchTable->hipMipmappedArrayGetLevel_fn = SavedTable.hipMipmappedArrayGetLevel_fn;
}

static void toggle_hipModuleGetFunction(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipModuleGetFunction_fn = hipModuleGetFunction_callback;
  else
    InternalRuntimeDispatchTable->hipModuleGetFunction_fn = SavedTable.hipModuleGetFunction_fn;
}

static void toggle_hipModuleGetGlobal(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipModuleGetGlobal_fn = hipModuleGetGlobal_callback;
  else
    InternalRuntimeDispatchTable->hipModuleGetGlobal_fn = SavedTable.hipModuleGetGlobal_fn;
}

static void toggle_hipModuleGetTexRef(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipModuleGetTexRef_fn = hipModuleGetTexRef_callback;
  else
    InternalRuntimeDispatchTable->hipModuleGetTexRef_fn = SavedTable.hipModuleGetTexRef_fn;
}

static void toggle_hipModuleLaunchCooperativeKernelMultiDevice(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipModuleLaunchCooperativeKernelMultiDevice_fn = hipModuleLaunchCooperativeKernelMultiDevice_callback;
  else
    InternalRuntimeDispatchTable->hipModuleLaunchCooperativeKernelMultiDevice_fn = SavedTable.hipModuleLaunchCooperativeKernelMultiDevice_fn;
}

static void toggle_hipModuleLoad(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipModuleLoad_fn = hipModuleLoad_callback;
  else
    InternalRuntimeDispatchTable->hipModuleLoad_fn = SavedTable.hipModuleLoad_fn;
}

static void toggle_hipModuleLoadData(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipModuleLoadData_fn = hipModuleLoadData_callback;
  else
    InternalRuntimeDispatchTable->hipModuleLoadData_fn = SavedTable.hipModuleLoadData_fn;
}

static void toggle_hipModuleLoadDataEx(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipModuleLoadDataEx_fn = hipModuleLoadDataEx_callback;
  else
    InternalRuntimeDispatchTable->hipModuleLoadDataEx_fn = SavedTable.hipModuleLoadDataEx_fn;
}

static void toggle_hipModuleUnload(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipModuleUnload_fn = hipModuleUnload_callback;
  else
    InternalRuntimeDispatchTable->hipModuleUnload_fn = SavedTable.hipModuleUnload_fn;
}

static void toggle_hipPeekAtLastError(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipPeekAtLastError_fn = hipPeekAtLastError_callback;
  else
    InternalRuntimeDispatchTable->hipPeekAtLastError_fn = SavedTable.hipPeekAtLastError_fn;
}

static void toggle_hipPointerGetAttribute(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipPointerGetAttribute_fn = hipPointerGetAttribute_callback;
  else
    InternalRuntimeDispatchTable->hipPointerGetAttribute_fn = SavedTable.hipPointerGetAttribute_fn;
}

static void toggle_hipPointerGetAttributes(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipPointerGetAttributes_fn = hipPointerGetAttributes_callback;
  else
    InternalRuntimeDispatchTable->hipPointerGetAttributes_fn = SavedTable.hipPointerGetAttributes_fn;
}

static void toggle_hipPointerSetAttribute(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipPointerSetAttribute_fn = hipPointerSetAttribute_callback;
  else
    InternalRuntimeDispatchTable->hipPointerSetAttribute_fn = SavedTable.hipPointerSetAttribute_fn;
}

static void toggle_hipProfilerStart(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipProfilerStart_fn = hipProfilerStart_callback;
  else
    InternalRuntimeDispatchTable->hipProfilerStart_fn = SavedTable.hipProfilerStart_fn;
}

static void toggle_hipProfilerStop(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipProfilerStop_fn = hipProfilerStop_callback;
  else
    InternalRuntimeDispatchTable->hipProfilerStop_fn = SavedTable.hipProfilerStop_fn;
}

static void toggle_hipRuntimeGetVersion(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipRuntimeGetVersion_fn = hipRuntimeGetVersion_callback;
  else
    InternalRuntimeDispatchTable->hipRuntimeGetVersion_fn = SavedTable.hipRuntimeGetVersion_fn;
}

static void toggle_hipSetDevice(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipSetDevice_fn = hipSetDevice_callback;
  else
    InternalRuntimeDispatchTable->hipSetDevice_fn = SavedTable.hipSetDevice_fn;
}

static void toggle_hipSetDeviceFlags(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipSetDeviceFlags_fn = hipSetDeviceFlags_callback;
  else
    InternalRuntimeDispatchTable->hipSetDeviceFlags_fn = SavedTable.hipSetDeviceFlags_fn;
}

static void toggle_hipSetupArgument(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipSetupArgument_fn = hipSetupArgument_callback;
  else
    InternalRuntimeDispatchTable->hipSetupArgument_fn = SavedTable.hipSetupArgument_fn;
}

static void toggle_hipSignalExternalSemaphoresAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipSignalExternalSemaphoresAsync_fn = hipSignalExternalSemaphoresAsync_callback;
  else
    InternalRuntimeDispatchTable->hipSignalExternalSemaphoresAsync_fn = SavedTable.hipSignalExternalSemaphoresAsync_fn;
}

static void toggle_hipStreamAddCallback(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamAddCallback_fn = hipStreamAddCallback_callback;
  else
    InternalRuntimeDispatchTable->hipStreamAddCallback_fn = SavedTable.hipStreamAddCallback_fn;
}

static void toggle_hipStreamAttachMemAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamAttachMemAsync_fn = hipStreamAttachMemAsync_callback;
  else
    InternalRuntimeDispatchTable->hipStreamAttachMemAsync_fn = SavedTable.hipStreamAttachMemAsync_fn;
}

static void toggle_hipStreamBeginCapture(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamBeginCapture_fn = hipStreamBeginCapture_callback;
  else
    InternalRuntimeDispatchTable->hipStreamBeginCapture_fn = SavedTable.hipStreamBeginCapture_fn;
}

static void toggle_hipStreamCreate(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamCreate_fn = hipStreamCreate_callback;
  else
    InternalRuntimeDispatchTable->hipStreamCreate_fn = SavedTable.hipStreamCreate_fn;
}

static void toggle_hipStreamCreateWithFlags(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamCreateWithFlags_fn = hipStreamCreateWithFlags_callback;
  else
    InternalRuntimeDispatchTable->hipStreamCreateWithFlags_fn = SavedTable.hipStreamCreateWithFlags_fn;
}

static void toggle_hipStreamCreateWithPriority(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamCreateWithPriority_fn = hipStreamCreateWithPriority_callback;
  else
    InternalRuntimeDispatchTable->hipStreamCreateWithPriority_fn = SavedTable.hipStreamCreateWithPriority_fn;
}

static void toggle_hipStreamDestroy(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamDestroy_fn = hipStreamDestroy_callback;
  else
    InternalRuntimeDispatchTable->hipStreamDestroy_fn = SavedTable.hipStreamDestroy_fn;
}

static void toggle_hipStreamEndCapture(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamEndCapture_fn = hipStreamEndCapture_callback;
  else
    InternalRuntimeDispatchTable->hipStreamEndCapture_fn = SavedTable.hipStreamEndCapture_fn;
}

static void toggle_hipStreamGetCaptureInfo(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamGetCaptureInfo_fn = hipStreamGetCaptureInfo_callback;
  else
    InternalRuntimeDispatchTable->hipStreamGetCaptureInfo_fn = SavedTable.hipStreamGetCaptureInfo_fn;
}

static void toggle_hipStreamGetCaptureInfo_v2(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamGetCaptureInfo_v2_fn = hipStreamGetCaptureInfo_v2_callback;
  else
    InternalRuntimeDispatchTable->hipStreamGetCaptureInfo_v2_fn = SavedTable.hipStreamGetCaptureInfo_v2_fn;
}

static void toggle_hipStreamGetDevice(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamGetDevice_fn = hipStreamGetDevice_callback;
  else
    InternalRuntimeDispatchTable->hipStreamGetDevice_fn = SavedTable.hipStreamGetDevice_fn;
}

static void toggle_hipStreamGetFlags(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamGetFlags_fn = hipStreamGetFlags_callback;
  else
    InternalRuntimeDispatchTable->hipStreamGetFlags_fn = SavedTable.hipStreamGetFlags_fn;
}

static void toggle_hipStreamGetPriority(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamGetPriority_fn = hipStreamGetPriority_callback;
  else
    InternalRuntimeDispatchTable->hipStreamGetPriority_fn = SavedTable.hipStreamGetPriority_fn;
}

static void toggle_hipStreamIsCapturing(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamIsCapturing_fn = hipStreamIsCapturing_callback;
  else
    InternalRuntimeDispatchTable->hipStreamIsCapturing_fn = SavedTable.hipStreamIsCapturing_fn;
}

static void toggle_hipStreamQuery(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamQuery_fn = hipStreamQuery_callback;
  else
    InternalRuntimeDispatchTable->hipStreamQuery_fn = SavedTable.hipStreamQuery_fn;
}

static void toggle_hipStreamSynchronize(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamSynchronize_fn = hipStreamSynchronize_callback;
  else
    InternalRuntimeDispatchTable->hipStreamSynchronize_fn = SavedTable.hipStreamSynchronize_fn;
}

static void toggle_hipStreamUpdateCaptureDependencies(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamUpdateCaptureDependencies_fn = hipStreamUpdateCaptureDependencies_callback;
  else
    InternalRuntimeDispatchTable->hipStreamUpdateCaptureDependencies_fn = SavedTable.hipStreamUpdateCaptureDependencies_fn;
}

static void toggle_hipStreamWaitEvent(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamWaitEvent_fn = hipStreamWaitEvent_callback;
  else
    InternalRuntimeDispatchTable->hipStreamWaitEvent_fn = SavedTable.hipStreamWaitEvent_fn;
}

static void toggle_hipStreamWaitValue32(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamWaitValue32_fn = hipStreamWaitValue32_callback;
  else
    InternalRuntimeDispatchTable->hipStreamWaitValue32_fn = SavedTable.hipStreamWaitValue32_fn;
}

static void toggle_hipStreamWaitValue64(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamWaitValue64_fn = hipStreamWaitValue64_callback;
  else
    InternalRuntimeDispatchTable->hipStreamWaitValue64_fn = SavedTable.hipStreamWaitValue64_fn;
}

static void toggle_hipStreamWriteValue32(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamWriteValue32_fn = hipStreamWriteValue32_callback;
  else
    InternalRuntimeDispatchTable->hipStreamWriteValue32_fn = SavedTable.hipStreamWriteValue32_fn;
}

static void toggle_hipStreamWriteValue64(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamWriteValue64_fn = hipStreamWriteValue64_callback;
  else
    InternalRuntimeDispatchTable->hipStreamWriteValue64_fn = SavedTable.hipStreamWriteValue64_fn;
}

static void toggle_hipTexObjectCreate(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexObjectCreate_fn = hipTexObjectCreate_callback;
  else
    InternalRuntimeDispatchTable->hipTexObjectCreate_fn = SavedTable.hipTexObjectCreate_fn;
}

static void toggle_hipTexObjectDestroy(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexObjectDestroy_fn = hipTexObjectDestroy_callback;
  else
    InternalRuntimeDispatchTable->hipTexObjectDestroy_fn = SavedTable.hipTexObjectDestroy_fn;
}

static void toggle_hipTexObjectGetResourceDesc(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexObjectGetResourceDesc_fn = hipTexObjectGetResourceDesc_callback;
  else
    InternalRuntimeDispatchTable->hipTexObjectGetResourceDesc_fn = SavedTable.hipTexObjectGetResourceDesc_fn;
}

static void toggle_hipTexObjectGetResourceViewDesc(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexObjectGetResourceViewDesc_fn = hipTexObjectGetResourceViewDesc_callback;
  else
    InternalRuntimeDispatchTable->hipTexObjectGetResourceViewDesc_fn = SavedTable.hipTexObjectGetResourceViewDesc_fn;
}

static void toggle_hipTexObjectGetTextureDesc(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexObjectGetTextureDesc_fn = hipTexObjectGetTextureDesc_callback;
  else
    InternalRuntimeDispatchTable->hipTexObjectGetTextureDesc_fn = SavedTable.hipTexObjectGetTextureDesc_fn;
}

static void toggle_hipTexRefGetAddress(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefGetAddress_fn = hipTexRefGetAddress_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefGetAddress_fn = SavedTable.hipTexRefGetAddress_fn;
}

static void toggle_hipTexRefGetAddressMode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefGetAddressMode_fn = hipTexRefGetAddressMode_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefGetAddressMode_fn = SavedTable.hipTexRefGetAddressMode_fn;
}

static void toggle_hipTexRefGetFilterMode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefGetFilterMode_fn = hipTexRefGetFilterMode_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefGetFilterMode_fn = SavedTable.hipTexRefGetFilterMode_fn;
}

static void toggle_hipTexRefGetFlags(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefGetFlags_fn = hipTexRefGetFlags_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefGetFlags_fn = SavedTable.hipTexRefGetFlags_fn;
}

static void toggle_hipTexRefGetFormat(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefGetFormat_fn = hipTexRefGetFormat_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefGetFormat_fn = SavedTable.hipTexRefGetFormat_fn;
}

static void toggle_hipTexRefGetMaxAnisotropy(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefGetMaxAnisotropy_fn = hipTexRefGetMaxAnisotropy_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefGetMaxAnisotropy_fn = SavedTable.hipTexRefGetMaxAnisotropy_fn;
}

static void toggle_hipTexRefGetMipMappedArray(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefGetMipMappedArray_fn = hipTexRefGetMipMappedArray_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefGetMipMappedArray_fn = SavedTable.hipTexRefGetMipMappedArray_fn;
}

static void toggle_hipTexRefGetMipmapFilterMode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefGetMipmapFilterMode_fn = hipTexRefGetMipmapFilterMode_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefGetMipmapFilterMode_fn = SavedTable.hipTexRefGetMipmapFilterMode_fn;
}

static void toggle_hipTexRefGetMipmapLevelBias(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefGetMipmapLevelBias_fn = hipTexRefGetMipmapLevelBias_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefGetMipmapLevelBias_fn = SavedTable.hipTexRefGetMipmapLevelBias_fn;
}

static void toggle_hipTexRefGetMipmapLevelClamp(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefGetMipmapLevelClamp_fn = hipTexRefGetMipmapLevelClamp_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefGetMipmapLevelClamp_fn = SavedTable.hipTexRefGetMipmapLevelClamp_fn;
}

static void toggle_hipTexRefSetAddress(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefSetAddress_fn = hipTexRefSetAddress_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefSetAddress_fn = SavedTable.hipTexRefSetAddress_fn;
}

static void toggle_hipTexRefSetAddress2D(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefSetAddress2D_fn = hipTexRefSetAddress2D_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefSetAddress2D_fn = SavedTable.hipTexRefSetAddress2D_fn;
}

static void toggle_hipTexRefSetAddressMode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefSetAddressMode_fn = hipTexRefSetAddressMode_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefSetAddressMode_fn = SavedTable.hipTexRefSetAddressMode_fn;
}

static void toggle_hipTexRefSetArray(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefSetArray_fn = hipTexRefSetArray_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefSetArray_fn = SavedTable.hipTexRefSetArray_fn;
}

static void toggle_hipTexRefSetBorderColor(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefSetBorderColor_fn = hipTexRefSetBorderColor_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefSetBorderColor_fn = SavedTable.hipTexRefSetBorderColor_fn;
}

static void toggle_hipTexRefSetFilterMode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefSetFilterMode_fn = hipTexRefSetFilterMode_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefSetFilterMode_fn = SavedTable.hipTexRefSetFilterMode_fn;
}

static void toggle_hipTexRefSetFlags(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefSetFlags_fn = hipTexRefSetFlags_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefSetFlags_fn = SavedTable.hipTexRefSetFlags_fn;
}

static void toggle_hipTexRefSetFormat(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefSetFormat_fn = hipTexRefSetFormat_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefSetFormat_fn = SavedTable.hipTexRefSetFormat_fn;
}

static void toggle_hipTexRefSetMaxAnisotropy(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefSetMaxAnisotropy_fn = hipTexRefSetMaxAnisotropy_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefSetMaxAnisotropy_fn = SavedTable.hipTexRefSetMaxAnisotropy_fn;
}

static void toggle_hipTexRefSetMipmapFilterMode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefSetMipmapFilterMode_fn = hipTexRefSetMipmapFilterMode_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefSetMipmapFilterMode_fn = SavedTable.hipTexRefSetMipmapFilterMode_fn;
}

static void toggle_hipTexRefSetMipmapLevelBias(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefSetMipmapLevelBias_fn = hipTexRefSetMipmapLevelBias_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefSetMipmapLevelBias_fn = SavedTable.hipTexRefSetMipmapLevelBias_fn;
}

static void toggle_hipTexRefSetMipmapLevelClamp(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefSetMipmapLevelClamp_fn = hipTexRefSetMipmapLevelClamp_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefSetMipmapLevelClamp_fn = SavedTable.hipTexRefSetMipmapLevelClamp_fn;
}

static void toggle_hipTexRefSetMipmappedArray(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefSetMipmappedArray_fn = hipTexRefSetMipmappedArray_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefSetMipmappedArray_fn = SavedTable.hipTexRefSetMipmappedArray_fn;
}

static void toggle_hipThreadExchangeStreamCaptureMode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipThreadExchangeStreamCaptureMode_fn = hipThreadExchangeStreamCaptureMode_callback;
  else
    InternalRuntimeDispatchTable->hipThreadExchangeStreamCaptureMode_fn = SavedTable.hipThreadExchangeStreamCaptureMode_fn;
}

static void toggle_hipUnbindTexture(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipUnbindTexture_fn = hipUnbindTexture_callback;
  else
    InternalRuntimeDispatchTable->hipUnbindTexture_fn = SavedTable.hipUnbindTexture_fn;
}

static void toggle_hipUserObjectCreate(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipUserObjectCreate_fn = hipUserObjectCreate_callback;
  else
    InternalRuntimeDispatchTable->hipUserObjectCreate_fn = SavedTable.hipUserObjectCreate_fn;
}

static void toggle_hipUserObjectRelease(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipUserObjectRelease_fn = hipUserObjectRelease_callback;
  else
    InternalRuntimeDispatchTable->hipUserObjectRelease_fn = SavedTable.hipUserObjectRelease_fn;
}

static void toggle_hipUserObjectRetain(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipUserObjectRetain_fn = hipUserObjectRetain_callback;
  else
    InternalRuntimeDispatchTable->hipUserObjectRetain_fn = SavedTable.hipUserObjectRetain_fn;
}

static void toggle_hipWaitExternalSemaphoresAsync(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipWaitExternalSemaphoresAsync_fn = hipWaitExternalSemaphoresAsync_callback;
  else
    InternalRuntimeDispatchTable->hipWaitExternalSemaphoresAsync_fn = SavedTable.hipWaitExternalSemaphoresAsync_fn;
}

static void toggle_hipCreateChannelDesc(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipCreateChannelDesc_fn = hipCreateChannelDesc_callback;
  else
    InternalRuntimeDispatchTable->hipCreateChannelDesc_fn = SavedTable.hipCreateChannelDesc_fn;
}

static void toggle_hipMemcpy_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy_spt_fn = hipMemcpy_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy_spt_fn = SavedTable.hipMemcpy_spt_fn;
}

static void toggle_hipMemcpyToSymbol_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyToSymbol_spt_fn = hipMemcpyToSymbol_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyToSymbol_spt_fn = SavedTable.hipMemcpyToSymbol_spt_fn;
}

static void toggle_hipMemcpyFromSymbol_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyFromSymbol_spt_fn = hipMemcpyFromSymbol_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyFromSymbol_spt_fn = SavedTable.hipMemcpyFromSymbol_spt_fn;
}

static void toggle_hipMemcpy2D_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy2D_spt_fn = hipMemcpy2D_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy2D_spt_fn = SavedTable.hipMemcpy2D_spt_fn;
}

static void toggle_hipMemcpy2DFromArray_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy2DFromArray_spt_fn = hipMemcpy2DFromArray_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy2DFromArray_spt_fn = SavedTable.hipMemcpy2DFromArray_spt_fn;
}

static void toggle_hipMemcpy3D_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy3D_spt_fn = hipMemcpy3D_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy3D_spt_fn = SavedTable.hipMemcpy3D_spt_fn;
}

static void toggle_hipMemset_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemset_spt_fn = hipMemset_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemset_spt_fn = SavedTable.hipMemset_spt_fn;
}

static void toggle_hipMemsetAsync_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemsetAsync_spt_fn = hipMemsetAsync_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemsetAsync_spt_fn = SavedTable.hipMemsetAsync_spt_fn;
}

static void toggle_hipMemset2D_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemset2D_spt_fn = hipMemset2D_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemset2D_spt_fn = SavedTable.hipMemset2D_spt_fn;
}

static void toggle_hipMemset2DAsync_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemset2DAsync_spt_fn = hipMemset2DAsync_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemset2DAsync_spt_fn = SavedTable.hipMemset2DAsync_spt_fn;
}

static void toggle_hipMemset3DAsync_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemset3DAsync_spt_fn = hipMemset3DAsync_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemset3DAsync_spt_fn = SavedTable.hipMemset3DAsync_spt_fn;
}

static void toggle_hipMemset3D_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemset3D_spt_fn = hipMemset3D_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemset3D_spt_fn = SavedTable.hipMemset3D_spt_fn;
}

static void toggle_hipMemcpyAsync_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyAsync_spt_fn = hipMemcpyAsync_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyAsync_spt_fn = SavedTable.hipMemcpyAsync_spt_fn;
}

static void toggle_hipMemcpy3DAsync_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy3DAsync_spt_fn = hipMemcpy3DAsync_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy3DAsync_spt_fn = SavedTable.hipMemcpy3DAsync_spt_fn;
}

static void toggle_hipMemcpy2DAsync_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy2DAsync_spt_fn = hipMemcpy2DAsync_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy2DAsync_spt_fn = SavedTable.hipMemcpy2DAsync_spt_fn;
}

static void toggle_hipMemcpyFromSymbolAsync_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyFromSymbolAsync_spt_fn = hipMemcpyFromSymbolAsync_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyFromSymbolAsync_spt_fn = SavedTable.hipMemcpyFromSymbolAsync_spt_fn;
}

static void toggle_hipMemcpyToSymbolAsync_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyToSymbolAsync_spt_fn = hipMemcpyToSymbolAsync_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyToSymbolAsync_spt_fn = SavedTable.hipMemcpyToSymbolAsync_spt_fn;
}

static void toggle_hipMemcpyFromArray_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpyFromArray_spt_fn = hipMemcpyFromArray_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpyFromArray_spt_fn = SavedTable.hipMemcpyFromArray_spt_fn;
}

static void toggle_hipMemcpy2DToArray_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy2DToArray_spt_fn = hipMemcpy2DToArray_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy2DToArray_spt_fn = SavedTable.hipMemcpy2DToArray_spt_fn;
}

static void toggle_hipMemcpy2DFromArrayAsync_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy2DFromArrayAsync_spt_fn = hipMemcpy2DFromArrayAsync_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy2DFromArrayAsync_spt_fn = SavedTable.hipMemcpy2DFromArrayAsync_spt_fn;
}

static void toggle_hipMemcpy2DToArrayAsync_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipMemcpy2DToArrayAsync_spt_fn = hipMemcpy2DToArrayAsync_spt_callback;
  else
    InternalRuntimeDispatchTable->hipMemcpy2DToArrayAsync_spt_fn = SavedTable.hipMemcpy2DToArrayAsync_spt_fn;
}

static void toggle_hipStreamQuery_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamQuery_spt_fn = hipStreamQuery_spt_callback;
  else
    InternalRuntimeDispatchTable->hipStreamQuery_spt_fn = SavedTable.hipStreamQuery_spt_fn;
}

static void toggle_hipStreamSynchronize_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamSynchronize_spt_fn = hipStreamSynchronize_spt_callback;
  else
    InternalRuntimeDispatchTable->hipStreamSynchronize_spt_fn = SavedTable.hipStreamSynchronize_spt_fn;
}

static void toggle_hipStreamGetPriority_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamGetPriority_spt_fn = hipStreamGetPriority_spt_callback;
  else
    InternalRuntimeDispatchTable->hipStreamGetPriority_spt_fn = SavedTable.hipStreamGetPriority_spt_fn;
}

static void toggle_hipStreamWaitEvent_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamWaitEvent_spt_fn = hipStreamWaitEvent_spt_callback;
  else
    InternalRuntimeDispatchTable->hipStreamWaitEvent_spt_fn = SavedTable.hipStreamWaitEvent_spt_fn;
}

static void toggle_hipStreamGetFlags_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamGetFlags_spt_fn = hipStreamGetFlags_spt_callback;
  else
    InternalRuntimeDispatchTable->hipStreamGetFlags_spt_fn = SavedTable.hipStreamGetFlags_spt_fn;
}

static void toggle_hipStreamAddCallback_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamAddCallback_spt_fn = hipStreamAddCallback_spt_callback;
  else
    InternalRuntimeDispatchTable->hipStreamAddCallback_spt_fn = SavedTable.hipStreamAddCallback_spt_fn;
}

static void toggle_hipEventRecord_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipEventRecord_spt_fn = hipEventRecord_spt_callback;
  else
    InternalRuntimeDispatchTable->hipEventRecord_spt_fn = SavedTable.hipEventRecord_spt_fn;
}

static void toggle_hipLaunchKernel_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipLaunchKernel_spt_fn = hipLaunchKernel_spt_callback;
  else
    InternalRuntimeDispatchTable->hipLaunchKernel_spt_fn = SavedTable.hipLaunchKernel_spt_fn;
}

static void toggle_hipGraphLaunch_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphLaunch_spt_fn = hipGraphLaunch_spt_callback;
  else
    InternalRuntimeDispatchTable->hipGraphLaunch_spt_fn = SavedTable.hipGraphLaunch_spt_fn;
}

static void toggle_hipStreamBeginCapture_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamBeginCapture_spt_fn = hipStreamBeginCapture_spt_callback;
  else
    InternalRuntimeDispatchTable->hipStreamBeginCapture_spt_fn = SavedTable.hipStreamBeginCapture_spt_fn;
}

static void toggle_hipStreamEndCapture_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamEndCapture_spt_fn = hipStreamEndCapture_spt_callback;
  else
    InternalRuntimeDispatchTable->hipStreamEndCapture_spt_fn = SavedTable.hipStreamEndCapture_spt_fn;
}

static void toggle_hipStreamIsCapturing_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamIsCapturing_spt_fn = hipStreamIsCapturing_spt_callback;
  else
    InternalRuntimeDispatchTable->hipStreamIsCapturing_spt_fn = SavedTable.hipStreamIsCapturing_spt_fn;
}

static void toggle_hipStreamGetCaptureInfo_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamGetCaptureInfo_spt_fn = hipStreamGetCaptureInfo_spt_callback;
  else
    InternalRuntimeDispatchTable->hipStreamGetCaptureInfo_spt_fn = SavedTable.hipStreamGetCaptureInfo_spt_fn;
}

static void toggle_hipStreamGetCaptureInfo_v2_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipStreamGetCaptureInfo_v2_spt_fn = hipStreamGetCaptureInfo_v2_spt_callback;
  else
    InternalRuntimeDispatchTable->hipStreamGetCaptureInfo_v2_spt_fn = SavedTable.hipStreamGetCaptureInfo_v2_spt_fn;
}

static void toggle_hipLaunchHostFunc_spt(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipLaunchHostFunc_spt_fn = hipLaunchHostFunc_spt_callback;
  else
    InternalRuntimeDispatchTable->hipLaunchHostFunc_spt_fn = SavedTable.hipLaunchHostFunc_spt_fn;
}

static void toggle_hipGetStreamDeviceId(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGetStreamDeviceId_fn = hipGetStreamDeviceId_callback;
  else
    InternalRuntimeDispatchTable->hipGetStreamDeviceId_fn = SavedTable.hipGetStreamDeviceId_fn;
}

static void toggle_hipDrvGraphAddMemsetNode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipDrvGraphAddMemsetNode_fn = hipDrvGraphAddMemsetNode_callback;
  else
    InternalRuntimeDispatchTable->hipDrvGraphAddMemsetNode_fn = SavedTable.hipDrvGraphAddMemsetNode_fn;
}

static void toggle_hipGraphAddExternalSemaphoresWaitNode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphAddExternalSemaphoresWaitNode_fn = hipGraphAddExternalSemaphoresWaitNode_callback;
  else
    InternalRuntimeDispatchTable->hipGraphAddExternalSemaphoresWaitNode_fn = SavedTable.hipGraphAddExternalSemaphoresWaitNode_fn;
}

static void toggle_hipGraphAddExternalSemaphoresSignalNode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphAddExternalSemaphoresSignalNode_fn = hipGraphAddExternalSemaphoresSignalNode_callback;
  else
    InternalRuntimeDispatchTable->hipGraphAddExternalSemaphoresSignalNode_fn = SavedTable.hipGraphAddExternalSemaphoresSignalNode_fn;
}

static void toggle_hipGraphExternalSemaphoresSignalNodeSetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExternalSemaphoresSignalNodeSetParams_fn = hipGraphExternalSemaphoresSignalNodeSetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExternalSemaphoresSignalNodeSetParams_fn = SavedTable.hipGraphExternalSemaphoresSignalNodeSetParams_fn;
}

static void toggle_hipGraphExternalSemaphoresWaitNodeSetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExternalSemaphoresWaitNodeSetParams_fn = hipGraphExternalSemaphoresWaitNodeSetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExternalSemaphoresWaitNodeSetParams_fn = SavedTable.hipGraphExternalSemaphoresWaitNodeSetParams_fn;
}

static void toggle_hipGraphExternalSemaphoresSignalNodeGetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExternalSemaphoresSignalNodeGetParams_fn = hipGraphExternalSemaphoresSignalNodeGetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExternalSemaphoresSignalNodeGetParams_fn = SavedTable.hipGraphExternalSemaphoresSignalNodeGetParams_fn;
}

static void toggle_hipGraphExternalSemaphoresWaitNodeGetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExternalSemaphoresWaitNodeGetParams_fn = hipGraphExternalSemaphoresWaitNodeGetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExternalSemaphoresWaitNodeGetParams_fn = SavedTable.hipGraphExternalSemaphoresWaitNodeGetParams_fn;
}

static void toggle_hipGraphExecExternalSemaphoresSignalNodeSetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExecExternalSemaphoresSignalNodeSetParams_fn = hipGraphExecExternalSemaphoresSignalNodeSetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExecExternalSemaphoresSignalNodeSetParams_fn = SavedTable.hipGraphExecExternalSemaphoresSignalNodeSetParams_fn;
}

static void toggle_hipGraphExecExternalSemaphoresWaitNodeSetParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphExecExternalSemaphoresWaitNodeSetParams_fn = hipGraphExecExternalSemaphoresWaitNodeSetParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphExecExternalSemaphoresWaitNodeSetParams_fn = SavedTable.hipGraphExecExternalSemaphoresWaitNodeSetParams_fn;
}

static void toggle_hipGraphAddNode(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphAddNode_fn = hipGraphAddNode_callback;
  else
    InternalRuntimeDispatchTable->hipGraphAddNode_fn = SavedTable.hipGraphAddNode_fn;
}

static void toggle_hipGraphInstantiateWithParams(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipGraphInstantiateWithParams_fn = hipGraphInstantiateWithParams_callback;
  else
    InternalRuntimeDispatchTable->hipGraphInstantiateWithParams_fn = SavedTable.hipGraphInstantiateWithParams_fn;
}

static void toggle_hipExtGetLastError(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipExtGetLastError_fn = hipExtGetLastError_callback;
  else
    InternalRuntimeDispatchTable->hipExtGetLastError_fn = SavedTable.hipExtGetLastError_fn;
}

static void toggle_hipTexRefGetBorderColor(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefGetBorderColor_fn = hipTexRefGetBorderColor_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefGetBorderColor_fn = SavedTable.hipTexRefGetBorderColor_fn;
}

static void toggle_hipTexRefGetArray(HipDispatchTable *InternalRuntimeDispatchTable, HipDispatchTable SavedTable, bool On) {
  if (On)
    InternalRuntimeDispatchTable->hipTexRefGetArray_fn = hipTexRefGetArray_callback;
  else
    InternalRuntimeDispatchTable->hipTexRefGetArray_fn = SavedTable.hipTexRefGetArray_fn;
}


static const llvm::DenseMap<rocprofiler_hip_runtime_api_id_t, std::function<void(HipDispatchTable *, const HipDispatchTable &, bool On)>> HipDispatchCallbackToggleFunctionsMap {
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipApiName, toggle_hipApiName },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipArray3DCreate, toggle_hipArray3DCreate },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipArray3DGetDescriptor, toggle_hipArray3DGetDescriptor },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipArrayCreate, toggle_hipArrayCreate },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipArrayDestroy, toggle_hipArrayDestroy },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipArrayGetDescriptor, toggle_hipArrayGetDescriptor },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipArrayGetInfo, toggle_hipArrayGetInfo },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipBindTexture, toggle_hipBindTexture },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipBindTexture2D, toggle_hipBindTexture2D },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipBindTextureToArray, toggle_hipBindTextureToArray },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipBindTextureToMipmappedArray, toggle_hipBindTextureToMipmappedArray },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipChooseDevice, toggle_hipChooseDevice },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipConfigureCall, toggle_hipConfigureCall },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCreateSurfaceObject, toggle_hipCreateSurfaceObject },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCreateTextureObject, toggle_hipCreateTextureObject },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxCreate, toggle_hipCtxCreate },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxDestroy, toggle_hipCtxDestroy },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxDisablePeerAccess, toggle_hipCtxDisablePeerAccess },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxEnablePeerAccess, toggle_hipCtxEnablePeerAccess },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetApiVersion, toggle_hipCtxGetApiVersion },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetCacheConfig, toggle_hipCtxGetCacheConfig },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetCurrent, toggle_hipCtxGetCurrent },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetDevice, toggle_hipCtxGetDevice },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetFlags, toggle_hipCtxGetFlags },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetSharedMemConfig, toggle_hipCtxGetSharedMemConfig },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxPopCurrent, toggle_hipCtxPopCurrent },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxPushCurrent, toggle_hipCtxPushCurrent },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxSetCacheConfig, toggle_hipCtxSetCacheConfig },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxSetCurrent, toggle_hipCtxSetCurrent },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxSetSharedMemConfig, toggle_hipCtxSetSharedMemConfig },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxSynchronize, toggle_hipCtxSynchronize },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDestroyExternalMemory, toggle_hipDestroyExternalMemory },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDestroyExternalSemaphore, toggle_hipDestroyExternalSemaphore },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDestroySurfaceObject, toggle_hipDestroySurfaceObject },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDestroyTextureObject, toggle_hipDestroyTextureObject },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceCanAccessPeer, toggle_hipDeviceCanAccessPeer },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceComputeCapability, toggle_hipDeviceComputeCapability },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceDisablePeerAccess, toggle_hipDeviceDisablePeerAccess },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceEnablePeerAccess, toggle_hipDeviceEnablePeerAccess },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGet, toggle_hipDeviceGet },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetAttribute, toggle_hipDeviceGetAttribute },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetByPCIBusId, toggle_hipDeviceGetByPCIBusId },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetCacheConfig, toggle_hipDeviceGetCacheConfig },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetDefaultMemPool, toggle_hipDeviceGetDefaultMemPool },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetGraphMemAttribute, toggle_hipDeviceGetGraphMemAttribute },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetLimit, toggle_hipDeviceGetLimit },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetMemPool, toggle_hipDeviceGetMemPool },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetName, toggle_hipDeviceGetName },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetP2PAttribute, toggle_hipDeviceGetP2PAttribute },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetPCIBusId, toggle_hipDeviceGetPCIBusId },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetSharedMemConfig, toggle_hipDeviceGetSharedMemConfig },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetStreamPriorityRange, toggle_hipDeviceGetStreamPriorityRange },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetUuid, toggle_hipDeviceGetUuid },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGraphMemTrim, toggle_hipDeviceGraphMemTrim },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDevicePrimaryCtxGetState, toggle_hipDevicePrimaryCtxGetState },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDevicePrimaryCtxRelease, toggle_hipDevicePrimaryCtxRelease },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDevicePrimaryCtxReset, toggle_hipDevicePrimaryCtxReset },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDevicePrimaryCtxRetain, toggle_hipDevicePrimaryCtxRetain },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDevicePrimaryCtxSetFlags, toggle_hipDevicePrimaryCtxSetFlags },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceReset, toggle_hipDeviceReset },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSetCacheConfig, toggle_hipDeviceSetCacheConfig },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSetGraphMemAttribute, toggle_hipDeviceSetGraphMemAttribute },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSetLimit, toggle_hipDeviceSetLimit },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSetMemPool, toggle_hipDeviceSetMemPool },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSetSharedMemConfig, toggle_hipDeviceSetSharedMemConfig },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSynchronize, toggle_hipDeviceSynchronize },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceTotalMem, toggle_hipDeviceTotalMem },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDriverGetVersion, toggle_hipDriverGetVersion },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvGetErrorName, toggle_hipDrvGetErrorName },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvGetErrorString, toggle_hipDrvGetErrorString },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvGraphAddMemcpyNode, toggle_hipDrvGraphAddMemcpyNode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvMemcpy2DUnaligned, toggle_hipDrvMemcpy2DUnaligned },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvMemcpy3D, toggle_hipDrvMemcpy3D },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvMemcpy3DAsync, toggle_hipDrvMemcpy3DAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvPointerGetAttributes, toggle_hipDrvPointerGetAttributes },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipEventCreate, toggle_hipEventCreate },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipEventCreateWithFlags, toggle_hipEventCreateWithFlags },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipEventDestroy, toggle_hipEventDestroy },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipEventElapsedTime, toggle_hipEventElapsedTime },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipEventQuery, toggle_hipEventQuery },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipEventRecord, toggle_hipEventRecord },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipEventSynchronize, toggle_hipEventSynchronize },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipExtGetLinkTypeAndHopCount, toggle_hipExtGetLinkTypeAndHopCount },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipExtLaunchKernel, toggle_hipExtLaunchKernel },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipExtLaunchMultiKernelMultiDevice, toggle_hipExtLaunchMultiKernelMultiDevice },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipExtMallocWithFlags, toggle_hipExtMallocWithFlags },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipExtStreamCreateWithCUMask, toggle_hipExtStreamCreateWithCUMask },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipExtStreamGetCUMask, toggle_hipExtStreamGetCUMask },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipExternalMemoryGetMappedBuffer, toggle_hipExternalMemoryGetMappedBuffer },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipFree, toggle_hipFree },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipFreeArray, toggle_hipFreeArray },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipFreeAsync, toggle_hipFreeAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipFreeHost, toggle_hipFreeHost },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipFreeMipmappedArray, toggle_hipFreeMipmappedArray },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipFuncGetAttribute, toggle_hipFuncGetAttribute },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipFuncGetAttributes, toggle_hipFuncGetAttributes },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipFuncSetAttribute, toggle_hipFuncSetAttribute },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipFuncSetCacheConfig, toggle_hipFuncSetCacheConfig },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipFuncSetSharedMemConfig, toggle_hipFuncSetSharedMemConfig },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGLGetDevices, toggle_hipGLGetDevices },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGetChannelDesc, toggle_hipGetChannelDesc },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGetDevice, toggle_hipGetDevice },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGetDeviceCount, toggle_hipGetDeviceCount },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGetDeviceFlags, toggle_hipGetDeviceFlags },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGetErrorName, toggle_hipGetErrorName },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGetErrorString, toggle_hipGetErrorString },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGetLastError, toggle_hipGetLastError },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGetMipmappedArrayLevel, toggle_hipGetMipmappedArrayLevel },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGetSymbolAddress, toggle_hipGetSymbolAddress },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGetSymbolSize, toggle_hipGetSymbolSize },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGetTextureAlignmentOffset, toggle_hipGetTextureAlignmentOffset },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGetTextureObjectResourceDesc, toggle_hipGetTextureObjectResourceDesc },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGetTextureObjectResourceViewDesc, toggle_hipGetTextureObjectResourceViewDesc },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGetTextureObjectTextureDesc, toggle_hipGetTextureObjectTextureDesc },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGetTextureReference, toggle_hipGetTextureReference },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddChildGraphNode, toggle_hipGraphAddChildGraphNode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddDependencies, toggle_hipGraphAddDependencies },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddEmptyNode, toggle_hipGraphAddEmptyNode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddEventRecordNode, toggle_hipGraphAddEventRecordNode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddEventWaitNode, toggle_hipGraphAddEventWaitNode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddHostNode, toggle_hipGraphAddHostNode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddKernelNode, toggle_hipGraphAddKernelNode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemAllocNode, toggle_hipGraphAddMemAllocNode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemFreeNode, toggle_hipGraphAddMemFreeNode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemcpyNode, toggle_hipGraphAddMemcpyNode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemcpyNode1D, toggle_hipGraphAddMemcpyNode1D },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemcpyNodeFromSymbol, toggle_hipGraphAddMemcpyNodeFromSymbol },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemcpyNodeToSymbol, toggle_hipGraphAddMemcpyNodeToSymbol },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemsetNode, toggle_hipGraphAddMemsetNode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphChildGraphNodeGetGraph, toggle_hipGraphChildGraphNodeGetGraph },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphClone, toggle_hipGraphClone },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphCreate, toggle_hipGraphCreate },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphDebugDotPrint, toggle_hipGraphDebugDotPrint },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphDestroy, toggle_hipGraphDestroy },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphDestroyNode, toggle_hipGraphDestroyNode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphEventRecordNodeGetEvent, toggle_hipGraphEventRecordNodeGetEvent },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphEventRecordNodeSetEvent, toggle_hipGraphEventRecordNodeSetEvent },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphEventWaitNodeGetEvent, toggle_hipGraphEventWaitNodeGetEvent },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphEventWaitNodeSetEvent, toggle_hipGraphEventWaitNodeSetEvent },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecChildGraphNodeSetParams, toggle_hipGraphExecChildGraphNodeSetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecDestroy, toggle_hipGraphExecDestroy },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecEventRecordNodeSetEvent, toggle_hipGraphExecEventRecordNodeSetEvent },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecEventWaitNodeSetEvent, toggle_hipGraphExecEventWaitNodeSetEvent },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecHostNodeSetParams, toggle_hipGraphExecHostNodeSetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecKernelNodeSetParams, toggle_hipGraphExecKernelNodeSetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecMemcpyNodeSetParams, toggle_hipGraphExecMemcpyNodeSetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecMemcpyNodeSetParams1D, toggle_hipGraphExecMemcpyNodeSetParams1D },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecMemcpyNodeSetParamsFromSymbol, toggle_hipGraphExecMemcpyNodeSetParamsFromSymbol },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecMemcpyNodeSetParamsToSymbol, toggle_hipGraphExecMemcpyNodeSetParamsToSymbol },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecMemsetNodeSetParams, toggle_hipGraphExecMemsetNodeSetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecUpdate, toggle_hipGraphExecUpdate },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphGetEdges, toggle_hipGraphGetEdges },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphGetNodes, toggle_hipGraphGetNodes },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphGetRootNodes, toggle_hipGraphGetRootNodes },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphHostNodeGetParams, toggle_hipGraphHostNodeGetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphHostNodeSetParams, toggle_hipGraphHostNodeSetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphInstantiate, toggle_hipGraphInstantiate },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphInstantiateWithFlags, toggle_hipGraphInstantiateWithFlags },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphKernelNodeCopyAttributes, toggle_hipGraphKernelNodeCopyAttributes },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphKernelNodeGetAttribute, toggle_hipGraphKernelNodeGetAttribute },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphKernelNodeGetParams, toggle_hipGraphKernelNodeGetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphKernelNodeSetAttribute, toggle_hipGraphKernelNodeSetAttribute },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphKernelNodeSetParams, toggle_hipGraphKernelNodeSetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphLaunch, toggle_hipGraphLaunch },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemAllocNodeGetParams, toggle_hipGraphMemAllocNodeGetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemFreeNodeGetParams, toggle_hipGraphMemFreeNodeGetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemcpyNodeGetParams, toggle_hipGraphMemcpyNodeGetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemcpyNodeSetParams, toggle_hipGraphMemcpyNodeSetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemcpyNodeSetParams1D, toggle_hipGraphMemcpyNodeSetParams1D },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemcpyNodeSetParamsFromSymbol, toggle_hipGraphMemcpyNodeSetParamsFromSymbol },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemcpyNodeSetParamsToSymbol, toggle_hipGraphMemcpyNodeSetParamsToSymbol },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemsetNodeGetParams, toggle_hipGraphMemsetNodeGetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemsetNodeSetParams, toggle_hipGraphMemsetNodeSetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeFindInClone, toggle_hipGraphNodeFindInClone },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeGetDependencies, toggle_hipGraphNodeGetDependencies },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeGetDependentNodes, toggle_hipGraphNodeGetDependentNodes },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeGetEnabled, toggle_hipGraphNodeGetEnabled },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeGetType, toggle_hipGraphNodeGetType },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeSetEnabled, toggle_hipGraphNodeSetEnabled },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphReleaseUserObject, toggle_hipGraphReleaseUserObject },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphRemoveDependencies, toggle_hipGraphRemoveDependencies },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphRetainUserObject, toggle_hipGraphRetainUserObject },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphUpload, toggle_hipGraphUpload },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsGLRegisterBuffer, toggle_hipGraphicsGLRegisterBuffer },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsGLRegisterImage, toggle_hipGraphicsGLRegisterImage },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsMapResources, toggle_hipGraphicsMapResources },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsResourceGetMappedPointer, toggle_hipGraphicsResourceGetMappedPointer },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsSubResourceGetMappedArray, toggle_hipGraphicsSubResourceGetMappedArray },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsUnmapResources, toggle_hipGraphicsUnmapResources },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsUnregisterResource, toggle_hipGraphicsUnregisterResource },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipHostAlloc, toggle_hipHostAlloc },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipHostFree, toggle_hipHostFree },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipHostGetDevicePointer, toggle_hipHostGetDevicePointer },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipHostGetFlags, toggle_hipHostGetFlags },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipHostMalloc, toggle_hipHostMalloc },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipHostRegister, toggle_hipHostRegister },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipHostUnregister, toggle_hipHostUnregister },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipImportExternalMemory, toggle_hipImportExternalMemory },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipImportExternalSemaphore, toggle_hipImportExternalSemaphore },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipInit, toggle_hipInit },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipIpcCloseMemHandle, toggle_hipIpcCloseMemHandle },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipIpcGetEventHandle, toggle_hipIpcGetEventHandle },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipIpcGetMemHandle, toggle_hipIpcGetMemHandle },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipIpcOpenEventHandle, toggle_hipIpcOpenEventHandle },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipIpcOpenMemHandle, toggle_hipIpcOpenMemHandle },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipKernelNameRefByPtr, toggle_hipKernelNameRefByPtr },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchByPtr, toggle_hipLaunchByPtr },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchCooperativeKernelMultiDevice, toggle_hipLaunchCooperativeKernelMultiDevice },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchHostFunc, toggle_hipLaunchHostFunc },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchKernel, toggle_hipLaunchKernel },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMalloc, toggle_hipMalloc },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMalloc3D, toggle_hipMalloc3D },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMalloc3DArray, toggle_hipMalloc3DArray },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocArray, toggle_hipMallocArray },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocAsync, toggle_hipMallocAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocFromPoolAsync, toggle_hipMallocFromPoolAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocHost, toggle_hipMallocHost },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocManaged, toggle_hipMallocManaged },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocMipmappedArray, toggle_hipMallocMipmappedArray },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocPitch, toggle_hipMallocPitch },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemAddressFree, toggle_hipMemAddressFree },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemAddressReserve, toggle_hipMemAddressReserve },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemAdvise, toggle_hipMemAdvise },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemAllocHost, toggle_hipMemAllocHost },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemAllocPitch, toggle_hipMemAllocPitch },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemCreate, toggle_hipMemCreate },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemExportToShareableHandle, toggle_hipMemExportToShareableHandle },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemGetAccess, toggle_hipMemGetAccess },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemGetAddressRange, toggle_hipMemGetAddressRange },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemGetAllocationGranularity, toggle_hipMemGetAllocationGranularity },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemGetAllocationPropertiesFromHandle, toggle_hipMemGetAllocationPropertiesFromHandle },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemGetInfo, toggle_hipMemGetInfo },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemImportFromShareableHandle, toggle_hipMemImportFromShareableHandle },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemMap, toggle_hipMemMap },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemMapArrayAsync, toggle_hipMemMapArrayAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolCreate, toggle_hipMemPoolCreate },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolDestroy, toggle_hipMemPoolDestroy },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolExportPointer, toggle_hipMemPoolExportPointer },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolExportToShareableHandle, toggle_hipMemPoolExportToShareableHandle },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolGetAccess, toggle_hipMemPoolGetAccess },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolGetAttribute, toggle_hipMemPoolGetAttribute },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolImportFromShareableHandle, toggle_hipMemPoolImportFromShareableHandle },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolImportPointer, toggle_hipMemPoolImportPointer },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolSetAccess, toggle_hipMemPoolSetAccess },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolSetAttribute, toggle_hipMemPoolSetAttribute },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolTrimTo, toggle_hipMemPoolTrimTo },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPrefetchAsync, toggle_hipMemPrefetchAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPtrGetInfo, toggle_hipMemPtrGetInfo },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemRangeGetAttribute, toggle_hipMemRangeGetAttribute },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemRangeGetAttributes, toggle_hipMemRangeGetAttributes },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemRelease, toggle_hipMemRelease },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemRetainAllocationHandle, toggle_hipMemRetainAllocationHandle },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemSetAccess, toggle_hipMemSetAccess },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemUnmap, toggle_hipMemUnmap },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy, toggle_hipMemcpy },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2D, toggle_hipMemcpy2D },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DAsync, toggle_hipMemcpy2DAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DFromArray, toggle_hipMemcpy2DFromArray },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DFromArrayAsync, toggle_hipMemcpy2DFromArrayAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DToArray, toggle_hipMemcpy2DToArray },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DToArrayAsync, toggle_hipMemcpy2DToArrayAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy3D, toggle_hipMemcpy3D },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy3DAsync, toggle_hipMemcpy3DAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyAsync, toggle_hipMemcpyAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyAtoH, toggle_hipMemcpyAtoH },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyDtoD, toggle_hipMemcpyDtoD },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyDtoDAsync, toggle_hipMemcpyDtoDAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyDtoH, toggle_hipMemcpyDtoH },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyDtoHAsync, toggle_hipMemcpyDtoHAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromArray, toggle_hipMemcpyFromArray },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromSymbol, toggle_hipMemcpyFromSymbol },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromSymbolAsync, toggle_hipMemcpyFromSymbolAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyHtoA, toggle_hipMemcpyHtoA },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyHtoD, toggle_hipMemcpyHtoD },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyHtoDAsync, toggle_hipMemcpyHtoDAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyParam2D, toggle_hipMemcpyParam2D },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyParam2DAsync, toggle_hipMemcpyParam2DAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyPeer, toggle_hipMemcpyPeer },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyPeerAsync, toggle_hipMemcpyPeerAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToArray, toggle_hipMemcpyToArray },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToSymbol, toggle_hipMemcpyToSymbol },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToSymbolAsync, toggle_hipMemcpyToSymbolAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyWithStream, toggle_hipMemcpyWithStream },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset, toggle_hipMemset },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset2D, toggle_hipMemset2D },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset2DAsync, toggle_hipMemset2DAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset3D, toggle_hipMemset3D },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset3DAsync, toggle_hipMemset3DAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetAsync, toggle_hipMemsetAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD16, toggle_hipMemsetD16 },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD16Async, toggle_hipMemsetD16Async },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD32, toggle_hipMemsetD32 },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD32Async, toggle_hipMemsetD32Async },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD8, toggle_hipMemsetD8 },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD8Async, toggle_hipMemsetD8Async },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMipmappedArrayCreate, toggle_hipMipmappedArrayCreate },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMipmappedArrayDestroy, toggle_hipMipmappedArrayDestroy },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMipmappedArrayGetLevel, toggle_hipMipmappedArrayGetLevel },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleGetFunction, toggle_hipModuleGetFunction },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleGetGlobal, toggle_hipModuleGetGlobal },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleGetTexRef, toggle_hipModuleGetTexRef },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleLaunchCooperativeKernelMultiDevice, toggle_hipModuleLaunchCooperativeKernelMultiDevice },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleLoad, toggle_hipModuleLoad },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleLoadData, toggle_hipModuleLoadData },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleLoadDataEx, toggle_hipModuleLoadDataEx },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleUnload, toggle_hipModuleUnload },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipPeekAtLastError, toggle_hipPeekAtLastError },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipPointerGetAttribute, toggle_hipPointerGetAttribute },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipPointerGetAttributes, toggle_hipPointerGetAttributes },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipPointerSetAttribute, toggle_hipPointerSetAttribute },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipProfilerStart, toggle_hipProfilerStart },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipProfilerStop, toggle_hipProfilerStop },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipRuntimeGetVersion, toggle_hipRuntimeGetVersion },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipSetDevice, toggle_hipSetDevice },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipSetDeviceFlags, toggle_hipSetDeviceFlags },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipSetupArgument, toggle_hipSetupArgument },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipSignalExternalSemaphoresAsync, toggle_hipSignalExternalSemaphoresAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamAddCallback, toggle_hipStreamAddCallback },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamAttachMemAsync, toggle_hipStreamAttachMemAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamBeginCapture, toggle_hipStreamBeginCapture },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamCreate, toggle_hipStreamCreate },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamCreateWithFlags, toggle_hipStreamCreateWithFlags },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamCreateWithPriority, toggle_hipStreamCreateWithPriority },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamDestroy, toggle_hipStreamDestroy },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamEndCapture, toggle_hipStreamEndCapture },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetCaptureInfo, toggle_hipStreamGetCaptureInfo },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetCaptureInfo_v2, toggle_hipStreamGetCaptureInfo_v2 },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetDevice, toggle_hipStreamGetDevice },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetFlags, toggle_hipStreamGetFlags },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetPriority, toggle_hipStreamGetPriority },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamIsCapturing, toggle_hipStreamIsCapturing },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamQuery, toggle_hipStreamQuery },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamSynchronize, toggle_hipStreamSynchronize },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamUpdateCaptureDependencies, toggle_hipStreamUpdateCaptureDependencies },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWaitEvent, toggle_hipStreamWaitEvent },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWaitValue32, toggle_hipStreamWaitValue32 },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWaitValue64, toggle_hipStreamWaitValue64 },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWriteValue32, toggle_hipStreamWriteValue32 },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWriteValue64, toggle_hipStreamWriteValue64 },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexObjectCreate, toggle_hipTexObjectCreate },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexObjectDestroy, toggle_hipTexObjectDestroy },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexObjectGetResourceDesc, toggle_hipTexObjectGetResourceDesc },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexObjectGetResourceViewDesc, toggle_hipTexObjectGetResourceViewDesc },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexObjectGetTextureDesc, toggle_hipTexObjectGetTextureDesc },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetAddress, toggle_hipTexRefGetAddress },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetAddressMode, toggle_hipTexRefGetAddressMode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetFilterMode, toggle_hipTexRefGetFilterMode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetFlags, toggle_hipTexRefGetFlags },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetFormat, toggle_hipTexRefGetFormat },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetMaxAnisotropy, toggle_hipTexRefGetMaxAnisotropy },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetMipMappedArray, toggle_hipTexRefGetMipMappedArray },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetMipmapFilterMode, toggle_hipTexRefGetMipmapFilterMode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetMipmapLevelBias, toggle_hipTexRefGetMipmapLevelBias },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetMipmapLevelClamp, toggle_hipTexRefGetMipmapLevelClamp },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetAddress, toggle_hipTexRefSetAddress },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetAddress2D, toggle_hipTexRefSetAddress2D },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetAddressMode, toggle_hipTexRefSetAddressMode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetArray, toggle_hipTexRefSetArray },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetBorderColor, toggle_hipTexRefSetBorderColor },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetFilterMode, toggle_hipTexRefSetFilterMode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetFlags, toggle_hipTexRefSetFlags },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetFormat, toggle_hipTexRefSetFormat },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetMaxAnisotropy, toggle_hipTexRefSetMaxAnisotropy },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetMipmapFilterMode, toggle_hipTexRefSetMipmapFilterMode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetMipmapLevelBias, toggle_hipTexRefSetMipmapLevelBias },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetMipmapLevelClamp, toggle_hipTexRefSetMipmapLevelClamp },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetMipmappedArray, toggle_hipTexRefSetMipmappedArray },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipThreadExchangeStreamCaptureMode, toggle_hipThreadExchangeStreamCaptureMode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipUnbindTexture, toggle_hipUnbindTexture },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipUserObjectCreate, toggle_hipUserObjectCreate },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipUserObjectRelease, toggle_hipUserObjectRelease },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipUserObjectRetain, toggle_hipUserObjectRetain },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipWaitExternalSemaphoresAsync, toggle_hipWaitExternalSemaphoresAsync },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipCreateChannelDesc, toggle_hipCreateChannelDesc },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy_spt, toggle_hipMemcpy_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToSymbol_spt, toggle_hipMemcpyToSymbol_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromSymbol_spt, toggle_hipMemcpyFromSymbol_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2D_spt, toggle_hipMemcpy2D_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DFromArray_spt, toggle_hipMemcpy2DFromArray_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy3D_spt, toggle_hipMemcpy3D_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset_spt, toggle_hipMemset_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetAsync_spt, toggle_hipMemsetAsync_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset2D_spt, toggle_hipMemset2D_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset2DAsync_spt, toggle_hipMemset2DAsync_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset3DAsync_spt, toggle_hipMemset3DAsync_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset3D_spt, toggle_hipMemset3D_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyAsync_spt, toggle_hipMemcpyAsync_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy3DAsync_spt, toggle_hipMemcpy3DAsync_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DAsync_spt, toggle_hipMemcpy2DAsync_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromSymbolAsync_spt, toggle_hipMemcpyFromSymbolAsync_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToSymbolAsync_spt, toggle_hipMemcpyToSymbolAsync_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromArray_spt, toggle_hipMemcpyFromArray_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DToArray_spt, toggle_hipMemcpy2DToArray_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DFromArrayAsync_spt, toggle_hipMemcpy2DFromArrayAsync_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DToArrayAsync_spt, toggle_hipMemcpy2DToArrayAsync_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamQuery_spt, toggle_hipStreamQuery_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamSynchronize_spt, toggle_hipStreamSynchronize_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetPriority_spt, toggle_hipStreamGetPriority_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWaitEvent_spt, toggle_hipStreamWaitEvent_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetFlags_spt, toggle_hipStreamGetFlags_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamAddCallback_spt, toggle_hipStreamAddCallback_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipEventRecord_spt, toggle_hipEventRecord_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchKernel_spt, toggle_hipLaunchKernel_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphLaunch_spt, toggle_hipGraphLaunch_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamBeginCapture_spt, toggle_hipStreamBeginCapture_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamEndCapture_spt, toggle_hipStreamEndCapture_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamIsCapturing_spt, toggle_hipStreamIsCapturing_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetCaptureInfo_spt, toggle_hipStreamGetCaptureInfo_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetCaptureInfo_v2_spt, toggle_hipStreamGetCaptureInfo_v2_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchHostFunc_spt, toggle_hipLaunchHostFunc_spt },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGetStreamDeviceId, toggle_hipGetStreamDeviceId },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvGraphAddMemsetNode, toggle_hipDrvGraphAddMemsetNode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddExternalSemaphoresWaitNode, toggle_hipGraphAddExternalSemaphoresWaitNode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddExternalSemaphoresSignalNode, toggle_hipGraphAddExternalSemaphoresSignalNode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExternalSemaphoresSignalNodeSetParams, toggle_hipGraphExternalSemaphoresSignalNodeSetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExternalSemaphoresWaitNodeSetParams, toggle_hipGraphExternalSemaphoresWaitNodeSetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExternalSemaphoresSignalNodeGetParams, toggle_hipGraphExternalSemaphoresSignalNodeGetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExternalSemaphoresWaitNodeGetParams, toggle_hipGraphExternalSemaphoresWaitNodeGetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecExternalSemaphoresSignalNodeSetParams, toggle_hipGraphExecExternalSemaphoresSignalNodeSetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecExternalSemaphoresWaitNodeSetParams, toggle_hipGraphExecExternalSemaphoresWaitNodeSetParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddNode, toggle_hipGraphAddNode },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphInstantiateWithParams, toggle_hipGraphInstantiateWithParams },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipExtGetLastError, toggle_hipExtGetLastError },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetBorderColor, toggle_hipTexRefGetBorderColor },
  { ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetArray, toggle_hipTexRefGetArray },
};

void luthier::hip::RuntimeInterceptor::enableUserCallback(rocprofiler_hip_runtime_api_id_t Op) {
  HipDispatchCallbackToggleFunctionsMap.at(Op)(InternalRuntimeDispatchTable, SavedDispatchTable, true);
  EnabledUserOps.insert(Op);
}

void luthier::hip::RuntimeInterceptor::disableUserCallback(rocprofiler_hip_runtime_api_id_t Op) {
  EnabledUserOps.erase(Op);
  if (!EnabledInternalOps.contains(Op))
    HipDispatchCallbackToggleFunctionsMap.at(Op)(InternalRuntimeDispatchTable, SavedDispatchTable, false);
}

void luthier::hip::RuntimeInterceptor::enableInternalCallback(rocprofiler_hip_runtime_api_id_t Op) {
  HipDispatchCallbackToggleFunctionsMap.at(Op)(InternalRuntimeDispatchTable, SavedDispatchTable, true);
  EnabledInternalOps.insert(Op);
}

void luthier::hip::RuntimeInterceptor::disableInternalCallback(rocprofiler_hip_runtime_api_id_t Op) {
  EnabledInternalOps.erase(Op);
  if (!EnabledUserOps.contains(Op))
    HipDispatchCallbackToggleFunctionsMap.at(Op)(InternalRuntimeDispatchTable, SavedDispatchTable, false);
}

// NOLINTEND
