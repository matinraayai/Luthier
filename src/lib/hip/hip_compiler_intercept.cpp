// NOLINTBEGIN
/* Generated by hip_intercept_gen.py. DO NOT EDIT! */
#include "hip/hip_compiler_intercept.hpp"
#include "luthier/luthier.h"
#include "luthier/types.h"
#include <rocprofiler-sdk/hip/api_args.h>
#include <rocprofiler-sdk/hip/api_id.h>

static hipError_t __hipPopCallConfiguration_callback(dim3* gridDim, dim3* blockDim, size_t* sharedMem, hipStream_t* stream) {
  auto& HipInterceptor = luthier::hip::CompilerInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_COMPILER_API_ID___hipPopCallConfiguration;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.__hipPopCallConfiguration.gridDim = gridDim;
    Args.__hipPopCallConfiguration.blockDim = blockDim;
    Args.__hipPopCallConfiguration.sharedMem = sharedMem;
    Args.__hipPopCallConfiguration.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedCompilerTable().__hipPopCallConfiguration_fn(Args.__hipPopCallConfiguration.gridDim, Args.__hipPopCallConfiguration.blockDim, Args.__hipPopCallConfiguration.sharedMem, Args.__hipPopCallConfiguration.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedCompilerTable().__hipPopCallConfiguration_fn(gridDim, blockDim, sharedMem, stream);
  }
}

static hipError_t __hipPushCallConfiguration_callback(dim3 gridDim, dim3 blockDim, size_t sharedMem, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::CompilerInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_COMPILER_API_ID___hipPushCallConfiguration;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.__hipPushCallConfiguration.gridDim = luthier::convertToRocprofilerDim3(gridDim);
    Args.__hipPushCallConfiguration.blockDim = luthier::convertToRocprofilerDim3(blockDim);
    Args.__hipPushCallConfiguration.sharedMem = sharedMem;
    Args.__hipPushCallConfiguration.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedCompilerTable().__hipPushCallConfiguration_fn(gridDim, blockDim, Args.__hipPushCallConfiguration.sharedMem, Args.__hipPushCallConfiguration.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedCompilerTable().__hipPushCallConfiguration_fn(gridDim, blockDim, sharedMem, stream);
  }
}

static void** __hipRegisterFatBinary_callback(const void* data) {
  auto& HipInterceptor = luthier::hip::CompilerInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_COMPILER_API_ID___hipRegisterFatBinary;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    void** Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.__hipRegisterFatBinary.data = data;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedCompilerTable().__hipRegisterFatBinary_fn(Args.__hipRegisterFatBinary.data);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedCompilerTable().__hipRegisterFatBinary_fn(data);
  }
}

static void __hipRegisterFunction_callback(void** modules, const void* hostFunction, char* deviceFunction, const char* deviceName, unsigned int threadLimit, uint3* tid, uint3* bid, dim3* blockDim, dim3* gridDim, int* wSize) {
  auto& HipInterceptor = luthier::hip::CompilerInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_COMPILER_API_ID___hipRegisterFunction;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.__hipRegisterFunction.modules = modules;
    Args.__hipRegisterFunction.hostFunction = hostFunction;
    Args.__hipRegisterFunction.deviceFunction = deviceFunction;
    Args.__hipRegisterFunction.deviceName = deviceName;
    Args.__hipRegisterFunction.threadLimit = threadLimit;
    Args.__hipRegisterFunction.tid = tid;
    Args.__hipRegisterFunction.bid = bid;
    Args.__hipRegisterFunction.blockDim = blockDim;
    Args.__hipRegisterFunction.gridDim = gridDim;
    Args.__hipRegisterFunction.wSize = wSize;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
       HipInterceptor.getSavedCompilerTable().__hipRegisterFunction_fn(Args.__hipRegisterFunction.modules, Args.__hipRegisterFunction.hostFunction, Args.__hipRegisterFunction.deviceFunction, Args.__hipRegisterFunction.deviceName, Args.__hipRegisterFunction.threadLimit, Args.__hipRegisterFunction.tid, Args.__hipRegisterFunction.bid, Args.__hipRegisterFunction.blockDim, Args.__hipRegisterFunction.gridDim, Args.__hipRegisterFunction.wSize);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    
  }
  else {
    return HipInterceptor.getSavedCompilerTable().__hipRegisterFunction_fn(modules, hostFunction, deviceFunction, deviceName, threadLimit, tid, bid, blockDim, gridDim, wSize);
  }
}

static void __hipRegisterManagedVar_callback(void* hipModule, void** pointer, void* init_value, const char* name, size_t size, unsigned align) {
  auto& HipInterceptor = luthier::hip::CompilerInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_COMPILER_API_ID___hipRegisterManagedVar;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.__hipRegisterManagedVar.hipModule = hipModule;
    Args.__hipRegisterManagedVar.pointer = pointer;
    Args.__hipRegisterManagedVar.init_value = init_value;
    Args.__hipRegisterManagedVar.name = name;
    Args.__hipRegisterManagedVar.size = size;
    Args.__hipRegisterManagedVar.align = align;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
       HipInterceptor.getSavedCompilerTable().__hipRegisterManagedVar_fn(Args.__hipRegisterManagedVar.hipModule, Args.__hipRegisterManagedVar.pointer, Args.__hipRegisterManagedVar.init_value, Args.__hipRegisterManagedVar.name, Args.__hipRegisterManagedVar.size, Args.__hipRegisterManagedVar.align);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    
  }
  else {
    return HipInterceptor.getSavedCompilerTable().__hipRegisterManagedVar_fn(hipModule, pointer, init_value, name, size, align);
  }
}

static void __hipRegisterSurface_callback(void** modules, void* var, char* hostVar, char* deviceVar, int type, int ext) {
  auto& HipInterceptor = luthier::hip::CompilerInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_COMPILER_API_ID___hipRegisterSurface;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.__hipRegisterSurface.modules = modules;
    Args.__hipRegisterSurface.var = var;
    Args.__hipRegisterSurface.hostVar = hostVar;
    Args.__hipRegisterSurface.deviceVar = deviceVar;
    Args.__hipRegisterSurface.type = type;
    Args.__hipRegisterSurface.ext = ext;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
       HipInterceptor.getSavedCompilerTable().__hipRegisterSurface_fn(Args.__hipRegisterSurface.modules, Args.__hipRegisterSurface.var, Args.__hipRegisterSurface.hostVar, Args.__hipRegisterSurface.deviceVar, Args.__hipRegisterSurface.type, Args.__hipRegisterSurface.ext);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    
  }
  else {
    return HipInterceptor.getSavedCompilerTable().__hipRegisterSurface_fn(modules, var, hostVar, deviceVar, type, ext);
  }
}

static void __hipRegisterTexture_callback(void** modules, void* var, char* hostVar, char* deviceVar, int type, int norm, int ext) {
  auto& HipInterceptor = luthier::hip::CompilerInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_COMPILER_API_ID___hipRegisterTexture;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.__hipRegisterTexture.modules = modules;
    Args.__hipRegisterTexture.var = var;
    Args.__hipRegisterTexture.hostVar = hostVar;
    Args.__hipRegisterTexture.deviceVar = deviceVar;
    Args.__hipRegisterTexture.type = type;
    Args.__hipRegisterTexture.norm = norm;
    Args.__hipRegisterTexture.ext = ext;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
       HipInterceptor.getSavedCompilerTable().__hipRegisterTexture_fn(Args.__hipRegisterTexture.modules, Args.__hipRegisterTexture.var, Args.__hipRegisterTexture.hostVar, Args.__hipRegisterTexture.deviceVar, Args.__hipRegisterTexture.type, Args.__hipRegisterTexture.norm, Args.__hipRegisterTexture.ext);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    
  }
  else {
    return HipInterceptor.getSavedCompilerTable().__hipRegisterTexture_fn(modules, var, hostVar, deviceVar, type, norm, ext);
  }
}

static void __hipRegisterVar_callback(void** modules, void* var, char* hostVar, char* deviceVar, int ext, size_t size, int constant, int global) {
  auto& HipInterceptor = luthier::hip::CompilerInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_COMPILER_API_ID___hipRegisterVar;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.__hipRegisterVar.modules = modules;
    Args.__hipRegisterVar.var = var;
    Args.__hipRegisterVar.hostVar = hostVar;
    Args.__hipRegisterVar.deviceVar = deviceVar;
    Args.__hipRegisterVar.ext = ext;
    Args.__hipRegisterVar.size = size;
    Args.__hipRegisterVar.constant = constant;
    Args.__hipRegisterVar.global = global;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
       HipInterceptor.getSavedCompilerTable().__hipRegisterVar_fn(Args.__hipRegisterVar.modules, Args.__hipRegisterVar.var, Args.__hipRegisterVar.hostVar, Args.__hipRegisterVar.deviceVar, Args.__hipRegisterVar.ext, Args.__hipRegisterVar.size, Args.__hipRegisterVar.constant, Args.__hipRegisterVar.global);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    
  }
  else {
    return HipInterceptor.getSavedCompilerTable().__hipRegisterVar_fn(modules, var, hostVar, deviceVar, ext, size, constant, global);
  }
}

static void __hipUnregisterFatBinary_callback(void** modules) {
  auto& HipInterceptor = luthier::hip::CompilerInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_COMPILER_API_ID___hipUnregisterFatBinary;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.__hipUnregisterFatBinary.modules = modules;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_BEFORE, ApiId, &SkipFunction);
    if (!SkipFunction)
       HipInterceptor.getSavedCompilerTable().__hipUnregisterFatBinary_fn(Args.__hipUnregisterFatBinary.modules);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_AFTER, ApiId, &SkipFunction);
    
  }
  else {
    return HipInterceptor.getSavedCompilerTable().__hipUnregisterFatBinary_fn(modules);
  }
}


void luthier::hip::CompilerInterceptor::captureCompilerDispatchTable(HipCompilerDispatchTable *CompilerTable) {
	SavedCompilerDispatchTable = *CompilerTable;
};


static void toggle___hipPopCallConfiguration(HipCompilerDispatchTable *InternalHipApiTable, HipCompilerDispatchTable SavedTable, bool On) {
  if (On)
    InternalHipApiTable->__hipPopCallConfiguration_fn = __hipPopCallConfiguration_callback;
  else
    InternalHipApiTable->__hipPopCallConfiguration_fn = SavedTable.__hipPopCallConfiguration_fn;
}

static void toggle___hipPushCallConfiguration(HipCompilerDispatchTable *InternalHipApiTable, HipCompilerDispatchTable SavedTable, bool On) {
  if (On)
    InternalHipApiTable->__hipPushCallConfiguration_fn = __hipPushCallConfiguration_callback;
  else
    InternalHipApiTable->__hipPushCallConfiguration_fn = SavedTable.__hipPushCallConfiguration_fn;
}

static void toggle___hipRegisterFatBinary(HipCompilerDispatchTable *InternalHipApiTable, HipCompilerDispatchTable SavedTable, bool On) {
  if (On)
    InternalHipApiTable->__hipRegisterFatBinary_fn = __hipRegisterFatBinary_callback;
  else
    InternalHipApiTable->__hipRegisterFatBinary_fn = SavedTable.__hipRegisterFatBinary_fn;
}

static void toggle___hipRegisterFunction(HipCompilerDispatchTable *InternalHipApiTable, HipCompilerDispatchTable SavedTable, bool On) {
  if (On)
    InternalHipApiTable->__hipRegisterFunction_fn = __hipRegisterFunction_callback;
  else
    InternalHipApiTable->__hipRegisterFunction_fn = SavedTable.__hipRegisterFunction_fn;
}

static void toggle___hipRegisterManagedVar(HipCompilerDispatchTable *InternalHipApiTable, HipCompilerDispatchTable SavedTable, bool On) {
  if (On)
    InternalHipApiTable->__hipRegisterManagedVar_fn = __hipRegisterManagedVar_callback;
  else
    InternalHipApiTable->__hipRegisterManagedVar_fn = SavedTable.__hipRegisterManagedVar_fn;
}

static void toggle___hipRegisterSurface(HipCompilerDispatchTable *InternalHipApiTable, HipCompilerDispatchTable SavedTable, bool On) {
  if (On)
    InternalHipApiTable->__hipRegisterSurface_fn = __hipRegisterSurface_callback;
  else
    InternalHipApiTable->__hipRegisterSurface_fn = SavedTable.__hipRegisterSurface_fn;
}

static void toggle___hipRegisterTexture(HipCompilerDispatchTable *InternalHipApiTable, HipCompilerDispatchTable SavedTable, bool On) {
  if (On)
    InternalHipApiTable->__hipRegisterTexture_fn = __hipRegisterTexture_callback;
  else
    InternalHipApiTable->__hipRegisterTexture_fn = SavedTable.__hipRegisterTexture_fn;
}

static void toggle___hipRegisterVar(HipCompilerDispatchTable *InternalHipApiTable, HipCompilerDispatchTable SavedTable, bool On) {
  if (On)
    InternalHipApiTable->__hipRegisterVar_fn = __hipRegisterVar_callback;
  else
    InternalHipApiTable->__hipRegisterVar_fn = SavedTable.__hipRegisterVar_fn;
}

static void toggle___hipUnregisterFatBinary(HipCompilerDispatchTable *InternalHipApiTable, HipCompilerDispatchTable SavedTable, bool On) {
  if (On)
    InternalHipApiTable->__hipUnregisterFatBinary_fn = __hipUnregisterFatBinary_callback;
  else
    InternalHipApiTable->__hipUnregisterFatBinary_fn = SavedTable.__hipUnregisterFatBinary_fn;
}


static const llvm::DenseMap<rocprofiler_hip_compiler_api_id_t, std::function<void(HipCompilerDispatchTable *, const HipCompilerDispatchTable &, bool On)>> HipCompilerDispatchCallbackToggleFunctionsMap {
  { ROCPROFILER_HIP_COMPILER_API_ID___hipPopCallConfiguration, toggle___hipPopCallConfiguration },
  { ROCPROFILER_HIP_COMPILER_API_ID___hipPushCallConfiguration, toggle___hipPushCallConfiguration },
  { ROCPROFILER_HIP_COMPILER_API_ID___hipRegisterFatBinary, toggle___hipRegisterFatBinary },
  { ROCPROFILER_HIP_COMPILER_API_ID___hipRegisterFunction, toggle___hipRegisterFunction },
  { ROCPROFILER_HIP_COMPILER_API_ID___hipRegisterManagedVar, toggle___hipRegisterManagedVar },
  { ROCPROFILER_HIP_COMPILER_API_ID___hipRegisterSurface, toggle___hipRegisterSurface },
  { ROCPROFILER_HIP_COMPILER_API_ID___hipRegisterTexture, toggle___hipRegisterTexture },
  { ROCPROFILER_HIP_COMPILER_API_ID___hipRegisterVar, toggle___hipRegisterVar },
  { ROCPROFILER_HIP_COMPILER_API_ID___hipUnregisterFatBinary, toggle___hipUnregisterFatBinary },
};

void luthier::hip::CompilerInterceptor::enableUserCallback(rocprofiler_hip_compiler_api_id_t Op) {
  HipCompilerDispatchCallbackToggleFunctionsMap.at(Op)(InternalCompilerDispatchTable, SavedCompilerDispatchTable, true);
  EnabledUserOps.insert(Op);
}

void luthier::hip::CompilerInterceptor::disableUserCallback(rocprofiler_hip_compiler_api_id_t Op) {
  EnabledUserOps.erase(Op);
  if (!EnabledInternalOps.contains(Op))
    HipCompilerDispatchCallbackToggleFunctionsMap.at(Op)(InternalCompilerDispatchTable, SavedCompilerDispatchTable, false);
}

void luthier::hip::CompilerInterceptor::enableInternalCallback(rocprofiler_hip_compiler_api_id_t Op) {
  HipCompilerDispatchCallbackToggleFunctionsMap.at(Op)(InternalCompilerDispatchTable, SavedCompilerDispatchTable, true);
  EnabledInternalOps.insert(Op);
}

void luthier::hip::CompilerInterceptor::disableInternalCallback(rocprofiler_hip_compiler_api_id_t Op) {
  EnabledInternalOps.erase(Op);
  if (!EnabledUserOps.contains(Op))
    HipCompilerDispatchCallbackToggleFunctionsMap.at(Op)(InternalCompilerDispatchTable, SavedCompilerDispatchTable, false);
}

// NOLINTEND
