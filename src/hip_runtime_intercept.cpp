// NOLINTBEGIN
/* Generated by hip_intercept_gen.py. DO NOT EDIT! */
#include "hip_runtime_intercept.hpp"
#include "luthier/types.h"
#include <rocprofiler-sdk/hip/api_args.h>
#include <rocprofiler-sdk/hip/api_id.h>

static const char* hipApiName_callback(uint32_t id) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipApiName;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    const char* Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipApiName.id = id;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipApiName_fn(Args.hipApiName.id);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipApiName_fn(id);
  }
}

static hipError_t hipArray3DCreate_callback(hipArray_t* array, const HIP_ARRAY3D_DESCRIPTOR* pAllocateArray) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipArray3DCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipArray3DCreate.array = array;
    Args.hipArray3DCreate.pAllocateArray = pAllocateArray;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipArray3DCreate_fn(Args.hipArray3DCreate.array, Args.hipArray3DCreate.pAllocateArray);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipArray3DCreate_fn(array, pAllocateArray);
  }
}

static hipError_t hipArray3DGetDescriptor_callback(HIP_ARRAY3D_DESCRIPTOR* pArrayDescriptor, hipArray_t array) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipArray3DGetDescriptor;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipArray3DGetDescriptor.pArrayDescriptor = pArrayDescriptor;
    Args.hipArray3DGetDescriptor.array = array;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipArray3DGetDescriptor_fn(Args.hipArray3DGetDescriptor.pArrayDescriptor, Args.hipArray3DGetDescriptor.array);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipArray3DGetDescriptor_fn(pArrayDescriptor, array);
  }
}

static hipError_t hipArrayCreate_callback(hipArray_t* pHandle, const HIP_ARRAY_DESCRIPTOR* pAllocateArray) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipArrayCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipArrayCreate.pHandle = pHandle;
    Args.hipArrayCreate.pAllocateArray = pAllocateArray;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipArrayCreate_fn(Args.hipArrayCreate.pHandle, Args.hipArrayCreate.pAllocateArray);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipArrayCreate_fn(pHandle, pAllocateArray);
  }
}

static hipError_t hipArrayDestroy_callback(hipArray_t array) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipArrayDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipArrayDestroy.array = array;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipArrayDestroy_fn(Args.hipArrayDestroy.array);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipArrayDestroy_fn(array);
  }
}

static hipError_t hipArrayGetDescriptor_callback(HIP_ARRAY_DESCRIPTOR* pArrayDescriptor, hipArray_t array) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipArrayGetDescriptor;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipArrayGetDescriptor.pArrayDescriptor = pArrayDescriptor;
    Args.hipArrayGetDescriptor.array = array;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipArrayGetDescriptor_fn(Args.hipArrayGetDescriptor.pArrayDescriptor, Args.hipArrayGetDescriptor.array);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipArrayGetDescriptor_fn(pArrayDescriptor, array);
  }
}

static hipError_t hipArrayGetInfo_callback(hipChannelFormatDesc* desc, hipExtent* extent, unsigned int* flags, hipArray_t array) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipArrayGetInfo;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipArrayGetInfo.desc = desc;
    Args.hipArrayGetInfo.extent = extent;
    Args.hipArrayGetInfo.flags = flags;
    Args.hipArrayGetInfo.array = array;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipArrayGetInfo_fn(Args.hipArrayGetInfo.desc, Args.hipArrayGetInfo.extent, Args.hipArrayGetInfo.flags, Args.hipArrayGetInfo.array);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipArrayGetInfo_fn(desc, extent, flags, array);
  }
}

static hipError_t hipBindTexture_callback(size_t* offset, const textureReference* tex, const void* devPtr, const hipChannelFormatDesc* desc, size_t size) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipBindTexture;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipBindTexture.offset = offset;
    Args.hipBindTexture.tex = tex;
    Args.hipBindTexture.devPtr = devPtr;
    Args.hipBindTexture.desc = desc;
    Args.hipBindTexture.size = size;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipBindTexture_fn(Args.hipBindTexture.offset, Args.hipBindTexture.tex, Args.hipBindTexture.devPtr, Args.hipBindTexture.desc, Args.hipBindTexture.size);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipBindTexture_fn(offset, tex, devPtr, desc, size);
  }
}

static hipError_t hipBindTexture2D_callback(size_t* offset, const textureReference* tex, const void* devPtr, const hipChannelFormatDesc* desc, size_t width, size_t height, size_t pitch) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipBindTexture2D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipBindTexture2D.offset = offset;
    Args.hipBindTexture2D.tex = tex;
    Args.hipBindTexture2D.devPtr = devPtr;
    Args.hipBindTexture2D.desc = desc;
    Args.hipBindTexture2D.width = width;
    Args.hipBindTexture2D.height = height;
    Args.hipBindTexture2D.pitch = pitch;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipBindTexture2D_fn(Args.hipBindTexture2D.offset, Args.hipBindTexture2D.tex, Args.hipBindTexture2D.devPtr, Args.hipBindTexture2D.desc, Args.hipBindTexture2D.width, Args.hipBindTexture2D.height, Args.hipBindTexture2D.pitch);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipBindTexture2D_fn(offset, tex, devPtr, desc, width, height, pitch);
  }
}

static hipError_t hipBindTextureToArray_callback(const textureReference* tex, hipArray_const_t array, const hipChannelFormatDesc* desc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipBindTextureToArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipBindTextureToArray.tex = tex;
    Args.hipBindTextureToArray.array = array;
    Args.hipBindTextureToArray.desc = desc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipBindTextureToArray_fn(Args.hipBindTextureToArray.tex, Args.hipBindTextureToArray.array, Args.hipBindTextureToArray.desc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipBindTextureToArray_fn(tex, array, desc);
  }
}

static hipError_t hipBindTextureToMipmappedArray_callback(const textureReference* tex, hipMipmappedArray_const_t mipmappedArray, const hipChannelFormatDesc* desc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipBindTextureToMipmappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipBindTextureToMipmappedArray.tex = tex;
    Args.hipBindTextureToMipmappedArray.mipmappedArray = mipmappedArray;
    Args.hipBindTextureToMipmappedArray.desc = desc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipBindTextureToMipmappedArray_fn(Args.hipBindTextureToMipmappedArray.tex, Args.hipBindTextureToMipmappedArray.mipmappedArray, Args.hipBindTextureToMipmappedArray.desc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipBindTextureToMipmappedArray_fn(tex, mipmappedArray, desc);
  }
}

static hipError_t hipChooseDevice_callback(int* device, const hipDeviceProp_t* prop) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipChooseDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipChooseDevice.device = device;
    Args.hipChooseDevice.prop = prop;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipChooseDevice_fn(Args.hipChooseDevice.device, Args.hipChooseDevice.prop);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipChooseDevice_fn(device, prop);
  }
}

static hipError_t hipChooseDeviceR0000_callback(int* device, const hipDeviceProp_tR0000* properties) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipChooseDeviceR0000;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipChooseDeviceR0000.device = device;
    Args.hipChooseDeviceR0000.properties = properties;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipChooseDeviceR0000_fn(Args.hipChooseDeviceR0000.device, Args.hipChooseDeviceR0000.properties);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipChooseDeviceR0000_fn(device, properties);
  }
}

static hipError_t hipConfigureCall_callback(dim3 gridDim, dim3 blockDim, size_t sharedMem, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipConfigureCall;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipConfigureCall.gridDim = gridDim;
    Args.hipConfigureCall.blockDim = blockDim;
    Args.hipConfigureCall.sharedMem = sharedMem;
    Args.hipConfigureCall.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipConfigureCall_fn(Args.hipConfigureCall.gridDim, Args.hipConfigureCall.blockDim, Args.hipConfigureCall.sharedMem, Args.hipConfigureCall.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipConfigureCall_fn(gridDim, blockDim, sharedMem, stream);
  }
}

static hipError_t hipCreateSurfaceObject_callback(hipSurfaceObject_t* pSurfObject, const hipResourceDesc* pResDesc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCreateSurfaceObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCreateSurfaceObject.pSurfObject = pSurfObject;
    Args.hipCreateSurfaceObject.pResDesc = pResDesc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCreateSurfaceObject_fn(Args.hipCreateSurfaceObject.pSurfObject, Args.hipCreateSurfaceObject.pResDesc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCreateSurfaceObject_fn(pSurfObject, pResDesc);
  }
}

static hipError_t hipCreateTextureObject_callback(hipTextureObject_t* pTexObject, const hipResourceDesc* pResDesc, const hipTextureDesc* pTexDesc, const struct hipResourceViewDesc* pResViewDesc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCreateTextureObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCreateTextureObject.pTexObject = pTexObject;
    Args.hipCreateTextureObject.pResDesc = pResDesc;
    Args.hipCreateTextureObject.pTexDesc = pTexDesc;
    Args.hipCreateTextureObject.pResViewDesc = pResViewDesc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCreateTextureObject_fn(Args.hipCreateTextureObject.pTexObject, Args.hipCreateTextureObject.pResDesc, Args.hipCreateTextureObject.pTexDesc, Args.hipCreateTextureObject.pResViewDesc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCreateTextureObject_fn(pTexObject, pResDesc, pTexDesc, pResViewDesc);
  }
}

static hipError_t hipCtxCreate_callback(hipCtx_t* ctx, unsigned int flags, hipDevice_t device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxCreate.ctx = ctx;
    Args.hipCtxCreate.flags = flags;
    Args.hipCtxCreate.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxCreate_fn(Args.hipCtxCreate.ctx, Args.hipCtxCreate.flags, Args.hipCtxCreate.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxCreate_fn(ctx, flags, device);
  }
}

static hipError_t hipCtxDestroy_callback(hipCtx_t ctx) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxDestroy.ctx = ctx;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxDestroy_fn(Args.hipCtxDestroy.ctx);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxDestroy_fn(ctx);
  }
}

static hipError_t hipCtxDisablePeerAccess_callback(hipCtx_t peerCtx) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxDisablePeerAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxDisablePeerAccess.peerCtx = peerCtx;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxDisablePeerAccess_fn(Args.hipCtxDisablePeerAccess.peerCtx);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxDisablePeerAccess_fn(peerCtx);
  }
}

static hipError_t hipCtxEnablePeerAccess_callback(hipCtx_t peerCtx, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxEnablePeerAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxEnablePeerAccess.peerCtx = peerCtx;
    Args.hipCtxEnablePeerAccess.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxEnablePeerAccess_fn(Args.hipCtxEnablePeerAccess.peerCtx, Args.hipCtxEnablePeerAccess.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxEnablePeerAccess_fn(peerCtx, flags);
  }
}

static hipError_t hipCtxGetApiVersion_callback(hipCtx_t ctx, int* apiVersion) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetApiVersion;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxGetApiVersion.ctx = ctx;
    Args.hipCtxGetApiVersion.apiVersion = apiVersion;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxGetApiVersion_fn(Args.hipCtxGetApiVersion.ctx, Args.hipCtxGetApiVersion.apiVersion);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxGetApiVersion_fn(ctx, apiVersion);
  }
}

static hipError_t hipCtxGetCacheConfig_callback(hipFuncCache_t* cacheConfig) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetCacheConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxGetCacheConfig.cacheConfig = cacheConfig;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxGetCacheConfig_fn(Args.hipCtxGetCacheConfig.cacheConfig);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxGetCacheConfig_fn(cacheConfig);
  }
}

static hipError_t hipCtxGetCurrent_callback(hipCtx_t* ctx) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetCurrent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxGetCurrent.ctx = ctx;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxGetCurrent_fn(Args.hipCtxGetCurrent.ctx);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxGetCurrent_fn(ctx);
  }
}

static hipError_t hipCtxGetDevice_callback(hipDevice_t* device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxGetDevice.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxGetDevice_fn(Args.hipCtxGetDevice.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxGetDevice_fn(device);
  }
}

static hipError_t hipCtxGetFlags_callback(unsigned int* flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxGetFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxGetFlags_fn(Args.hipCtxGetFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxGetFlags_fn(flags);
  }
}

static hipError_t hipCtxGetSharedMemConfig_callback(hipSharedMemConfig* pConfig) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxGetSharedMemConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxGetSharedMemConfig.pConfig = pConfig;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxGetSharedMemConfig_fn(Args.hipCtxGetSharedMemConfig.pConfig);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxGetSharedMemConfig_fn(pConfig);
  }
}

static hipError_t hipCtxPopCurrent_callback(hipCtx_t* ctx) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxPopCurrent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxPopCurrent.ctx = ctx;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxPopCurrent_fn(Args.hipCtxPopCurrent.ctx);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxPopCurrent_fn(ctx);
  }
}

static hipError_t hipCtxPushCurrent_callback(hipCtx_t ctx) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxPushCurrent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxPushCurrent.ctx = ctx;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxPushCurrent_fn(Args.hipCtxPushCurrent.ctx);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxPushCurrent_fn(ctx);
  }
}

static hipError_t hipCtxSetCacheConfig_callback(hipFuncCache_t cacheConfig) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxSetCacheConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxSetCacheConfig.cacheConfig = cacheConfig;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxSetCacheConfig_fn(Args.hipCtxSetCacheConfig.cacheConfig);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxSetCacheConfig_fn(cacheConfig);
  }
}

static hipError_t hipCtxSetCurrent_callback(hipCtx_t ctx) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxSetCurrent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxSetCurrent.ctx = ctx;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxSetCurrent_fn(Args.hipCtxSetCurrent.ctx);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxSetCurrent_fn(ctx);
  }
}

static hipError_t hipCtxSetSharedMemConfig_callback(hipSharedMemConfig config) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxSetSharedMemConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCtxSetSharedMemConfig.config = config;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxSetSharedMemConfig_fn(Args.hipCtxSetSharedMemConfig.config);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxSetSharedMemConfig_fn(config);
  }
}

static hipError_t hipCtxSynchronize_callback() {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCtxSynchronize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCtxSynchronize_fn();
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCtxSynchronize_fn();
  }
}

static hipError_t hipDestroyExternalMemory_callback(hipExternalMemory_t extMem) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDestroyExternalMemory;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDestroyExternalMemory.extMem = extMem;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDestroyExternalMemory_fn(Args.hipDestroyExternalMemory.extMem);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDestroyExternalMemory_fn(extMem);
  }
}

static hipError_t hipDestroyExternalSemaphore_callback(hipExternalSemaphore_t extSem) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDestroyExternalSemaphore;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDestroyExternalSemaphore.extSem = extSem;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDestroyExternalSemaphore_fn(Args.hipDestroyExternalSemaphore.extSem);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDestroyExternalSemaphore_fn(extSem);
  }
}

static hipError_t hipDestroySurfaceObject_callback(hipSurfaceObject_t surfaceObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDestroySurfaceObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDestroySurfaceObject.surfaceObject = surfaceObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDestroySurfaceObject_fn(Args.hipDestroySurfaceObject.surfaceObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDestroySurfaceObject_fn(surfaceObject);
  }
}

static hipError_t hipDestroyTextureObject_callback(hipTextureObject_t textureObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDestroyTextureObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDestroyTextureObject.textureObject = textureObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDestroyTextureObject_fn(Args.hipDestroyTextureObject.textureObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDestroyTextureObject_fn(textureObject);
  }
}

static hipError_t hipDeviceCanAccessPeer_callback(int* canAccessPeer, int deviceId, int peerDeviceId) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceCanAccessPeer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceCanAccessPeer.canAccessPeer = canAccessPeer;
    Args.hipDeviceCanAccessPeer.deviceId = deviceId;
    Args.hipDeviceCanAccessPeer.peerDeviceId = peerDeviceId;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceCanAccessPeer_fn(Args.hipDeviceCanAccessPeer.canAccessPeer, Args.hipDeviceCanAccessPeer.deviceId, Args.hipDeviceCanAccessPeer.peerDeviceId);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceCanAccessPeer_fn(canAccessPeer, deviceId, peerDeviceId);
  }
}

static hipError_t hipDeviceComputeCapability_callback(int* major, int* minor, hipDevice_t device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceComputeCapability;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceComputeCapability.major = major;
    Args.hipDeviceComputeCapability.minor = minor;
    Args.hipDeviceComputeCapability.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceComputeCapability_fn(Args.hipDeviceComputeCapability.major, Args.hipDeviceComputeCapability.minor, Args.hipDeviceComputeCapability.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceComputeCapability_fn(major, minor, device);
  }
}

static hipError_t hipDeviceDisablePeerAccess_callback(int peerDeviceId) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceDisablePeerAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceDisablePeerAccess.peerDeviceId = peerDeviceId;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceDisablePeerAccess_fn(Args.hipDeviceDisablePeerAccess.peerDeviceId);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceDisablePeerAccess_fn(peerDeviceId);
  }
}

static hipError_t hipDeviceEnablePeerAccess_callback(int peerDeviceId, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceEnablePeerAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceEnablePeerAccess.peerDeviceId = peerDeviceId;
    Args.hipDeviceEnablePeerAccess.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceEnablePeerAccess_fn(Args.hipDeviceEnablePeerAccess.peerDeviceId, Args.hipDeviceEnablePeerAccess.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceEnablePeerAccess_fn(peerDeviceId, flags);
  }
}

static hipError_t hipDeviceGet_callback(hipDevice_t* device, int ordinal) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGet;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGet.device = device;
    Args.hipDeviceGet.ordinal = ordinal;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGet_fn(Args.hipDeviceGet.device, Args.hipDeviceGet.ordinal);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGet_fn(device, ordinal);
  }
}

static hipError_t hipDeviceGetAttribute_callback(int* pi, hipDeviceAttribute_t attr, int deviceId) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetAttribute.pi = pi;
    Args.hipDeviceGetAttribute.attr = attr;
    Args.hipDeviceGetAttribute.deviceId = deviceId;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetAttribute_fn(Args.hipDeviceGetAttribute.pi, Args.hipDeviceGetAttribute.attr, Args.hipDeviceGetAttribute.deviceId);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetAttribute_fn(pi, attr, deviceId);
  }
}

static hipError_t hipDeviceGetByPCIBusId_callback(int* device, const char* pciBusId) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetByPCIBusId;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetByPCIBusId.device = device;
    Args.hipDeviceGetByPCIBusId.pciBusId = pciBusId;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetByPCIBusId_fn(Args.hipDeviceGetByPCIBusId.device, Args.hipDeviceGetByPCIBusId.pciBusId);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetByPCIBusId_fn(device, pciBusId);
  }
}

static hipError_t hipDeviceGetCacheConfig_callback(hipFuncCache_t* cacheConfig) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetCacheConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetCacheConfig.cacheConfig = cacheConfig;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetCacheConfig_fn(Args.hipDeviceGetCacheConfig.cacheConfig);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetCacheConfig_fn(cacheConfig);
  }
}

static hipError_t hipDeviceGetDefaultMemPool_callback(hipMemPool_t* mem_pool, int device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetDefaultMemPool;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetDefaultMemPool.mem_pool = mem_pool;
    Args.hipDeviceGetDefaultMemPool.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetDefaultMemPool_fn(Args.hipDeviceGetDefaultMemPool.mem_pool, Args.hipDeviceGetDefaultMemPool.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetDefaultMemPool_fn(mem_pool, device);
  }
}

static hipError_t hipDeviceGetGraphMemAttribute_callback(int device, hipGraphMemAttributeType attr, void* value) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetGraphMemAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetGraphMemAttribute.device = device;
    Args.hipDeviceGetGraphMemAttribute.attr = attr;
    Args.hipDeviceGetGraphMemAttribute.value = value;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetGraphMemAttribute_fn(Args.hipDeviceGetGraphMemAttribute.device, Args.hipDeviceGetGraphMemAttribute.attr, Args.hipDeviceGetGraphMemAttribute.value);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetGraphMemAttribute_fn(device, attr, value);
  }
}

static hipError_t hipDeviceGetLimit_callback(size_t* pValue, enum hipLimit_t limit) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetLimit;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetLimit.pValue = pValue;
    Args.hipDeviceGetLimit.limit = limit;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetLimit_fn(Args.hipDeviceGetLimit.pValue, Args.hipDeviceGetLimit.limit);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetLimit_fn(pValue, limit);
  }
}

static hipError_t hipDeviceGetMemPool_callback(hipMemPool_t* mem_pool, int device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetMemPool;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetMemPool.mem_pool = mem_pool;
    Args.hipDeviceGetMemPool.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetMemPool_fn(Args.hipDeviceGetMemPool.mem_pool, Args.hipDeviceGetMemPool.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetMemPool_fn(mem_pool, device);
  }
}

static hipError_t hipDeviceGetName_callback(char* name, int len, hipDevice_t device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetName;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetName.name = name;
    Args.hipDeviceGetName.len = len;
    Args.hipDeviceGetName.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetName_fn(Args.hipDeviceGetName.name, Args.hipDeviceGetName.len, Args.hipDeviceGetName.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetName_fn(name, len, device);
  }
}

static hipError_t hipDeviceGetP2PAttribute_callback(int* value, hipDeviceP2PAttr attr, int srcDevice, int dstDevice) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetP2PAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetP2PAttribute.value = value;
    Args.hipDeviceGetP2PAttribute.attr = attr;
    Args.hipDeviceGetP2PAttribute.srcDevice = srcDevice;
    Args.hipDeviceGetP2PAttribute.dstDevice = dstDevice;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetP2PAttribute_fn(Args.hipDeviceGetP2PAttribute.value, Args.hipDeviceGetP2PAttribute.attr, Args.hipDeviceGetP2PAttribute.srcDevice, Args.hipDeviceGetP2PAttribute.dstDevice);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetP2PAttribute_fn(value, attr, srcDevice, dstDevice);
  }
}

static hipError_t hipDeviceGetPCIBusId_callback(char* pciBusId, int len, int device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetPCIBusId;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetPCIBusId.pciBusId = pciBusId;
    Args.hipDeviceGetPCIBusId.len = len;
    Args.hipDeviceGetPCIBusId.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetPCIBusId_fn(Args.hipDeviceGetPCIBusId.pciBusId, Args.hipDeviceGetPCIBusId.len, Args.hipDeviceGetPCIBusId.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetPCIBusId_fn(pciBusId, len, device);
  }
}

static hipError_t hipDeviceGetSharedMemConfig_callback(hipSharedMemConfig* pConfig) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetSharedMemConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetSharedMemConfig.pConfig = pConfig;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetSharedMemConfig_fn(Args.hipDeviceGetSharedMemConfig.pConfig);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetSharedMemConfig_fn(pConfig);
  }
}

static hipError_t hipDeviceGetStreamPriorityRange_callback(int* leastPriority, int* greatestPriority) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetStreamPriorityRange;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetStreamPriorityRange.leastPriority = leastPriority;
    Args.hipDeviceGetStreamPriorityRange.greatestPriority = greatestPriority;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetStreamPriorityRange_fn(Args.hipDeviceGetStreamPriorityRange.leastPriority, Args.hipDeviceGetStreamPriorityRange.greatestPriority);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetStreamPriorityRange_fn(leastPriority, greatestPriority);
  }
}

static hipError_t hipDeviceGetUuid_callback(hipUUID* uuid, hipDevice_t device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGetUuid;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGetUuid.uuid = uuid;
    Args.hipDeviceGetUuid.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGetUuid_fn(Args.hipDeviceGetUuid.uuid, Args.hipDeviceGetUuid.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGetUuid_fn(uuid, device);
  }
}

static hipError_t hipDeviceGraphMemTrim_callback(int device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceGraphMemTrim;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceGraphMemTrim.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceGraphMemTrim_fn(Args.hipDeviceGraphMemTrim.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceGraphMemTrim_fn(device);
  }
}

static hipError_t hipDevicePrimaryCtxGetState_callback(hipDevice_t dev, unsigned int* flags, int* active) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDevicePrimaryCtxGetState;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDevicePrimaryCtxGetState.dev = dev;
    Args.hipDevicePrimaryCtxGetState.flags = flags;
    Args.hipDevicePrimaryCtxGetState.active = active;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxGetState_fn(Args.hipDevicePrimaryCtxGetState.dev, Args.hipDevicePrimaryCtxGetState.flags, Args.hipDevicePrimaryCtxGetState.active);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxGetState_fn(dev, flags, active);
  }
}

static hipError_t hipDevicePrimaryCtxRelease_callback(hipDevice_t dev) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDevicePrimaryCtxRelease;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDevicePrimaryCtxRelease.dev = dev;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxRelease_fn(Args.hipDevicePrimaryCtxRelease.dev);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxRelease_fn(dev);
  }
}

static hipError_t hipDevicePrimaryCtxReset_callback(hipDevice_t dev) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDevicePrimaryCtxReset;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDevicePrimaryCtxReset.dev = dev;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxReset_fn(Args.hipDevicePrimaryCtxReset.dev);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxReset_fn(dev);
  }
}

static hipError_t hipDevicePrimaryCtxRetain_callback(hipCtx_t* pctx, hipDevice_t dev) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDevicePrimaryCtxRetain;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDevicePrimaryCtxRetain.pctx = pctx;
    Args.hipDevicePrimaryCtxRetain.dev = dev;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxRetain_fn(Args.hipDevicePrimaryCtxRetain.pctx, Args.hipDevicePrimaryCtxRetain.dev);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxRetain_fn(pctx, dev);
  }
}

static hipError_t hipDevicePrimaryCtxSetFlags_callback(hipDevice_t dev, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDevicePrimaryCtxSetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDevicePrimaryCtxSetFlags.dev = dev;
    Args.hipDevicePrimaryCtxSetFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxSetFlags_fn(Args.hipDevicePrimaryCtxSetFlags.dev, Args.hipDevicePrimaryCtxSetFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDevicePrimaryCtxSetFlags_fn(dev, flags);
  }
}

static hipError_t hipDeviceReset_callback() {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceReset;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceReset_fn();
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceReset_fn();
  }
}

static hipError_t hipDeviceSetCacheConfig_callback(hipFuncCache_t cacheConfig) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSetCacheConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceSetCacheConfig.cacheConfig = cacheConfig;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceSetCacheConfig_fn(Args.hipDeviceSetCacheConfig.cacheConfig);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceSetCacheConfig_fn(cacheConfig);
  }
}

static hipError_t hipDeviceSetGraphMemAttribute_callback(int device, hipGraphMemAttributeType attr, void* value) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSetGraphMemAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceSetGraphMemAttribute.device = device;
    Args.hipDeviceSetGraphMemAttribute.attr = attr;
    Args.hipDeviceSetGraphMemAttribute.value = value;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceSetGraphMemAttribute_fn(Args.hipDeviceSetGraphMemAttribute.device, Args.hipDeviceSetGraphMemAttribute.attr, Args.hipDeviceSetGraphMemAttribute.value);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceSetGraphMemAttribute_fn(device, attr, value);
  }
}

static hipError_t hipDeviceSetLimit_callback(enum hipLimit_t limit, size_t value) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSetLimit;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceSetLimit.limit = limit;
    Args.hipDeviceSetLimit.value = value;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceSetLimit_fn(Args.hipDeviceSetLimit.limit, Args.hipDeviceSetLimit.value);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceSetLimit_fn(limit, value);
  }
}

static hipError_t hipDeviceSetMemPool_callback(int device, hipMemPool_t mem_pool) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSetMemPool;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceSetMemPool.device = device;
    Args.hipDeviceSetMemPool.mem_pool = mem_pool;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceSetMemPool_fn(Args.hipDeviceSetMemPool.device, Args.hipDeviceSetMemPool.mem_pool);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceSetMemPool_fn(device, mem_pool);
  }
}

static hipError_t hipDeviceSetSharedMemConfig_callback(hipSharedMemConfig config) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSetSharedMemConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceSetSharedMemConfig.config = config;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceSetSharedMemConfig_fn(Args.hipDeviceSetSharedMemConfig.config);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceSetSharedMemConfig_fn(config);
  }
}

static hipError_t hipDeviceSynchronize_callback() {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceSynchronize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceSynchronize_fn();
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceSynchronize_fn();
  }
}

static hipError_t hipDeviceTotalMem_callback(size_t* bytes, hipDevice_t device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDeviceTotalMem;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDeviceTotalMem.bytes = bytes;
    Args.hipDeviceTotalMem.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDeviceTotalMem_fn(Args.hipDeviceTotalMem.bytes, Args.hipDeviceTotalMem.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDeviceTotalMem_fn(bytes, device);
  }
}

static hipError_t hipDriverGetVersion_callback(int* driverVersion) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDriverGetVersion;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDriverGetVersion.driverVersion = driverVersion;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDriverGetVersion_fn(Args.hipDriverGetVersion.driverVersion);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDriverGetVersion_fn(driverVersion);
  }
}

static hipError_t hipDrvGetErrorName_callback(hipError_t hipError, const char** errorString) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvGetErrorName;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDrvGetErrorName.hipError = hipError;
    Args.hipDrvGetErrorName.errorString = errorString;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDrvGetErrorName_fn(Args.hipDrvGetErrorName.hipError, Args.hipDrvGetErrorName.errorString);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDrvGetErrorName_fn(hipError, errorString);
  }
}

static hipError_t hipDrvGetErrorString_callback(hipError_t hipError, const char** errorString) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvGetErrorString;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDrvGetErrorString.hipError = hipError;
    Args.hipDrvGetErrorString.errorString = errorString;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDrvGetErrorString_fn(Args.hipDrvGetErrorString.hipError, Args.hipDrvGetErrorString.errorString);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDrvGetErrorString_fn(hipError, errorString);
  }
}

static hipError_t hipDrvGraphAddMemcpyNode_callback(hipGraphNode_t* phGraphNode, hipGraph_t hGraph, const hipGraphNode_t* dependencies, size_t numDependencies, const HIP_MEMCPY3D* copyParams, hipCtx_t ctx) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvGraphAddMemcpyNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDrvGraphAddMemcpyNode.phGraphNode = phGraphNode;
    Args.hipDrvGraphAddMemcpyNode.hGraph = hGraph;
    Args.hipDrvGraphAddMemcpyNode.dependencies = dependencies;
    Args.hipDrvGraphAddMemcpyNode.numDependencies = numDependencies;
    Args.hipDrvGraphAddMemcpyNode.copyParams = copyParams;
    Args.hipDrvGraphAddMemcpyNode.ctx = ctx;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDrvGraphAddMemcpyNode_fn(Args.hipDrvGraphAddMemcpyNode.phGraphNode, Args.hipDrvGraphAddMemcpyNode.hGraph, Args.hipDrvGraphAddMemcpyNode.dependencies, Args.hipDrvGraphAddMemcpyNode.numDependencies, Args.hipDrvGraphAddMemcpyNode.copyParams, Args.hipDrvGraphAddMemcpyNode.ctx);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDrvGraphAddMemcpyNode_fn(phGraphNode, hGraph, dependencies, numDependencies, copyParams, ctx);
  }
}

static hipError_t hipDrvMemcpy2DUnaligned_callback(const hip_Memcpy2D* pCopy) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvMemcpy2DUnaligned;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDrvMemcpy2DUnaligned.pCopy = pCopy;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDrvMemcpy2DUnaligned_fn(Args.hipDrvMemcpy2DUnaligned.pCopy);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDrvMemcpy2DUnaligned_fn(pCopy);
  }
}

static hipError_t hipDrvMemcpy3D_callback(const HIP_MEMCPY3D* pCopy) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvMemcpy3D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDrvMemcpy3D.pCopy = pCopy;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDrvMemcpy3D_fn(Args.hipDrvMemcpy3D.pCopy);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDrvMemcpy3D_fn(pCopy);
  }
}

static hipError_t hipDrvMemcpy3DAsync_callback(const HIP_MEMCPY3D* pCopy, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvMemcpy3DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDrvMemcpy3DAsync.pCopy = pCopy;
    Args.hipDrvMemcpy3DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDrvMemcpy3DAsync_fn(Args.hipDrvMemcpy3DAsync.pCopy, Args.hipDrvMemcpy3DAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDrvMemcpy3DAsync_fn(pCopy, stream);
  }
}

static hipError_t hipDrvPointerGetAttributes_callback(unsigned int numAttributes, hipPointer_attribute* attributes, void** data, hipDeviceptr_t ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipDrvPointerGetAttributes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipDrvPointerGetAttributes.numAttributes = numAttributes;
    Args.hipDrvPointerGetAttributes.attributes = attributes;
    Args.hipDrvPointerGetAttributes.data = data;
    Args.hipDrvPointerGetAttributes.ptr = ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipDrvPointerGetAttributes_fn(Args.hipDrvPointerGetAttributes.numAttributes, Args.hipDrvPointerGetAttributes.attributes, Args.hipDrvPointerGetAttributes.data, Args.hipDrvPointerGetAttributes.ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipDrvPointerGetAttributes_fn(numAttributes, attributes, data, ptr);
  }
}

static hipError_t hipEventCreate_callback(hipEvent_t* event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipEventCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipEventCreate.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipEventCreate_fn(Args.hipEventCreate.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipEventCreate_fn(event);
  }
}

static hipError_t hipEventCreateWithFlags_callback(hipEvent_t* event, unsigned flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipEventCreateWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipEventCreateWithFlags.event = event;
    Args.hipEventCreateWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipEventCreateWithFlags_fn(Args.hipEventCreateWithFlags.event, Args.hipEventCreateWithFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipEventCreateWithFlags_fn(event, flags);
  }
}

static hipError_t hipEventDestroy_callback(hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipEventDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipEventDestroy.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipEventDestroy_fn(Args.hipEventDestroy.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipEventDestroy_fn(event);
  }
}

static hipError_t hipEventElapsedTime_callback(float* ms, hipEvent_t start, hipEvent_t stop) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipEventElapsedTime;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipEventElapsedTime.ms = ms;
    Args.hipEventElapsedTime.start = start;
    Args.hipEventElapsedTime.stop = stop;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipEventElapsedTime_fn(Args.hipEventElapsedTime.ms, Args.hipEventElapsedTime.start, Args.hipEventElapsedTime.stop);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipEventElapsedTime_fn(ms, start, stop);
  }
}

static hipError_t hipEventQuery_callback(hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipEventQuery;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipEventQuery.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipEventQuery_fn(Args.hipEventQuery.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipEventQuery_fn(event);
  }
}

static hipError_t hipEventRecord_callback(hipEvent_t event, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipEventRecord;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipEventRecord.event = event;
    Args.hipEventRecord.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipEventRecord_fn(Args.hipEventRecord.event, Args.hipEventRecord.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipEventRecord_fn(event, stream);
  }
}

static hipError_t hipEventSynchronize_callback(hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipEventSynchronize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipEventSynchronize.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipEventSynchronize_fn(Args.hipEventSynchronize.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipEventSynchronize_fn(event);
  }
}

static hipError_t hipExtGetLinkTypeAndHopCount_callback(int device1, int device2, uint32_t* linktype, uint32_t* hopcount) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipExtGetLinkTypeAndHopCount;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipExtGetLinkTypeAndHopCount.device1 = device1;
    Args.hipExtGetLinkTypeAndHopCount.device2 = device2;
    Args.hipExtGetLinkTypeAndHopCount.linktype = linktype;
    Args.hipExtGetLinkTypeAndHopCount.hopcount = hopcount;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipExtGetLinkTypeAndHopCount_fn(Args.hipExtGetLinkTypeAndHopCount.device1, Args.hipExtGetLinkTypeAndHopCount.device2, Args.hipExtGetLinkTypeAndHopCount.linktype, Args.hipExtGetLinkTypeAndHopCount.hopcount);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipExtGetLinkTypeAndHopCount_fn(device1, device2, linktype, hopcount);
  }
}

static hipError_t hipExtLaunchKernel_callback(const void* function_address, dim3 numBlocks, dim3 dimBlocks, void** args, size_t sharedMemBytes, hipStream_t stream, hipEvent_t startEvent, hipEvent_t stopEvent, int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipExtLaunchKernel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipExtLaunchKernel.function_address = function_address;
    Args.hipExtLaunchKernel.numBlocks = numBlocks;
    Args.hipExtLaunchKernel.dimBlocks = dimBlocks;
    Args.hipExtLaunchKernel.args = args;
    Args.hipExtLaunchKernel.sharedMemBytes = sharedMemBytes;
    Args.hipExtLaunchKernel.stream = stream;
    Args.hipExtLaunchKernel.startEvent = startEvent;
    Args.hipExtLaunchKernel.stopEvent = stopEvent;
    Args.hipExtLaunchKernel.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipExtLaunchKernel_fn(Args.hipExtLaunchKernel.function_address, Args.hipExtLaunchKernel.numBlocks, Args.hipExtLaunchKernel.dimBlocks, Args.hipExtLaunchKernel.args, Args.hipExtLaunchKernel.sharedMemBytes, Args.hipExtLaunchKernel.stream, Args.hipExtLaunchKernel.startEvent, Args.hipExtLaunchKernel.stopEvent, Args.hipExtLaunchKernel.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipExtLaunchKernel_fn(function_address, numBlocks, dimBlocks, args, sharedMemBytes, stream, startEvent, stopEvent, flags);
  }
}

static hipError_t hipExtLaunchMultiKernelMultiDevice_callback(hipLaunchParams* launchParamsList, int numDevices, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipExtLaunchMultiKernelMultiDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipExtLaunchMultiKernelMultiDevice.launchParamsList = launchParamsList;
    Args.hipExtLaunchMultiKernelMultiDevice.numDevices = numDevices;
    Args.hipExtLaunchMultiKernelMultiDevice.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipExtLaunchMultiKernelMultiDevice_fn(Args.hipExtLaunchMultiKernelMultiDevice.launchParamsList, Args.hipExtLaunchMultiKernelMultiDevice.numDevices, Args.hipExtLaunchMultiKernelMultiDevice.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipExtLaunchMultiKernelMultiDevice_fn(launchParamsList, numDevices, flags);
  }
}

static hipError_t hipExtMallocWithFlags_callback(void** ptr, size_t sizeBytes, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipExtMallocWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipExtMallocWithFlags.ptr = ptr;
    Args.hipExtMallocWithFlags.sizeBytes = sizeBytes;
    Args.hipExtMallocWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipExtMallocWithFlags_fn(Args.hipExtMallocWithFlags.ptr, Args.hipExtMallocWithFlags.sizeBytes, Args.hipExtMallocWithFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipExtMallocWithFlags_fn(ptr, sizeBytes, flags);
  }
}

static hipError_t hipExtStreamCreateWithCUMask_callback(hipStream_t* stream, uint32_t cuMaskSize, const uint32_t* cuMask) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipExtStreamCreateWithCUMask;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipExtStreamCreateWithCUMask.stream = stream;
    Args.hipExtStreamCreateWithCUMask.cuMaskSize = cuMaskSize;
    Args.hipExtStreamCreateWithCUMask.cuMask = cuMask;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipExtStreamCreateWithCUMask_fn(Args.hipExtStreamCreateWithCUMask.stream, Args.hipExtStreamCreateWithCUMask.cuMaskSize, Args.hipExtStreamCreateWithCUMask.cuMask);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipExtStreamCreateWithCUMask_fn(stream, cuMaskSize, cuMask);
  }
}

static hipError_t hipExtStreamGetCUMask_callback(hipStream_t stream, uint32_t cuMaskSize, uint32_t* cuMask) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipExtStreamGetCUMask;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipExtStreamGetCUMask.stream = stream;
    Args.hipExtStreamGetCUMask.cuMaskSize = cuMaskSize;
    Args.hipExtStreamGetCUMask.cuMask = cuMask;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipExtStreamGetCUMask_fn(Args.hipExtStreamGetCUMask.stream, Args.hipExtStreamGetCUMask.cuMaskSize, Args.hipExtStreamGetCUMask.cuMask);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipExtStreamGetCUMask_fn(stream, cuMaskSize, cuMask);
  }
}

static hipError_t hipExternalMemoryGetMappedBuffer_callback(void** devPtr, hipExternalMemory_t extMem, const hipExternalMemoryBufferDesc* bufferDesc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipExternalMemoryGetMappedBuffer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipExternalMemoryGetMappedBuffer.devPtr = devPtr;
    Args.hipExternalMemoryGetMappedBuffer.extMem = extMem;
    Args.hipExternalMemoryGetMappedBuffer.bufferDesc = bufferDesc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipExternalMemoryGetMappedBuffer_fn(Args.hipExternalMemoryGetMappedBuffer.devPtr, Args.hipExternalMemoryGetMappedBuffer.extMem, Args.hipExternalMemoryGetMappedBuffer.bufferDesc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipExternalMemoryGetMappedBuffer_fn(devPtr, extMem, bufferDesc);
  }
}

static hipError_t hipFree_callback(void* ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFree;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFree.ptr = ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFree_fn(Args.hipFree.ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFree_fn(ptr);
  }
}

static hipError_t hipFreeArray_callback(hipArray_t array) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFreeArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFreeArray.array = array;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFreeArray_fn(Args.hipFreeArray.array);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFreeArray_fn(array);
  }
}

static hipError_t hipFreeAsync_callback(void* dev_ptr, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFreeAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFreeAsync.dev_ptr = dev_ptr;
    Args.hipFreeAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFreeAsync_fn(Args.hipFreeAsync.dev_ptr, Args.hipFreeAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFreeAsync_fn(dev_ptr, stream);
  }
}

static hipError_t hipFreeHost_callback(void* ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFreeHost;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFreeHost.ptr = ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFreeHost_fn(Args.hipFreeHost.ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFreeHost_fn(ptr);
  }
}

static hipError_t hipFreeMipmappedArray_callback(hipMipmappedArray_t mipmappedArray) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFreeMipmappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFreeMipmappedArray.mipmappedArray = mipmappedArray;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFreeMipmappedArray_fn(Args.hipFreeMipmappedArray.mipmappedArray);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFreeMipmappedArray_fn(mipmappedArray);
  }
}

static hipError_t hipFuncGetAttribute_callback(int* value, hipFunction_attribute attrib, hipFunction_t hfunc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFuncGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFuncGetAttribute.value = value;
    Args.hipFuncGetAttribute.attrib = attrib;
    Args.hipFuncGetAttribute.hfunc = hfunc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFuncGetAttribute_fn(Args.hipFuncGetAttribute.value, Args.hipFuncGetAttribute.attrib, Args.hipFuncGetAttribute.hfunc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFuncGetAttribute_fn(value, attrib, hfunc);
  }
}

static hipError_t hipFuncGetAttributes_callback(struct hipFuncAttributes* attr, const void* func) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFuncGetAttributes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFuncGetAttributes.attr = attr;
    Args.hipFuncGetAttributes.func = func;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFuncGetAttributes_fn(Args.hipFuncGetAttributes.attr, Args.hipFuncGetAttributes.func);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFuncGetAttributes_fn(attr, func);
  }
}

static hipError_t hipFuncSetAttribute_callback(const void* func, hipFuncAttribute attr, int value) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFuncSetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFuncSetAttribute.func = func;
    Args.hipFuncSetAttribute.attr = attr;
    Args.hipFuncSetAttribute.value = value;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFuncSetAttribute_fn(Args.hipFuncSetAttribute.func, Args.hipFuncSetAttribute.attr, Args.hipFuncSetAttribute.value);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFuncSetAttribute_fn(func, attr, value);
  }
}

static hipError_t hipFuncSetCacheConfig_callback(const void* func, hipFuncCache_t config) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFuncSetCacheConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFuncSetCacheConfig.func = func;
    Args.hipFuncSetCacheConfig.config = config;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFuncSetCacheConfig_fn(Args.hipFuncSetCacheConfig.func, Args.hipFuncSetCacheConfig.config);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFuncSetCacheConfig_fn(func, config);
  }
}

static hipError_t hipFuncSetSharedMemConfig_callback(const void* func, hipSharedMemConfig config) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipFuncSetSharedMemConfig;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipFuncSetSharedMemConfig.func = func;
    Args.hipFuncSetSharedMemConfig.config = config;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipFuncSetSharedMemConfig_fn(Args.hipFuncSetSharedMemConfig.func, Args.hipFuncSetSharedMemConfig.config);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipFuncSetSharedMemConfig_fn(func, config);
  }
}

static hipError_t hipGLGetDevices_callback(unsigned int* pHipDeviceCount, int* pHipDevices, unsigned int hipDeviceCount, hipGLDeviceList deviceList) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGLGetDevices;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGLGetDevices.pHipDeviceCount = pHipDeviceCount;
    Args.hipGLGetDevices.pHipDevices = pHipDevices;
    Args.hipGLGetDevices.hipDeviceCount = hipDeviceCount;
    Args.hipGLGetDevices.deviceList = deviceList;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGLGetDevices_fn(Args.hipGLGetDevices.pHipDeviceCount, Args.hipGLGetDevices.pHipDevices, Args.hipGLGetDevices.hipDeviceCount, Args.hipGLGetDevices.deviceList);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGLGetDevices_fn(pHipDeviceCount, pHipDevices, hipDeviceCount, deviceList);
  }
}

static hipError_t hipGetChannelDesc_callback(hipChannelFormatDesc* desc, hipArray_const_t array) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetChannelDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetChannelDesc.desc = desc;
    Args.hipGetChannelDesc.array = array;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetChannelDesc_fn(Args.hipGetChannelDesc.desc, Args.hipGetChannelDesc.array);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetChannelDesc_fn(desc, array);
  }
}

static hipError_t hipGetDevice_callback(int* deviceId) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetDevice.deviceId = deviceId;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetDevice_fn(Args.hipGetDevice.deviceId);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetDevice_fn(deviceId);
  }
}

static hipError_t hipGetDeviceCount_callback(int* count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetDeviceCount;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetDeviceCount.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetDeviceCount_fn(Args.hipGetDeviceCount.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetDeviceCount_fn(count);
  }
}

static hipError_t hipGetDeviceFlags_callback(unsigned int* flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetDeviceFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetDeviceFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetDeviceFlags_fn(Args.hipGetDeviceFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetDeviceFlags_fn(flags);
  }
}

static hipError_t hipGetDevicePropertiesR0600_callback(hipDeviceProp_tR0600* prop, int device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetDevicePropertiesR0600;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetDevicePropertiesR0600.prop = prop;
    Args.hipGetDevicePropertiesR0600.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetDevicePropertiesR0600_fn(Args.hipGetDevicePropertiesR0600.prop, Args.hipGetDevicePropertiesR0600.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetDevicePropertiesR0600_fn(prop, device);
  }
}

static hipError_t hipGetDevicePropertiesR0000_callback(hipDeviceProp_tR0000* prop, int device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetDevicePropertiesR0000;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetDevicePropertiesR0000.prop = prop;
    Args.hipGetDevicePropertiesR0000.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetDevicePropertiesR0000_fn(Args.hipGetDevicePropertiesR0000.prop, Args.hipGetDevicePropertiesR0000.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetDevicePropertiesR0000_fn(prop, device);
  }
}

static const char* hipGetErrorName_callback(hipError_t hip_error) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetErrorName;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    const char* Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetErrorName.hip_error = hip_error;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetErrorName_fn(Args.hipGetErrorName.hip_error);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetErrorName_fn(hip_error);
  }
}

static const char* hipGetErrorString_callback(hipError_t hipError) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetErrorString;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    const char* Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetErrorString.hipError = hipError;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetErrorString_fn(Args.hipGetErrorString.hipError);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetErrorString_fn(hipError);
  }
}

static hipError_t hipGetLastError_callback() {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetLastError;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetLastError_fn();
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetLastError_fn();
  }
}

static hipError_t hipGetMipmappedArrayLevel_callback(hipArray_t* levelArray, hipMipmappedArray_const_t mipmappedArray, unsigned int level) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetMipmappedArrayLevel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetMipmappedArrayLevel.levelArray = levelArray;
    Args.hipGetMipmappedArrayLevel.mipmappedArray = mipmappedArray;
    Args.hipGetMipmappedArrayLevel.level = level;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetMipmappedArrayLevel_fn(Args.hipGetMipmappedArrayLevel.levelArray, Args.hipGetMipmappedArrayLevel.mipmappedArray, Args.hipGetMipmappedArrayLevel.level);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetMipmappedArrayLevel_fn(levelArray, mipmappedArray, level);
  }
}

static hipError_t hipGetSymbolAddress_callback(void** devPtr, const void* symbol) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetSymbolAddress;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetSymbolAddress.devPtr = devPtr;
    Args.hipGetSymbolAddress.symbol = symbol;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetSymbolAddress_fn(Args.hipGetSymbolAddress.devPtr, Args.hipGetSymbolAddress.symbol);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetSymbolAddress_fn(devPtr, symbol);
  }
}

static hipError_t hipGetSymbolSize_callback(size_t* size, const void* symbol) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetSymbolSize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetSymbolSize.size = size;
    Args.hipGetSymbolSize.symbol = symbol;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetSymbolSize_fn(Args.hipGetSymbolSize.size, Args.hipGetSymbolSize.symbol);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetSymbolSize_fn(size, symbol);
  }
}

static hipError_t hipGetTextureAlignmentOffset_callback(size_t* offset, const textureReference* texref) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetTextureAlignmentOffset;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetTextureAlignmentOffset.offset = offset;
    Args.hipGetTextureAlignmentOffset.texref = texref;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetTextureAlignmentOffset_fn(Args.hipGetTextureAlignmentOffset.offset, Args.hipGetTextureAlignmentOffset.texref);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetTextureAlignmentOffset_fn(offset, texref);
  }
}

static hipError_t hipGetTextureObjectResourceDesc_callback(hipResourceDesc* pResDesc, hipTextureObject_t textureObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetTextureObjectResourceDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetTextureObjectResourceDesc.pResDesc = pResDesc;
    Args.hipGetTextureObjectResourceDesc.textureObject = textureObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetTextureObjectResourceDesc_fn(Args.hipGetTextureObjectResourceDesc.pResDesc, Args.hipGetTextureObjectResourceDesc.textureObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetTextureObjectResourceDesc_fn(pResDesc, textureObject);
  }
}

static hipError_t hipGetTextureObjectResourceViewDesc_callback(struct hipResourceViewDesc* pResViewDesc, hipTextureObject_t textureObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetTextureObjectResourceViewDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetTextureObjectResourceViewDesc.pResViewDesc = pResViewDesc;
    Args.hipGetTextureObjectResourceViewDesc.textureObject = textureObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetTextureObjectResourceViewDesc_fn(Args.hipGetTextureObjectResourceViewDesc.pResViewDesc, Args.hipGetTextureObjectResourceViewDesc.textureObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetTextureObjectResourceViewDesc_fn(pResViewDesc, textureObject);
  }
}

static hipError_t hipGetTextureObjectTextureDesc_callback(hipTextureDesc* pTexDesc, hipTextureObject_t textureObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetTextureObjectTextureDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetTextureObjectTextureDesc.pTexDesc = pTexDesc;
    Args.hipGetTextureObjectTextureDesc.textureObject = textureObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetTextureObjectTextureDesc_fn(Args.hipGetTextureObjectTextureDesc.pTexDesc, Args.hipGetTextureObjectTextureDesc.textureObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetTextureObjectTextureDesc_fn(pTexDesc, textureObject);
  }
}

static hipError_t hipGetTextureReference_callback(const textureReference** texref, const void* symbol) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetTextureReference;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetTextureReference.texref = texref;
    Args.hipGetTextureReference.symbol = symbol;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetTextureReference_fn(Args.hipGetTextureReference.texref, Args.hipGetTextureReference.symbol);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetTextureReference_fn(texref, symbol);
  }
}

static hipError_t hipGraphAddChildGraphNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, hipGraph_t childGraph) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddChildGraphNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddChildGraphNode.pGraphNode = pGraphNode;
    Args.hipGraphAddChildGraphNode.graph = graph;
    Args.hipGraphAddChildGraphNode.pDependencies = pDependencies;
    Args.hipGraphAddChildGraphNode.numDependencies = numDependencies;
    Args.hipGraphAddChildGraphNode.childGraph = childGraph;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddChildGraphNode_fn(Args.hipGraphAddChildGraphNode.pGraphNode, Args.hipGraphAddChildGraphNode.graph, Args.hipGraphAddChildGraphNode.pDependencies, Args.hipGraphAddChildGraphNode.numDependencies, Args.hipGraphAddChildGraphNode.childGraph);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddChildGraphNode_fn(pGraphNode, graph, pDependencies, numDependencies, childGraph);
  }
}

static hipError_t hipGraphAddDependencies_callback(hipGraph_t graph, const hipGraphNode_t* from, const hipGraphNode_t* to, size_t numDependencies) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddDependencies;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddDependencies.graph = graph;
    Args.hipGraphAddDependencies.from = from;
    Args.hipGraphAddDependencies.to = to;
    Args.hipGraphAddDependencies.numDependencies = numDependencies;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddDependencies_fn(Args.hipGraphAddDependencies.graph, Args.hipGraphAddDependencies.from, Args.hipGraphAddDependencies.to, Args.hipGraphAddDependencies.numDependencies);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddDependencies_fn(graph, from, to, numDependencies);
  }
}

static hipError_t hipGraphAddEmptyNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddEmptyNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddEmptyNode.pGraphNode = pGraphNode;
    Args.hipGraphAddEmptyNode.graph = graph;
    Args.hipGraphAddEmptyNode.pDependencies = pDependencies;
    Args.hipGraphAddEmptyNode.numDependencies = numDependencies;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddEmptyNode_fn(Args.hipGraphAddEmptyNode.pGraphNode, Args.hipGraphAddEmptyNode.graph, Args.hipGraphAddEmptyNode.pDependencies, Args.hipGraphAddEmptyNode.numDependencies);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddEmptyNode_fn(pGraphNode, graph, pDependencies, numDependencies);
  }
}

static hipError_t hipGraphAddEventRecordNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddEventRecordNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddEventRecordNode.pGraphNode = pGraphNode;
    Args.hipGraphAddEventRecordNode.graph = graph;
    Args.hipGraphAddEventRecordNode.pDependencies = pDependencies;
    Args.hipGraphAddEventRecordNode.numDependencies = numDependencies;
    Args.hipGraphAddEventRecordNode.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddEventRecordNode_fn(Args.hipGraphAddEventRecordNode.pGraphNode, Args.hipGraphAddEventRecordNode.graph, Args.hipGraphAddEventRecordNode.pDependencies, Args.hipGraphAddEventRecordNode.numDependencies, Args.hipGraphAddEventRecordNode.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddEventRecordNode_fn(pGraphNode, graph, pDependencies, numDependencies, event);
  }
}

static hipError_t hipGraphAddEventWaitNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddEventWaitNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddEventWaitNode.pGraphNode = pGraphNode;
    Args.hipGraphAddEventWaitNode.graph = graph;
    Args.hipGraphAddEventWaitNode.pDependencies = pDependencies;
    Args.hipGraphAddEventWaitNode.numDependencies = numDependencies;
    Args.hipGraphAddEventWaitNode.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddEventWaitNode_fn(Args.hipGraphAddEventWaitNode.pGraphNode, Args.hipGraphAddEventWaitNode.graph, Args.hipGraphAddEventWaitNode.pDependencies, Args.hipGraphAddEventWaitNode.numDependencies, Args.hipGraphAddEventWaitNode.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddEventWaitNode_fn(pGraphNode, graph, pDependencies, numDependencies, event);
  }
}

static hipError_t hipGraphAddHostNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const hipHostNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddHostNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddHostNode.pGraphNode = pGraphNode;
    Args.hipGraphAddHostNode.graph = graph;
    Args.hipGraphAddHostNode.pDependencies = pDependencies;
    Args.hipGraphAddHostNode.numDependencies = numDependencies;
    Args.hipGraphAddHostNode.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddHostNode_fn(Args.hipGraphAddHostNode.pGraphNode, Args.hipGraphAddHostNode.graph, Args.hipGraphAddHostNode.pDependencies, Args.hipGraphAddHostNode.numDependencies, Args.hipGraphAddHostNode.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddHostNode_fn(pGraphNode, graph, pDependencies, numDependencies, pNodeParams);
  }
}

static hipError_t hipGraphAddKernelNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const hipKernelNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddKernelNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddKernelNode.pGraphNode = pGraphNode;
    Args.hipGraphAddKernelNode.graph = graph;
    Args.hipGraphAddKernelNode.pDependencies = pDependencies;
    Args.hipGraphAddKernelNode.numDependencies = numDependencies;
    Args.hipGraphAddKernelNode.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddKernelNode_fn(Args.hipGraphAddKernelNode.pGraphNode, Args.hipGraphAddKernelNode.graph, Args.hipGraphAddKernelNode.pDependencies, Args.hipGraphAddKernelNode.numDependencies, Args.hipGraphAddKernelNode.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddKernelNode_fn(pGraphNode, graph, pDependencies, numDependencies, pNodeParams);
  }
}

static hipError_t hipGraphAddMemAllocNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, hipMemAllocNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemAllocNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddMemAllocNode.pGraphNode = pGraphNode;
    Args.hipGraphAddMemAllocNode.graph = graph;
    Args.hipGraphAddMemAllocNode.pDependencies = pDependencies;
    Args.hipGraphAddMemAllocNode.numDependencies = numDependencies;
    Args.hipGraphAddMemAllocNode.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddMemAllocNode_fn(Args.hipGraphAddMemAllocNode.pGraphNode, Args.hipGraphAddMemAllocNode.graph, Args.hipGraphAddMemAllocNode.pDependencies, Args.hipGraphAddMemAllocNode.numDependencies, Args.hipGraphAddMemAllocNode.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddMemAllocNode_fn(pGraphNode, graph, pDependencies, numDependencies, pNodeParams);
  }
}

static hipError_t hipGraphAddMemFreeNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, void* dev_ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemFreeNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddMemFreeNode.pGraphNode = pGraphNode;
    Args.hipGraphAddMemFreeNode.graph = graph;
    Args.hipGraphAddMemFreeNode.pDependencies = pDependencies;
    Args.hipGraphAddMemFreeNode.numDependencies = numDependencies;
    Args.hipGraphAddMemFreeNode.dev_ptr = dev_ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddMemFreeNode_fn(Args.hipGraphAddMemFreeNode.pGraphNode, Args.hipGraphAddMemFreeNode.graph, Args.hipGraphAddMemFreeNode.pDependencies, Args.hipGraphAddMemFreeNode.numDependencies, Args.hipGraphAddMemFreeNode.dev_ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddMemFreeNode_fn(pGraphNode, graph, pDependencies, numDependencies, dev_ptr);
  }
}

static hipError_t hipGraphAddMemcpyNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const hipMemcpy3DParms* pCopyParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemcpyNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddMemcpyNode.pGraphNode = pGraphNode;
    Args.hipGraphAddMemcpyNode.graph = graph;
    Args.hipGraphAddMemcpyNode.pDependencies = pDependencies;
    Args.hipGraphAddMemcpyNode.numDependencies = numDependencies;
    Args.hipGraphAddMemcpyNode.pCopyParams = pCopyParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddMemcpyNode_fn(Args.hipGraphAddMemcpyNode.pGraphNode, Args.hipGraphAddMemcpyNode.graph, Args.hipGraphAddMemcpyNode.pDependencies, Args.hipGraphAddMemcpyNode.numDependencies, Args.hipGraphAddMemcpyNode.pCopyParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddMemcpyNode_fn(pGraphNode, graph, pDependencies, numDependencies, pCopyParams);
  }
}

static hipError_t hipGraphAddMemcpyNode1D_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, void* dst, const void* src, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemcpyNode1D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddMemcpyNode1D.pGraphNode = pGraphNode;
    Args.hipGraphAddMemcpyNode1D.graph = graph;
    Args.hipGraphAddMemcpyNode1D.pDependencies = pDependencies;
    Args.hipGraphAddMemcpyNode1D.numDependencies = numDependencies;
    Args.hipGraphAddMemcpyNode1D.dst = dst;
    Args.hipGraphAddMemcpyNode1D.src = src;
    Args.hipGraphAddMemcpyNode1D.count = count;
    Args.hipGraphAddMemcpyNode1D.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddMemcpyNode1D_fn(Args.hipGraphAddMemcpyNode1D.pGraphNode, Args.hipGraphAddMemcpyNode1D.graph, Args.hipGraphAddMemcpyNode1D.pDependencies, Args.hipGraphAddMemcpyNode1D.numDependencies, Args.hipGraphAddMemcpyNode1D.dst, Args.hipGraphAddMemcpyNode1D.src, Args.hipGraphAddMemcpyNode1D.count, Args.hipGraphAddMemcpyNode1D.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddMemcpyNode1D_fn(pGraphNode, graph, pDependencies, numDependencies, dst, src, count, kind);
  }
}

static hipError_t hipGraphAddMemcpyNodeFromSymbol_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, void* dst, const void* symbol, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemcpyNodeFromSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddMemcpyNodeFromSymbol.pGraphNode = pGraphNode;
    Args.hipGraphAddMemcpyNodeFromSymbol.graph = graph;
    Args.hipGraphAddMemcpyNodeFromSymbol.pDependencies = pDependencies;
    Args.hipGraphAddMemcpyNodeFromSymbol.numDependencies = numDependencies;
    Args.hipGraphAddMemcpyNodeFromSymbol.dst = dst;
    Args.hipGraphAddMemcpyNodeFromSymbol.symbol = symbol;
    Args.hipGraphAddMemcpyNodeFromSymbol.count = count;
    Args.hipGraphAddMemcpyNodeFromSymbol.offset = offset;
    Args.hipGraphAddMemcpyNodeFromSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddMemcpyNodeFromSymbol_fn(Args.hipGraphAddMemcpyNodeFromSymbol.pGraphNode, Args.hipGraphAddMemcpyNodeFromSymbol.graph, Args.hipGraphAddMemcpyNodeFromSymbol.pDependencies, Args.hipGraphAddMemcpyNodeFromSymbol.numDependencies, Args.hipGraphAddMemcpyNodeFromSymbol.dst, Args.hipGraphAddMemcpyNodeFromSymbol.symbol, Args.hipGraphAddMemcpyNodeFromSymbol.count, Args.hipGraphAddMemcpyNodeFromSymbol.offset, Args.hipGraphAddMemcpyNodeFromSymbol.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddMemcpyNodeFromSymbol_fn(pGraphNode, graph, pDependencies, numDependencies, dst, symbol, count, offset, kind);
  }
}

static hipError_t hipGraphAddMemcpyNodeToSymbol_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const void* symbol, const void* src, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemcpyNodeToSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddMemcpyNodeToSymbol.pGraphNode = pGraphNode;
    Args.hipGraphAddMemcpyNodeToSymbol.graph = graph;
    Args.hipGraphAddMemcpyNodeToSymbol.pDependencies = pDependencies;
    Args.hipGraphAddMemcpyNodeToSymbol.numDependencies = numDependencies;
    Args.hipGraphAddMemcpyNodeToSymbol.symbol = symbol;
    Args.hipGraphAddMemcpyNodeToSymbol.src = src;
    Args.hipGraphAddMemcpyNodeToSymbol.count = count;
    Args.hipGraphAddMemcpyNodeToSymbol.offset = offset;
    Args.hipGraphAddMemcpyNodeToSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddMemcpyNodeToSymbol_fn(Args.hipGraphAddMemcpyNodeToSymbol.pGraphNode, Args.hipGraphAddMemcpyNodeToSymbol.graph, Args.hipGraphAddMemcpyNodeToSymbol.pDependencies, Args.hipGraphAddMemcpyNodeToSymbol.numDependencies, Args.hipGraphAddMemcpyNodeToSymbol.symbol, Args.hipGraphAddMemcpyNodeToSymbol.src, Args.hipGraphAddMemcpyNodeToSymbol.count, Args.hipGraphAddMemcpyNodeToSymbol.offset, Args.hipGraphAddMemcpyNodeToSymbol.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddMemcpyNodeToSymbol_fn(pGraphNode, graph, pDependencies, numDependencies, symbol, src, count, offset, kind);
  }
}

static hipError_t hipGraphAddMemsetNode_callback(hipGraphNode_t* pGraphNode, hipGraph_t graph, const hipGraphNode_t* pDependencies, size_t numDependencies, const hipMemsetParams* pMemsetParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphAddMemsetNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphAddMemsetNode.pGraphNode = pGraphNode;
    Args.hipGraphAddMemsetNode.graph = graph;
    Args.hipGraphAddMemsetNode.pDependencies = pDependencies;
    Args.hipGraphAddMemsetNode.numDependencies = numDependencies;
    Args.hipGraphAddMemsetNode.pMemsetParams = pMemsetParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphAddMemsetNode_fn(Args.hipGraphAddMemsetNode.pGraphNode, Args.hipGraphAddMemsetNode.graph, Args.hipGraphAddMemsetNode.pDependencies, Args.hipGraphAddMemsetNode.numDependencies, Args.hipGraphAddMemsetNode.pMemsetParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphAddMemsetNode_fn(pGraphNode, graph, pDependencies, numDependencies, pMemsetParams);
  }
}

static hipError_t hipGraphChildGraphNodeGetGraph_callback(hipGraphNode_t node, hipGraph_t* pGraph) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphChildGraphNodeGetGraph;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphChildGraphNodeGetGraph.node = node;
    Args.hipGraphChildGraphNodeGetGraph.pGraph = pGraph;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphChildGraphNodeGetGraph_fn(Args.hipGraphChildGraphNodeGetGraph.node, Args.hipGraphChildGraphNodeGetGraph.pGraph);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphChildGraphNodeGetGraph_fn(node, pGraph);
  }
}

static hipError_t hipGraphClone_callback(hipGraph_t* pGraphClone, hipGraph_t originalGraph) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphClone;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphClone.pGraphClone = pGraphClone;
    Args.hipGraphClone.originalGraph = originalGraph;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphClone_fn(Args.hipGraphClone.pGraphClone, Args.hipGraphClone.originalGraph);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphClone_fn(pGraphClone, originalGraph);
  }
}

static hipError_t hipGraphCreate_callback(hipGraph_t* pGraph, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphCreate.pGraph = pGraph;
    Args.hipGraphCreate.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphCreate_fn(Args.hipGraphCreate.pGraph, Args.hipGraphCreate.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphCreate_fn(pGraph, flags);
  }
}

static hipError_t hipGraphDebugDotPrint_callback(hipGraph_t graph, const char* path, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphDebugDotPrint;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphDebugDotPrint.graph = graph;
    Args.hipGraphDebugDotPrint.path = path;
    Args.hipGraphDebugDotPrint.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphDebugDotPrint_fn(Args.hipGraphDebugDotPrint.graph, Args.hipGraphDebugDotPrint.path, Args.hipGraphDebugDotPrint.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphDebugDotPrint_fn(graph, path, flags);
  }
}

static hipError_t hipGraphDestroy_callback(hipGraph_t graph) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphDestroy.graph = graph;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphDestroy_fn(Args.hipGraphDestroy.graph);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphDestroy_fn(graph);
  }
}

static hipError_t hipGraphDestroyNode_callback(hipGraphNode_t node) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphDestroyNode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphDestroyNode.node = node;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphDestroyNode_fn(Args.hipGraphDestroyNode.node);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphDestroyNode_fn(node);
  }
}

static hipError_t hipGraphEventRecordNodeGetEvent_callback(hipGraphNode_t node, hipEvent_t* event_out) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphEventRecordNodeGetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphEventRecordNodeGetEvent.node = node;
    Args.hipGraphEventRecordNodeGetEvent.event_out = event_out;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphEventRecordNodeGetEvent_fn(Args.hipGraphEventRecordNodeGetEvent.node, Args.hipGraphEventRecordNodeGetEvent.event_out);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphEventRecordNodeGetEvent_fn(node, event_out);
  }
}

static hipError_t hipGraphEventRecordNodeSetEvent_callback(hipGraphNode_t node, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphEventRecordNodeSetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphEventRecordNodeSetEvent.node = node;
    Args.hipGraphEventRecordNodeSetEvent.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphEventRecordNodeSetEvent_fn(Args.hipGraphEventRecordNodeSetEvent.node, Args.hipGraphEventRecordNodeSetEvent.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphEventRecordNodeSetEvent_fn(node, event);
  }
}

static hipError_t hipGraphEventWaitNodeGetEvent_callback(hipGraphNode_t node, hipEvent_t* event_out) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphEventWaitNodeGetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphEventWaitNodeGetEvent.node = node;
    Args.hipGraphEventWaitNodeGetEvent.event_out = event_out;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphEventWaitNodeGetEvent_fn(Args.hipGraphEventWaitNodeGetEvent.node, Args.hipGraphEventWaitNodeGetEvent.event_out);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphEventWaitNodeGetEvent_fn(node, event_out);
  }
}

static hipError_t hipGraphEventWaitNodeSetEvent_callback(hipGraphNode_t node, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphEventWaitNodeSetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphEventWaitNodeSetEvent.node = node;
    Args.hipGraphEventWaitNodeSetEvent.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphEventWaitNodeSetEvent_fn(Args.hipGraphEventWaitNodeSetEvent.node, Args.hipGraphEventWaitNodeSetEvent.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphEventWaitNodeSetEvent_fn(node, event);
  }
}

static hipError_t hipGraphExecChildGraphNodeSetParams_callback(hipGraphExec_t hGraphExec, hipGraphNode_t node, hipGraph_t childGraph) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecChildGraphNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecChildGraphNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecChildGraphNodeSetParams.node = node;
    Args.hipGraphExecChildGraphNodeSetParams.childGraph = childGraph;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecChildGraphNodeSetParams_fn(Args.hipGraphExecChildGraphNodeSetParams.hGraphExec, Args.hipGraphExecChildGraphNodeSetParams.node, Args.hipGraphExecChildGraphNodeSetParams.childGraph);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecChildGraphNodeSetParams_fn(hGraphExec, node, childGraph);
  }
}

static hipError_t hipGraphExecDestroy_callback(hipGraphExec_t graphExec) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecDestroy.graphExec = graphExec;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecDestroy_fn(Args.hipGraphExecDestroy.graphExec);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecDestroy_fn(graphExec);
  }
}

static hipError_t hipGraphExecEventRecordNodeSetEvent_callback(hipGraphExec_t hGraphExec, hipGraphNode_t hNode, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecEventRecordNodeSetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecEventRecordNodeSetEvent.hGraphExec = hGraphExec;
    Args.hipGraphExecEventRecordNodeSetEvent.hNode = hNode;
    Args.hipGraphExecEventRecordNodeSetEvent.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecEventRecordNodeSetEvent_fn(Args.hipGraphExecEventRecordNodeSetEvent.hGraphExec, Args.hipGraphExecEventRecordNodeSetEvent.hNode, Args.hipGraphExecEventRecordNodeSetEvent.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecEventRecordNodeSetEvent_fn(hGraphExec, hNode, event);
  }
}

static hipError_t hipGraphExecEventWaitNodeSetEvent_callback(hipGraphExec_t hGraphExec, hipGraphNode_t hNode, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecEventWaitNodeSetEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecEventWaitNodeSetEvent.hGraphExec = hGraphExec;
    Args.hipGraphExecEventWaitNodeSetEvent.hNode = hNode;
    Args.hipGraphExecEventWaitNodeSetEvent.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecEventWaitNodeSetEvent_fn(Args.hipGraphExecEventWaitNodeSetEvent.hGraphExec, Args.hipGraphExecEventWaitNodeSetEvent.hNode, Args.hipGraphExecEventWaitNodeSetEvent.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecEventWaitNodeSetEvent_fn(hGraphExec, hNode, event);
  }
}

static hipError_t hipGraphExecHostNodeSetParams_callback(hipGraphExec_t hGraphExec, hipGraphNode_t node, const hipHostNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecHostNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecHostNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecHostNodeSetParams.node = node;
    Args.hipGraphExecHostNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecHostNodeSetParams_fn(Args.hipGraphExecHostNodeSetParams.hGraphExec, Args.hipGraphExecHostNodeSetParams.node, Args.hipGraphExecHostNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecHostNodeSetParams_fn(hGraphExec, node, pNodeParams);
  }
}

static hipError_t hipGraphExecKernelNodeSetParams_callback(hipGraphExec_t hGraphExec, hipGraphNode_t node, const hipKernelNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecKernelNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecKernelNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecKernelNodeSetParams.node = node;
    Args.hipGraphExecKernelNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecKernelNodeSetParams_fn(Args.hipGraphExecKernelNodeSetParams.hGraphExec, Args.hipGraphExecKernelNodeSetParams.node, Args.hipGraphExecKernelNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecKernelNodeSetParams_fn(hGraphExec, node, pNodeParams);
  }
}

static hipError_t hipGraphExecMemcpyNodeSetParams_callback(hipGraphExec_t hGraphExec, hipGraphNode_t node, hipMemcpy3DParms* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecMemcpyNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecMemcpyNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecMemcpyNodeSetParams.node = node;
    Args.hipGraphExecMemcpyNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecMemcpyNodeSetParams_fn(Args.hipGraphExecMemcpyNodeSetParams.hGraphExec, Args.hipGraphExecMemcpyNodeSetParams.node, Args.hipGraphExecMemcpyNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecMemcpyNodeSetParams_fn(hGraphExec, node, pNodeParams);
  }
}

static hipError_t hipGraphExecMemcpyNodeSetParams1D_callback(hipGraphExec_t hGraphExec, hipGraphNode_t node, void* dst, const void* src, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecMemcpyNodeSetParams1D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecMemcpyNodeSetParams1D.hGraphExec = hGraphExec;
    Args.hipGraphExecMemcpyNodeSetParams1D.node = node;
    Args.hipGraphExecMemcpyNodeSetParams1D.dst = dst;
    Args.hipGraphExecMemcpyNodeSetParams1D.src = src;
    Args.hipGraphExecMemcpyNodeSetParams1D.count = count;
    Args.hipGraphExecMemcpyNodeSetParams1D.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecMemcpyNodeSetParams1D_fn(Args.hipGraphExecMemcpyNodeSetParams1D.hGraphExec, Args.hipGraphExecMemcpyNodeSetParams1D.node, Args.hipGraphExecMemcpyNodeSetParams1D.dst, Args.hipGraphExecMemcpyNodeSetParams1D.src, Args.hipGraphExecMemcpyNodeSetParams1D.count, Args.hipGraphExecMemcpyNodeSetParams1D.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecMemcpyNodeSetParams1D_fn(hGraphExec, node, dst, src, count, kind);
  }
}

static hipError_t hipGraphExecMemcpyNodeSetParamsFromSymbol_callback(hipGraphExec_t hGraphExec, hipGraphNode_t node, void* dst, const void* symbol, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecMemcpyNodeSetParamsFromSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.hGraphExec = hGraphExec;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.node = node;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.dst = dst;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.symbol = symbol;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.count = count;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.offset = offset;
    Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecMemcpyNodeSetParamsFromSymbol_fn(Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.hGraphExec, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.node, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.dst, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.symbol, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.count, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.offset, Args.hipGraphExecMemcpyNodeSetParamsFromSymbol.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecMemcpyNodeSetParamsFromSymbol_fn(hGraphExec, node, dst, symbol, count, offset, kind);
  }
}

static hipError_t hipGraphExecMemcpyNodeSetParamsToSymbol_callback(hipGraphExec_t hGraphExec, hipGraphNode_t node, const void* symbol, const void* src, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecMemcpyNodeSetParamsToSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.hGraphExec = hGraphExec;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.node = node;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.symbol = symbol;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.src = src;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.count = count;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.offset = offset;
    Args.hipGraphExecMemcpyNodeSetParamsToSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecMemcpyNodeSetParamsToSymbol_fn(Args.hipGraphExecMemcpyNodeSetParamsToSymbol.hGraphExec, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.node, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.symbol, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.src, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.count, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.offset, Args.hipGraphExecMemcpyNodeSetParamsToSymbol.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecMemcpyNodeSetParamsToSymbol_fn(hGraphExec, node, symbol, src, count, offset, kind);
  }
}

static hipError_t hipGraphExecMemsetNodeSetParams_callback(hipGraphExec_t hGraphExec, hipGraphNode_t node, const hipMemsetParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecMemsetNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecMemsetNodeSetParams.hGraphExec = hGraphExec;
    Args.hipGraphExecMemsetNodeSetParams.node = node;
    Args.hipGraphExecMemsetNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecMemsetNodeSetParams_fn(Args.hipGraphExecMemsetNodeSetParams.hGraphExec, Args.hipGraphExecMemsetNodeSetParams.node, Args.hipGraphExecMemsetNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecMemsetNodeSetParams_fn(hGraphExec, node, pNodeParams);
  }
}

static hipError_t hipGraphExecUpdate_callback(hipGraphExec_t hGraphExec, hipGraph_t hGraph, hipGraphNode_t* hErrorNode_out, hipGraphExecUpdateResult* updateResult_out) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphExecUpdate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphExecUpdate.hGraphExec = hGraphExec;
    Args.hipGraphExecUpdate.hGraph = hGraph;
    Args.hipGraphExecUpdate.hErrorNode_out = hErrorNode_out;
    Args.hipGraphExecUpdate.updateResult_out = updateResult_out;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphExecUpdate_fn(Args.hipGraphExecUpdate.hGraphExec, Args.hipGraphExecUpdate.hGraph, Args.hipGraphExecUpdate.hErrorNode_out, Args.hipGraphExecUpdate.updateResult_out);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphExecUpdate_fn(hGraphExec, hGraph, hErrorNode_out, updateResult_out);
  }
}

static hipError_t hipGraphGetEdges_callback(hipGraph_t graph, hipGraphNode_t* from, hipGraphNode_t* to, size_t* numEdges) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphGetEdges;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphGetEdges.graph = graph;
    Args.hipGraphGetEdges.from = from;
    Args.hipGraphGetEdges.to = to;
    Args.hipGraphGetEdges.numEdges = numEdges;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphGetEdges_fn(Args.hipGraphGetEdges.graph, Args.hipGraphGetEdges.from, Args.hipGraphGetEdges.to, Args.hipGraphGetEdges.numEdges);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphGetEdges_fn(graph, from, to, numEdges);
  }
}

static hipError_t hipGraphGetNodes_callback(hipGraph_t graph, hipGraphNode_t* nodes, size_t* numNodes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphGetNodes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphGetNodes.graph = graph;
    Args.hipGraphGetNodes.nodes = nodes;
    Args.hipGraphGetNodes.numNodes = numNodes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphGetNodes_fn(Args.hipGraphGetNodes.graph, Args.hipGraphGetNodes.nodes, Args.hipGraphGetNodes.numNodes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphGetNodes_fn(graph, nodes, numNodes);
  }
}

static hipError_t hipGraphGetRootNodes_callback(hipGraph_t graph, hipGraphNode_t* pRootNodes, size_t* pNumRootNodes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphGetRootNodes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphGetRootNodes.graph = graph;
    Args.hipGraphGetRootNodes.pRootNodes = pRootNodes;
    Args.hipGraphGetRootNodes.pNumRootNodes = pNumRootNodes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphGetRootNodes_fn(Args.hipGraphGetRootNodes.graph, Args.hipGraphGetRootNodes.pRootNodes, Args.hipGraphGetRootNodes.pNumRootNodes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphGetRootNodes_fn(graph, pRootNodes, pNumRootNodes);
  }
}

static hipError_t hipGraphHostNodeGetParams_callback(hipGraphNode_t node, hipHostNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphHostNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphHostNodeGetParams.node = node;
    Args.hipGraphHostNodeGetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphHostNodeGetParams_fn(Args.hipGraphHostNodeGetParams.node, Args.hipGraphHostNodeGetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphHostNodeGetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphHostNodeSetParams_callback(hipGraphNode_t node, const hipHostNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphHostNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphHostNodeSetParams.node = node;
    Args.hipGraphHostNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphHostNodeSetParams_fn(Args.hipGraphHostNodeSetParams.node, Args.hipGraphHostNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphHostNodeSetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphInstantiate_callback(hipGraphExec_t* pGraphExec, hipGraph_t graph, hipGraphNode_t* pErrorNode, char* pLogBuffer, size_t bufferSize) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphInstantiate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphInstantiate.pGraphExec = pGraphExec;
    Args.hipGraphInstantiate.graph = graph;
    Args.hipGraphInstantiate.pErrorNode = pErrorNode;
    Args.hipGraphInstantiate.pLogBuffer = pLogBuffer;
    Args.hipGraphInstantiate.bufferSize = bufferSize;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphInstantiate_fn(Args.hipGraphInstantiate.pGraphExec, Args.hipGraphInstantiate.graph, Args.hipGraphInstantiate.pErrorNode, Args.hipGraphInstantiate.pLogBuffer, Args.hipGraphInstantiate.bufferSize);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphInstantiate_fn(pGraphExec, graph, pErrorNode, pLogBuffer, bufferSize);
  }
}

static hipError_t hipGraphInstantiateWithFlags_callback(hipGraphExec_t* pGraphExec, hipGraph_t graph, unsigned long long flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphInstantiateWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphInstantiateWithFlags.pGraphExec = pGraphExec;
    Args.hipGraphInstantiateWithFlags.graph = graph;
    Args.hipGraphInstantiateWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphInstantiateWithFlags_fn(Args.hipGraphInstantiateWithFlags.pGraphExec, Args.hipGraphInstantiateWithFlags.graph, Args.hipGraphInstantiateWithFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphInstantiateWithFlags_fn(pGraphExec, graph, flags);
  }
}

static hipError_t hipGraphKernelNodeCopyAttributes_callback(hipGraphNode_t hSrc, hipGraphNode_t hDst) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphKernelNodeCopyAttributes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphKernelNodeCopyAttributes.hSrc = hSrc;
    Args.hipGraphKernelNodeCopyAttributes.hDst = hDst;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeCopyAttributes_fn(Args.hipGraphKernelNodeCopyAttributes.hSrc, Args.hipGraphKernelNodeCopyAttributes.hDst);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeCopyAttributes_fn(hSrc, hDst);
  }
}

static hipError_t hipGraphKernelNodeGetAttribute_callback(hipGraphNode_t hNode, hipKernelNodeAttrID attr, hipKernelNodeAttrValue* value) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphKernelNodeGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphKernelNodeGetAttribute.hNode = hNode;
    Args.hipGraphKernelNodeGetAttribute.attr = attr;
    Args.hipGraphKernelNodeGetAttribute.value = value;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeGetAttribute_fn(Args.hipGraphKernelNodeGetAttribute.hNode, Args.hipGraphKernelNodeGetAttribute.attr, Args.hipGraphKernelNodeGetAttribute.value);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeGetAttribute_fn(hNode, attr, value);
  }
}

static hipError_t hipGraphKernelNodeGetParams_callback(hipGraphNode_t node, hipKernelNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphKernelNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphKernelNodeGetParams.node = node;
    Args.hipGraphKernelNodeGetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeGetParams_fn(Args.hipGraphKernelNodeGetParams.node, Args.hipGraphKernelNodeGetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeGetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphKernelNodeSetAttribute_callback(hipGraphNode_t hNode, hipKernelNodeAttrID attr, const hipKernelNodeAttrValue* value) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphKernelNodeSetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphKernelNodeSetAttribute.hNode = hNode;
    Args.hipGraphKernelNodeSetAttribute.attr = attr;
    Args.hipGraphKernelNodeSetAttribute.value = value;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeSetAttribute_fn(Args.hipGraphKernelNodeSetAttribute.hNode, Args.hipGraphKernelNodeSetAttribute.attr, Args.hipGraphKernelNodeSetAttribute.value);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeSetAttribute_fn(hNode, attr, value);
  }
}

static hipError_t hipGraphKernelNodeSetParams_callback(hipGraphNode_t node, const hipKernelNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphKernelNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphKernelNodeSetParams.node = node;
    Args.hipGraphKernelNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeSetParams_fn(Args.hipGraphKernelNodeSetParams.node, Args.hipGraphKernelNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphKernelNodeSetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphLaunch_callback(hipGraphExec_t graphExec, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphLaunch;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphLaunch.graphExec = graphExec;
    Args.hipGraphLaunch.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphLaunch_fn(Args.hipGraphLaunch.graphExec, Args.hipGraphLaunch.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphLaunch_fn(graphExec, stream);
  }
}

static hipError_t hipGraphMemAllocNodeGetParams_callback(hipGraphNode_t node, hipMemAllocNodeParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemAllocNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemAllocNodeGetParams.node = node;
    Args.hipGraphMemAllocNodeGetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemAllocNodeGetParams_fn(Args.hipGraphMemAllocNodeGetParams.node, Args.hipGraphMemAllocNodeGetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemAllocNodeGetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphMemFreeNodeGetParams_callback(hipGraphNode_t node, void* dev_ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemFreeNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemFreeNodeGetParams.node = node;
    Args.hipGraphMemFreeNodeGetParams.dev_ptr = dev_ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemFreeNodeGetParams_fn(Args.hipGraphMemFreeNodeGetParams.node, Args.hipGraphMemFreeNodeGetParams.dev_ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemFreeNodeGetParams_fn(node, dev_ptr);
  }
}

static hipError_t hipGraphMemcpyNodeGetParams_callback(hipGraphNode_t node, hipMemcpy3DParms* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemcpyNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemcpyNodeGetParams.node = node;
    Args.hipGraphMemcpyNodeGetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeGetParams_fn(Args.hipGraphMemcpyNodeGetParams.node, Args.hipGraphMemcpyNodeGetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeGetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphMemcpyNodeSetParams_callback(hipGraphNode_t node, const hipMemcpy3DParms* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemcpyNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemcpyNodeSetParams.node = node;
    Args.hipGraphMemcpyNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeSetParams_fn(Args.hipGraphMemcpyNodeSetParams.node, Args.hipGraphMemcpyNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeSetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphMemcpyNodeSetParams1D_callback(hipGraphNode_t node, void* dst, const void* src, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemcpyNodeSetParams1D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemcpyNodeSetParams1D.node = node;
    Args.hipGraphMemcpyNodeSetParams1D.dst = dst;
    Args.hipGraphMemcpyNodeSetParams1D.src = src;
    Args.hipGraphMemcpyNodeSetParams1D.count = count;
    Args.hipGraphMemcpyNodeSetParams1D.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeSetParams1D_fn(Args.hipGraphMemcpyNodeSetParams1D.node, Args.hipGraphMemcpyNodeSetParams1D.dst, Args.hipGraphMemcpyNodeSetParams1D.src, Args.hipGraphMemcpyNodeSetParams1D.count, Args.hipGraphMemcpyNodeSetParams1D.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeSetParams1D_fn(node, dst, src, count, kind);
  }
}

static hipError_t hipGraphMemcpyNodeSetParamsFromSymbol_callback(hipGraphNode_t node, void* dst, const void* symbol, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemcpyNodeSetParamsFromSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.node = node;
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.dst = dst;
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.symbol = symbol;
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.count = count;
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.offset = offset;
    Args.hipGraphMemcpyNodeSetParamsFromSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeSetParamsFromSymbol_fn(Args.hipGraphMemcpyNodeSetParamsFromSymbol.node, Args.hipGraphMemcpyNodeSetParamsFromSymbol.dst, Args.hipGraphMemcpyNodeSetParamsFromSymbol.symbol, Args.hipGraphMemcpyNodeSetParamsFromSymbol.count, Args.hipGraphMemcpyNodeSetParamsFromSymbol.offset, Args.hipGraphMemcpyNodeSetParamsFromSymbol.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeSetParamsFromSymbol_fn(node, dst, symbol, count, offset, kind);
  }
}

static hipError_t hipGraphMemcpyNodeSetParamsToSymbol_callback(hipGraphNode_t node, const void* symbol, const void* src, size_t count, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemcpyNodeSetParamsToSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemcpyNodeSetParamsToSymbol.node = node;
    Args.hipGraphMemcpyNodeSetParamsToSymbol.symbol = symbol;
    Args.hipGraphMemcpyNodeSetParamsToSymbol.src = src;
    Args.hipGraphMemcpyNodeSetParamsToSymbol.count = count;
    Args.hipGraphMemcpyNodeSetParamsToSymbol.offset = offset;
    Args.hipGraphMemcpyNodeSetParamsToSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeSetParamsToSymbol_fn(Args.hipGraphMemcpyNodeSetParamsToSymbol.node, Args.hipGraphMemcpyNodeSetParamsToSymbol.symbol, Args.hipGraphMemcpyNodeSetParamsToSymbol.src, Args.hipGraphMemcpyNodeSetParamsToSymbol.count, Args.hipGraphMemcpyNodeSetParamsToSymbol.offset, Args.hipGraphMemcpyNodeSetParamsToSymbol.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemcpyNodeSetParamsToSymbol_fn(node, symbol, src, count, offset, kind);
  }
}

static hipError_t hipGraphMemsetNodeGetParams_callback(hipGraphNode_t node, hipMemsetParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemsetNodeGetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemsetNodeGetParams.node = node;
    Args.hipGraphMemsetNodeGetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemsetNodeGetParams_fn(Args.hipGraphMemsetNodeGetParams.node, Args.hipGraphMemsetNodeGetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemsetNodeGetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphMemsetNodeSetParams_callback(hipGraphNode_t node, const hipMemsetParams* pNodeParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphMemsetNodeSetParams;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphMemsetNodeSetParams.node = node;
    Args.hipGraphMemsetNodeSetParams.pNodeParams = pNodeParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphMemsetNodeSetParams_fn(Args.hipGraphMemsetNodeSetParams.node, Args.hipGraphMemsetNodeSetParams.pNodeParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphMemsetNodeSetParams_fn(node, pNodeParams);
  }
}

static hipError_t hipGraphNodeFindInClone_callback(hipGraphNode_t* pNode, hipGraphNode_t originalNode, hipGraph_t clonedGraph) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeFindInClone;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphNodeFindInClone.pNode = pNode;
    Args.hipGraphNodeFindInClone.originalNode = originalNode;
    Args.hipGraphNodeFindInClone.clonedGraph = clonedGraph;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphNodeFindInClone_fn(Args.hipGraphNodeFindInClone.pNode, Args.hipGraphNodeFindInClone.originalNode, Args.hipGraphNodeFindInClone.clonedGraph);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphNodeFindInClone_fn(pNode, originalNode, clonedGraph);
  }
}

static hipError_t hipGraphNodeGetDependencies_callback(hipGraphNode_t node, hipGraphNode_t* pDependencies, size_t* pNumDependencies) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeGetDependencies;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphNodeGetDependencies.node = node;
    Args.hipGraphNodeGetDependencies.pDependencies = pDependencies;
    Args.hipGraphNodeGetDependencies.pNumDependencies = pNumDependencies;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphNodeGetDependencies_fn(Args.hipGraphNodeGetDependencies.node, Args.hipGraphNodeGetDependencies.pDependencies, Args.hipGraphNodeGetDependencies.pNumDependencies);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphNodeGetDependencies_fn(node, pDependencies, pNumDependencies);
  }
}

static hipError_t hipGraphNodeGetDependentNodes_callback(hipGraphNode_t node, hipGraphNode_t* pDependentNodes, size_t* pNumDependentNodes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeGetDependentNodes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphNodeGetDependentNodes.node = node;
    Args.hipGraphNodeGetDependentNodes.pDependentNodes = pDependentNodes;
    Args.hipGraphNodeGetDependentNodes.pNumDependentNodes = pNumDependentNodes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphNodeGetDependentNodes_fn(Args.hipGraphNodeGetDependentNodes.node, Args.hipGraphNodeGetDependentNodes.pDependentNodes, Args.hipGraphNodeGetDependentNodes.pNumDependentNodes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphNodeGetDependentNodes_fn(node, pDependentNodes, pNumDependentNodes);
  }
}

static hipError_t hipGraphNodeGetEnabled_callback(hipGraphExec_t hGraphExec, hipGraphNode_t hNode, unsigned int* isEnabled) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeGetEnabled;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphNodeGetEnabled.hGraphExec = hGraphExec;
    Args.hipGraphNodeGetEnabled.hNode = hNode;
    Args.hipGraphNodeGetEnabled.isEnabled = isEnabled;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphNodeGetEnabled_fn(Args.hipGraphNodeGetEnabled.hGraphExec, Args.hipGraphNodeGetEnabled.hNode, Args.hipGraphNodeGetEnabled.isEnabled);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphNodeGetEnabled_fn(hGraphExec, hNode, isEnabled);
  }
}

static hipError_t hipGraphNodeGetType_callback(hipGraphNode_t node, hipGraphNodeType* pType) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeGetType;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphNodeGetType.node = node;
    Args.hipGraphNodeGetType.pType = pType;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphNodeGetType_fn(Args.hipGraphNodeGetType.node, Args.hipGraphNodeGetType.pType);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphNodeGetType_fn(node, pType);
  }
}

static hipError_t hipGraphNodeSetEnabled_callback(hipGraphExec_t hGraphExec, hipGraphNode_t hNode, unsigned int isEnabled) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphNodeSetEnabled;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphNodeSetEnabled.hGraphExec = hGraphExec;
    Args.hipGraphNodeSetEnabled.hNode = hNode;
    Args.hipGraphNodeSetEnabled.isEnabled = isEnabled;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphNodeSetEnabled_fn(Args.hipGraphNodeSetEnabled.hGraphExec, Args.hipGraphNodeSetEnabled.hNode, Args.hipGraphNodeSetEnabled.isEnabled);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphNodeSetEnabled_fn(hGraphExec, hNode, isEnabled);
  }
}

static hipError_t hipGraphReleaseUserObject_callback(hipGraph_t graph, hipUserObject_t object, unsigned int count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphReleaseUserObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphReleaseUserObject.graph = graph;
    Args.hipGraphReleaseUserObject.object = object;
    Args.hipGraphReleaseUserObject.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphReleaseUserObject_fn(Args.hipGraphReleaseUserObject.graph, Args.hipGraphReleaseUserObject.object, Args.hipGraphReleaseUserObject.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphReleaseUserObject_fn(graph, object, count);
  }
}

static hipError_t hipGraphRemoveDependencies_callback(hipGraph_t graph, const hipGraphNode_t* from, const hipGraphNode_t* to, size_t numDependencies) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphRemoveDependencies;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphRemoveDependencies.graph = graph;
    Args.hipGraphRemoveDependencies.from = from;
    Args.hipGraphRemoveDependencies.to = to;
    Args.hipGraphRemoveDependencies.numDependencies = numDependencies;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphRemoveDependencies_fn(Args.hipGraphRemoveDependencies.graph, Args.hipGraphRemoveDependencies.from, Args.hipGraphRemoveDependencies.to, Args.hipGraphRemoveDependencies.numDependencies);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphRemoveDependencies_fn(graph, from, to, numDependencies);
  }
}

static hipError_t hipGraphRetainUserObject_callback(hipGraph_t graph, hipUserObject_t object, unsigned int count, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphRetainUserObject;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphRetainUserObject.graph = graph;
    Args.hipGraphRetainUserObject.object = object;
    Args.hipGraphRetainUserObject.count = count;
    Args.hipGraphRetainUserObject.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphRetainUserObject_fn(Args.hipGraphRetainUserObject.graph, Args.hipGraphRetainUserObject.object, Args.hipGraphRetainUserObject.count, Args.hipGraphRetainUserObject.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphRetainUserObject_fn(graph, object, count, flags);
  }
}

static hipError_t hipGraphUpload_callback(hipGraphExec_t graphExec, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphUpload;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphUpload.graphExec = graphExec;
    Args.hipGraphUpload.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphUpload_fn(Args.hipGraphUpload.graphExec, Args.hipGraphUpload.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphUpload_fn(graphExec, stream);
  }
}

static hipError_t hipGraphicsGLRegisterBuffer_callback(hipGraphicsResource** resource, GLuint buffer, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsGLRegisterBuffer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphicsGLRegisterBuffer.resource = resource;
    Args.hipGraphicsGLRegisterBuffer.buffer = buffer;
    Args.hipGraphicsGLRegisterBuffer.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphicsGLRegisterBuffer_fn(Args.hipGraphicsGLRegisterBuffer.resource, Args.hipGraphicsGLRegisterBuffer.buffer, Args.hipGraphicsGLRegisterBuffer.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphicsGLRegisterBuffer_fn(resource, buffer, flags);
  }
}

static hipError_t hipGraphicsGLRegisterImage_callback(hipGraphicsResource** resource, GLuint image, GLenum target, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsGLRegisterImage;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphicsGLRegisterImage.resource = resource;
    Args.hipGraphicsGLRegisterImage.image = image;
    Args.hipGraphicsGLRegisterImage.target = target;
    Args.hipGraphicsGLRegisterImage.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphicsGLRegisterImage_fn(Args.hipGraphicsGLRegisterImage.resource, Args.hipGraphicsGLRegisterImage.image, Args.hipGraphicsGLRegisterImage.target, Args.hipGraphicsGLRegisterImage.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphicsGLRegisterImage_fn(resource, image, target, flags);
  }
}

static hipError_t hipGraphicsMapResources_callback(int count, hipGraphicsResource_t* resources, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsMapResources;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphicsMapResources.count = count;
    Args.hipGraphicsMapResources.resources = resources;
    Args.hipGraphicsMapResources.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphicsMapResources_fn(Args.hipGraphicsMapResources.count, Args.hipGraphicsMapResources.resources, Args.hipGraphicsMapResources.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphicsMapResources_fn(count, resources, stream);
  }
}

static hipError_t hipGraphicsResourceGetMappedPointer_callback(void** devPtr, size_t* size, hipGraphicsResource_t resource) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsResourceGetMappedPointer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphicsResourceGetMappedPointer.devPtr = devPtr;
    Args.hipGraphicsResourceGetMappedPointer.size = size;
    Args.hipGraphicsResourceGetMappedPointer.resource = resource;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphicsResourceGetMappedPointer_fn(Args.hipGraphicsResourceGetMappedPointer.devPtr, Args.hipGraphicsResourceGetMappedPointer.size, Args.hipGraphicsResourceGetMappedPointer.resource);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphicsResourceGetMappedPointer_fn(devPtr, size, resource);
  }
}

static hipError_t hipGraphicsSubResourceGetMappedArray_callback(hipArray_t* array, hipGraphicsResource_t resource, unsigned int arrayIndex, unsigned int mipLevel) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsSubResourceGetMappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphicsSubResourceGetMappedArray.array = array;
    Args.hipGraphicsSubResourceGetMappedArray.resource = resource;
    Args.hipGraphicsSubResourceGetMappedArray.arrayIndex = arrayIndex;
    Args.hipGraphicsSubResourceGetMappedArray.mipLevel = mipLevel;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphicsSubResourceGetMappedArray_fn(Args.hipGraphicsSubResourceGetMappedArray.array, Args.hipGraphicsSubResourceGetMappedArray.resource, Args.hipGraphicsSubResourceGetMappedArray.arrayIndex, Args.hipGraphicsSubResourceGetMappedArray.mipLevel);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphicsSubResourceGetMappedArray_fn(array, resource, arrayIndex, mipLevel);
  }
}

static hipError_t hipGraphicsUnmapResources_callback(int count, hipGraphicsResource_t* resources, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsUnmapResources;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphicsUnmapResources.count = count;
    Args.hipGraphicsUnmapResources.resources = resources;
    Args.hipGraphicsUnmapResources.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphicsUnmapResources_fn(Args.hipGraphicsUnmapResources.count, Args.hipGraphicsUnmapResources.resources, Args.hipGraphicsUnmapResources.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphicsUnmapResources_fn(count, resources, stream);
  }
}

static hipError_t hipGraphicsUnregisterResource_callback(hipGraphicsResource_t resource) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphicsUnregisterResource;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphicsUnregisterResource.resource = resource;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphicsUnregisterResource_fn(Args.hipGraphicsUnregisterResource.resource);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphicsUnregisterResource_fn(resource);
  }
}

static hipError_t hipHostAlloc_callback(void** ptr, size_t size, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipHostAlloc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipHostAlloc.ptr = ptr;
    Args.hipHostAlloc.size = size;
    Args.hipHostAlloc.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipHostAlloc_fn(Args.hipHostAlloc.ptr, Args.hipHostAlloc.size, Args.hipHostAlloc.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipHostAlloc_fn(ptr, size, flags);
  }
}

static hipError_t hipHostFree_callback(void* ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipHostFree;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipHostFree.ptr = ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipHostFree_fn(Args.hipHostFree.ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipHostFree_fn(ptr);
  }
}

static hipError_t hipHostGetDevicePointer_callback(void** devPtr, void* hstPtr, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipHostGetDevicePointer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipHostGetDevicePointer.devPtr = devPtr;
    Args.hipHostGetDevicePointer.hstPtr = hstPtr;
    Args.hipHostGetDevicePointer.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipHostGetDevicePointer_fn(Args.hipHostGetDevicePointer.devPtr, Args.hipHostGetDevicePointer.hstPtr, Args.hipHostGetDevicePointer.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipHostGetDevicePointer_fn(devPtr, hstPtr, flags);
  }
}

static hipError_t hipHostGetFlags_callback(unsigned int* flagsPtr, void* hostPtr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipHostGetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipHostGetFlags.flagsPtr = flagsPtr;
    Args.hipHostGetFlags.hostPtr = hostPtr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipHostGetFlags_fn(Args.hipHostGetFlags.flagsPtr, Args.hipHostGetFlags.hostPtr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipHostGetFlags_fn(flagsPtr, hostPtr);
  }
}

static hipError_t hipHostMalloc_callback(void** ptr, size_t size, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipHostMalloc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipHostMalloc.ptr = ptr;
    Args.hipHostMalloc.size = size;
    Args.hipHostMalloc.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipHostMalloc_fn(Args.hipHostMalloc.ptr, Args.hipHostMalloc.size, Args.hipHostMalloc.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipHostMalloc_fn(ptr, size, flags);
  }
}

static hipError_t hipHostRegister_callback(void* hostPtr, size_t sizeBytes, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipHostRegister;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipHostRegister.hostPtr = hostPtr;
    Args.hipHostRegister.sizeBytes = sizeBytes;
    Args.hipHostRegister.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipHostRegister_fn(Args.hipHostRegister.hostPtr, Args.hipHostRegister.sizeBytes, Args.hipHostRegister.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipHostRegister_fn(hostPtr, sizeBytes, flags);
  }
}

static hipError_t hipHostUnregister_callback(void* hostPtr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipHostUnregister;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipHostUnregister.hostPtr = hostPtr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipHostUnregister_fn(Args.hipHostUnregister.hostPtr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipHostUnregister_fn(hostPtr);
  }
}

static hipError_t hipImportExternalMemory_callback(hipExternalMemory_t* extMem_out, const hipExternalMemoryHandleDesc* memHandleDesc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipImportExternalMemory;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipImportExternalMemory.extMem_out = extMem_out;
    Args.hipImportExternalMemory.memHandleDesc = memHandleDesc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipImportExternalMemory_fn(Args.hipImportExternalMemory.extMem_out, Args.hipImportExternalMemory.memHandleDesc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipImportExternalMemory_fn(extMem_out, memHandleDesc);
  }
}

static hipError_t hipImportExternalSemaphore_callback(hipExternalSemaphore_t* extSem_out, const hipExternalSemaphoreHandleDesc* semHandleDesc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipImportExternalSemaphore;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipImportExternalSemaphore.extSem_out = extSem_out;
    Args.hipImportExternalSemaphore.semHandleDesc = semHandleDesc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipImportExternalSemaphore_fn(Args.hipImportExternalSemaphore.extSem_out, Args.hipImportExternalSemaphore.semHandleDesc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipImportExternalSemaphore_fn(extSem_out, semHandleDesc);
  }
}

static hipError_t hipInit_callback(unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipInit;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipInit.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipInit_fn(Args.hipInit.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipInit_fn(flags);
  }
}

static hipError_t hipIpcCloseMemHandle_callback(void* devPtr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipIpcCloseMemHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipIpcCloseMemHandle.devPtr = devPtr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipIpcCloseMemHandle_fn(Args.hipIpcCloseMemHandle.devPtr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipIpcCloseMemHandle_fn(devPtr);
  }
}

static hipError_t hipIpcGetEventHandle_callback(hipIpcEventHandle_t* handle, hipEvent_t event) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipIpcGetEventHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipIpcGetEventHandle.handle = handle;
    Args.hipIpcGetEventHandle.event = event;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipIpcGetEventHandle_fn(Args.hipIpcGetEventHandle.handle, Args.hipIpcGetEventHandle.event);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipIpcGetEventHandle_fn(handle, event);
  }
}

static hipError_t hipIpcGetMemHandle_callback(hipIpcMemHandle_t* handle, void* devPtr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipIpcGetMemHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipIpcGetMemHandle.handle = handle;
    Args.hipIpcGetMemHandle.devPtr = devPtr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipIpcGetMemHandle_fn(Args.hipIpcGetMemHandle.handle, Args.hipIpcGetMemHandle.devPtr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipIpcGetMemHandle_fn(handle, devPtr);
  }
}

static hipError_t hipIpcOpenEventHandle_callback(hipEvent_t* event, hipIpcEventHandle_t handle) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipIpcOpenEventHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipIpcOpenEventHandle.event = event;
    Args.hipIpcOpenEventHandle.handle = handle;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipIpcOpenEventHandle_fn(Args.hipIpcOpenEventHandle.event, Args.hipIpcOpenEventHandle.handle);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipIpcOpenEventHandle_fn(event, handle);
  }
}

static hipError_t hipIpcOpenMemHandle_callback(void** devPtr, hipIpcMemHandle_t handle, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipIpcOpenMemHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipIpcOpenMemHandle.devPtr = devPtr;
    Args.hipIpcOpenMemHandle.handle = handle;
    Args.hipIpcOpenMemHandle.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipIpcOpenMemHandle_fn(Args.hipIpcOpenMemHandle.devPtr, Args.hipIpcOpenMemHandle.handle, Args.hipIpcOpenMemHandle.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipIpcOpenMemHandle_fn(devPtr, handle, flags);
  }
}

static const char* hipKernelNameRef_callback(const hipFunction_t f) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipKernelNameRef;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    const char* Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipKernelNameRef.f = f;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipKernelNameRef_fn(Args.hipKernelNameRef.f);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipKernelNameRef_fn(f);
  }
}

static const char* hipKernelNameRefByPtr_callback(const void* hostFunction, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipKernelNameRefByPtr;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    const char* Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipKernelNameRefByPtr.hostFunction = hostFunction;
    Args.hipKernelNameRefByPtr.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipKernelNameRefByPtr_fn(Args.hipKernelNameRefByPtr.hostFunction, Args.hipKernelNameRefByPtr.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipKernelNameRefByPtr_fn(hostFunction, stream);
  }
}

static hipError_t hipLaunchByPtr_callback(const void* func) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchByPtr;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipLaunchByPtr.func = func;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipLaunchByPtr_fn(Args.hipLaunchByPtr.func);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipLaunchByPtr_fn(func);
  }
}

static hipError_t hipLaunchCooperativeKernel_callback(const void* f, dim3 gridDim, dim3 blockDimX, void** kernelParams, unsigned int sharedMemBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchCooperativeKernel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipLaunchCooperativeKernel.f = f;
    Args.hipLaunchCooperativeKernel.gridDim = gridDim;
    Args.hipLaunchCooperativeKernel.blockDimX = blockDimX;
    Args.hipLaunchCooperativeKernel.kernelParams = kernelParams;
    Args.hipLaunchCooperativeKernel.sharedMemBytes = sharedMemBytes;
    Args.hipLaunchCooperativeKernel.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipLaunchCooperativeKernel_fn(Args.hipLaunchCooperativeKernel.f, Args.hipLaunchCooperativeKernel.gridDim, Args.hipLaunchCooperativeKernel.blockDimX, Args.hipLaunchCooperativeKernel.kernelParams, Args.hipLaunchCooperativeKernel.sharedMemBytes, Args.hipLaunchCooperativeKernel.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipLaunchCooperativeKernel_fn(f, gridDim, blockDimX, kernelParams, sharedMemBytes, stream);
  }
}

static hipError_t hipLaunchCooperativeKernelMultiDevice_callback(hipLaunchParams* launchParamsList, int numDevices, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchCooperativeKernelMultiDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipLaunchCooperativeKernelMultiDevice.launchParamsList = launchParamsList;
    Args.hipLaunchCooperativeKernelMultiDevice.numDevices = numDevices;
    Args.hipLaunchCooperativeKernelMultiDevice.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipLaunchCooperativeKernelMultiDevice_fn(Args.hipLaunchCooperativeKernelMultiDevice.launchParamsList, Args.hipLaunchCooperativeKernelMultiDevice.numDevices, Args.hipLaunchCooperativeKernelMultiDevice.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipLaunchCooperativeKernelMultiDevice_fn(launchParamsList, numDevices, flags);
  }
}

static hipError_t hipLaunchHostFunc_callback(hipStream_t stream, hipHostFn_t fn, void* userData) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchHostFunc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipLaunchHostFunc.stream = stream;
    Args.hipLaunchHostFunc.fn = fn;
    Args.hipLaunchHostFunc.userData = userData;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipLaunchHostFunc_fn(Args.hipLaunchHostFunc.stream, Args.hipLaunchHostFunc.fn, Args.hipLaunchHostFunc.userData);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipLaunchHostFunc_fn(stream, fn, userData);
  }
}

static hipError_t hipLaunchKernel_callback(const void* function_address, dim3 numBlocks, dim3 dimBlocks, void** args, size_t sharedMemBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchKernel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipLaunchKernel.function_address = function_address;
    Args.hipLaunchKernel.numBlocks = numBlocks;
    Args.hipLaunchKernel.dimBlocks = dimBlocks;
    Args.hipLaunchKernel.args = args;
    Args.hipLaunchKernel.sharedMemBytes = sharedMemBytes;
    Args.hipLaunchKernel.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipLaunchKernel_fn(Args.hipLaunchKernel.function_address, Args.hipLaunchKernel.numBlocks, Args.hipLaunchKernel.dimBlocks, Args.hipLaunchKernel.args, Args.hipLaunchKernel.sharedMemBytes, Args.hipLaunchKernel.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipLaunchKernel_fn(function_address, numBlocks, dimBlocks, args, sharedMemBytes, stream);
  }
}

static hipError_t hipMalloc_callback(void** ptr, size_t size) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMalloc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMalloc.ptr = ptr;
    Args.hipMalloc.size = size;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMalloc_fn(Args.hipMalloc.ptr, Args.hipMalloc.size);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMalloc_fn(ptr, size);
  }
}

static hipError_t hipMalloc3D_callback(hipPitchedPtr* pitchedDevPtr, hipExtent extent) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMalloc3D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMalloc3D.pitchedDevPtr = pitchedDevPtr;
    Args.hipMalloc3D.extent = extent;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMalloc3D_fn(Args.hipMalloc3D.pitchedDevPtr, Args.hipMalloc3D.extent);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMalloc3D_fn(pitchedDevPtr, extent);
  }
}

static hipError_t hipMalloc3DArray_callback(hipArray_t* array, const struct hipChannelFormatDesc* desc, struct hipExtent extent, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMalloc3DArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMalloc3DArray.array = array;
    Args.hipMalloc3DArray.desc = desc;
    Args.hipMalloc3DArray.extent = extent;
    Args.hipMalloc3DArray.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMalloc3DArray_fn(Args.hipMalloc3DArray.array, Args.hipMalloc3DArray.desc, Args.hipMalloc3DArray.extent, Args.hipMalloc3DArray.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMalloc3DArray_fn(array, desc, extent, flags);
  }
}

static hipError_t hipMallocArray_callback(hipArray_t* array, const hipChannelFormatDesc* desc, size_t width, size_t height, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMallocArray.array = array;
    Args.hipMallocArray.desc = desc;
    Args.hipMallocArray.width = width;
    Args.hipMallocArray.height = height;
    Args.hipMallocArray.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMallocArray_fn(Args.hipMallocArray.array, Args.hipMallocArray.desc, Args.hipMallocArray.width, Args.hipMallocArray.height, Args.hipMallocArray.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMallocArray_fn(array, desc, width, height, flags);
  }
}

static hipError_t hipMallocAsync_callback(void** dev_ptr, size_t size, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMallocAsync.dev_ptr = dev_ptr;
    Args.hipMallocAsync.size = size;
    Args.hipMallocAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMallocAsync_fn(Args.hipMallocAsync.dev_ptr, Args.hipMallocAsync.size, Args.hipMallocAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMallocAsync_fn(dev_ptr, size, stream);
  }
}

static hipError_t hipMallocFromPoolAsync_callback(void** dev_ptr, size_t size, hipMemPool_t mem_pool, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocFromPoolAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMallocFromPoolAsync.dev_ptr = dev_ptr;
    Args.hipMallocFromPoolAsync.size = size;
    Args.hipMallocFromPoolAsync.mem_pool = mem_pool;
    Args.hipMallocFromPoolAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMallocFromPoolAsync_fn(Args.hipMallocFromPoolAsync.dev_ptr, Args.hipMallocFromPoolAsync.size, Args.hipMallocFromPoolAsync.mem_pool, Args.hipMallocFromPoolAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMallocFromPoolAsync_fn(dev_ptr, size, mem_pool, stream);
  }
}

static hipError_t hipMallocHost_callback(void** ptr, size_t size) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocHost;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMallocHost.ptr = ptr;
    Args.hipMallocHost.size = size;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMallocHost_fn(Args.hipMallocHost.ptr, Args.hipMallocHost.size);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMallocHost_fn(ptr, size);
  }
}

static hipError_t hipMallocManaged_callback(void** dev_ptr, size_t size, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocManaged;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMallocManaged.dev_ptr = dev_ptr;
    Args.hipMallocManaged.size = size;
    Args.hipMallocManaged.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMallocManaged_fn(Args.hipMallocManaged.dev_ptr, Args.hipMallocManaged.size, Args.hipMallocManaged.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMallocManaged_fn(dev_ptr, size, flags);
  }
}

static hipError_t hipMallocMipmappedArray_callback(hipMipmappedArray_t* mipmappedArray, const struct hipChannelFormatDesc* desc, struct hipExtent extent, unsigned int numLevels, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocMipmappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMallocMipmappedArray.mipmappedArray = mipmappedArray;
    Args.hipMallocMipmappedArray.desc = desc;
    Args.hipMallocMipmappedArray.extent = extent;
    Args.hipMallocMipmappedArray.numLevels = numLevels;
    Args.hipMallocMipmappedArray.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMallocMipmappedArray_fn(Args.hipMallocMipmappedArray.mipmappedArray, Args.hipMallocMipmappedArray.desc, Args.hipMallocMipmappedArray.extent, Args.hipMallocMipmappedArray.numLevels, Args.hipMallocMipmappedArray.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMallocMipmappedArray_fn(mipmappedArray, desc, extent, numLevels, flags);
  }
}

static hipError_t hipMallocPitch_callback(void** ptr, size_t* pitch, size_t width, size_t height) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMallocPitch;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMallocPitch.ptr = ptr;
    Args.hipMallocPitch.pitch = pitch;
    Args.hipMallocPitch.width = width;
    Args.hipMallocPitch.height = height;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMallocPitch_fn(Args.hipMallocPitch.ptr, Args.hipMallocPitch.pitch, Args.hipMallocPitch.width, Args.hipMallocPitch.height);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMallocPitch_fn(ptr, pitch, width, height);
  }
}

static hipError_t hipMemAddressFree_callback(void* devPtr, size_t size) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemAddressFree;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemAddressFree.devPtr = devPtr;
    Args.hipMemAddressFree.size = size;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemAddressFree_fn(Args.hipMemAddressFree.devPtr, Args.hipMemAddressFree.size);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemAddressFree_fn(devPtr, size);
  }
}

static hipError_t hipMemAddressReserve_callback(void** ptr, size_t size, size_t alignment, void* addr, unsigned long long flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemAddressReserve;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemAddressReserve.ptr = ptr;
    Args.hipMemAddressReserve.size = size;
    Args.hipMemAddressReserve.alignment = alignment;
    Args.hipMemAddressReserve.addr = addr;
    Args.hipMemAddressReserve.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemAddressReserve_fn(Args.hipMemAddressReserve.ptr, Args.hipMemAddressReserve.size, Args.hipMemAddressReserve.alignment, Args.hipMemAddressReserve.addr, Args.hipMemAddressReserve.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemAddressReserve_fn(ptr, size, alignment, addr, flags);
  }
}

static hipError_t hipMemAdvise_callback(const void* dev_ptr, size_t count, hipMemoryAdvise advice, int device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemAdvise;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemAdvise.dev_ptr = dev_ptr;
    Args.hipMemAdvise.count = count;
    Args.hipMemAdvise.advice = advice;
    Args.hipMemAdvise.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemAdvise_fn(Args.hipMemAdvise.dev_ptr, Args.hipMemAdvise.count, Args.hipMemAdvise.advice, Args.hipMemAdvise.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemAdvise_fn(dev_ptr, count, advice, device);
  }
}

static hipError_t hipMemAllocHost_callback(void** ptr, size_t size) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemAllocHost;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemAllocHost.ptr = ptr;
    Args.hipMemAllocHost.size = size;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemAllocHost_fn(Args.hipMemAllocHost.ptr, Args.hipMemAllocHost.size);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemAllocHost_fn(ptr, size);
  }
}

static hipError_t hipMemAllocPitch_callback(hipDeviceptr_t* dptr, size_t* pitch, size_t widthInBytes, size_t height, unsigned int elementSizeBytes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemAllocPitch;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemAllocPitch.dptr = dptr;
    Args.hipMemAllocPitch.pitch = pitch;
    Args.hipMemAllocPitch.widthInBytes = widthInBytes;
    Args.hipMemAllocPitch.height = height;
    Args.hipMemAllocPitch.elementSizeBytes = elementSizeBytes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemAllocPitch_fn(Args.hipMemAllocPitch.dptr, Args.hipMemAllocPitch.pitch, Args.hipMemAllocPitch.widthInBytes, Args.hipMemAllocPitch.height, Args.hipMemAllocPitch.elementSizeBytes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemAllocPitch_fn(dptr, pitch, widthInBytes, height, elementSizeBytes);
  }
}

static hipError_t hipMemCreate_callback(hipMemGenericAllocationHandle_t* handle, size_t size, const hipMemAllocationProp* prop, unsigned long long flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemCreate.handle = handle;
    Args.hipMemCreate.size = size;
    Args.hipMemCreate.prop = prop;
    Args.hipMemCreate.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemCreate_fn(Args.hipMemCreate.handle, Args.hipMemCreate.size, Args.hipMemCreate.prop, Args.hipMemCreate.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemCreate_fn(handle, size, prop, flags);
  }
}

static hipError_t hipMemExportToShareableHandle_callback(void* shareableHandle, hipMemGenericAllocationHandle_t handle, hipMemAllocationHandleType handleType, unsigned long long flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemExportToShareableHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemExportToShareableHandle.shareableHandle = shareableHandle;
    Args.hipMemExportToShareableHandle.handle = handle;
    Args.hipMemExportToShareableHandle.handleType = handleType;
    Args.hipMemExportToShareableHandle.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemExportToShareableHandle_fn(Args.hipMemExportToShareableHandle.shareableHandle, Args.hipMemExportToShareableHandle.handle, Args.hipMemExportToShareableHandle.handleType, Args.hipMemExportToShareableHandle.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemExportToShareableHandle_fn(shareableHandle, handle, handleType, flags);
  }
}

static hipError_t hipMemGetAccess_callback(unsigned long long* flags, const hipMemLocation* location, void* ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemGetAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemGetAccess.flags = flags;
    Args.hipMemGetAccess.location = location;
    Args.hipMemGetAccess.ptr = ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemGetAccess_fn(Args.hipMemGetAccess.flags, Args.hipMemGetAccess.location, Args.hipMemGetAccess.ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemGetAccess_fn(flags, location, ptr);
  }
}

static hipError_t hipMemGetAddressRange_callback(hipDeviceptr_t* pbase, size_t* psize, hipDeviceptr_t dptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemGetAddressRange;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemGetAddressRange.pbase = pbase;
    Args.hipMemGetAddressRange.psize = psize;
    Args.hipMemGetAddressRange.dptr = dptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemGetAddressRange_fn(Args.hipMemGetAddressRange.pbase, Args.hipMemGetAddressRange.psize, Args.hipMemGetAddressRange.dptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemGetAddressRange_fn(pbase, psize, dptr);
  }
}

static hipError_t hipMemGetAllocationGranularity_callback(size_t* granularity, const hipMemAllocationProp* prop, hipMemAllocationGranularity_flags option) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemGetAllocationGranularity;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemGetAllocationGranularity.granularity = granularity;
    Args.hipMemGetAllocationGranularity.prop = prop;
    Args.hipMemGetAllocationGranularity.option = option;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemGetAllocationGranularity_fn(Args.hipMemGetAllocationGranularity.granularity, Args.hipMemGetAllocationGranularity.prop, Args.hipMemGetAllocationGranularity.option);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemGetAllocationGranularity_fn(granularity, prop, option);
  }
}

static hipError_t hipMemGetAllocationPropertiesFromHandle_callback(hipMemAllocationProp* prop, hipMemGenericAllocationHandle_t handle) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemGetAllocationPropertiesFromHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemGetAllocationPropertiesFromHandle.prop = prop;
    Args.hipMemGetAllocationPropertiesFromHandle.handle = handle;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemGetAllocationPropertiesFromHandle_fn(Args.hipMemGetAllocationPropertiesFromHandle.prop, Args.hipMemGetAllocationPropertiesFromHandle.handle);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemGetAllocationPropertiesFromHandle_fn(prop, handle);
  }
}

static hipError_t hipMemGetInfo_callback(size_t* free, size_t* total) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemGetInfo;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemGetInfo.free = free;
    Args.hipMemGetInfo.total = total;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemGetInfo_fn(Args.hipMemGetInfo.free, Args.hipMemGetInfo.total);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemGetInfo_fn(free, total);
  }
}

static hipError_t hipMemImportFromShareableHandle_callback(hipMemGenericAllocationHandle_t* handle, void* osHandle, hipMemAllocationHandleType shHandleType) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemImportFromShareableHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemImportFromShareableHandle.handle = handle;
    Args.hipMemImportFromShareableHandle.osHandle = osHandle;
    Args.hipMemImportFromShareableHandle.shHandleType = shHandleType;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemImportFromShareableHandle_fn(Args.hipMemImportFromShareableHandle.handle, Args.hipMemImportFromShareableHandle.osHandle, Args.hipMemImportFromShareableHandle.shHandleType);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemImportFromShareableHandle_fn(handle, osHandle, shHandleType);
  }
}

static hipError_t hipMemMap_callback(void* ptr, size_t size, size_t offset, hipMemGenericAllocationHandle_t handle, unsigned long long flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemMap;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemMap.ptr = ptr;
    Args.hipMemMap.size = size;
    Args.hipMemMap.offset = offset;
    Args.hipMemMap.handle = handle;
    Args.hipMemMap.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemMap_fn(Args.hipMemMap.ptr, Args.hipMemMap.size, Args.hipMemMap.offset, Args.hipMemMap.handle, Args.hipMemMap.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemMap_fn(ptr, size, offset, handle, flags);
  }
}

static hipError_t hipMemMapArrayAsync_callback(hipArrayMapInfo* mapInfoList, unsigned int count, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemMapArrayAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemMapArrayAsync.mapInfoList = mapInfoList;
    Args.hipMemMapArrayAsync.count = count;
    Args.hipMemMapArrayAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemMapArrayAsync_fn(Args.hipMemMapArrayAsync.mapInfoList, Args.hipMemMapArrayAsync.count, Args.hipMemMapArrayAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemMapArrayAsync_fn(mapInfoList, count, stream);
  }
}

static hipError_t hipMemPoolCreate_callback(hipMemPool_t* mem_pool, const hipMemPoolProps* pool_props) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolCreate.mem_pool = mem_pool;
    Args.hipMemPoolCreate.pool_props = pool_props;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolCreate_fn(Args.hipMemPoolCreate.mem_pool, Args.hipMemPoolCreate.pool_props);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolCreate_fn(mem_pool, pool_props);
  }
}

static hipError_t hipMemPoolDestroy_callback(hipMemPool_t mem_pool) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolDestroy.mem_pool = mem_pool;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolDestroy_fn(Args.hipMemPoolDestroy.mem_pool);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolDestroy_fn(mem_pool);
  }
}

static hipError_t hipMemPoolExportPointer_callback(hipMemPoolPtrExportData* export_data, void* dev_ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolExportPointer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolExportPointer.export_data = export_data;
    Args.hipMemPoolExportPointer.dev_ptr = dev_ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolExportPointer_fn(Args.hipMemPoolExportPointer.export_data, Args.hipMemPoolExportPointer.dev_ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolExportPointer_fn(export_data, dev_ptr);
  }
}

static hipError_t hipMemPoolExportToShareableHandle_callback(void* shared_handle, hipMemPool_t mem_pool, hipMemAllocationHandleType handle_type, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolExportToShareableHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolExportToShareableHandle.shared_handle = shared_handle;
    Args.hipMemPoolExportToShareableHandle.mem_pool = mem_pool;
    Args.hipMemPoolExportToShareableHandle.handle_type = handle_type;
    Args.hipMemPoolExportToShareableHandle.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolExportToShareableHandle_fn(Args.hipMemPoolExportToShareableHandle.shared_handle, Args.hipMemPoolExportToShareableHandle.mem_pool, Args.hipMemPoolExportToShareableHandle.handle_type, Args.hipMemPoolExportToShareableHandle.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolExportToShareableHandle_fn(shared_handle, mem_pool, handle_type, flags);
  }
}

static hipError_t hipMemPoolGetAccess_callback(hipMemAccessFlags* flags, hipMemPool_t mem_pool, hipMemLocation* location) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolGetAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolGetAccess.flags = flags;
    Args.hipMemPoolGetAccess.mem_pool = mem_pool;
    Args.hipMemPoolGetAccess.location = location;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolGetAccess_fn(Args.hipMemPoolGetAccess.flags, Args.hipMemPoolGetAccess.mem_pool, Args.hipMemPoolGetAccess.location);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolGetAccess_fn(flags, mem_pool, location);
  }
}

static hipError_t hipMemPoolGetAttribute_callback(hipMemPool_t mem_pool, hipMemPoolAttr attr, void* value) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolGetAttribute.mem_pool = mem_pool;
    Args.hipMemPoolGetAttribute.attr = attr;
    Args.hipMemPoolGetAttribute.value = value;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolGetAttribute_fn(Args.hipMemPoolGetAttribute.mem_pool, Args.hipMemPoolGetAttribute.attr, Args.hipMemPoolGetAttribute.value);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolGetAttribute_fn(mem_pool, attr, value);
  }
}

static hipError_t hipMemPoolImportFromShareableHandle_callback(hipMemPool_t* mem_pool, void* shared_handle, hipMemAllocationHandleType handle_type, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolImportFromShareableHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolImportFromShareableHandle.mem_pool = mem_pool;
    Args.hipMemPoolImportFromShareableHandle.shared_handle = shared_handle;
    Args.hipMemPoolImportFromShareableHandle.handle_type = handle_type;
    Args.hipMemPoolImportFromShareableHandle.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolImportFromShareableHandle_fn(Args.hipMemPoolImportFromShareableHandle.mem_pool, Args.hipMemPoolImportFromShareableHandle.shared_handle, Args.hipMemPoolImportFromShareableHandle.handle_type, Args.hipMemPoolImportFromShareableHandle.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolImportFromShareableHandle_fn(mem_pool, shared_handle, handle_type, flags);
  }
}

static hipError_t hipMemPoolImportPointer_callback(void** dev_ptr, hipMemPool_t mem_pool, hipMemPoolPtrExportData* export_data) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolImportPointer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolImportPointer.dev_ptr = dev_ptr;
    Args.hipMemPoolImportPointer.mem_pool = mem_pool;
    Args.hipMemPoolImportPointer.export_data = export_data;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolImportPointer_fn(Args.hipMemPoolImportPointer.dev_ptr, Args.hipMemPoolImportPointer.mem_pool, Args.hipMemPoolImportPointer.export_data);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolImportPointer_fn(dev_ptr, mem_pool, export_data);
  }
}

static hipError_t hipMemPoolSetAccess_callback(hipMemPool_t mem_pool, const hipMemAccessDesc* desc_list, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolSetAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolSetAccess.mem_pool = mem_pool;
    Args.hipMemPoolSetAccess.desc_list = desc_list;
    Args.hipMemPoolSetAccess.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolSetAccess_fn(Args.hipMemPoolSetAccess.mem_pool, Args.hipMemPoolSetAccess.desc_list, Args.hipMemPoolSetAccess.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolSetAccess_fn(mem_pool, desc_list, count);
  }
}

static hipError_t hipMemPoolSetAttribute_callback(hipMemPool_t mem_pool, hipMemPoolAttr attr, void* value) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolSetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolSetAttribute.mem_pool = mem_pool;
    Args.hipMemPoolSetAttribute.attr = attr;
    Args.hipMemPoolSetAttribute.value = value;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolSetAttribute_fn(Args.hipMemPoolSetAttribute.mem_pool, Args.hipMemPoolSetAttribute.attr, Args.hipMemPoolSetAttribute.value);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolSetAttribute_fn(mem_pool, attr, value);
  }
}

static hipError_t hipMemPoolTrimTo_callback(hipMemPool_t mem_pool, size_t min_bytes_to_hold) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPoolTrimTo;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPoolTrimTo.mem_pool = mem_pool;
    Args.hipMemPoolTrimTo.min_bytes_to_hold = min_bytes_to_hold;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPoolTrimTo_fn(Args.hipMemPoolTrimTo.mem_pool, Args.hipMemPoolTrimTo.min_bytes_to_hold);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPoolTrimTo_fn(mem_pool, min_bytes_to_hold);
  }
}

static hipError_t hipMemPrefetchAsync_callback(const void* dev_ptr, size_t count, int device, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPrefetchAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPrefetchAsync.dev_ptr = dev_ptr;
    Args.hipMemPrefetchAsync.count = count;
    Args.hipMemPrefetchAsync.device = device;
    Args.hipMemPrefetchAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPrefetchAsync_fn(Args.hipMemPrefetchAsync.dev_ptr, Args.hipMemPrefetchAsync.count, Args.hipMemPrefetchAsync.device, Args.hipMemPrefetchAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPrefetchAsync_fn(dev_ptr, count, device, stream);
  }
}

static hipError_t hipMemPtrGetInfo_callback(void* ptr, size_t* size) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemPtrGetInfo;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemPtrGetInfo.ptr = ptr;
    Args.hipMemPtrGetInfo.size = size;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemPtrGetInfo_fn(Args.hipMemPtrGetInfo.ptr, Args.hipMemPtrGetInfo.size);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemPtrGetInfo_fn(ptr, size);
  }
}

static hipError_t hipMemRangeGetAttribute_callback(void* data, size_t data_size, hipMemRangeAttribute attribute, const void* dev_ptr, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemRangeGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemRangeGetAttribute.data = data;
    Args.hipMemRangeGetAttribute.data_size = data_size;
    Args.hipMemRangeGetAttribute.attribute = attribute;
    Args.hipMemRangeGetAttribute.dev_ptr = dev_ptr;
    Args.hipMemRangeGetAttribute.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemRangeGetAttribute_fn(Args.hipMemRangeGetAttribute.data, Args.hipMemRangeGetAttribute.data_size, Args.hipMemRangeGetAttribute.attribute, Args.hipMemRangeGetAttribute.dev_ptr, Args.hipMemRangeGetAttribute.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemRangeGetAttribute_fn(data, data_size, attribute, dev_ptr, count);
  }
}

static hipError_t hipMemRangeGetAttributes_callback(void** data, size_t* data_sizes, hipMemRangeAttribute* attributes, size_t num_attributes, const void* dev_ptr, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemRangeGetAttributes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemRangeGetAttributes.data = data;
    Args.hipMemRangeGetAttributes.data_sizes = data_sizes;
    Args.hipMemRangeGetAttributes.attributes = attributes;
    Args.hipMemRangeGetAttributes.num_attributes = num_attributes;
    Args.hipMemRangeGetAttributes.dev_ptr = dev_ptr;
    Args.hipMemRangeGetAttributes.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemRangeGetAttributes_fn(Args.hipMemRangeGetAttributes.data, Args.hipMemRangeGetAttributes.data_sizes, Args.hipMemRangeGetAttributes.attributes, Args.hipMemRangeGetAttributes.num_attributes, Args.hipMemRangeGetAttributes.dev_ptr, Args.hipMemRangeGetAttributes.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemRangeGetAttributes_fn(data, data_sizes, attributes, num_attributes, dev_ptr, count);
  }
}

static hipError_t hipMemRelease_callback(hipMemGenericAllocationHandle_t handle) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemRelease;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemRelease.handle = handle;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemRelease_fn(Args.hipMemRelease.handle);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemRelease_fn(handle);
  }
}

static hipError_t hipMemRetainAllocationHandle_callback(hipMemGenericAllocationHandle_t* handle, void* addr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemRetainAllocationHandle;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemRetainAllocationHandle.handle = handle;
    Args.hipMemRetainAllocationHandle.addr = addr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemRetainAllocationHandle_fn(Args.hipMemRetainAllocationHandle.handle, Args.hipMemRetainAllocationHandle.addr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemRetainAllocationHandle_fn(handle, addr);
  }
}

static hipError_t hipMemSetAccess_callback(void* ptr, size_t size, const hipMemAccessDesc* desc, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemSetAccess;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemSetAccess.ptr = ptr;
    Args.hipMemSetAccess.size = size;
    Args.hipMemSetAccess.desc = desc;
    Args.hipMemSetAccess.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemSetAccess_fn(Args.hipMemSetAccess.ptr, Args.hipMemSetAccess.size, Args.hipMemSetAccess.desc, Args.hipMemSetAccess.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemSetAccess_fn(ptr, size, desc, count);
  }
}

static hipError_t hipMemUnmap_callback(void* ptr, size_t size) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemUnmap;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemUnmap.ptr = ptr;
    Args.hipMemUnmap.size = size;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemUnmap_fn(Args.hipMemUnmap.ptr, Args.hipMemUnmap.size);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemUnmap_fn(ptr, size);
  }
}

static hipError_t hipMemcpy_callback(void* dst, const void* src, size_t sizeBytes, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy.dst = dst;
    Args.hipMemcpy.src = src;
    Args.hipMemcpy.sizeBytes = sizeBytes;
    Args.hipMemcpy.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy_fn(Args.hipMemcpy.dst, Args.hipMemcpy.src, Args.hipMemcpy.sizeBytes, Args.hipMemcpy.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy_fn(dst, src, sizeBytes, kind);
  }
}

static hipError_t hipMemcpy2D_callback(void* dst, size_t dpitch, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2D.dst = dst;
    Args.hipMemcpy2D.dpitch = dpitch;
    Args.hipMemcpy2D.src = src;
    Args.hipMemcpy2D.spitch = spitch;
    Args.hipMemcpy2D.width = width;
    Args.hipMemcpy2D.height = height;
    Args.hipMemcpy2D.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2D_fn(Args.hipMemcpy2D.dst, Args.hipMemcpy2D.dpitch, Args.hipMemcpy2D.src, Args.hipMemcpy2D.spitch, Args.hipMemcpy2D.width, Args.hipMemcpy2D.height, Args.hipMemcpy2D.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2D_fn(dst, dpitch, src, spitch, width, height, kind);
  }
}

static hipError_t hipMemcpy2DAsync_callback(void* dst, size_t dpitch, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DAsync.dst = dst;
    Args.hipMemcpy2DAsync.dpitch = dpitch;
    Args.hipMemcpy2DAsync.src = src;
    Args.hipMemcpy2DAsync.spitch = spitch;
    Args.hipMemcpy2DAsync.width = width;
    Args.hipMemcpy2DAsync.height = height;
    Args.hipMemcpy2DAsync.kind = kind;
    Args.hipMemcpy2DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DAsync_fn(Args.hipMemcpy2DAsync.dst, Args.hipMemcpy2DAsync.dpitch, Args.hipMemcpy2DAsync.src, Args.hipMemcpy2DAsync.spitch, Args.hipMemcpy2DAsync.width, Args.hipMemcpy2DAsync.height, Args.hipMemcpy2DAsync.kind, Args.hipMemcpy2DAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DAsync_fn(dst, dpitch, src, spitch, width, height, kind, stream);
  }
}

static hipError_t hipMemcpy2DFromArray_callback(void* dst, size_t dpitch, hipArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DFromArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DFromArray.dst = dst;
    Args.hipMemcpy2DFromArray.dpitch = dpitch;
    Args.hipMemcpy2DFromArray.src = src;
    Args.hipMemcpy2DFromArray.wOffset = wOffset;
    Args.hipMemcpy2DFromArray.hOffset = hOffset;
    Args.hipMemcpy2DFromArray.width = width;
    Args.hipMemcpy2DFromArray.height = height;
    Args.hipMemcpy2DFromArray.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DFromArray_fn(Args.hipMemcpy2DFromArray.dst, Args.hipMemcpy2DFromArray.dpitch, Args.hipMemcpy2DFromArray.src, Args.hipMemcpy2DFromArray.wOffset, Args.hipMemcpy2DFromArray.hOffset, Args.hipMemcpy2DFromArray.width, Args.hipMemcpy2DFromArray.height, Args.hipMemcpy2DFromArray.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DFromArray_fn(dst, dpitch, src, wOffset, hOffset, width, height, kind);
  }
}

static hipError_t hipMemcpy2DFromArrayAsync_callback(void* dst, size_t dpitch, hipArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DFromArrayAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DFromArrayAsync.dst = dst;
    Args.hipMemcpy2DFromArrayAsync.dpitch = dpitch;
    Args.hipMemcpy2DFromArrayAsync.src = src;
    Args.hipMemcpy2DFromArrayAsync.wOffset = wOffset;
    Args.hipMemcpy2DFromArrayAsync.hOffset = hOffset;
    Args.hipMemcpy2DFromArrayAsync.width = width;
    Args.hipMemcpy2DFromArrayAsync.height = height;
    Args.hipMemcpy2DFromArrayAsync.kind = kind;
    Args.hipMemcpy2DFromArrayAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DFromArrayAsync_fn(Args.hipMemcpy2DFromArrayAsync.dst, Args.hipMemcpy2DFromArrayAsync.dpitch, Args.hipMemcpy2DFromArrayAsync.src, Args.hipMemcpy2DFromArrayAsync.wOffset, Args.hipMemcpy2DFromArrayAsync.hOffset, Args.hipMemcpy2DFromArrayAsync.width, Args.hipMemcpy2DFromArrayAsync.height, Args.hipMemcpy2DFromArrayAsync.kind, Args.hipMemcpy2DFromArrayAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DFromArrayAsync_fn(dst, dpitch, src, wOffset, hOffset, width, height, kind, stream);
  }
}

static hipError_t hipMemcpy2DToArray_callback(hipArray_t dst, size_t wOffset, size_t hOffset, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DToArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DToArray.dst = dst;
    Args.hipMemcpy2DToArray.wOffset = wOffset;
    Args.hipMemcpy2DToArray.hOffset = hOffset;
    Args.hipMemcpy2DToArray.src = src;
    Args.hipMemcpy2DToArray.spitch = spitch;
    Args.hipMemcpy2DToArray.width = width;
    Args.hipMemcpy2DToArray.height = height;
    Args.hipMemcpy2DToArray.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DToArray_fn(Args.hipMemcpy2DToArray.dst, Args.hipMemcpy2DToArray.wOffset, Args.hipMemcpy2DToArray.hOffset, Args.hipMemcpy2DToArray.src, Args.hipMemcpy2DToArray.spitch, Args.hipMemcpy2DToArray.width, Args.hipMemcpy2DToArray.height, Args.hipMemcpy2DToArray.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DToArray_fn(dst, wOffset, hOffset, src, spitch, width, height, kind);
  }
}

static hipError_t hipMemcpy2DToArrayAsync_callback(hipArray_t dst, size_t wOffset, size_t hOffset, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DToArrayAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DToArrayAsync.dst = dst;
    Args.hipMemcpy2DToArrayAsync.wOffset = wOffset;
    Args.hipMemcpy2DToArrayAsync.hOffset = hOffset;
    Args.hipMemcpy2DToArrayAsync.src = src;
    Args.hipMemcpy2DToArrayAsync.spitch = spitch;
    Args.hipMemcpy2DToArrayAsync.width = width;
    Args.hipMemcpy2DToArrayAsync.height = height;
    Args.hipMemcpy2DToArrayAsync.kind = kind;
    Args.hipMemcpy2DToArrayAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DToArrayAsync_fn(Args.hipMemcpy2DToArrayAsync.dst, Args.hipMemcpy2DToArrayAsync.wOffset, Args.hipMemcpy2DToArrayAsync.hOffset, Args.hipMemcpy2DToArrayAsync.src, Args.hipMemcpy2DToArrayAsync.spitch, Args.hipMemcpy2DToArrayAsync.width, Args.hipMemcpy2DToArrayAsync.height, Args.hipMemcpy2DToArrayAsync.kind, Args.hipMemcpy2DToArrayAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DToArrayAsync_fn(dst, wOffset, hOffset, src, spitch, width, height, kind, stream);
  }
}

static hipError_t hipMemcpy3D_callback(const struct hipMemcpy3DParms* p) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy3D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy3D.p = p;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy3D_fn(Args.hipMemcpy3D.p);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy3D_fn(p);
  }
}

static hipError_t hipMemcpy3DAsync_callback(const struct hipMemcpy3DParms* p, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy3DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy3DAsync.p = p;
    Args.hipMemcpy3DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy3DAsync_fn(Args.hipMemcpy3DAsync.p, Args.hipMemcpy3DAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy3DAsync_fn(p, stream);
  }
}

static hipError_t hipMemcpyAsync_callback(void* dst, const void* src, size_t sizeBytes, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyAsync.dst = dst;
    Args.hipMemcpyAsync.src = src;
    Args.hipMemcpyAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyAsync.kind = kind;
    Args.hipMemcpyAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyAsync_fn(Args.hipMemcpyAsync.dst, Args.hipMemcpyAsync.src, Args.hipMemcpyAsync.sizeBytes, Args.hipMemcpyAsync.kind, Args.hipMemcpyAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyAsync_fn(dst, src, sizeBytes, kind, stream);
  }
}

static hipError_t hipMemcpyAtoH_callback(void* dst, hipArray_t srcArray, size_t srcOffset, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyAtoH;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyAtoH.dst = dst;
    Args.hipMemcpyAtoH.srcArray = srcArray;
    Args.hipMemcpyAtoH.srcOffset = srcOffset;
    Args.hipMemcpyAtoH.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyAtoH_fn(Args.hipMemcpyAtoH.dst, Args.hipMemcpyAtoH.srcArray, Args.hipMemcpyAtoH.srcOffset, Args.hipMemcpyAtoH.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyAtoH_fn(dst, srcArray, srcOffset, count);
  }
}

static hipError_t hipMemcpyDtoD_callback(hipDeviceptr_t dst, hipDeviceptr_t src, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyDtoD;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyDtoD.dst = dst;
    Args.hipMemcpyDtoD.src = src;
    Args.hipMemcpyDtoD.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyDtoD_fn(Args.hipMemcpyDtoD.dst, Args.hipMemcpyDtoD.src, Args.hipMemcpyDtoD.sizeBytes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyDtoD_fn(dst, src, sizeBytes);
  }
}

static hipError_t hipMemcpyDtoDAsync_callback(hipDeviceptr_t dst, hipDeviceptr_t src, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyDtoDAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyDtoDAsync.dst = dst;
    Args.hipMemcpyDtoDAsync.src = src;
    Args.hipMemcpyDtoDAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyDtoDAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyDtoDAsync_fn(Args.hipMemcpyDtoDAsync.dst, Args.hipMemcpyDtoDAsync.src, Args.hipMemcpyDtoDAsync.sizeBytes, Args.hipMemcpyDtoDAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyDtoDAsync_fn(dst, src, sizeBytes, stream);
  }
}

static hipError_t hipMemcpyDtoH_callback(void* dst, hipDeviceptr_t src, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyDtoH;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyDtoH.dst = dst;
    Args.hipMemcpyDtoH.src = src;
    Args.hipMemcpyDtoH.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyDtoH_fn(Args.hipMemcpyDtoH.dst, Args.hipMemcpyDtoH.src, Args.hipMemcpyDtoH.sizeBytes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyDtoH_fn(dst, src, sizeBytes);
  }
}

static hipError_t hipMemcpyDtoHAsync_callback(void* dst, hipDeviceptr_t src, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyDtoHAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyDtoHAsync.dst = dst;
    Args.hipMemcpyDtoHAsync.src = src;
    Args.hipMemcpyDtoHAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyDtoHAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyDtoHAsync_fn(Args.hipMemcpyDtoHAsync.dst, Args.hipMemcpyDtoHAsync.src, Args.hipMemcpyDtoHAsync.sizeBytes, Args.hipMemcpyDtoHAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyDtoHAsync_fn(dst, src, sizeBytes, stream);
  }
}

static hipError_t hipMemcpyFromArray_callback(void* dst, hipArray_const_t srcArray, size_t wOffset, size_t hOffset, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyFromArray.dst = dst;
    Args.hipMemcpyFromArray.srcArray = srcArray;
    Args.hipMemcpyFromArray.wOffset = wOffset;
    Args.hipMemcpyFromArray.hOffset = hOffset;
    Args.hipMemcpyFromArray.count = count;
    Args.hipMemcpyFromArray.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyFromArray_fn(Args.hipMemcpyFromArray.dst, Args.hipMemcpyFromArray.srcArray, Args.hipMemcpyFromArray.wOffset, Args.hipMemcpyFromArray.hOffset, Args.hipMemcpyFromArray.count, Args.hipMemcpyFromArray.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyFromArray_fn(dst, srcArray, wOffset, hOffset, count, kind);
  }
}

static hipError_t hipMemcpyFromSymbol_callback(void* dst, const void* symbol, size_t sizeBytes, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyFromSymbol.dst = dst;
    Args.hipMemcpyFromSymbol.symbol = symbol;
    Args.hipMemcpyFromSymbol.sizeBytes = sizeBytes;
    Args.hipMemcpyFromSymbol.offset = offset;
    Args.hipMemcpyFromSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyFromSymbol_fn(Args.hipMemcpyFromSymbol.dst, Args.hipMemcpyFromSymbol.symbol, Args.hipMemcpyFromSymbol.sizeBytes, Args.hipMemcpyFromSymbol.offset, Args.hipMemcpyFromSymbol.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyFromSymbol_fn(dst, symbol, sizeBytes, offset, kind);
  }
}

static hipError_t hipMemcpyFromSymbolAsync_callback(void* dst, const void* symbol, size_t sizeBytes, size_t offset, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromSymbolAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyFromSymbolAsync.dst = dst;
    Args.hipMemcpyFromSymbolAsync.symbol = symbol;
    Args.hipMemcpyFromSymbolAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyFromSymbolAsync.offset = offset;
    Args.hipMemcpyFromSymbolAsync.kind = kind;
    Args.hipMemcpyFromSymbolAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyFromSymbolAsync_fn(Args.hipMemcpyFromSymbolAsync.dst, Args.hipMemcpyFromSymbolAsync.symbol, Args.hipMemcpyFromSymbolAsync.sizeBytes, Args.hipMemcpyFromSymbolAsync.offset, Args.hipMemcpyFromSymbolAsync.kind, Args.hipMemcpyFromSymbolAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyFromSymbolAsync_fn(dst, symbol, sizeBytes, offset, kind, stream);
  }
}

static hipError_t hipMemcpyHtoA_callback(hipArray_t dstArray, size_t dstOffset, const void* srcHost, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyHtoA;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyHtoA.dstArray = dstArray;
    Args.hipMemcpyHtoA.dstOffset = dstOffset;
    Args.hipMemcpyHtoA.srcHost = srcHost;
    Args.hipMemcpyHtoA.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyHtoA_fn(Args.hipMemcpyHtoA.dstArray, Args.hipMemcpyHtoA.dstOffset, Args.hipMemcpyHtoA.srcHost, Args.hipMemcpyHtoA.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyHtoA_fn(dstArray, dstOffset, srcHost, count);
  }
}

static hipError_t hipMemcpyHtoD_callback(hipDeviceptr_t dst, void* src, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyHtoD;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyHtoD.dst = dst;
    Args.hipMemcpyHtoD.src = src;
    Args.hipMemcpyHtoD.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyHtoD_fn(Args.hipMemcpyHtoD.dst, Args.hipMemcpyHtoD.src, Args.hipMemcpyHtoD.sizeBytes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyHtoD_fn(dst, src, sizeBytes);
  }
}

static hipError_t hipMemcpyHtoDAsync_callback(hipDeviceptr_t dst, void* src, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyHtoDAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyHtoDAsync.dst = dst;
    Args.hipMemcpyHtoDAsync.src = src;
    Args.hipMemcpyHtoDAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyHtoDAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyHtoDAsync_fn(Args.hipMemcpyHtoDAsync.dst, Args.hipMemcpyHtoDAsync.src, Args.hipMemcpyHtoDAsync.sizeBytes, Args.hipMemcpyHtoDAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyHtoDAsync_fn(dst, src, sizeBytes, stream);
  }
}

static hipError_t hipMemcpyParam2D_callback(const hip_Memcpy2D* pCopy) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyParam2D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyParam2D.pCopy = pCopy;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyParam2D_fn(Args.hipMemcpyParam2D.pCopy);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyParam2D_fn(pCopy);
  }
}

static hipError_t hipMemcpyParam2DAsync_callback(const hip_Memcpy2D* pCopy, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyParam2DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyParam2DAsync.pCopy = pCopy;
    Args.hipMemcpyParam2DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyParam2DAsync_fn(Args.hipMemcpyParam2DAsync.pCopy, Args.hipMemcpyParam2DAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyParam2DAsync_fn(pCopy, stream);
  }
}

static hipError_t hipMemcpyPeer_callback(void* dst, int dstDeviceId, const void* src, int srcDeviceId, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyPeer;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyPeer.dst = dst;
    Args.hipMemcpyPeer.dstDeviceId = dstDeviceId;
    Args.hipMemcpyPeer.src = src;
    Args.hipMemcpyPeer.srcDeviceId = srcDeviceId;
    Args.hipMemcpyPeer.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyPeer_fn(Args.hipMemcpyPeer.dst, Args.hipMemcpyPeer.dstDeviceId, Args.hipMemcpyPeer.src, Args.hipMemcpyPeer.srcDeviceId, Args.hipMemcpyPeer.sizeBytes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyPeer_fn(dst, dstDeviceId, src, srcDeviceId, sizeBytes);
  }
}

static hipError_t hipMemcpyPeerAsync_callback(void* dst, int dstDeviceId, const void* src, int srcDevice, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyPeerAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyPeerAsync.dst = dst;
    Args.hipMemcpyPeerAsync.dstDeviceId = dstDeviceId;
    Args.hipMemcpyPeerAsync.src = src;
    Args.hipMemcpyPeerAsync.srcDevice = srcDevice;
    Args.hipMemcpyPeerAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyPeerAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyPeerAsync_fn(Args.hipMemcpyPeerAsync.dst, Args.hipMemcpyPeerAsync.dstDeviceId, Args.hipMemcpyPeerAsync.src, Args.hipMemcpyPeerAsync.srcDevice, Args.hipMemcpyPeerAsync.sizeBytes, Args.hipMemcpyPeerAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyPeerAsync_fn(dst, dstDeviceId, src, srcDevice, sizeBytes, stream);
  }
}

static hipError_t hipMemcpyToArray_callback(hipArray_t dst, size_t wOffset, size_t hOffset, const void* src, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyToArray.dst = dst;
    Args.hipMemcpyToArray.wOffset = wOffset;
    Args.hipMemcpyToArray.hOffset = hOffset;
    Args.hipMemcpyToArray.src = src;
    Args.hipMemcpyToArray.count = count;
    Args.hipMemcpyToArray.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyToArray_fn(Args.hipMemcpyToArray.dst, Args.hipMemcpyToArray.wOffset, Args.hipMemcpyToArray.hOffset, Args.hipMemcpyToArray.src, Args.hipMemcpyToArray.count, Args.hipMemcpyToArray.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyToArray_fn(dst, wOffset, hOffset, src, count, kind);
  }
}

static hipError_t hipMemcpyToSymbol_callback(const void* symbol, const void* src, size_t sizeBytes, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToSymbol;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyToSymbol.symbol = symbol;
    Args.hipMemcpyToSymbol.src = src;
    Args.hipMemcpyToSymbol.sizeBytes = sizeBytes;
    Args.hipMemcpyToSymbol.offset = offset;
    Args.hipMemcpyToSymbol.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyToSymbol_fn(Args.hipMemcpyToSymbol.symbol, Args.hipMemcpyToSymbol.src, Args.hipMemcpyToSymbol.sizeBytes, Args.hipMemcpyToSymbol.offset, Args.hipMemcpyToSymbol.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyToSymbol_fn(symbol, src, sizeBytes, offset, kind);
  }
}

static hipError_t hipMemcpyToSymbolAsync_callback(const void* symbol, const void* src, size_t sizeBytes, size_t offset, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToSymbolAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyToSymbolAsync.symbol = symbol;
    Args.hipMemcpyToSymbolAsync.src = src;
    Args.hipMemcpyToSymbolAsync.sizeBytes = sizeBytes;
    Args.hipMemcpyToSymbolAsync.offset = offset;
    Args.hipMemcpyToSymbolAsync.kind = kind;
    Args.hipMemcpyToSymbolAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyToSymbolAsync_fn(Args.hipMemcpyToSymbolAsync.symbol, Args.hipMemcpyToSymbolAsync.src, Args.hipMemcpyToSymbolAsync.sizeBytes, Args.hipMemcpyToSymbolAsync.offset, Args.hipMemcpyToSymbolAsync.kind, Args.hipMemcpyToSymbolAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyToSymbolAsync_fn(symbol, src, sizeBytes, offset, kind, stream);
  }
}

static hipError_t hipMemcpyWithStream_callback(void* dst, const void* src, size_t sizeBytes, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyWithStream;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyWithStream.dst = dst;
    Args.hipMemcpyWithStream.src = src;
    Args.hipMemcpyWithStream.sizeBytes = sizeBytes;
    Args.hipMemcpyWithStream.kind = kind;
    Args.hipMemcpyWithStream.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyWithStream_fn(Args.hipMemcpyWithStream.dst, Args.hipMemcpyWithStream.src, Args.hipMemcpyWithStream.sizeBytes, Args.hipMemcpyWithStream.kind, Args.hipMemcpyWithStream.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyWithStream_fn(dst, src, sizeBytes, kind, stream);
  }
}

static hipError_t hipMemset_callback(void* dst, int value, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset.dst = dst;
    Args.hipMemset.value = value;
    Args.hipMemset.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset_fn(Args.hipMemset.dst, Args.hipMemset.value, Args.hipMemset.sizeBytes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset_fn(dst, value, sizeBytes);
  }
}

static hipError_t hipMemset2D_callback(void* dst, size_t pitch, int value, size_t width, size_t height) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset2D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset2D.dst = dst;
    Args.hipMemset2D.pitch = pitch;
    Args.hipMemset2D.value = value;
    Args.hipMemset2D.width = width;
    Args.hipMemset2D.height = height;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset2D_fn(Args.hipMemset2D.dst, Args.hipMemset2D.pitch, Args.hipMemset2D.value, Args.hipMemset2D.width, Args.hipMemset2D.height);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset2D_fn(dst, pitch, value, width, height);
  }
}

static hipError_t hipMemset2DAsync_callback(void* dst, size_t pitch, int value, size_t width, size_t height, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset2DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset2DAsync.dst = dst;
    Args.hipMemset2DAsync.pitch = pitch;
    Args.hipMemset2DAsync.value = value;
    Args.hipMemset2DAsync.width = width;
    Args.hipMemset2DAsync.height = height;
    Args.hipMemset2DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset2DAsync_fn(Args.hipMemset2DAsync.dst, Args.hipMemset2DAsync.pitch, Args.hipMemset2DAsync.value, Args.hipMemset2DAsync.width, Args.hipMemset2DAsync.height, Args.hipMemset2DAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset2DAsync_fn(dst, pitch, value, width, height, stream);
  }
}

static hipError_t hipMemset3D_callback(hipPitchedPtr pitchedDevPtr, int value, hipExtent extent) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset3D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset3D.pitchedDevPtr = pitchedDevPtr;
    Args.hipMemset3D.value = value;
    Args.hipMemset3D.extent = extent;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset3D_fn(Args.hipMemset3D.pitchedDevPtr, Args.hipMemset3D.value, Args.hipMemset3D.extent);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset3D_fn(pitchedDevPtr, value, extent);
  }
}

static hipError_t hipMemset3DAsync_callback(hipPitchedPtr pitchedDevPtr, int value, hipExtent extent, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset3DAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset3DAsync.pitchedDevPtr = pitchedDevPtr;
    Args.hipMemset3DAsync.value = value;
    Args.hipMemset3DAsync.extent = extent;
    Args.hipMemset3DAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset3DAsync_fn(Args.hipMemset3DAsync.pitchedDevPtr, Args.hipMemset3DAsync.value, Args.hipMemset3DAsync.extent, Args.hipMemset3DAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset3DAsync_fn(pitchedDevPtr, value, extent, stream);
  }
}

static hipError_t hipMemsetAsync_callback(void* dst, int value, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemsetAsync.dst = dst;
    Args.hipMemsetAsync.value = value;
    Args.hipMemsetAsync.sizeBytes = sizeBytes;
    Args.hipMemsetAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemsetAsync_fn(Args.hipMemsetAsync.dst, Args.hipMemsetAsync.value, Args.hipMemsetAsync.sizeBytes, Args.hipMemsetAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemsetAsync_fn(dst, value, sizeBytes, stream);
  }
}

static hipError_t hipMemsetD16_callback(hipDeviceptr_t dest, unsigned short value, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD16;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemsetD16.dest = dest;
    Args.hipMemsetD16.value = value;
    Args.hipMemsetD16.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemsetD16_fn(Args.hipMemsetD16.dest, Args.hipMemsetD16.value, Args.hipMemsetD16.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemsetD16_fn(dest, value, count);
  }
}

static hipError_t hipMemsetD16Async_callback(hipDeviceptr_t dest, unsigned short value, size_t count, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD16Async;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemsetD16Async.dest = dest;
    Args.hipMemsetD16Async.value = value;
    Args.hipMemsetD16Async.count = count;
    Args.hipMemsetD16Async.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemsetD16Async_fn(Args.hipMemsetD16Async.dest, Args.hipMemsetD16Async.value, Args.hipMemsetD16Async.count, Args.hipMemsetD16Async.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemsetD16Async_fn(dest, value, count, stream);
  }
}

static hipError_t hipMemsetD32_callback(hipDeviceptr_t dest, int value, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD32;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemsetD32.dest = dest;
    Args.hipMemsetD32.value = value;
    Args.hipMemsetD32.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemsetD32_fn(Args.hipMemsetD32.dest, Args.hipMemsetD32.value, Args.hipMemsetD32.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemsetD32_fn(dest, value, count);
  }
}

static hipError_t hipMemsetD32Async_callback(hipDeviceptr_t dst, int value, size_t count, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD32Async;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemsetD32Async.dst = dst;
    Args.hipMemsetD32Async.value = value;
    Args.hipMemsetD32Async.count = count;
    Args.hipMemsetD32Async.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemsetD32Async_fn(Args.hipMemsetD32Async.dst, Args.hipMemsetD32Async.value, Args.hipMemsetD32Async.count, Args.hipMemsetD32Async.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemsetD32Async_fn(dst, value, count, stream);
  }
}

static hipError_t hipMemsetD8_callback(hipDeviceptr_t dest, unsigned char value, size_t count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD8;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemsetD8.dest = dest;
    Args.hipMemsetD8.value = value;
    Args.hipMemsetD8.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemsetD8_fn(Args.hipMemsetD8.dest, Args.hipMemsetD8.value, Args.hipMemsetD8.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemsetD8_fn(dest, value, count);
  }
}

static hipError_t hipMemsetD8Async_callback(hipDeviceptr_t dest, unsigned char value, size_t count, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetD8Async;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemsetD8Async.dest = dest;
    Args.hipMemsetD8Async.value = value;
    Args.hipMemsetD8Async.count = count;
    Args.hipMemsetD8Async.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemsetD8Async_fn(Args.hipMemsetD8Async.dest, Args.hipMemsetD8Async.value, Args.hipMemsetD8Async.count, Args.hipMemsetD8Async.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemsetD8Async_fn(dest, value, count, stream);
  }
}

static hipError_t hipMipmappedArrayCreate_callback(hipMipmappedArray_t* pHandle, HIP_ARRAY3D_DESCRIPTOR* pMipmappedArrayDesc, unsigned int numMipmapLevels) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMipmappedArrayCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMipmappedArrayCreate.pHandle = pHandle;
    Args.hipMipmappedArrayCreate.pMipmappedArrayDesc = pMipmappedArrayDesc;
    Args.hipMipmappedArrayCreate.numMipmapLevels = numMipmapLevels;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMipmappedArrayCreate_fn(Args.hipMipmappedArrayCreate.pHandle, Args.hipMipmappedArrayCreate.pMipmappedArrayDesc, Args.hipMipmappedArrayCreate.numMipmapLevels);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMipmappedArrayCreate_fn(pHandle, pMipmappedArrayDesc, numMipmapLevels);
  }
}

static hipError_t hipMipmappedArrayDestroy_callback(hipMipmappedArray_t hMipmappedArray) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMipmappedArrayDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMipmappedArrayDestroy.hMipmappedArray = hMipmappedArray;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMipmappedArrayDestroy_fn(Args.hipMipmappedArrayDestroy.hMipmappedArray);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMipmappedArrayDestroy_fn(hMipmappedArray);
  }
}

static hipError_t hipMipmappedArrayGetLevel_callback(hipArray_t* pLevelArray, hipMipmappedArray_t hMipMappedArray, unsigned int level) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMipmappedArrayGetLevel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMipmappedArrayGetLevel.pLevelArray = pLevelArray;
    Args.hipMipmappedArrayGetLevel.hMipMappedArray = hMipMappedArray;
    Args.hipMipmappedArrayGetLevel.level = level;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMipmappedArrayGetLevel_fn(Args.hipMipmappedArrayGetLevel.pLevelArray, Args.hipMipmappedArrayGetLevel.hMipMappedArray, Args.hipMipmappedArrayGetLevel.level);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMipmappedArrayGetLevel_fn(pLevelArray, hMipMappedArray, level);
  }
}

static hipError_t hipModuleGetFunction_callback(hipFunction_t* function, hipModule_t module, const char* kname) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleGetFunction;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleGetFunction.function = function;
    Args.hipModuleGetFunction.module = module;
    Args.hipModuleGetFunction.kname = kname;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleGetFunction_fn(Args.hipModuleGetFunction.function, Args.hipModuleGetFunction.module, Args.hipModuleGetFunction.kname);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleGetFunction_fn(function, module, kname);
  }
}

static hipError_t hipModuleGetGlobal_callback(hipDeviceptr_t* dptr, size_t* bytes, hipModule_t hmod, const char* name) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleGetGlobal;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleGetGlobal.dptr = dptr;
    Args.hipModuleGetGlobal.bytes = bytes;
    Args.hipModuleGetGlobal.hmod = hmod;
    Args.hipModuleGetGlobal.name = name;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleGetGlobal_fn(Args.hipModuleGetGlobal.dptr, Args.hipModuleGetGlobal.bytes, Args.hipModuleGetGlobal.hmod, Args.hipModuleGetGlobal.name);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleGetGlobal_fn(dptr, bytes, hmod, name);
  }
}

static hipError_t hipModuleGetTexRef_callback(textureReference** texRef, hipModule_t hmod, const char* name) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleGetTexRef;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleGetTexRef.texRef = texRef;
    Args.hipModuleGetTexRef.hmod = hmod;
    Args.hipModuleGetTexRef.name = name;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleGetTexRef_fn(Args.hipModuleGetTexRef.texRef, Args.hipModuleGetTexRef.hmod, Args.hipModuleGetTexRef.name);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleGetTexRef_fn(texRef, hmod, name);
  }
}

static hipError_t hipModuleLaunchCooperativeKernel_callback(hipFunction_t f, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, hipStream_t stream, void** kernelParams) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleLaunchCooperativeKernel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleLaunchCooperativeKernel.f = f;
    Args.hipModuleLaunchCooperativeKernel.gridDimX = gridDimX;
    Args.hipModuleLaunchCooperativeKernel.gridDimY = gridDimY;
    Args.hipModuleLaunchCooperativeKernel.gridDimZ = gridDimZ;
    Args.hipModuleLaunchCooperativeKernel.blockDimX = blockDimX;
    Args.hipModuleLaunchCooperativeKernel.blockDimY = blockDimY;
    Args.hipModuleLaunchCooperativeKernel.blockDimZ = blockDimZ;
    Args.hipModuleLaunchCooperativeKernel.sharedMemBytes = sharedMemBytes;
    Args.hipModuleLaunchCooperativeKernel.stream = stream;
    Args.hipModuleLaunchCooperativeKernel.kernelParams = kernelParams;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleLaunchCooperativeKernel_fn(Args.hipModuleLaunchCooperativeKernel.f, Args.hipModuleLaunchCooperativeKernel.gridDimX, Args.hipModuleLaunchCooperativeKernel.gridDimY, Args.hipModuleLaunchCooperativeKernel.gridDimZ, Args.hipModuleLaunchCooperativeKernel.blockDimX, Args.hipModuleLaunchCooperativeKernel.blockDimY, Args.hipModuleLaunchCooperativeKernel.blockDimZ, Args.hipModuleLaunchCooperativeKernel.sharedMemBytes, Args.hipModuleLaunchCooperativeKernel.stream, Args.hipModuleLaunchCooperativeKernel.kernelParams);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleLaunchCooperativeKernel_fn(f, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, stream, kernelParams);
  }
}

static hipError_t hipModuleLaunchCooperativeKernelMultiDevice_callback(hipFunctionLaunchParams* launchParamsList, unsigned int numDevices, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleLaunchCooperativeKernelMultiDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleLaunchCooperativeKernelMultiDevice.launchParamsList = launchParamsList;
    Args.hipModuleLaunchCooperativeKernelMultiDevice.numDevices = numDevices;
    Args.hipModuleLaunchCooperativeKernelMultiDevice.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleLaunchCooperativeKernelMultiDevice_fn(Args.hipModuleLaunchCooperativeKernelMultiDevice.launchParamsList, Args.hipModuleLaunchCooperativeKernelMultiDevice.numDevices, Args.hipModuleLaunchCooperativeKernelMultiDevice.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleLaunchCooperativeKernelMultiDevice_fn(launchParamsList, numDevices, flags);
  }
}

static hipError_t hipModuleLaunchKernel_callback(hipFunction_t f, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, hipStream_t stream, void** kernelParams, void** extra) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleLaunchKernel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleLaunchKernel.f = f;
    Args.hipModuleLaunchKernel.gridDimX = gridDimX;
    Args.hipModuleLaunchKernel.gridDimY = gridDimY;
    Args.hipModuleLaunchKernel.gridDimZ = gridDimZ;
    Args.hipModuleLaunchKernel.blockDimX = blockDimX;
    Args.hipModuleLaunchKernel.blockDimY = blockDimY;
    Args.hipModuleLaunchKernel.blockDimZ = blockDimZ;
    Args.hipModuleLaunchKernel.sharedMemBytes = sharedMemBytes;
    Args.hipModuleLaunchKernel.stream = stream;
    Args.hipModuleLaunchKernel.kernelParams = kernelParams;
    Args.hipModuleLaunchKernel.extra = extra;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleLaunchKernel_fn(Args.hipModuleLaunchKernel.f, Args.hipModuleLaunchKernel.gridDimX, Args.hipModuleLaunchKernel.gridDimY, Args.hipModuleLaunchKernel.gridDimZ, Args.hipModuleLaunchKernel.blockDimX, Args.hipModuleLaunchKernel.blockDimY, Args.hipModuleLaunchKernel.blockDimZ, Args.hipModuleLaunchKernel.sharedMemBytes, Args.hipModuleLaunchKernel.stream, Args.hipModuleLaunchKernel.kernelParams, Args.hipModuleLaunchKernel.extra);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleLaunchKernel_fn(f, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, stream, kernelParams, extra);
  }
}

static hipError_t hipModuleLoad_callback(hipModule_t* module, const char* fname) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleLoad;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleLoad.module = module;
    Args.hipModuleLoad.fname = fname;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleLoad_fn(Args.hipModuleLoad.module, Args.hipModuleLoad.fname);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleLoad_fn(module, fname);
  }
}

static hipError_t hipModuleLoadData_callback(hipModule_t* module, const void* image) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleLoadData;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleLoadData.module = module;
    Args.hipModuleLoadData.image = image;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleLoadData_fn(Args.hipModuleLoadData.module, Args.hipModuleLoadData.image);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleLoadData_fn(module, image);
  }
}

static hipError_t hipModuleLoadDataEx_callback(hipModule_t* module, const void* image, unsigned int numOptions, hipJitOption* options, void** optionValues) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleLoadDataEx;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleLoadDataEx.module = module;
    Args.hipModuleLoadDataEx.image = image;
    Args.hipModuleLoadDataEx.numOptions = numOptions;
    Args.hipModuleLoadDataEx.options = options;
    Args.hipModuleLoadDataEx.optionValues = optionValues;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleLoadDataEx_fn(Args.hipModuleLoadDataEx.module, Args.hipModuleLoadDataEx.image, Args.hipModuleLoadDataEx.numOptions, Args.hipModuleLoadDataEx.options, Args.hipModuleLoadDataEx.optionValues);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleLoadDataEx_fn(module, image, numOptions, options, optionValues);
  }
}

static hipError_t hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_callback(int* numBlocks, hipFunction_t f, int blockSize, size_t dynSharedMemPerBlk) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleOccupancyMaxActiveBlocksPerMultiprocessor;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.numBlocks = numBlocks;
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.f = f;
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.blockSize = blockSize;
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.dynSharedMemPerBlk = dynSharedMemPerBlk;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_fn(Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.numBlocks, Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.f, Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.blockSize, Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.dynSharedMemPerBlk);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_fn(numBlocks, f, blockSize, dynSharedMemPerBlk);
  }
}

static hipError_t hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_callback(int* numBlocks, hipFunction_t f, int blockSize, size_t dynSharedMemPerBlk, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.numBlocks = numBlocks;
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.f = f;
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.blockSize = blockSize;
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.dynSharedMemPerBlk = dynSharedMemPerBlk;
    Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_fn(Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.numBlocks, Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.f, Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.blockSize, Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.dynSharedMemPerBlk, Args.hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_fn(numBlocks, f, blockSize, dynSharedMemPerBlk, flags);
  }
}

static hipError_t hipModuleOccupancyMaxPotentialBlockSize_callback(int* gridSize, int* blockSize, hipFunction_t f, size_t dynSharedMemPerBlk, int blockSizeLimit) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleOccupancyMaxPotentialBlockSize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleOccupancyMaxPotentialBlockSize.gridSize = gridSize;
    Args.hipModuleOccupancyMaxPotentialBlockSize.blockSize = blockSize;
    Args.hipModuleOccupancyMaxPotentialBlockSize.f = f;
    Args.hipModuleOccupancyMaxPotentialBlockSize.dynSharedMemPerBlk = dynSharedMemPerBlk;
    Args.hipModuleOccupancyMaxPotentialBlockSize.blockSizeLimit = blockSizeLimit;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleOccupancyMaxPotentialBlockSize_fn(Args.hipModuleOccupancyMaxPotentialBlockSize.gridSize, Args.hipModuleOccupancyMaxPotentialBlockSize.blockSize, Args.hipModuleOccupancyMaxPotentialBlockSize.f, Args.hipModuleOccupancyMaxPotentialBlockSize.dynSharedMemPerBlk, Args.hipModuleOccupancyMaxPotentialBlockSize.blockSizeLimit);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleOccupancyMaxPotentialBlockSize_fn(gridSize, blockSize, f, dynSharedMemPerBlk, blockSizeLimit);
  }
}

static hipError_t hipModuleOccupancyMaxPotentialBlockSizeWithFlags_callback(int* gridSize, int* blockSize, hipFunction_t f, size_t dynSharedMemPerBlk, int blockSizeLimit, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleOccupancyMaxPotentialBlockSizeWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.gridSize = gridSize;
    Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.blockSize = blockSize;
    Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.f = f;
    Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.dynSharedMemPerBlk = dynSharedMemPerBlk;
    Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.blockSizeLimit = blockSizeLimit;
    Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleOccupancyMaxPotentialBlockSizeWithFlags_fn(Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.gridSize, Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.blockSize, Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.f, Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.dynSharedMemPerBlk, Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.blockSizeLimit, Args.hipModuleOccupancyMaxPotentialBlockSizeWithFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleOccupancyMaxPotentialBlockSizeWithFlags_fn(gridSize, blockSize, f, dynSharedMemPerBlk, blockSizeLimit, flags);
  }
}

static hipError_t hipModuleUnload_callback(hipModule_t module) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipModuleUnload;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipModuleUnload.module = module;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipModuleUnload_fn(Args.hipModuleUnload.module);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipModuleUnload_fn(module);
  }
}

static hipError_t hipOccupancyMaxActiveBlocksPerMultiprocessor_callback(int* numBlocks, const void* f, int blockSize, size_t dynSharedMemPerBlk) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipOccupancyMaxActiveBlocksPerMultiprocessor;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessor.numBlocks = numBlocks;
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessor.f = f;
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessor.blockSize = blockSize;
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessor.dynSharedMemPerBlk = dynSharedMemPerBlk;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipOccupancyMaxActiveBlocksPerMultiprocessor_fn(Args.hipOccupancyMaxActiveBlocksPerMultiprocessor.numBlocks, Args.hipOccupancyMaxActiveBlocksPerMultiprocessor.f, Args.hipOccupancyMaxActiveBlocksPerMultiprocessor.blockSize, Args.hipOccupancyMaxActiveBlocksPerMultiprocessor.dynSharedMemPerBlk);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipOccupancyMaxActiveBlocksPerMultiprocessor_fn(numBlocks, f, blockSize, dynSharedMemPerBlk);
  }
}

static hipError_t hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_callback(int* numBlocks, const void* f, int blockSize, size_t dynSharedMemPerBlk, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.numBlocks = numBlocks;
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.f = f;
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.blockSize = blockSize;
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.dynSharedMemPerBlk = dynSharedMemPerBlk;
    Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_fn(Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.numBlocks, Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.f, Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.blockSize, Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.dynSharedMemPerBlk, Args.hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_fn(numBlocks, f, blockSize, dynSharedMemPerBlk, flags);
  }
}

static hipError_t hipOccupancyMaxPotentialBlockSize_callback(int* gridSize, int* blockSize, const void* f, size_t dynSharedMemPerBlk, int blockSizeLimit) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipOccupancyMaxPotentialBlockSize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipOccupancyMaxPotentialBlockSize.gridSize = gridSize;
    Args.hipOccupancyMaxPotentialBlockSize.blockSize = blockSize;
    Args.hipOccupancyMaxPotentialBlockSize.f = f;
    Args.hipOccupancyMaxPotentialBlockSize.dynSharedMemPerBlk = dynSharedMemPerBlk;
    Args.hipOccupancyMaxPotentialBlockSize.blockSizeLimit = blockSizeLimit;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipOccupancyMaxPotentialBlockSize_fn(Args.hipOccupancyMaxPotentialBlockSize.gridSize, Args.hipOccupancyMaxPotentialBlockSize.blockSize, Args.hipOccupancyMaxPotentialBlockSize.f, Args.hipOccupancyMaxPotentialBlockSize.dynSharedMemPerBlk, Args.hipOccupancyMaxPotentialBlockSize.blockSizeLimit);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipOccupancyMaxPotentialBlockSize_fn(gridSize, blockSize, f, dynSharedMemPerBlk, blockSizeLimit);
  }
}

static hipError_t hipPeekAtLastError_callback() {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipPeekAtLastError;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipPeekAtLastError_fn();
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipPeekAtLastError_fn();
  }
}

static hipError_t hipPointerGetAttribute_callback(void* data, hipPointer_attribute attribute, hipDeviceptr_t ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipPointerGetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipPointerGetAttribute.data = data;
    Args.hipPointerGetAttribute.attribute = attribute;
    Args.hipPointerGetAttribute.ptr = ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipPointerGetAttribute_fn(Args.hipPointerGetAttribute.data, Args.hipPointerGetAttribute.attribute, Args.hipPointerGetAttribute.ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipPointerGetAttribute_fn(data, attribute, ptr);
  }
}

static hipError_t hipPointerGetAttributes_callback(hipPointerAttribute_t* attributes, const void* ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipPointerGetAttributes;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipPointerGetAttributes.attributes = attributes;
    Args.hipPointerGetAttributes.ptr = ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipPointerGetAttributes_fn(Args.hipPointerGetAttributes.attributes, Args.hipPointerGetAttributes.ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipPointerGetAttributes_fn(attributes, ptr);
  }
}

static hipError_t hipPointerSetAttribute_callback(const void* value, hipPointer_attribute attribute, hipDeviceptr_t ptr) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipPointerSetAttribute;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipPointerSetAttribute.value = value;
    Args.hipPointerSetAttribute.attribute = attribute;
    Args.hipPointerSetAttribute.ptr = ptr;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipPointerSetAttribute_fn(Args.hipPointerSetAttribute.value, Args.hipPointerSetAttribute.attribute, Args.hipPointerSetAttribute.ptr);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipPointerSetAttribute_fn(value, attribute, ptr);
  }
}

static hipError_t hipProfilerStart_callback() {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipProfilerStart;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipProfilerStart_fn();
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipProfilerStart_fn();
  }
}

static hipError_t hipProfilerStop_callback() {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipProfilerStop;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipProfilerStop_fn();
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipProfilerStop_fn();
  }
}

static hipError_t hipRuntimeGetVersion_callback(int* runtimeVersion) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipRuntimeGetVersion;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipRuntimeGetVersion.runtimeVersion = runtimeVersion;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipRuntimeGetVersion_fn(Args.hipRuntimeGetVersion.runtimeVersion);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipRuntimeGetVersion_fn(runtimeVersion);
  }
}

static hipError_t hipSetDevice_callback(int deviceId) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipSetDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipSetDevice.deviceId = deviceId;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipSetDevice_fn(Args.hipSetDevice.deviceId);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipSetDevice_fn(deviceId);
  }
}

static hipError_t hipSetDeviceFlags_callback(unsigned flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipSetDeviceFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipSetDeviceFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipSetDeviceFlags_fn(Args.hipSetDeviceFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipSetDeviceFlags_fn(flags);
  }
}

static hipError_t hipSetupArgument_callback(const void* arg, size_t size, size_t offset) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipSetupArgument;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipSetupArgument.arg = arg;
    Args.hipSetupArgument.size = size;
    Args.hipSetupArgument.offset = offset;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipSetupArgument_fn(Args.hipSetupArgument.arg, Args.hipSetupArgument.size, Args.hipSetupArgument.offset);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipSetupArgument_fn(arg, size, offset);
  }
}

static hipError_t hipSignalExternalSemaphoresAsync_callback(const hipExternalSemaphore_t* extSemArray, const hipExternalSemaphoreSignalParams* paramsArray, unsigned int numExtSems, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipSignalExternalSemaphoresAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipSignalExternalSemaphoresAsync.extSemArray = extSemArray;
    Args.hipSignalExternalSemaphoresAsync.paramsArray = paramsArray;
    Args.hipSignalExternalSemaphoresAsync.numExtSems = numExtSems;
    Args.hipSignalExternalSemaphoresAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipSignalExternalSemaphoresAsync_fn(Args.hipSignalExternalSemaphoresAsync.extSemArray, Args.hipSignalExternalSemaphoresAsync.paramsArray, Args.hipSignalExternalSemaphoresAsync.numExtSems, Args.hipSignalExternalSemaphoresAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipSignalExternalSemaphoresAsync_fn(extSemArray, paramsArray, numExtSems, stream);
  }
}

static hipError_t hipStreamAddCallback_callback(hipStream_t stream, hipStreamCallback_t callback, void* userData, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamAddCallback;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamAddCallback.stream = stream;
    Args.hipStreamAddCallback.callback = callback;
    Args.hipStreamAddCallback.userData = userData;
    Args.hipStreamAddCallback.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamAddCallback_fn(Args.hipStreamAddCallback.stream, Args.hipStreamAddCallback.callback, Args.hipStreamAddCallback.userData, Args.hipStreamAddCallback.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamAddCallback_fn(stream, callback, userData, flags);
  }
}

static hipError_t hipStreamAttachMemAsync_callback(hipStream_t stream, void* dev_ptr, size_t length, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamAttachMemAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamAttachMemAsync.stream = stream;
    Args.hipStreamAttachMemAsync.dev_ptr = dev_ptr;
    Args.hipStreamAttachMemAsync.length = length;
    Args.hipStreamAttachMemAsync.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamAttachMemAsync_fn(Args.hipStreamAttachMemAsync.stream, Args.hipStreamAttachMemAsync.dev_ptr, Args.hipStreamAttachMemAsync.length, Args.hipStreamAttachMemAsync.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamAttachMemAsync_fn(stream, dev_ptr, length, flags);
  }
}

static hipError_t hipStreamBeginCapture_callback(hipStream_t stream, hipStreamCaptureMode mode) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamBeginCapture;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamBeginCapture.stream = stream;
    Args.hipStreamBeginCapture.mode = mode;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamBeginCapture_fn(Args.hipStreamBeginCapture.stream, Args.hipStreamBeginCapture.mode);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamBeginCapture_fn(stream, mode);
  }
}

static hipError_t hipStreamCreate_callback(hipStream_t* stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamCreate.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamCreate_fn(Args.hipStreamCreate.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamCreate_fn(stream);
  }
}

static hipError_t hipStreamCreateWithFlags_callback(hipStream_t* stream, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamCreateWithFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamCreateWithFlags.stream = stream;
    Args.hipStreamCreateWithFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamCreateWithFlags_fn(Args.hipStreamCreateWithFlags.stream, Args.hipStreamCreateWithFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamCreateWithFlags_fn(stream, flags);
  }
}

static hipError_t hipStreamCreateWithPriority_callback(hipStream_t* stream, unsigned int flags, int priority) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamCreateWithPriority;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamCreateWithPriority.stream = stream;
    Args.hipStreamCreateWithPriority.flags = flags;
    Args.hipStreamCreateWithPriority.priority = priority;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamCreateWithPriority_fn(Args.hipStreamCreateWithPriority.stream, Args.hipStreamCreateWithPriority.flags, Args.hipStreamCreateWithPriority.priority);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamCreateWithPriority_fn(stream, flags, priority);
  }
}

static hipError_t hipStreamDestroy_callback(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamDestroy.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamDestroy_fn(Args.hipStreamDestroy.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamDestroy_fn(stream);
  }
}

static hipError_t hipStreamEndCapture_callback(hipStream_t stream, hipGraph_t* pGraph) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamEndCapture;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamEndCapture.stream = stream;
    Args.hipStreamEndCapture.pGraph = pGraph;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamEndCapture_fn(Args.hipStreamEndCapture.stream, Args.hipStreamEndCapture.pGraph);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamEndCapture_fn(stream, pGraph);
  }
}

static hipError_t hipStreamGetCaptureInfo_callback(hipStream_t stream, hipStreamCaptureStatus* pCaptureStatus, unsigned long long* pId) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetCaptureInfo;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetCaptureInfo.stream = stream;
    Args.hipStreamGetCaptureInfo.pCaptureStatus = pCaptureStatus;
    Args.hipStreamGetCaptureInfo.pId = pId;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetCaptureInfo_fn(Args.hipStreamGetCaptureInfo.stream, Args.hipStreamGetCaptureInfo.pCaptureStatus, Args.hipStreamGetCaptureInfo.pId);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetCaptureInfo_fn(stream, pCaptureStatus, pId);
  }
}

static hipError_t hipStreamGetCaptureInfo_v2_callback(hipStream_t stream, hipStreamCaptureStatus* captureStatus_out, unsigned long long* id_out, hipGraph_t* graph_out, const hipGraphNode_t** dependencies_out, size_t* numDependencies_out) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetCaptureInfo_v2;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetCaptureInfo_v2.stream = stream;
    Args.hipStreamGetCaptureInfo_v2.captureStatus_out = captureStatus_out;
    Args.hipStreamGetCaptureInfo_v2.id_out = id_out;
    Args.hipStreamGetCaptureInfo_v2.graph_out = graph_out;
    Args.hipStreamGetCaptureInfo_v2.dependencies_out = dependencies_out;
    Args.hipStreamGetCaptureInfo_v2.numDependencies_out = numDependencies_out;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetCaptureInfo_v2_fn(Args.hipStreamGetCaptureInfo_v2.stream, Args.hipStreamGetCaptureInfo_v2.captureStatus_out, Args.hipStreamGetCaptureInfo_v2.id_out, Args.hipStreamGetCaptureInfo_v2.graph_out, Args.hipStreamGetCaptureInfo_v2.dependencies_out, Args.hipStreamGetCaptureInfo_v2.numDependencies_out);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetCaptureInfo_v2_fn(stream, captureStatus_out, id_out, graph_out, dependencies_out, numDependencies_out);
  }
}

static hipError_t hipStreamGetDevice_callback(hipStream_t stream, hipDevice_t* device) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetDevice;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetDevice.stream = stream;
    Args.hipStreamGetDevice.device = device;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetDevice_fn(Args.hipStreamGetDevice.stream, Args.hipStreamGetDevice.device);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetDevice_fn(stream, device);
  }
}

static hipError_t hipStreamGetFlags_callback(hipStream_t stream, unsigned int* flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetFlags.stream = stream;
    Args.hipStreamGetFlags.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetFlags_fn(Args.hipStreamGetFlags.stream, Args.hipStreamGetFlags.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetFlags_fn(stream, flags);
  }
}

static hipError_t hipStreamGetPriority_callback(hipStream_t stream, int* priority) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetPriority;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetPriority.stream = stream;
    Args.hipStreamGetPriority.priority = priority;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetPriority_fn(Args.hipStreamGetPriority.stream, Args.hipStreamGetPriority.priority);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetPriority_fn(stream, priority);
  }
}

static hipError_t hipStreamIsCapturing_callback(hipStream_t stream, hipStreamCaptureStatus* pCaptureStatus) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamIsCapturing;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamIsCapturing.stream = stream;
    Args.hipStreamIsCapturing.pCaptureStatus = pCaptureStatus;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamIsCapturing_fn(Args.hipStreamIsCapturing.stream, Args.hipStreamIsCapturing.pCaptureStatus);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamIsCapturing_fn(stream, pCaptureStatus);
  }
}

static hipError_t hipStreamQuery_callback(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamQuery;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamQuery.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamQuery_fn(Args.hipStreamQuery.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamQuery_fn(stream);
  }
}

static hipError_t hipStreamSynchronize_callback(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamSynchronize;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamSynchronize.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamSynchronize_fn(Args.hipStreamSynchronize.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamSynchronize_fn(stream);
  }
}

static hipError_t hipStreamUpdateCaptureDependencies_callback(hipStream_t stream, hipGraphNode_t* dependencies, size_t numDependencies, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamUpdateCaptureDependencies;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamUpdateCaptureDependencies.stream = stream;
    Args.hipStreamUpdateCaptureDependencies.dependencies = dependencies;
    Args.hipStreamUpdateCaptureDependencies.numDependencies = numDependencies;
    Args.hipStreamUpdateCaptureDependencies.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamUpdateCaptureDependencies_fn(Args.hipStreamUpdateCaptureDependencies.stream, Args.hipStreamUpdateCaptureDependencies.dependencies, Args.hipStreamUpdateCaptureDependencies.numDependencies, Args.hipStreamUpdateCaptureDependencies.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamUpdateCaptureDependencies_fn(stream, dependencies, numDependencies, flags);
  }
}

static hipError_t hipStreamWaitEvent_callback(hipStream_t stream, hipEvent_t event, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWaitEvent;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamWaitEvent.stream = stream;
    Args.hipStreamWaitEvent.event = event;
    Args.hipStreamWaitEvent.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamWaitEvent_fn(Args.hipStreamWaitEvent.stream, Args.hipStreamWaitEvent.event, Args.hipStreamWaitEvent.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamWaitEvent_fn(stream, event, flags);
  }
}

static hipError_t hipStreamWaitValue32_callback(hipStream_t stream, void* ptr, uint32_t value, unsigned int flags, uint32_t mask) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWaitValue32;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamWaitValue32.stream = stream;
    Args.hipStreamWaitValue32.ptr = ptr;
    Args.hipStreamWaitValue32.value = value;
    Args.hipStreamWaitValue32.flags = flags;
    Args.hipStreamWaitValue32.mask = mask;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamWaitValue32_fn(Args.hipStreamWaitValue32.stream, Args.hipStreamWaitValue32.ptr, Args.hipStreamWaitValue32.value, Args.hipStreamWaitValue32.flags, Args.hipStreamWaitValue32.mask);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamWaitValue32_fn(stream, ptr, value, flags, mask);
  }
}

static hipError_t hipStreamWaitValue64_callback(hipStream_t stream, void* ptr, uint64_t value, unsigned int flags, uint64_t mask) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWaitValue64;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamWaitValue64.stream = stream;
    Args.hipStreamWaitValue64.ptr = ptr;
    Args.hipStreamWaitValue64.value = value;
    Args.hipStreamWaitValue64.flags = flags;
    Args.hipStreamWaitValue64.mask = mask;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamWaitValue64_fn(Args.hipStreamWaitValue64.stream, Args.hipStreamWaitValue64.ptr, Args.hipStreamWaitValue64.value, Args.hipStreamWaitValue64.flags, Args.hipStreamWaitValue64.mask);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamWaitValue64_fn(stream, ptr, value, flags, mask);
  }
}

static hipError_t hipStreamWriteValue32_callback(hipStream_t stream, void* ptr, uint32_t value, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWriteValue32;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamWriteValue32.stream = stream;
    Args.hipStreamWriteValue32.ptr = ptr;
    Args.hipStreamWriteValue32.value = value;
    Args.hipStreamWriteValue32.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamWriteValue32_fn(Args.hipStreamWriteValue32.stream, Args.hipStreamWriteValue32.ptr, Args.hipStreamWriteValue32.value, Args.hipStreamWriteValue32.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamWriteValue32_fn(stream, ptr, value, flags);
  }
}

static hipError_t hipStreamWriteValue64_callback(hipStream_t stream, void* ptr, uint64_t value, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWriteValue64;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamWriteValue64.stream = stream;
    Args.hipStreamWriteValue64.ptr = ptr;
    Args.hipStreamWriteValue64.value = value;
    Args.hipStreamWriteValue64.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamWriteValue64_fn(Args.hipStreamWriteValue64.stream, Args.hipStreamWriteValue64.ptr, Args.hipStreamWriteValue64.value, Args.hipStreamWriteValue64.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamWriteValue64_fn(stream, ptr, value, flags);
  }
}

static hipError_t hipTexObjectCreate_callback(hipTextureObject_t* pTexObject, const HIP_RESOURCE_DESC* pResDesc, const HIP_TEXTURE_DESC* pTexDesc, const HIP_RESOURCE_VIEW_DESC* pResViewDesc) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexObjectCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexObjectCreate.pTexObject = pTexObject;
    Args.hipTexObjectCreate.pResDesc = pResDesc;
    Args.hipTexObjectCreate.pTexDesc = pTexDesc;
    Args.hipTexObjectCreate.pResViewDesc = pResViewDesc;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexObjectCreate_fn(Args.hipTexObjectCreate.pTexObject, Args.hipTexObjectCreate.pResDesc, Args.hipTexObjectCreate.pTexDesc, Args.hipTexObjectCreate.pResViewDesc);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexObjectCreate_fn(pTexObject, pResDesc, pTexDesc, pResViewDesc);
  }
}

static hipError_t hipTexObjectDestroy_callback(hipTextureObject_t texObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexObjectDestroy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexObjectDestroy.texObject = texObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexObjectDestroy_fn(Args.hipTexObjectDestroy.texObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexObjectDestroy_fn(texObject);
  }
}

static hipError_t hipTexObjectGetResourceDesc_callback(HIP_RESOURCE_DESC* pResDesc, hipTextureObject_t texObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexObjectGetResourceDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexObjectGetResourceDesc.pResDesc = pResDesc;
    Args.hipTexObjectGetResourceDesc.texObject = texObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexObjectGetResourceDesc_fn(Args.hipTexObjectGetResourceDesc.pResDesc, Args.hipTexObjectGetResourceDesc.texObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexObjectGetResourceDesc_fn(pResDesc, texObject);
  }
}

static hipError_t hipTexObjectGetResourceViewDesc_callback(HIP_RESOURCE_VIEW_DESC* pResViewDesc, hipTextureObject_t texObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexObjectGetResourceViewDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexObjectGetResourceViewDesc.pResViewDesc = pResViewDesc;
    Args.hipTexObjectGetResourceViewDesc.texObject = texObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexObjectGetResourceViewDesc_fn(Args.hipTexObjectGetResourceViewDesc.pResViewDesc, Args.hipTexObjectGetResourceViewDesc.texObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexObjectGetResourceViewDesc_fn(pResViewDesc, texObject);
  }
}

static hipError_t hipTexObjectGetTextureDesc_callback(HIP_TEXTURE_DESC* pTexDesc, hipTextureObject_t texObject) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexObjectGetTextureDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexObjectGetTextureDesc.pTexDesc = pTexDesc;
    Args.hipTexObjectGetTextureDesc.texObject = texObject;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexObjectGetTextureDesc_fn(Args.hipTexObjectGetTextureDesc.pTexDesc, Args.hipTexObjectGetTextureDesc.texObject);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexObjectGetTextureDesc_fn(pTexDesc, texObject);
  }
}

static hipError_t hipTexRefGetAddress_callback(hipDeviceptr_t* dev_ptr, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetAddress;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetAddress.dev_ptr = dev_ptr;
    Args.hipTexRefGetAddress.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetAddress_fn(Args.hipTexRefGetAddress.dev_ptr, Args.hipTexRefGetAddress.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetAddress_fn(dev_ptr, texRef);
  }
}

static hipError_t hipTexRefGetAddressMode_callback(enum hipTextureAddressMode* pam, const textureReference* texRef, int dim) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetAddressMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetAddressMode.pam = pam;
    Args.hipTexRefGetAddressMode.texRef = texRef;
    Args.hipTexRefGetAddressMode.dim = dim;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetAddressMode_fn(Args.hipTexRefGetAddressMode.pam, Args.hipTexRefGetAddressMode.texRef, Args.hipTexRefGetAddressMode.dim);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetAddressMode_fn(pam, texRef, dim);
  }
}

static hipError_t hipTexRefGetFilterMode_callback(enum hipTextureFilterMode* pfm, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetFilterMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetFilterMode.pfm = pfm;
    Args.hipTexRefGetFilterMode.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetFilterMode_fn(Args.hipTexRefGetFilterMode.pfm, Args.hipTexRefGetFilterMode.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetFilterMode_fn(pfm, texRef);
  }
}

static hipError_t hipTexRefGetFlags_callback(unsigned int* pFlags, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetFlags.pFlags = pFlags;
    Args.hipTexRefGetFlags.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetFlags_fn(Args.hipTexRefGetFlags.pFlags, Args.hipTexRefGetFlags.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetFlags_fn(pFlags, texRef);
  }
}

static hipError_t hipTexRefGetFormat_callback(hipArray_Format* pFormat, int* pNumChannels, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetFormat;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetFormat.pFormat = pFormat;
    Args.hipTexRefGetFormat.pNumChannels = pNumChannels;
    Args.hipTexRefGetFormat.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetFormat_fn(Args.hipTexRefGetFormat.pFormat, Args.hipTexRefGetFormat.pNumChannels, Args.hipTexRefGetFormat.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetFormat_fn(pFormat, pNumChannels, texRef);
  }
}

static hipError_t hipTexRefGetMaxAnisotropy_callback(int* pmaxAnsio, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetMaxAnisotropy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetMaxAnisotropy.pmaxAnsio = pmaxAnsio;
    Args.hipTexRefGetMaxAnisotropy.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetMaxAnisotropy_fn(Args.hipTexRefGetMaxAnisotropy.pmaxAnsio, Args.hipTexRefGetMaxAnisotropy.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetMaxAnisotropy_fn(pmaxAnsio, texRef);
  }
}

static hipError_t hipTexRefGetMipMappedArray_callback(hipMipmappedArray_t* pArray, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetMipMappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetMipMappedArray.pArray = pArray;
    Args.hipTexRefGetMipMappedArray.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetMipMappedArray_fn(Args.hipTexRefGetMipMappedArray.pArray, Args.hipTexRefGetMipMappedArray.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetMipMappedArray_fn(pArray, texRef);
  }
}

static hipError_t hipTexRefGetMipmapFilterMode_callback(enum hipTextureFilterMode* pfm, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetMipmapFilterMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetMipmapFilterMode.pfm = pfm;
    Args.hipTexRefGetMipmapFilterMode.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetMipmapFilterMode_fn(Args.hipTexRefGetMipmapFilterMode.pfm, Args.hipTexRefGetMipmapFilterMode.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetMipmapFilterMode_fn(pfm, texRef);
  }
}

static hipError_t hipTexRefGetMipmapLevelBias_callback(float* pbias, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetMipmapLevelBias;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetMipmapLevelBias.pbias = pbias;
    Args.hipTexRefGetMipmapLevelBias.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetMipmapLevelBias_fn(Args.hipTexRefGetMipmapLevelBias.pbias, Args.hipTexRefGetMipmapLevelBias.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetMipmapLevelBias_fn(pbias, texRef);
  }
}

static hipError_t hipTexRefGetMipmapLevelClamp_callback(float* pminMipmapLevelClamp, float* pmaxMipmapLevelClamp, const textureReference* texRef) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefGetMipmapLevelClamp;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefGetMipmapLevelClamp.pminMipmapLevelClamp = pminMipmapLevelClamp;
    Args.hipTexRefGetMipmapLevelClamp.pmaxMipmapLevelClamp = pmaxMipmapLevelClamp;
    Args.hipTexRefGetMipmapLevelClamp.texRef = texRef;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefGetMipmapLevelClamp_fn(Args.hipTexRefGetMipmapLevelClamp.pminMipmapLevelClamp, Args.hipTexRefGetMipmapLevelClamp.pmaxMipmapLevelClamp, Args.hipTexRefGetMipmapLevelClamp.texRef);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefGetMipmapLevelClamp_fn(pminMipmapLevelClamp, pmaxMipmapLevelClamp, texRef);
  }
}

static hipError_t hipTexRefSetAddress_callback(size_t* ByteOffset, textureReference* texRef, hipDeviceptr_t dptr, size_t bytes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetAddress;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetAddress.ByteOffset = ByteOffset;
    Args.hipTexRefSetAddress.texRef = texRef;
    Args.hipTexRefSetAddress.dptr = dptr;
    Args.hipTexRefSetAddress.bytes = bytes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetAddress_fn(Args.hipTexRefSetAddress.ByteOffset, Args.hipTexRefSetAddress.texRef, Args.hipTexRefSetAddress.dptr, Args.hipTexRefSetAddress.bytes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetAddress_fn(ByteOffset, texRef, dptr, bytes);
  }
}

static hipError_t hipTexRefSetAddress2D_callback(textureReference* texRef, const HIP_ARRAY_DESCRIPTOR* desc, hipDeviceptr_t dptr, size_t Pitch) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetAddress2D;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetAddress2D.texRef = texRef;
    Args.hipTexRefSetAddress2D.desc = desc;
    Args.hipTexRefSetAddress2D.dptr = dptr;
    Args.hipTexRefSetAddress2D.Pitch = Pitch;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetAddress2D_fn(Args.hipTexRefSetAddress2D.texRef, Args.hipTexRefSetAddress2D.desc, Args.hipTexRefSetAddress2D.dptr, Args.hipTexRefSetAddress2D.Pitch);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetAddress2D_fn(texRef, desc, dptr, Pitch);
  }
}

static hipError_t hipTexRefSetAddressMode_callback(textureReference* texRef, int dim, enum hipTextureAddressMode am) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetAddressMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetAddressMode.texRef = texRef;
    Args.hipTexRefSetAddressMode.dim = dim;
    Args.hipTexRefSetAddressMode.am = am;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetAddressMode_fn(Args.hipTexRefSetAddressMode.texRef, Args.hipTexRefSetAddressMode.dim, Args.hipTexRefSetAddressMode.am);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetAddressMode_fn(texRef, dim, am);
  }
}

static hipError_t hipTexRefSetArray_callback(textureReference* tex, hipArray_const_t array, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetArray.tex = tex;
    Args.hipTexRefSetArray.array = array;
    Args.hipTexRefSetArray.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetArray_fn(Args.hipTexRefSetArray.tex, Args.hipTexRefSetArray.array, Args.hipTexRefSetArray.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetArray_fn(tex, array, flags);
  }
}

static hipError_t hipTexRefSetBorderColor_callback(textureReference* texRef, float* pBorderColor) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetBorderColor;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetBorderColor.texRef = texRef;
    Args.hipTexRefSetBorderColor.pBorderColor = pBorderColor;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetBorderColor_fn(Args.hipTexRefSetBorderColor.texRef, Args.hipTexRefSetBorderColor.pBorderColor);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetBorderColor_fn(texRef, pBorderColor);
  }
}

static hipError_t hipTexRefSetFilterMode_callback(textureReference* texRef, enum hipTextureFilterMode fm) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetFilterMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetFilterMode.texRef = texRef;
    Args.hipTexRefSetFilterMode.fm = fm;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetFilterMode_fn(Args.hipTexRefSetFilterMode.texRef, Args.hipTexRefSetFilterMode.fm);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetFilterMode_fn(texRef, fm);
  }
}

static hipError_t hipTexRefSetFlags_callback(textureReference* texRef, unsigned int Flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetFlags;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetFlags.texRef = texRef;
    Args.hipTexRefSetFlags.Flags = Flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetFlags_fn(Args.hipTexRefSetFlags.texRef, Args.hipTexRefSetFlags.Flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetFlags_fn(texRef, Flags);
  }
}

static hipError_t hipTexRefSetFormat_callback(textureReference* texRef, hipArray_Format fmt, int NumPackedComponents) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetFormat;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetFormat.texRef = texRef;
    Args.hipTexRefSetFormat.fmt = fmt;
    Args.hipTexRefSetFormat.NumPackedComponents = NumPackedComponents;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetFormat_fn(Args.hipTexRefSetFormat.texRef, Args.hipTexRefSetFormat.fmt, Args.hipTexRefSetFormat.NumPackedComponents);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetFormat_fn(texRef, fmt, NumPackedComponents);
  }
}

static hipError_t hipTexRefSetMaxAnisotropy_callback(textureReference* texRef, unsigned int maxAniso) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetMaxAnisotropy;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetMaxAnisotropy.texRef = texRef;
    Args.hipTexRefSetMaxAnisotropy.maxAniso = maxAniso;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetMaxAnisotropy_fn(Args.hipTexRefSetMaxAnisotropy.texRef, Args.hipTexRefSetMaxAnisotropy.maxAniso);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetMaxAnisotropy_fn(texRef, maxAniso);
  }
}

static hipError_t hipTexRefSetMipmapFilterMode_callback(textureReference* texRef, enum hipTextureFilterMode fm) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetMipmapFilterMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetMipmapFilterMode.texRef = texRef;
    Args.hipTexRefSetMipmapFilterMode.fm = fm;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetMipmapFilterMode_fn(Args.hipTexRefSetMipmapFilterMode.texRef, Args.hipTexRefSetMipmapFilterMode.fm);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetMipmapFilterMode_fn(texRef, fm);
  }
}

static hipError_t hipTexRefSetMipmapLevelBias_callback(textureReference* texRef, float bias) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetMipmapLevelBias;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetMipmapLevelBias.texRef = texRef;
    Args.hipTexRefSetMipmapLevelBias.bias = bias;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetMipmapLevelBias_fn(Args.hipTexRefSetMipmapLevelBias.texRef, Args.hipTexRefSetMipmapLevelBias.bias);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetMipmapLevelBias_fn(texRef, bias);
  }
}

static hipError_t hipTexRefSetMipmapLevelClamp_callback(textureReference* texRef, float minMipMapLevelClamp, float maxMipMapLevelClamp) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetMipmapLevelClamp;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetMipmapLevelClamp.texRef = texRef;
    Args.hipTexRefSetMipmapLevelClamp.minMipMapLevelClamp = minMipMapLevelClamp;
    Args.hipTexRefSetMipmapLevelClamp.maxMipMapLevelClamp = maxMipMapLevelClamp;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetMipmapLevelClamp_fn(Args.hipTexRefSetMipmapLevelClamp.texRef, Args.hipTexRefSetMipmapLevelClamp.minMipMapLevelClamp, Args.hipTexRefSetMipmapLevelClamp.maxMipMapLevelClamp);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetMipmapLevelClamp_fn(texRef, minMipMapLevelClamp, maxMipMapLevelClamp);
  }
}

static hipError_t hipTexRefSetMipmappedArray_callback(textureReference* texRef, struct hipMipmappedArray* mipmappedArray, unsigned int Flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipTexRefSetMipmappedArray;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipTexRefSetMipmappedArray.texRef = texRef;
    Args.hipTexRefSetMipmappedArray.mipmappedArray = mipmappedArray;
    Args.hipTexRefSetMipmappedArray.Flags = Flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipTexRefSetMipmappedArray_fn(Args.hipTexRefSetMipmappedArray.texRef, Args.hipTexRefSetMipmappedArray.mipmappedArray, Args.hipTexRefSetMipmappedArray.Flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipTexRefSetMipmappedArray_fn(texRef, mipmappedArray, Flags);
  }
}

static hipError_t hipThreadExchangeStreamCaptureMode_callback(hipStreamCaptureMode* mode) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipThreadExchangeStreamCaptureMode;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipThreadExchangeStreamCaptureMode.mode = mode;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipThreadExchangeStreamCaptureMode_fn(Args.hipThreadExchangeStreamCaptureMode.mode);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipThreadExchangeStreamCaptureMode_fn(mode);
  }
}

static hipError_t hipUnbindTexture_callback(const textureReference* tex) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipUnbindTexture;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipUnbindTexture.tex = tex;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipUnbindTexture_fn(Args.hipUnbindTexture.tex);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipUnbindTexture_fn(tex);
  }
}

static hipError_t hipUserObjectCreate_callback(hipUserObject_t* object_out, void* ptr, hipHostFn_t destroy, unsigned int initialRefcount, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipUserObjectCreate;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipUserObjectCreate.object_out = object_out;
    Args.hipUserObjectCreate.ptr = ptr;
    Args.hipUserObjectCreate.destroy = destroy;
    Args.hipUserObjectCreate.initialRefcount = initialRefcount;
    Args.hipUserObjectCreate.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipUserObjectCreate_fn(Args.hipUserObjectCreate.object_out, Args.hipUserObjectCreate.ptr, Args.hipUserObjectCreate.destroy, Args.hipUserObjectCreate.initialRefcount, Args.hipUserObjectCreate.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipUserObjectCreate_fn(object_out, ptr, destroy, initialRefcount, flags);
  }
}

static hipError_t hipUserObjectRelease_callback(hipUserObject_t object, unsigned int count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipUserObjectRelease;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipUserObjectRelease.object = object;
    Args.hipUserObjectRelease.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipUserObjectRelease_fn(Args.hipUserObjectRelease.object, Args.hipUserObjectRelease.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipUserObjectRelease_fn(object, count);
  }
}

static hipError_t hipUserObjectRetain_callback(hipUserObject_t object, unsigned int count) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipUserObjectRetain;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipUserObjectRetain.object = object;
    Args.hipUserObjectRetain.count = count;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipUserObjectRetain_fn(Args.hipUserObjectRetain.object, Args.hipUserObjectRetain.count);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipUserObjectRetain_fn(object, count);
  }
}

static hipError_t hipWaitExternalSemaphoresAsync_callback(const hipExternalSemaphore_t* extSemArray, const hipExternalSemaphoreWaitParams* paramsArray, unsigned int numExtSems, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipWaitExternalSemaphoresAsync;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipWaitExternalSemaphoresAsync.extSemArray = extSemArray;
    Args.hipWaitExternalSemaphoresAsync.paramsArray = paramsArray;
    Args.hipWaitExternalSemaphoresAsync.numExtSems = numExtSems;
    Args.hipWaitExternalSemaphoresAsync.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipWaitExternalSemaphoresAsync_fn(Args.hipWaitExternalSemaphoresAsync.extSemArray, Args.hipWaitExternalSemaphoresAsync.paramsArray, Args.hipWaitExternalSemaphoresAsync.numExtSems, Args.hipWaitExternalSemaphoresAsync.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipWaitExternalSemaphoresAsync_fn(extSemArray, paramsArray, numExtSems, stream);
  }
}

static hipChannelFormatDesc hipCreateChannelDesc_callback(int x, int y, int z, int w, hipChannelFormatKind f) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipCreateChannelDesc;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipChannelFormatDesc Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipCreateChannelDesc.x = x;
    Args.hipCreateChannelDesc.y = y;
    Args.hipCreateChannelDesc.z = z;
    Args.hipCreateChannelDesc.w = w;
    Args.hipCreateChannelDesc.f = f;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipCreateChannelDesc_fn(Args.hipCreateChannelDesc.x, Args.hipCreateChannelDesc.y, Args.hipCreateChannelDesc.z, Args.hipCreateChannelDesc.w, Args.hipCreateChannelDesc.f);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipCreateChannelDesc_fn(x, y, z, w, f);
  }
}

static hipError_t hipExtModuleLaunchKernel_callback(hipFunction_t f, uint32_t globalWorkSizeX, uint32_t globalWorkSizeY, uint32_t globalWorkSizeZ, uint32_t localWorkSizeX, uint32_t localWorkSizeY, uint32_t localWorkSizeZ, size_t sharedMemBytes, hipStream_t hStream, void** kernelParams, void** extra, hipEvent_t startEvent, hipEvent_t stopEvent, uint32_t flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipExtModuleLaunchKernel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipExtModuleLaunchKernel.f = f;
    Args.hipExtModuleLaunchKernel.globalWorkSizeX = globalWorkSizeX;
    Args.hipExtModuleLaunchKernel.globalWorkSizeY = globalWorkSizeY;
    Args.hipExtModuleLaunchKernel.globalWorkSizeZ = globalWorkSizeZ;
    Args.hipExtModuleLaunchKernel.localWorkSizeX = localWorkSizeX;
    Args.hipExtModuleLaunchKernel.localWorkSizeY = localWorkSizeY;
    Args.hipExtModuleLaunchKernel.localWorkSizeZ = localWorkSizeZ;
    Args.hipExtModuleLaunchKernel.sharedMemBytes = sharedMemBytes;
    Args.hipExtModuleLaunchKernel.hStream = hStream;
    Args.hipExtModuleLaunchKernel.kernelParams = kernelParams;
    Args.hipExtModuleLaunchKernel.extra = extra;
    Args.hipExtModuleLaunchKernel.startEvent = startEvent;
    Args.hipExtModuleLaunchKernel.stopEvent = stopEvent;
    Args.hipExtModuleLaunchKernel.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipExtModuleLaunchKernel_fn(Args.hipExtModuleLaunchKernel.f, Args.hipExtModuleLaunchKernel.globalWorkSizeX, Args.hipExtModuleLaunchKernel.globalWorkSizeY, Args.hipExtModuleLaunchKernel.globalWorkSizeZ, Args.hipExtModuleLaunchKernel.localWorkSizeX, Args.hipExtModuleLaunchKernel.localWorkSizeY, Args.hipExtModuleLaunchKernel.localWorkSizeZ, Args.hipExtModuleLaunchKernel.sharedMemBytes, Args.hipExtModuleLaunchKernel.hStream, Args.hipExtModuleLaunchKernel.kernelParams, Args.hipExtModuleLaunchKernel.extra, Args.hipExtModuleLaunchKernel.startEvent, Args.hipExtModuleLaunchKernel.stopEvent, Args.hipExtModuleLaunchKernel.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipExtModuleLaunchKernel_fn(f, globalWorkSizeX, globalWorkSizeY, globalWorkSizeZ, localWorkSizeX, localWorkSizeY, localWorkSizeZ, sharedMemBytes, hStream, kernelParams, extra, startEvent, stopEvent, flags);
  }
}

static hipError_t hipHccModuleLaunchKernel_callback(hipFunction_t f, uint32_t globalWorkSizeX, uint32_t globalWorkSizeY, uint32_t globalWorkSizeZ, uint32_t localWorkSizeX, uint32_t localWorkSizeY, uint32_t localWorkSizeZ, size_t sharedMemBytes, hipStream_t hStream, void** kernelParams, void** extra, hipEvent_t startEvent, hipEvent_t stopEvent) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipHccModuleLaunchKernel;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipHccModuleLaunchKernel.f = f;
    Args.hipHccModuleLaunchKernel.globalWorkSizeX = globalWorkSizeX;
    Args.hipHccModuleLaunchKernel.globalWorkSizeY = globalWorkSizeY;
    Args.hipHccModuleLaunchKernel.globalWorkSizeZ = globalWorkSizeZ;
    Args.hipHccModuleLaunchKernel.localWorkSizeX = localWorkSizeX;
    Args.hipHccModuleLaunchKernel.localWorkSizeY = localWorkSizeY;
    Args.hipHccModuleLaunchKernel.localWorkSizeZ = localWorkSizeZ;
    Args.hipHccModuleLaunchKernel.sharedMemBytes = sharedMemBytes;
    Args.hipHccModuleLaunchKernel.hStream = hStream;
    Args.hipHccModuleLaunchKernel.kernelParams = kernelParams;
    Args.hipHccModuleLaunchKernel.extra = extra;
    Args.hipHccModuleLaunchKernel.startEvent = startEvent;
    Args.hipHccModuleLaunchKernel.stopEvent = stopEvent;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipHccModuleLaunchKernel_fn(Args.hipHccModuleLaunchKernel.f, Args.hipHccModuleLaunchKernel.globalWorkSizeX, Args.hipHccModuleLaunchKernel.globalWorkSizeY, Args.hipHccModuleLaunchKernel.globalWorkSizeZ, Args.hipHccModuleLaunchKernel.localWorkSizeX, Args.hipHccModuleLaunchKernel.localWorkSizeY, Args.hipHccModuleLaunchKernel.localWorkSizeZ, Args.hipHccModuleLaunchKernel.sharedMemBytes, Args.hipHccModuleLaunchKernel.hStream, Args.hipHccModuleLaunchKernel.kernelParams, Args.hipHccModuleLaunchKernel.extra, Args.hipHccModuleLaunchKernel.startEvent, Args.hipHccModuleLaunchKernel.stopEvent);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipHccModuleLaunchKernel_fn(f, globalWorkSizeX, globalWorkSizeY, globalWorkSizeZ, localWorkSizeX, localWorkSizeY, localWorkSizeZ, sharedMemBytes, hStream, kernelParams, extra, startEvent, stopEvent);
  }
}

static hipError_t hipMemcpy_spt_callback(void* dst, const void* src, size_t sizeBytes, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy_spt.dst = dst;
    Args.hipMemcpy_spt.src = src;
    Args.hipMemcpy_spt.sizeBytes = sizeBytes;
    Args.hipMemcpy_spt.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy_spt_fn(Args.hipMemcpy_spt.dst, Args.hipMemcpy_spt.src, Args.hipMemcpy_spt.sizeBytes, Args.hipMemcpy_spt.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy_spt_fn(dst, src, sizeBytes, kind);
  }
}

static hipError_t hipMemcpyToSymbol_spt_callback(const void* symbol, const void* src, size_t sizeBytes, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToSymbol_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyToSymbol_spt.symbol = symbol;
    Args.hipMemcpyToSymbol_spt.src = src;
    Args.hipMemcpyToSymbol_spt.sizeBytes = sizeBytes;
    Args.hipMemcpyToSymbol_spt.offset = offset;
    Args.hipMemcpyToSymbol_spt.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyToSymbol_spt_fn(Args.hipMemcpyToSymbol_spt.symbol, Args.hipMemcpyToSymbol_spt.src, Args.hipMemcpyToSymbol_spt.sizeBytes, Args.hipMemcpyToSymbol_spt.offset, Args.hipMemcpyToSymbol_spt.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyToSymbol_spt_fn(symbol, src, sizeBytes, offset, kind);
  }
}

static hipError_t hipMemcpyFromSymbol_spt_callback(void* dst, const void* symbol, size_t sizeBytes, size_t offset, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromSymbol_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyFromSymbol_spt.dst = dst;
    Args.hipMemcpyFromSymbol_spt.symbol = symbol;
    Args.hipMemcpyFromSymbol_spt.sizeBytes = sizeBytes;
    Args.hipMemcpyFromSymbol_spt.offset = offset;
    Args.hipMemcpyFromSymbol_spt.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyFromSymbol_spt_fn(Args.hipMemcpyFromSymbol_spt.dst, Args.hipMemcpyFromSymbol_spt.symbol, Args.hipMemcpyFromSymbol_spt.sizeBytes, Args.hipMemcpyFromSymbol_spt.offset, Args.hipMemcpyFromSymbol_spt.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyFromSymbol_spt_fn(dst, symbol, sizeBytes, offset, kind);
  }
}

static hipError_t hipMemcpy2D_spt_callback(void* dst, size_t dpitch, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2D_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2D_spt.dst = dst;
    Args.hipMemcpy2D_spt.dpitch = dpitch;
    Args.hipMemcpy2D_spt.src = src;
    Args.hipMemcpy2D_spt.spitch = spitch;
    Args.hipMemcpy2D_spt.width = width;
    Args.hipMemcpy2D_spt.height = height;
    Args.hipMemcpy2D_spt.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2D_spt_fn(Args.hipMemcpy2D_spt.dst, Args.hipMemcpy2D_spt.dpitch, Args.hipMemcpy2D_spt.src, Args.hipMemcpy2D_spt.spitch, Args.hipMemcpy2D_spt.width, Args.hipMemcpy2D_spt.height, Args.hipMemcpy2D_spt.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2D_spt_fn(dst, dpitch, src, spitch, width, height, kind);
  }
}

static hipError_t hipMemcpy2DFromArray_spt_callback(void* dst, size_t dpitch, hipArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DFromArray_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DFromArray_spt.dst = dst;
    Args.hipMemcpy2DFromArray_spt.dpitch = dpitch;
    Args.hipMemcpy2DFromArray_spt.src = src;
    Args.hipMemcpy2DFromArray_spt.wOffset = wOffset;
    Args.hipMemcpy2DFromArray_spt.hOffset = hOffset;
    Args.hipMemcpy2DFromArray_spt.width = width;
    Args.hipMemcpy2DFromArray_spt.height = height;
    Args.hipMemcpy2DFromArray_spt.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DFromArray_spt_fn(Args.hipMemcpy2DFromArray_spt.dst, Args.hipMemcpy2DFromArray_spt.dpitch, Args.hipMemcpy2DFromArray_spt.src, Args.hipMemcpy2DFromArray_spt.wOffset, Args.hipMemcpy2DFromArray_spt.hOffset, Args.hipMemcpy2DFromArray_spt.width, Args.hipMemcpy2DFromArray_spt.height, Args.hipMemcpy2DFromArray_spt.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DFromArray_spt_fn(dst, dpitch, src, wOffset, hOffset, width, height, kind);
  }
}

static hipError_t hipMemcpy3D_spt_callback(const struct hipMemcpy3DParms* p) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy3D_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy3D_spt.p = p;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy3D_spt_fn(Args.hipMemcpy3D_spt.p);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy3D_spt_fn(p);
  }
}

static hipError_t hipMemset_spt_callback(void* dst, int value, size_t sizeBytes) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset_spt.dst = dst;
    Args.hipMemset_spt.value = value;
    Args.hipMemset_spt.sizeBytes = sizeBytes;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset_spt_fn(Args.hipMemset_spt.dst, Args.hipMemset_spt.value, Args.hipMemset_spt.sizeBytes);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset_spt_fn(dst, value, sizeBytes);
  }
}

static hipError_t hipMemsetAsync_spt_callback(void* dst, int value, size_t sizeBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemsetAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemsetAsync_spt.dst = dst;
    Args.hipMemsetAsync_spt.value = value;
    Args.hipMemsetAsync_spt.sizeBytes = sizeBytes;
    Args.hipMemsetAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemsetAsync_spt_fn(Args.hipMemsetAsync_spt.dst, Args.hipMemsetAsync_spt.value, Args.hipMemsetAsync_spt.sizeBytes, Args.hipMemsetAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemsetAsync_spt_fn(dst, value, sizeBytes, stream);
  }
}

static hipError_t hipMemset2D_spt_callback(void* dst, size_t pitch, int value, size_t width, size_t height) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset2D_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset2D_spt.dst = dst;
    Args.hipMemset2D_spt.pitch = pitch;
    Args.hipMemset2D_spt.value = value;
    Args.hipMemset2D_spt.width = width;
    Args.hipMemset2D_spt.height = height;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset2D_spt_fn(Args.hipMemset2D_spt.dst, Args.hipMemset2D_spt.pitch, Args.hipMemset2D_spt.value, Args.hipMemset2D_spt.width, Args.hipMemset2D_spt.height);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset2D_spt_fn(dst, pitch, value, width, height);
  }
}

static hipError_t hipMemset2DAsync_spt_callback(void* dst, size_t pitch, int value, size_t width, size_t height, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset2DAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset2DAsync_spt.dst = dst;
    Args.hipMemset2DAsync_spt.pitch = pitch;
    Args.hipMemset2DAsync_spt.value = value;
    Args.hipMemset2DAsync_spt.width = width;
    Args.hipMemset2DAsync_spt.height = height;
    Args.hipMemset2DAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset2DAsync_spt_fn(Args.hipMemset2DAsync_spt.dst, Args.hipMemset2DAsync_spt.pitch, Args.hipMemset2DAsync_spt.value, Args.hipMemset2DAsync_spt.width, Args.hipMemset2DAsync_spt.height, Args.hipMemset2DAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset2DAsync_spt_fn(dst, pitch, value, width, height, stream);
  }
}

static hipError_t hipMemset3DAsync_spt_callback(hipPitchedPtr pitchedDevPtr, int value, hipExtent extent, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset3DAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset3DAsync_spt.pitchedDevPtr = pitchedDevPtr;
    Args.hipMemset3DAsync_spt.value = value;
    Args.hipMemset3DAsync_spt.extent = extent;
    Args.hipMemset3DAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset3DAsync_spt_fn(Args.hipMemset3DAsync_spt.pitchedDevPtr, Args.hipMemset3DAsync_spt.value, Args.hipMemset3DAsync_spt.extent, Args.hipMemset3DAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset3DAsync_spt_fn(pitchedDevPtr, value, extent, stream);
  }
}

static hipError_t hipMemset3D_spt_callback(hipPitchedPtr pitchedDevPtr, int value, hipExtent extent) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemset3D_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemset3D_spt.pitchedDevPtr = pitchedDevPtr;
    Args.hipMemset3D_spt.value = value;
    Args.hipMemset3D_spt.extent = extent;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemset3D_spt_fn(Args.hipMemset3D_spt.pitchedDevPtr, Args.hipMemset3D_spt.value, Args.hipMemset3D_spt.extent);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemset3D_spt_fn(pitchedDevPtr, value, extent);
  }
}

static hipError_t hipMemcpyAsync_spt_callback(void* dst, const void* src, size_t sizeBytes, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyAsync_spt.dst = dst;
    Args.hipMemcpyAsync_spt.src = src;
    Args.hipMemcpyAsync_spt.sizeBytes = sizeBytes;
    Args.hipMemcpyAsync_spt.kind = kind;
    Args.hipMemcpyAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyAsync_spt_fn(Args.hipMemcpyAsync_spt.dst, Args.hipMemcpyAsync_spt.src, Args.hipMemcpyAsync_spt.sizeBytes, Args.hipMemcpyAsync_spt.kind, Args.hipMemcpyAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyAsync_spt_fn(dst, src, sizeBytes, kind, stream);
  }
}

static hipError_t hipMemcpy3DAsync_spt_callback(const hipMemcpy3DParms* p, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy3DAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy3DAsync_spt.p = p;
    Args.hipMemcpy3DAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy3DAsync_spt_fn(Args.hipMemcpy3DAsync_spt.p, Args.hipMemcpy3DAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy3DAsync_spt_fn(p, stream);
  }
}

static hipError_t hipMemcpy2DAsync_spt_callback(void* dst, size_t dpitch, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DAsync_spt.dst = dst;
    Args.hipMemcpy2DAsync_spt.dpitch = dpitch;
    Args.hipMemcpy2DAsync_spt.src = src;
    Args.hipMemcpy2DAsync_spt.spitch = spitch;
    Args.hipMemcpy2DAsync_spt.width = width;
    Args.hipMemcpy2DAsync_spt.height = height;
    Args.hipMemcpy2DAsync_spt.kind = kind;
    Args.hipMemcpy2DAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DAsync_spt_fn(Args.hipMemcpy2DAsync_spt.dst, Args.hipMemcpy2DAsync_spt.dpitch, Args.hipMemcpy2DAsync_spt.src, Args.hipMemcpy2DAsync_spt.spitch, Args.hipMemcpy2DAsync_spt.width, Args.hipMemcpy2DAsync_spt.height, Args.hipMemcpy2DAsync_spt.kind, Args.hipMemcpy2DAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DAsync_spt_fn(dst, dpitch, src, spitch, width, height, kind, stream);
  }
}

static hipError_t hipMemcpyFromSymbolAsync_spt_callback(void* dst, const void* symbol, size_t sizeBytes, size_t offset, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromSymbolAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyFromSymbolAsync_spt.dst = dst;
    Args.hipMemcpyFromSymbolAsync_spt.symbol = symbol;
    Args.hipMemcpyFromSymbolAsync_spt.sizeBytes = sizeBytes;
    Args.hipMemcpyFromSymbolAsync_spt.offset = offset;
    Args.hipMemcpyFromSymbolAsync_spt.kind = kind;
    Args.hipMemcpyFromSymbolAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyFromSymbolAsync_spt_fn(Args.hipMemcpyFromSymbolAsync_spt.dst, Args.hipMemcpyFromSymbolAsync_spt.symbol, Args.hipMemcpyFromSymbolAsync_spt.sizeBytes, Args.hipMemcpyFromSymbolAsync_spt.offset, Args.hipMemcpyFromSymbolAsync_spt.kind, Args.hipMemcpyFromSymbolAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyFromSymbolAsync_spt_fn(dst, symbol, sizeBytes, offset, kind, stream);
  }
}

static hipError_t hipMemcpyToSymbolAsync_spt_callback(const void* symbol, const void* src, size_t sizeBytes, size_t offset, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyToSymbolAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyToSymbolAsync_spt.symbol = symbol;
    Args.hipMemcpyToSymbolAsync_spt.src = src;
    Args.hipMemcpyToSymbolAsync_spt.sizeBytes = sizeBytes;
    Args.hipMemcpyToSymbolAsync_spt.offset = offset;
    Args.hipMemcpyToSymbolAsync_spt.kind = kind;
    Args.hipMemcpyToSymbolAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyToSymbolAsync_spt_fn(Args.hipMemcpyToSymbolAsync_spt.symbol, Args.hipMemcpyToSymbolAsync_spt.src, Args.hipMemcpyToSymbolAsync_spt.sizeBytes, Args.hipMemcpyToSymbolAsync_spt.offset, Args.hipMemcpyToSymbolAsync_spt.kind, Args.hipMemcpyToSymbolAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyToSymbolAsync_spt_fn(symbol, src, sizeBytes, offset, kind, stream);
  }
}

static hipError_t hipMemcpyFromArray_spt_callback(void* dst, hipArray_const_t src, size_t wOffsetSrc, size_t hOffset, size_t count, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpyFromArray_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpyFromArray_spt.dst = dst;
    Args.hipMemcpyFromArray_spt.src = src;
    Args.hipMemcpyFromArray_spt.wOffsetSrc = wOffsetSrc;
    Args.hipMemcpyFromArray_spt.hOffset = hOffset;
    Args.hipMemcpyFromArray_spt.count = count;
    Args.hipMemcpyFromArray_spt.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpyFromArray_spt_fn(Args.hipMemcpyFromArray_spt.dst, Args.hipMemcpyFromArray_spt.src, Args.hipMemcpyFromArray_spt.wOffsetSrc, Args.hipMemcpyFromArray_spt.hOffset, Args.hipMemcpyFromArray_spt.count, Args.hipMemcpyFromArray_spt.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpyFromArray_spt_fn(dst, src, wOffsetSrc, hOffset, count, kind);
  }
}

static hipError_t hipMemcpy2DToArray_spt_callback(hipArray_t dst, size_t wOffset, size_t hOffset, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DToArray_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DToArray_spt.dst = dst;
    Args.hipMemcpy2DToArray_spt.wOffset = wOffset;
    Args.hipMemcpy2DToArray_spt.hOffset = hOffset;
    Args.hipMemcpy2DToArray_spt.src = src;
    Args.hipMemcpy2DToArray_spt.spitch = spitch;
    Args.hipMemcpy2DToArray_spt.width = width;
    Args.hipMemcpy2DToArray_spt.height = height;
    Args.hipMemcpy2DToArray_spt.kind = kind;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DToArray_spt_fn(Args.hipMemcpy2DToArray_spt.dst, Args.hipMemcpy2DToArray_spt.wOffset, Args.hipMemcpy2DToArray_spt.hOffset, Args.hipMemcpy2DToArray_spt.src, Args.hipMemcpy2DToArray_spt.spitch, Args.hipMemcpy2DToArray_spt.width, Args.hipMemcpy2DToArray_spt.height, Args.hipMemcpy2DToArray_spt.kind);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DToArray_spt_fn(dst, wOffset, hOffset, src, spitch, width, height, kind);
  }
}

static hipError_t hipMemcpy2DFromArrayAsync_spt_callback(void* dst, size_t dpitch, hipArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DFromArrayAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DFromArrayAsync_spt.dst = dst;
    Args.hipMemcpy2DFromArrayAsync_spt.dpitch = dpitch;
    Args.hipMemcpy2DFromArrayAsync_spt.src = src;
    Args.hipMemcpy2DFromArrayAsync_spt.wOffsetSrc = wOffsetSrc;
    Args.hipMemcpy2DFromArrayAsync_spt.hOffsetSrc = hOffsetSrc;
    Args.hipMemcpy2DFromArrayAsync_spt.width = width;
    Args.hipMemcpy2DFromArrayAsync_spt.height = height;
    Args.hipMemcpy2DFromArrayAsync_spt.kind = kind;
    Args.hipMemcpy2DFromArrayAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DFromArrayAsync_spt_fn(Args.hipMemcpy2DFromArrayAsync_spt.dst, Args.hipMemcpy2DFromArrayAsync_spt.dpitch, Args.hipMemcpy2DFromArrayAsync_spt.src, Args.hipMemcpy2DFromArrayAsync_spt.wOffsetSrc, Args.hipMemcpy2DFromArrayAsync_spt.hOffsetSrc, Args.hipMemcpy2DFromArrayAsync_spt.width, Args.hipMemcpy2DFromArrayAsync_spt.height, Args.hipMemcpy2DFromArrayAsync_spt.kind, Args.hipMemcpy2DFromArrayAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DFromArrayAsync_spt_fn(dst, dpitch, src, wOffsetSrc, hOffsetSrc, width, height, kind, stream);
  }
}

static hipError_t hipMemcpy2DToArrayAsync_spt_callback(hipArray_t dst, size_t wOffset, size_t hOffset, const void* src, size_t spitch, size_t width, size_t height, hipMemcpyKind kind, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipMemcpy2DToArrayAsync_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipMemcpy2DToArrayAsync_spt.dst = dst;
    Args.hipMemcpy2DToArrayAsync_spt.wOffset = wOffset;
    Args.hipMemcpy2DToArrayAsync_spt.hOffset = hOffset;
    Args.hipMemcpy2DToArrayAsync_spt.src = src;
    Args.hipMemcpy2DToArrayAsync_spt.spitch = spitch;
    Args.hipMemcpy2DToArrayAsync_spt.width = width;
    Args.hipMemcpy2DToArrayAsync_spt.height = height;
    Args.hipMemcpy2DToArrayAsync_spt.kind = kind;
    Args.hipMemcpy2DToArrayAsync_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipMemcpy2DToArrayAsync_spt_fn(Args.hipMemcpy2DToArrayAsync_spt.dst, Args.hipMemcpy2DToArrayAsync_spt.wOffset, Args.hipMemcpy2DToArrayAsync_spt.hOffset, Args.hipMemcpy2DToArrayAsync_spt.src, Args.hipMemcpy2DToArrayAsync_spt.spitch, Args.hipMemcpy2DToArrayAsync_spt.width, Args.hipMemcpy2DToArrayAsync_spt.height, Args.hipMemcpy2DToArrayAsync_spt.kind, Args.hipMemcpy2DToArrayAsync_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipMemcpy2DToArrayAsync_spt_fn(dst, wOffset, hOffset, src, spitch, width, height, kind, stream);
  }
}

static hipError_t hipStreamQuery_spt_callback(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamQuery_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamQuery_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamQuery_spt_fn(Args.hipStreamQuery_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamQuery_spt_fn(stream);
  }
}

static hipError_t hipStreamSynchronize_spt_callback(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamSynchronize_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamSynchronize_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamSynchronize_spt_fn(Args.hipStreamSynchronize_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamSynchronize_spt_fn(stream);
  }
}

static hipError_t hipStreamGetPriority_spt_callback(hipStream_t stream, int* priority) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetPriority_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetPriority_spt.stream = stream;
    Args.hipStreamGetPriority_spt.priority = priority;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetPriority_spt_fn(Args.hipStreamGetPriority_spt.stream, Args.hipStreamGetPriority_spt.priority);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetPriority_spt_fn(stream, priority);
  }
}

static hipError_t hipStreamWaitEvent_spt_callback(hipStream_t stream, hipEvent_t event, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamWaitEvent_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamWaitEvent_spt.stream = stream;
    Args.hipStreamWaitEvent_spt.event = event;
    Args.hipStreamWaitEvent_spt.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamWaitEvent_spt_fn(Args.hipStreamWaitEvent_spt.stream, Args.hipStreamWaitEvent_spt.event, Args.hipStreamWaitEvent_spt.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamWaitEvent_spt_fn(stream, event, flags);
  }
}

static hipError_t hipStreamGetFlags_spt_callback(hipStream_t stream, unsigned int* flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetFlags_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetFlags_spt.stream = stream;
    Args.hipStreamGetFlags_spt.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetFlags_spt_fn(Args.hipStreamGetFlags_spt.stream, Args.hipStreamGetFlags_spt.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetFlags_spt_fn(stream, flags);
  }
}

static hipError_t hipStreamAddCallback_spt_callback(hipStream_t stream, hipStreamCallback_t callback, void* userData, unsigned int flags) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamAddCallback_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamAddCallback_spt.stream = stream;
    Args.hipStreamAddCallback_spt.callback = callback;
    Args.hipStreamAddCallback_spt.userData = userData;
    Args.hipStreamAddCallback_spt.flags = flags;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamAddCallback_spt_fn(Args.hipStreamAddCallback_spt.stream, Args.hipStreamAddCallback_spt.callback, Args.hipStreamAddCallback_spt.userData, Args.hipStreamAddCallback_spt.flags);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamAddCallback_spt_fn(stream, callback, userData, flags);
  }
}

static hipError_t hipEventRecord_spt_callback(hipEvent_t event, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipEventRecord_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipEventRecord_spt.event = event;
    Args.hipEventRecord_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipEventRecord_spt_fn(Args.hipEventRecord_spt.event, Args.hipEventRecord_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipEventRecord_spt_fn(event, stream);
  }
}

static hipError_t hipLaunchCooperativeKernel_spt_callback(const void* f, dim3 gridDim, dim3 blockDim, void** kernelParams, uint32_t sharedMemBytes, hipStream_t hStream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchCooperativeKernel_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipLaunchCooperativeKernel_spt.f = f;
    Args.hipLaunchCooperativeKernel_spt.gridDim = gridDim;
    Args.hipLaunchCooperativeKernel_spt.blockDim = blockDim;
    Args.hipLaunchCooperativeKernel_spt.kernelParams = kernelParams;
    Args.hipLaunchCooperativeKernel_spt.sharedMemBytes = sharedMemBytes;
    Args.hipLaunchCooperativeKernel_spt.hStream = hStream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipLaunchCooperativeKernel_spt_fn(Args.hipLaunchCooperativeKernel_spt.f, Args.hipLaunchCooperativeKernel_spt.gridDim, Args.hipLaunchCooperativeKernel_spt.blockDim, Args.hipLaunchCooperativeKernel_spt.kernelParams, Args.hipLaunchCooperativeKernel_spt.sharedMemBytes, Args.hipLaunchCooperativeKernel_spt.hStream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipLaunchCooperativeKernel_spt_fn(f, gridDim, blockDim, kernelParams, sharedMemBytes, hStream);
  }
}

static hipError_t hipLaunchKernel_spt_callback(const void* function_address, dim3 numBlocks, dim3 dimBlocks, void** args, size_t sharedMemBytes, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchKernel_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipLaunchKernel_spt.function_address = function_address;
    Args.hipLaunchKernel_spt.numBlocks = numBlocks;
    Args.hipLaunchKernel_spt.dimBlocks = dimBlocks;
    Args.hipLaunchKernel_spt.args = args;
    Args.hipLaunchKernel_spt.sharedMemBytes = sharedMemBytes;
    Args.hipLaunchKernel_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipLaunchKernel_spt_fn(Args.hipLaunchKernel_spt.function_address, Args.hipLaunchKernel_spt.numBlocks, Args.hipLaunchKernel_spt.dimBlocks, Args.hipLaunchKernel_spt.args, Args.hipLaunchKernel_spt.sharedMemBytes, Args.hipLaunchKernel_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipLaunchKernel_spt_fn(function_address, numBlocks, dimBlocks, args, sharedMemBytes, stream);
  }
}

static hipError_t hipGraphLaunch_spt_callback(hipGraphExec_t graphExec, hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGraphLaunch_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGraphLaunch_spt.graphExec = graphExec;
    Args.hipGraphLaunch_spt.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGraphLaunch_spt_fn(Args.hipGraphLaunch_spt.graphExec, Args.hipGraphLaunch_spt.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGraphLaunch_spt_fn(graphExec, stream);
  }
}

static hipError_t hipStreamBeginCapture_spt_callback(hipStream_t stream, hipStreamCaptureMode mode) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamBeginCapture_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamBeginCapture_spt.stream = stream;
    Args.hipStreamBeginCapture_spt.mode = mode;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamBeginCapture_spt_fn(Args.hipStreamBeginCapture_spt.stream, Args.hipStreamBeginCapture_spt.mode);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamBeginCapture_spt_fn(stream, mode);
  }
}

static hipError_t hipStreamEndCapture_spt_callback(hipStream_t stream, hipGraph_t* pGraph) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamEndCapture_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamEndCapture_spt.stream = stream;
    Args.hipStreamEndCapture_spt.pGraph = pGraph;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamEndCapture_spt_fn(Args.hipStreamEndCapture_spt.stream, Args.hipStreamEndCapture_spt.pGraph);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamEndCapture_spt_fn(stream, pGraph);
  }
}

static hipError_t hipStreamIsCapturing_spt_callback(hipStream_t stream, hipStreamCaptureStatus* pCaptureStatus) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamIsCapturing_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamIsCapturing_spt.stream = stream;
    Args.hipStreamIsCapturing_spt.pCaptureStatus = pCaptureStatus;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamIsCapturing_spt_fn(Args.hipStreamIsCapturing_spt.stream, Args.hipStreamIsCapturing_spt.pCaptureStatus);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamIsCapturing_spt_fn(stream, pCaptureStatus);
  }
}

static hipError_t hipStreamGetCaptureInfo_spt_callback(hipStream_t stream, hipStreamCaptureStatus* pCaptureStatus, unsigned long long* pId) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetCaptureInfo_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetCaptureInfo_spt.stream = stream;
    Args.hipStreamGetCaptureInfo_spt.pCaptureStatus = pCaptureStatus;
    Args.hipStreamGetCaptureInfo_spt.pId = pId;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetCaptureInfo_spt_fn(Args.hipStreamGetCaptureInfo_spt.stream, Args.hipStreamGetCaptureInfo_spt.pCaptureStatus, Args.hipStreamGetCaptureInfo_spt.pId);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetCaptureInfo_spt_fn(stream, pCaptureStatus, pId);
  }
}

static hipError_t hipStreamGetCaptureInfo_v2_spt_callback(hipStream_t stream, hipStreamCaptureStatus* captureStatus_out, unsigned long long* id_out, hipGraph_t* graph_out, const hipGraphNode_t** dependencies_out, size_t* numDependencies_out) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipStreamGetCaptureInfo_v2_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipStreamGetCaptureInfo_v2_spt.stream = stream;
    Args.hipStreamGetCaptureInfo_v2_spt.captureStatus_out = captureStatus_out;
    Args.hipStreamGetCaptureInfo_v2_spt.id_out = id_out;
    Args.hipStreamGetCaptureInfo_v2_spt.graph_out = graph_out;
    Args.hipStreamGetCaptureInfo_v2_spt.dependencies_out = dependencies_out;
    Args.hipStreamGetCaptureInfo_v2_spt.numDependencies_out = numDependencies_out;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipStreamGetCaptureInfo_v2_spt_fn(Args.hipStreamGetCaptureInfo_v2_spt.stream, Args.hipStreamGetCaptureInfo_v2_spt.captureStatus_out, Args.hipStreamGetCaptureInfo_v2_spt.id_out, Args.hipStreamGetCaptureInfo_v2_spt.graph_out, Args.hipStreamGetCaptureInfo_v2_spt.dependencies_out, Args.hipStreamGetCaptureInfo_v2_spt.numDependencies_out);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipStreamGetCaptureInfo_v2_spt_fn(stream, captureStatus_out, id_out, graph_out, dependencies_out, numDependencies_out);
  }
}

static hipError_t hipLaunchHostFunc_spt_callback(hipStream_t stream, hipHostFn_t fn, void* userData) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipLaunchHostFunc_spt;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    hipError_t Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipLaunchHostFunc_spt.stream = stream;
    Args.hipLaunchHostFunc_spt.fn = fn;
    Args.hipLaunchHostFunc_spt.userData = userData;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipLaunchHostFunc_spt_fn(Args.hipLaunchHostFunc_spt.stream, Args.hipLaunchHostFunc_spt.fn, Args.hipLaunchHostFunc_spt.userData);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipLaunchHostFunc_spt_fn(stream, fn, userData);
  }
}

static int hipGetStreamDeviceId_callback(hipStream_t stream) {
  auto& HipInterceptor = luthier::hip::RuntimeInterceptor::instance();
  auto ApiId = ROCPROFILER_HIP_RUNTIME_API_ID_hipGetStreamDeviceId;
  bool IsUserCallbackEnabled = HipInterceptor.isUserCallbackEnabled(ApiId);
  bool IsInternalCallbackEnabled = HipInterceptor.isInternalCallbackEnabled(ApiId);
  bool ShouldCallback = IsUserCallbackEnabled || IsInternalCallbackEnabled;
  if (ShouldCallback) {
    int Out{};
    auto& HipUserCallback = HipInterceptor.getUserCallback();
    auto& HipInternalCallback = HipInterceptor.getInternalCallback();
    rocprofiler_hip_api_args_t Args;
    bool SkipFunction{false};
    Args.hipGetStreamDeviceId.stream = stream;
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_ENTER, ApiId, &SkipFunction);
    if (!SkipFunction)
      Out = HipInterceptor.getSavedRuntimeTable().hipGetStreamDeviceId_fn(Args.hipGetStreamDeviceId.stream);
    if (IsUserCallbackEnabled)
      HipUserCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId);
    if (IsInternalCallbackEnabled)
      HipInternalCallback(&Args, luthier::API_EVT_PHASE_EXIT, ApiId, &SkipFunction);
    return Out;
  }
  else {
    return HipInterceptor.getSavedRuntimeTable().hipGetStreamDeviceId_fn(stream);
  }
}


// NOLINTEND
