# Terminology
This chapter aggregates frequently used terms in Luthier for easy reference.

- __AMD GPU Code Object__: An ELF shared object file that can be loaded and run on AMD GPUs. Its specifications are
  described in depth by the [LLVM AMDGPU Backend Documentation](https://llvm.org/docs/AMDGPUUsage.html). Each AMD GPU
  code object roughly has a one-to-one relationship with a HIP Module (`hipModule_t`).
- __HIP FAT Binary__: A collection of AMD GPU code objects targeting multiple GPU architectures.
  When compiling HIP code, `hipcc` can be instructed to compile the same code for multiple GPU architectures so that
  it can run on different GPUs. A HIP FAT binary is bundled with the host executable and gets recognized by the
  HIP runtime during startup through the HIP runtime compiler API. The HIP runtime parses the FAT binary into
  individual AMD GPU code objects and loads them onto the appropriate GPU device.
- __HIP Runtime Compiler API__: A set of C library startup functions prefixed with `__hipRegister` in charge of
  loading HIP FAT binaries as well as registering the
- __Dynamic/Static HIP Module__: If a HIP module was extracted from a HIP FAT binary using the HIP compiler API, it is
  a static module; If the HIP Module was loaded using the `hipModuleLoad` functions, it is a dynamic module.

## ROCT
The ROCm Thunk Interface is the user-level used to interface with the AMDGPU driver. 


## ROCr (HSA)
The ROCm runtime is the lowest level of programing AMD GPUs for compute tasks on the ROCm platform for Linux. It

Throughout the docs ROCr and HSA is used interchangeably, unless explicitly specified.

## RocCLR
Part of what is now called the [Compute Language Runtime](https://github.com/roCm/clr) in ROCm, RocCLR acts as a device,
runtime, and OS-agnostic abstraction layer that sits directly under high-level application runtimes (e.g. HIP, OpenCL)
and on top of the low-level runtimes (e.g. ROCr, PAL). It contains common code used by HIP and OpenCL, allowing them 
to use low-level ROCr/PAL/OS functionality.

## HIP FAT Binary
A HIP FAT Binary is a collection of AMDGPU code objects compiled for different target architectures generated by the 
HIP (clang) compiler driver. It is primarily used by the HIP runtime. After loading, the HIP runtime parses them into 
individual AMDGPU code objects and then loads them to the device using RocCLR, when deemed appropriate. 

## Hip Compiler Dispatch Functions
A list of functions, prefixed with `__hipRegister`, called during startup of a HIP application to register 

## Static HIP FAT Binary
A HIP FAT Binary that is bundled with a host executable using the Clang offload bundler is considered static. 
Static HIP FAT Binaries are usually used in C/C++ applications that directly declares and uses its own HIP code. 
During startup of such applications, the HIP compiler dispatch functions 
a list of functions (with `__hipRegister` as a prefix in their name) startup and notify the HIP runtime . Static FAT
binaries can be loaded in a lazy manner, unless explicitly disabled by setting the `HIP_ENABLE_DEFERRED_LOADING` 
environment variable to zero.

## Dynamic HIP FAT Binary


## HSA (Heterogeneous Systems Architecture)

## Tool Code Object


## Instrumented 

## Instrumentation

## Original (Target)


The 